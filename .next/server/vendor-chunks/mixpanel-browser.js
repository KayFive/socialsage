"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mixpanel-browser";
exports.ids = ["vendor-chunks/mixpanel-browser"];
exports.modules = {

/***/ "(ssr)/./node_modules/mixpanel-browser/dist/mixpanel.module.js":
/*!***************************************************************!*\
  !*** ./node_modules/mixpanel-browser/dist/mixpanel.module.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ mixpanel)\n/* harmony export */ });\n// since es6 imports are static and we run unit tests from the console, window won't be defined when importing this file\nvar win;\nif (typeof(window) === 'undefined') {\n    var loc = {\n        hostname: ''\n    };\n    win = {\n        crypto: {randomUUID: function() {throw Error('unsupported');}},\n        navigator: { userAgent: '', onLine: true },\n        document: {\n            createElement: function() { return {}; },\n            location: loc,\n            referrer: ''\n        },\n        screen: { width: 0, height: 0 },\n        location: loc,\n        addEventListener: function() {},\n        removeEventListener: function() {}\n    };\n} else {\n    win = window;\n}\n\nfunction _array_like_to_array(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n        var info = gen[key](arg);\n        var value = info.value;\n    } catch (error) {\n        reject(error);\n        return;\n    }\n    if (info.done) {\n        resolve(value);\n    } else {\n        Promise.resolve(value).then(_next, _throw);\n    }\n}\nfunction _async_to_generator(fn) {\n    return function() {\n        var self = this, args = arguments;\n        return new Promise(function(resolve, reject) {\n            var gen = fn.apply(self, args);\n            function _next(value) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n            }\n            function _throw(err) {\n                asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n            }\n            _next(undefined);\n        });\n    };\n}\nfunction _construct(Parent, args, Class) {\n    if (_is_native_reflect_construct()) {\n        _construct = Reflect.construct;\n    } else {\n        _construct = function construct(Parent, args, Class) {\n            var a = [\n                null\n            ];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _set_prototype_of(instance, Class.prototype);\n            return instance;\n        };\n    }\n    return _construct.apply(null, arguments);\n}\nfunction _defineProperties(target, props) {\n    for(var i = 0; i < props.length; i++){\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n    }\n}\nfunction _create_class(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    return Constructor;\n}\nfunction _extends() {\n    _extends = Object.assign || function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _get_prototype_of(o) {\n    _get_prototype_of = Object.setPrototypeOf ? Object.getPrototypeOf : function getPrototypeOf(o) {\n        return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _get_prototype_of(o);\n}\nfunction _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n        throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n        constructor: {\n            value: subClass,\n            writable: true,\n            configurable: true\n        }\n    });\n    if (superClass) _set_prototype_of(subClass, superClass);\n}\nfunction _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n        return !!right[Symbol.hasInstance](left);\n    } else {\n        return left instanceof right;\n    }\n}\nfunction _is_native_function(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\nfunction _object_without_properties_loose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _set_prototype_of(o, p) {\n    _set_prototype_of = Object.setPrototypeOf || function setPrototypeOf(o, p) {\n        o.__proto__ = p;\n        return o;\n    };\n    return _set_prototype_of(o, p);\n}\nfunction _type_of(obj) {\n    \"@swc/helpers - typeof\";\n    return obj && typeof Symbol !== \"undefined\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n}\nfunction _unsupported_iterable_to_array(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _array_like_to_array(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(n);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);\n}\nfunction _wrap_native_super(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n    _wrap_native_super = function wrapNativeSuper(Class) {\n        if (Class === null || !_is_native_function(Class)) return Class;\n        if (typeof Class !== \"function\") {\n            throw new TypeError(\"Super expression must either be null or a function\");\n        }\n        if (typeof _cache !== \"undefined\") {\n            if (_cache.has(Class)) return _cache.get(Class);\n            _cache.set(Class, Wrapper);\n        }\n        function Wrapper() {\n            return _construct(Class, arguments, _get_prototype_of(this).constructor);\n        }\n        Wrapper.prototype = Object.create(Class.prototype, {\n            constructor: {\n                value: Wrapper,\n                enumerable: false,\n                writable: true,\n                configurable: true\n            }\n        });\n        return _set_prototype_of(Wrapper, Class);\n    };\n    return _wrap_native_super(Class);\n}\nfunction _is_native_reflect_construct() {\n    try {\n        var result = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n    } catch (_) {}\n    return (_is_native_reflect_construct = function() {\n        return !!result;\n    })();\n}\nfunction _create_for_of_iterator_helper_loose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (it) return (it = it.call(o)).next.bind(it);\n    if (Array.isArray(o) || (it = _unsupported_iterable_to_array(o)) || allowArrayLike) {\n        if (it) o = it;\n        var i = 0;\n        return function() {\n            if (i >= o.length) {\n                return {\n                    done: true\n                };\n            }\n            return {\n                done: false,\n                value: o[i++]\n            };\n        };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _ts_generator(thisArg, body) {\n    var f, y, t, g, _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(_)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n}\nfunction _ts_values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function(obj, key, value) {\n    return key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __publicField = function(obj, key, value) {\n    return __defNormalProp(obj, (typeof key === \"undefined\" ? \"undefined\" : _type_of(key)) !== \"symbol\" ? key + \"\" : key, value);\n};\nvar _a;\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = function(obj, key, value) {\n    return key in obj ? __defProp$1(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __publicField$1 = function(obj, key, value) {\n    return __defNormalProp$1(obj, (typeof key === \"undefined\" ? \"undefined\" : _type_of(key)) !== \"symbol\" ? key + \"\" : key, value);\n};\nvar NodeType$3 = /* @__PURE__ */ function(NodeType2) {\n    NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n    NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n    NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n    NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n    NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n    NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n    return NodeType2;\n}(NodeType$3 || {});\nvar testableAccessors$1 = {\n    Node: [\n        \"childNodes\",\n        \"parentNode\",\n        \"parentElement\",\n        \"textContent\"\n    ],\n    ShadowRoot: [\n        \"host\",\n        \"styleSheets\"\n    ],\n    Element: [\n        \"shadowRoot\",\n        \"querySelector\",\n        \"querySelectorAll\"\n    ],\n    MutationObserver: []\n};\nvar testableMethods$1 = {\n    Node: [\n        \"contains\",\n        \"getRootNode\"\n    ],\n    ShadowRoot: [\n        \"getSelection\"\n    ],\n    Element: [],\n    MutationObserver: [\n        \"constructor\"\n    ]\n};\nvar untaintedBasePrototype$1 = {};\nvar isAngularZonePresent$1 = function() {\n    return !!globalThis.Zone;\n};\nfunction getUntaintedPrototype$1(key) {\n    if (untaintedBasePrototype$1[key]) return untaintedBasePrototype$1[key];\n    var defaultObj = globalThis[key];\n    var defaultPrototype = defaultObj.prototype;\n    var accessorNames = key in testableAccessors$1 ? testableAccessors$1[key] : void 0;\n    var isUntaintedAccessors = Boolean(accessorNames && // @ts-expect-error 2345\n    accessorNames.every(function(accessor) {\n        var _a2, _b;\n        return Boolean((_b = (_a2 = Object.getOwnPropertyDescriptor(defaultPrototype, accessor)) == null ? void 0 : _a2.get) == null ? void 0 : _b.toString().includes(\"[native code]\"));\n    }));\n    var methodNames = key in testableMethods$1 ? testableMethods$1[key] : void 0;\n    var isUntaintedMethods = Boolean(methodNames && methodNames.every(// @ts-expect-error 2345\n    function(method) {\n        var _a2;\n        return typeof defaultPrototype[method] === \"function\" && ((_a2 = defaultPrototype[method]) == null ? void 0 : _a2.toString().includes(\"[native code]\"));\n    }));\n    if (isUntaintedAccessors && isUntaintedMethods && !isAngularZonePresent$1()) {\n        untaintedBasePrototype$1[key] = defaultObj.prototype;\n        return defaultObj.prototype;\n    }\n    try {\n        var iframeEl = document.createElement(\"iframe\");\n        document.body.appendChild(iframeEl);\n        var win = iframeEl.contentWindow;\n        if (!win) return defaultObj.prototype;\n        var untaintedObject = win[key].prototype;\n        document.body.removeChild(iframeEl);\n        if (!untaintedObject) return defaultPrototype;\n        return untaintedBasePrototype$1[key] = untaintedObject;\n    } catch (e) {\n        return defaultPrototype;\n    }\n}\nvar untaintedAccessorCache$1 = {};\nfunction getUntaintedAccessor$1(key, instance, accessor) {\n    var _a2;\n    var cacheKey = key + \".\" + String(accessor);\n    if (untaintedAccessorCache$1[cacheKey]) return untaintedAccessorCache$1[cacheKey].call(instance);\n    var untaintedPrototype = getUntaintedPrototype$1(key);\n    var untaintedAccessor = (_a2 = Object.getOwnPropertyDescriptor(untaintedPrototype, accessor)) == null ? void 0 : _a2.get;\n    if (!untaintedAccessor) return instance[accessor];\n    untaintedAccessorCache$1[cacheKey] = untaintedAccessor;\n    return untaintedAccessor.call(instance);\n}\nvar untaintedMethodCache$1 = {};\nfunction getUntaintedMethod$1(key, instance, method) {\n    var cacheKey = key + \".\" + String(method);\n    if (untaintedMethodCache$1[cacheKey]) return untaintedMethodCache$1[cacheKey].bind(instance);\n    var untaintedPrototype = getUntaintedPrototype$1(key);\n    var untaintedMethod = untaintedPrototype[method];\n    if (typeof untaintedMethod !== \"function\") return instance[method];\n    untaintedMethodCache$1[cacheKey] = untaintedMethod;\n    return untaintedMethod.bind(instance);\n}\nfunction childNodes$1(n2) {\n    return getUntaintedAccessor$1(\"Node\", n2, \"childNodes\");\n}\nfunction parentNode$1(n2) {\n    return getUntaintedAccessor$1(\"Node\", n2, \"parentNode\");\n}\nfunction parentElement$1(n2) {\n    return getUntaintedAccessor$1(\"Node\", n2, \"parentElement\");\n}\nfunction textContent$1(n2) {\n    return getUntaintedAccessor$1(\"Node\", n2, \"textContent\");\n}\nfunction contains$1(n2, other) {\n    return getUntaintedMethod$1(\"Node\", n2, \"contains\")(other);\n}\nfunction getRootNode$1(n2) {\n    return getUntaintedMethod$1(\"Node\", n2, \"getRootNode\")();\n}\nfunction host$1(n2) {\n    if (!n2 || !(\"host\" in n2)) return null;\n    return getUntaintedAccessor$1(\"ShadowRoot\", n2, \"host\");\n}\nfunction styleSheets$1(n2) {\n    return n2.styleSheets;\n}\nfunction shadowRoot$1(n2) {\n    if (!n2 || !(\"shadowRoot\" in n2)) return null;\n    return getUntaintedAccessor$1(\"Element\", n2, \"shadowRoot\");\n}\nfunction querySelector$1(n2, selectors) {\n    return getUntaintedAccessor$1(\"Element\", n2, \"querySelector\")(selectors);\n}\nfunction querySelectorAll$1(n2, selectors) {\n    return getUntaintedAccessor$1(\"Element\", n2, \"querySelectorAll\")(selectors);\n}\nfunction mutationObserverCtor$1() {\n    return getUntaintedPrototype$1(\"MutationObserver\").constructor;\n}\nvar index$1 = {\n    childNodes: childNodes$1,\n    parentNode: parentNode$1,\n    parentElement: parentElement$1,\n    textContent: textContent$1,\n    contains: contains$1,\n    getRootNode: getRootNode$1,\n    host: host$1,\n    styleSheets: styleSheets$1,\n    shadowRoot: shadowRoot$1,\n    querySelector: querySelector$1,\n    querySelectorAll: querySelectorAll$1,\n    mutationObserver: mutationObserverCtor$1\n};\nfunction isElement(n2) {\n    return n2.nodeType === n2.ELEMENT_NODE;\n}\nfunction isShadowRoot(n2) {\n    var hostEl = // anchor and textarea elements also have a `host` property\n    // but only shadow roots have a `mode` property\n    n2 && \"host\" in n2 && \"mode\" in n2 && index$1.host(n2) || null;\n    return Boolean(hostEl && \"shadowRoot\" in hostEl && index$1.shadowRoot(hostEl) === n2);\n}\nfunction isNativeShadowDom(shadowRoot2) {\n    return Object.prototype.toString.call(shadowRoot2) === \"[object ShadowRoot]\";\n}\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\n    if (cssText.includes(\" background-clip: text;\") && !cssText.includes(\" -webkit-background-clip: text;\")) {\n        cssText = cssText.replace(/\\sbackground-clip:\\s*text;/g, \" -webkit-background-clip: text; background-clip: text;\");\n    }\n    return cssText;\n}\nfunction escapeImportStatement(rule2) {\n    var cssText = rule2.cssText;\n    if (cssText.split('\"').length < 3) return cssText;\n    var statement = [\n        \"@import\",\n        \"url(\" + JSON.stringify(rule2.href) + \")\"\n    ];\n    if (rule2.layerName === \"\") {\n        statement.push(\"layer\");\n    } else if (rule2.layerName) {\n        statement.push(\"layer(\" + rule2.layerName + \")\");\n    }\n    if (rule2.supportsText) {\n        statement.push(\"supports(\" + rule2.supportsText + \")\");\n    }\n    if (rule2.media.length) {\n        statement.push(rule2.media.mediaText);\n    }\n    return statement.join(\" \") + \";\";\n}\nfunction stringifyStylesheet(s2) {\n    try {\n        var rules2 = s2.rules || s2.cssRules;\n        if (!rules2) {\n            return null;\n        }\n        var sheetHref = s2.href;\n        if (!sheetHref && s2.ownerNode && s2.ownerNode.ownerDocument) {\n            sheetHref = s2.ownerNode.ownerDocument.location.href;\n        }\n        var stringifiedRules = Array.from(rules2, function(rule2) {\n            return stringifyRule(rule2, sheetHref);\n        }).join(\"\");\n        return fixBrowserCompatibilityIssuesInCSS(stringifiedRules);\n    } catch (error) {\n        return null;\n    }\n}\nfunction stringifyRule(rule2, sheetHref) {\n    if (isCSSImportRule(rule2)) {\n        var importStringified;\n        try {\n            importStringified = // we can access the imported stylesheet rules directly\n            stringifyStylesheet(rule2.styleSheet) || // work around browser issues with the raw string `@import url(...)` statement\n            escapeImportStatement(rule2);\n        } catch (error) {\n            importStringified = rule2.cssText;\n        }\n        if (rule2.styleSheet.href) {\n            return absolutifyURLs(importStringified, rule2.styleSheet.href);\n        }\n        return importStringified;\n    } else {\n        var ruleStringified = rule2.cssText;\n        if (isCSSStyleRule(rule2) && rule2.selectorText.includes(\":\")) {\n            ruleStringified = fixSafariColons(ruleStringified);\n        }\n        if (sheetHref) {\n            return absolutifyURLs(ruleStringified, sheetHref);\n        }\n        return ruleStringified;\n    }\n}\nfunction fixSafariColons(cssStringified) {\n    var regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\n    return cssStringified.replace(regex, \"$1\\\\$2\");\n}\nfunction isCSSImportRule(rule2) {\n    return \"styleSheet\" in rule2;\n}\nfunction isCSSStyleRule(rule2) {\n    return \"selectorText\" in rule2;\n}\nvar Mirror = /*#__PURE__*/ function() {\n    function Mirror() {\n        __publicField$1(this, \"idNodeMap\", /* @__PURE__ */ new Map());\n        __publicField$1(this, \"nodeMetaMap\", /* @__PURE__ */ new WeakMap());\n    }\n    var _proto = Mirror.prototype;\n    _proto.getId = function getId(n2) {\n        var _a2;\n        if (!n2) return -1;\n        var id = (_a2 = this.getMeta(n2)) == null ? void 0 : _a2.id;\n        return id != null ? id : -1;\n    };\n    _proto.getNode = function getNode(id) {\n        return this.idNodeMap.get(id) || null;\n    };\n    _proto.getIds = function getIds() {\n        return Array.from(this.idNodeMap.keys());\n    };\n    _proto.getMeta = function getMeta(n2) {\n        return this.nodeMetaMap.get(n2) || null;\n    };\n    // removes the node from idNodeMap\n    // doesn't remove the node from nodeMetaMap\n    _proto.removeNodeFromMap = function removeNodeFromMap(n2) {\n        var _this = this;\n        var id = this.getId(n2);\n        this.idNodeMap.delete(id);\n        if (n2.childNodes) {\n            n2.childNodes.forEach(function(childNode) {\n                return _this.removeNodeFromMap(childNode);\n            });\n        }\n    };\n    _proto.has = function has(id) {\n        return this.idNodeMap.has(id);\n    };\n    _proto.hasNode = function hasNode(node2) {\n        return this.nodeMetaMap.has(node2);\n    };\n    _proto.add = function add(n2, meta) {\n        var id = meta.id;\n        this.idNodeMap.set(id, n2);\n        this.nodeMetaMap.set(n2, meta);\n    };\n    _proto.replace = function replace(id, n2) {\n        var oldNode = this.getNode(id);\n        if (oldNode) {\n            var meta = this.nodeMetaMap.get(oldNode);\n            if (meta) this.nodeMetaMap.set(n2, meta);\n        }\n        this.idNodeMap.set(id, n2);\n    };\n    _proto.reset = function reset() {\n        this.idNodeMap = /* @__PURE__ */ new Map();\n        this.nodeMetaMap = /* @__PURE__ */ new WeakMap();\n    };\n    return Mirror;\n}();\nfunction createMirror$2() {\n    return new Mirror();\n}\nfunction maskInputValue(param) {\n    var element = param.element, maskInputOptions = param.maskInputOptions, tagName = param.tagName, type = param.type, value = param.value, maskInputFn = param.maskInputFn;\n    var text = value || \"\";\n    var actualType = type && toLowerCase(type);\n    if (maskInputOptions[tagName.toLowerCase()] || actualType && maskInputOptions[actualType]) {\n        if (maskInputFn) {\n            text = maskInputFn(text, element);\n        } else {\n            text = \"*\".repeat(text.length);\n        }\n    }\n    return text;\n}\nfunction toLowerCase(str) {\n    return str.toLowerCase();\n}\nvar ORIGINAL_ATTRIBUTE_NAME = \"__rrweb_original__\";\nfunction is2DCanvasBlank(canvas) {\n    var ctx = canvas.getContext(\"2d\");\n    if (!ctx) return true;\n    var chunkSize = 50;\n    for(var x2 = 0; x2 < canvas.width; x2 += chunkSize){\n        for(var y = 0; y < canvas.height; y += chunkSize){\n            var getImageData = ctx.getImageData;\n            var originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;\n            var pixelBuffer = new Uint32Array(// eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n            originalGetImageData.call(ctx, x2, y, Math.min(chunkSize, canvas.width - x2), Math.min(chunkSize, canvas.height - y)).data.buffer);\n            if (pixelBuffer.some(function(pixel) {\n                return pixel !== 0;\n            })) return false;\n        }\n    }\n    return true;\n}\nfunction getInputType(element) {\n    var type = element.type;\n    return element.hasAttribute(\"data-rr-is-password\") ? \"password\" : type ? // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    toLowerCase(type) : null;\n}\nfunction extractFileExtension(path, baseURL) {\n    var url;\n    try {\n        url = new URL(path, baseURL != null ? baseURL : window.location.href);\n    } catch (err) {\n        return null;\n    }\n    var regex = /\\.([0-9a-z]+)(?:$)/i;\n    var match = url.pathname.match(regex);\n    var _ref;\n    return (_ref = match == null ? void 0 : match[1]) != null ? _ref : null;\n}\nfunction extractOrigin(url) {\n    var origin = \"\";\n    if (url.indexOf(\"//\") > -1) {\n        origin = url.split(\"/\").slice(0, 3).join(\"/\");\n    } else {\n        origin = url.split(\"/\")[0];\n    }\n    origin = origin.split(\"?\")[0];\n    return origin;\n}\nvar URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nvar URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\nvar URL_WWW_MATCH = /^www\\..*/i;\nvar DATA_URI = /^(data:)([^,]*),(.*)/i;\nfunction absolutifyURLs(cssText, href) {\n    return (cssText || \"\").replace(URL_IN_CSS_REF, function(origin, quote1, path1, quote2, path2, path3) {\n        var filePath = path1 || path2 || path3;\n        var maybeQuote = quote1 || quote2 || \"\";\n        if (!filePath) {\n            return origin;\n        }\n        if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\n            return \"url(\" + maybeQuote + filePath + maybeQuote + \")\";\n        }\n        if (DATA_URI.test(filePath)) {\n            return \"url(\" + maybeQuote + filePath + maybeQuote + \")\";\n        }\n        if (filePath[0] === \"/\") {\n            return \"url(\" + maybeQuote + (extractOrigin(href) + filePath) + maybeQuote + \")\";\n        }\n        var stack = href.split(\"/\");\n        var parts = filePath.split(\"/\");\n        stack.pop();\n        for(var _iterator = _create_for_of_iterator_helper_loose(parts), _step; !(_step = _iterator()).done;){\n            var part = _step.value;\n            if (part === \".\") {\n                continue;\n            } else if (part === \"..\") {\n                stack.pop();\n            } else {\n                stack.push(part);\n            }\n        }\n        return \"url(\" + maybeQuote + stack.join(\"/\") + maybeQuote + \")\";\n    });\n}\nfunction normalizeCssString(cssText) {\n    return cssText.replace(/(\\/\\*[^*]*\\*\\/)|[\\s;]/g, \"\");\n}\nfunction splitCssText(cssText, style) {\n    var childNodes2 = Array.from(style.childNodes);\n    var splits = [];\n    if (childNodes2.length > 1 && cssText && typeof cssText === \"string\") {\n        var cssTextNorm = normalizeCssString(cssText);\n        for(var i2 = 1; i2 < childNodes2.length; i2++){\n            if (childNodes2[i2].textContent && typeof childNodes2[i2].textContent === \"string\") {\n                var textContentNorm = normalizeCssString(childNodes2[i2].textContent);\n                for(var j = 3; j < textContentNorm.length; j++){\n                    var bit = textContentNorm.substring(0, j);\n                    if (cssTextNorm.split(bit).length === 2) {\n                        var splitNorm = cssTextNorm.indexOf(bit);\n                        for(var k = splitNorm; k < cssText.length; k++){\n                            if (normalizeCssString(cssText.substring(0, k)).length === splitNorm) {\n                                splits.push(cssText.substring(0, k));\n                                cssText = cssText.substring(k);\n                                break;\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    splits.push(cssText);\n    return splits;\n}\nfunction markCssSplits(cssText, style) {\n    return splitCssText(cssText, style).join(\"/* rr_split */\");\n}\nvar _id = 1;\nvar tagNameRegex = new RegExp(\"[^a-z0-9-_:]\");\nvar IGNORED_NODE = -2;\nfunction genId() {\n    return _id++;\n}\nfunction getValidTagName$1(element) {\n    if (_instanceof(element, HTMLFormElement)) {\n        return \"form\";\n    }\n    var processedTagName = toLowerCase(element.tagName);\n    if (tagNameRegex.test(processedTagName)) {\n        return \"div\";\n    }\n    return processedTagName;\n}\nvar canvasService;\nvar canvasCtx;\nvar SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\nvar SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\n    if (attributeValue.trim() === \"\") {\n        return attributeValue;\n    }\n    var pos = 0;\n    function collectCharacters(regEx) {\n        var chars2;\n        var match = regEx.exec(attributeValue.substring(pos));\n        if (match) {\n            chars2 = match[0];\n            pos += chars2.length;\n            return chars2;\n        }\n        return \"\";\n    }\n    var output = [];\n    while(true){\n        collectCharacters(SRCSET_COMMAS_OR_SPACES);\n        if (pos >= attributeValue.length) {\n            break;\n        }\n        var url = collectCharacters(SRCSET_NOT_SPACES);\n        if (url.slice(-1) === \",\") {\n            url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n            output.push(url);\n        } else {\n            var descriptorsStr = \"\";\n            url = absoluteToDoc(doc, url);\n            var inParens = false;\n            while(true){\n                var c2 = attributeValue.charAt(pos);\n                if (c2 === \"\") {\n                    output.push((url + descriptorsStr).trim());\n                    break;\n                } else if (!inParens) {\n                    if (c2 === \",\") {\n                        pos += 1;\n                        output.push((url + descriptorsStr).trim());\n                        break;\n                    } else if (c2 === \"(\") {\n                        inParens = true;\n                    }\n                } else {\n                    if (c2 === \")\") {\n                        inParens = false;\n                    }\n                }\n                descriptorsStr += c2;\n                pos += 1;\n            }\n        }\n    }\n    return output.join(\", \");\n}\nvar cachedDocument = /* @__PURE__ */ new WeakMap();\nfunction absoluteToDoc(doc, attributeValue) {\n    if (!attributeValue || attributeValue.trim() === \"\") {\n        return attributeValue;\n    }\n    return getHref(doc, attributeValue);\n}\nfunction isSVGElement(el) {\n    return Boolean(el.tagName === \"svg\" || el.ownerSVGElement);\n}\nfunction getHref(doc, customHref) {\n    var a2 = cachedDocument.get(doc);\n    if (!a2) {\n        a2 = doc.createElement(\"a\");\n        cachedDocument.set(doc, a2);\n    }\n    if (!customHref) {\n        customHref = \"\";\n    } else if (customHref.startsWith(\"blob:\") || customHref.startsWith(\"data:\")) {\n        return customHref;\n    }\n    a2.setAttribute(\"href\", customHref);\n    return a2.href;\n}\nfunction transformAttribute(doc, tagName, name, value) {\n    if (!value) {\n        return value;\n    }\n    if (name === \"src\" || name === \"href\" && !(tagName === \"use\" && value[0] === \"#\")) {\n        return absoluteToDoc(doc, value);\n    } else if (name === \"xlink:href\" && value[0] !== \"#\") {\n        return absoluteToDoc(doc, value);\n    } else if (name === \"background\" && (tagName === \"table\" || tagName === \"td\" || tagName === \"th\")) {\n        return absoluteToDoc(doc, value);\n    } else if (name === \"srcset\") {\n        return getAbsoluteSrcsetString(doc, value);\n    } else if (name === \"style\") {\n        return absolutifyURLs(value, getHref(doc));\n    } else if (tagName === \"object\" && name === \"data\") {\n        return absoluteToDoc(doc, value);\n    }\n    return value;\n}\nfunction ignoreAttribute(tagName, name, _value) {\n    return (tagName === \"video\" || tagName === \"audio\") && name === \"autoplay\";\n}\nfunction _isBlockedElement(element, blockClass, blockSelector) {\n    try {\n        if (typeof blockClass === \"string\") {\n            if (element.classList.contains(blockClass)) {\n                return true;\n            }\n        } else {\n            for(var eIndex = element.classList.length; eIndex--;){\n                var className = element.classList[eIndex];\n                if (blockClass.test(className)) {\n                    return true;\n                }\n            }\n        }\n        if (blockSelector) {\n            return element.matches(blockSelector);\n        }\n    } catch (e2) {}\n    return false;\n}\nfunction classMatchesRegex(node2, regex, checkAncestors) {\n    if (!node2) return false;\n    if (node2.nodeType !== node2.ELEMENT_NODE) {\n        if (!checkAncestors) return false;\n        return classMatchesRegex(index$1.parentNode(node2), regex, checkAncestors);\n    }\n    for(var eIndex = node2.classList.length; eIndex--;){\n        var className = node2.classList[eIndex];\n        if (regex.test(className)) {\n            return true;\n        }\n    }\n    if (!checkAncestors) return false;\n    return classMatchesRegex(index$1.parentNode(node2), regex, checkAncestors);\n}\nfunction needMaskingText(node2, maskTextClass, maskTextSelector, checkAncestors) {\n    var el;\n    if (isElement(node2)) {\n        el = node2;\n        if (!index$1.childNodes(el).length) {\n            return false;\n        }\n    } else if (index$1.parentElement(node2) === null) {\n        return false;\n    } else {\n        el = index$1.parentElement(node2);\n    }\n    try {\n        if (typeof maskTextClass === \"string\") {\n            if (checkAncestors) {\n                if (el.closest(\".\" + maskTextClass)) return true;\n            } else {\n                if (el.classList.contains(maskTextClass)) return true;\n            }\n        } else {\n            if (classMatchesRegex(el, maskTextClass, checkAncestors)) return true;\n        }\n        if (maskTextSelector) {\n            if (checkAncestors) {\n                if (el.closest(maskTextSelector)) return true;\n            } else {\n                if (el.matches(maskTextSelector)) return true;\n            }\n        }\n    } catch (e2) {}\n    return false;\n}\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\n    var win = iframeEl.contentWindow;\n    if (!win) {\n        return;\n    }\n    var fired = false;\n    var readyState;\n    try {\n        readyState = win.document.readyState;\n    } catch (error) {\n        return;\n    }\n    if (readyState !== \"complete\") {\n        var timer = setTimeout(function() {\n            if (!fired) {\n                listener();\n                fired = true;\n            }\n        }, iframeLoadTimeout);\n        iframeEl.addEventListener(\"load\", function() {\n            clearTimeout(timer);\n            fired = true;\n            listener();\n        });\n        return;\n    }\n    var blankUrl = \"about:blank\";\n    if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === \"\") {\n        setTimeout(listener, 0);\n        return iframeEl.addEventListener(\"load\", listener);\n    }\n    iframeEl.addEventListener(\"load\", listener);\n}\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\n    var fired = false;\n    var styleSheetLoaded;\n    try {\n        styleSheetLoaded = link.sheet;\n    } catch (error) {\n        return;\n    }\n    if (styleSheetLoaded) return;\n    var timer = setTimeout(function() {\n        if (!fired) {\n            listener();\n            fired = true;\n        }\n    }, styleSheetLoadTimeout);\n    link.addEventListener(\"load\", function() {\n        clearTimeout(timer);\n        fired = true;\n        listener();\n    });\n}\nfunction serializeNode(n2, options) {\n    var doc = options.doc, mirror2 = options.mirror, blockClass = options.blockClass, blockSelector = options.blockSelector, needsMask = options.needsMask, inlineStylesheet = options.inlineStylesheet, _options_maskInputOptions = options.maskInputOptions, maskInputOptions = _options_maskInputOptions === void 0 ? {} : _options_maskInputOptions, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, _options_dataURLOptions = options.dataURLOptions, dataURLOptions = _options_dataURLOptions === void 0 ? {} : _options_dataURLOptions, inlineImages = options.inlineImages, recordCanvas = options.recordCanvas, keepIframeSrcFn = options.keepIframeSrcFn, _options_newlyAddedElement = options.newlyAddedElement, newlyAddedElement = _options_newlyAddedElement === void 0 ? false : _options_newlyAddedElement, _options_cssCaptured = options.cssCaptured, cssCaptured = _options_cssCaptured === void 0 ? false : _options_cssCaptured;\n    var rootId = getRootId(doc, mirror2);\n    switch(n2.nodeType){\n        case n2.DOCUMENT_NODE:\n            if (n2.compatMode !== \"CSS1Compat\") {\n                return {\n                    type: NodeType$3.Document,\n                    childNodes: [],\n                    compatMode: n2.compatMode\n                };\n            } else {\n                return {\n                    type: NodeType$3.Document,\n                    childNodes: []\n                };\n            }\n        case n2.DOCUMENT_TYPE_NODE:\n            return {\n                type: NodeType$3.DocumentType,\n                name: n2.name,\n                publicId: n2.publicId,\n                systemId: n2.systemId,\n                rootId: rootId\n            };\n        case n2.ELEMENT_NODE:\n            return serializeElementNode(n2, {\n                doc: doc,\n                blockClass: blockClass,\n                blockSelector: blockSelector,\n                inlineStylesheet: inlineStylesheet,\n                maskInputOptions: maskInputOptions,\n                maskInputFn: maskInputFn,\n                dataURLOptions: dataURLOptions,\n                inlineImages: inlineImages,\n                recordCanvas: recordCanvas,\n                keepIframeSrcFn: keepIframeSrcFn,\n                newlyAddedElement: newlyAddedElement,\n                rootId: rootId\n            });\n        case n2.TEXT_NODE:\n            return serializeTextNode(n2, {\n                doc: doc,\n                needsMask: needsMask,\n                maskTextFn: maskTextFn,\n                rootId: rootId,\n                cssCaptured: cssCaptured\n            });\n        case n2.CDATA_SECTION_NODE:\n            return {\n                type: NodeType$3.CDATA,\n                textContent: \"\",\n                rootId: rootId\n            };\n        case n2.COMMENT_NODE:\n            return {\n                type: NodeType$3.Comment,\n                textContent: index$1.textContent(n2) || \"\",\n                rootId: rootId\n            };\n        default:\n            return false;\n    }\n}\nfunction getRootId(doc, mirror2) {\n    if (!mirror2.hasNode(doc)) return void 0;\n    var docId = mirror2.getId(doc);\n    return docId === 1 ? void 0 : docId;\n}\nfunction serializeTextNode(n2, options) {\n    var needsMask = options.needsMask, maskTextFn = options.maskTextFn, rootId = options.rootId, cssCaptured = options.cssCaptured;\n    var parent = index$1.parentNode(n2);\n    var parentTagName = parent && parent.tagName;\n    var textContent2 = \"\";\n    var isStyle = parentTagName === \"STYLE\" ? true : void 0;\n    var isScript = parentTagName === \"SCRIPT\" ? true : void 0;\n    if (isScript) {\n        textContent2 = \"SCRIPT_PLACEHOLDER\";\n    } else if (!cssCaptured) {\n        textContent2 = index$1.textContent(n2);\n        if (isStyle && textContent2) {\n            textContent2 = absolutifyURLs(textContent2, getHref(options.doc));\n        }\n    }\n    if (!isStyle && !isScript && textContent2 && needsMask) {\n        textContent2 = maskTextFn ? maskTextFn(textContent2, index$1.parentElement(n2)) : textContent2.replace(/[\\S]/g, \"*\");\n    }\n    return {\n        type: NodeType$3.Text,\n        textContent: textContent2 || \"\",\n        rootId: rootId\n    };\n}\nfunction serializeElementNode(n2, options) {\n    var doc = options.doc, blockClass = options.blockClass, blockSelector = options.blockSelector, inlineStylesheet = options.inlineStylesheet, _options_maskInputOptions = options.maskInputOptions, maskInputOptions = _options_maskInputOptions === void 0 ? {} : _options_maskInputOptions, maskInputFn = options.maskInputFn, _options_dataURLOptions = options.dataURLOptions, dataURLOptions = _options_dataURLOptions === void 0 ? {} : _options_dataURLOptions, inlineImages = options.inlineImages, recordCanvas = options.recordCanvas, keepIframeSrcFn = options.keepIframeSrcFn, _options_newlyAddedElement = options.newlyAddedElement, newlyAddedElement = _options_newlyAddedElement === void 0 ? false : _options_newlyAddedElement, rootId = options.rootId;\n    var needBlock = _isBlockedElement(n2, blockClass, blockSelector);\n    var tagName = getValidTagName$1(n2);\n    var attributes = {};\n    var len = n2.attributes.length;\n    for(var i2 = 0; i2 < len; i2++){\n        var attr = n2.attributes[i2];\n        if (!ignoreAttribute(tagName, attr.name, attr.value)) {\n            attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value);\n        }\n    }\n    if (tagName === \"link\" && inlineStylesheet) {\n        var stylesheet = Array.from(doc.styleSheets).find(function(s2) {\n            return s2.href === n2.href;\n        });\n        var cssText = null;\n        if (stylesheet) {\n            cssText = stringifyStylesheet(stylesheet);\n        }\n        if (cssText) {\n            delete attributes.rel;\n            delete attributes.href;\n            attributes._cssText = cssText;\n        }\n    }\n    if (tagName === \"style\" && n2.sheet) {\n        var cssText1 = stringifyStylesheet(n2.sheet);\n        if (cssText1) {\n            if (n2.childNodes.length > 1) {\n                cssText1 = markCssSplits(cssText1, n2);\n            }\n            attributes._cssText = cssText1;\n        }\n    }\n    if (tagName === \"input\" || tagName === \"textarea\" || tagName === \"select\") {\n        var value = n2.value;\n        var checked = n2.checked;\n        if (attributes.type !== \"radio\" && attributes.type !== \"checkbox\" && attributes.type !== \"submit\" && attributes.type !== \"button\" && value) {\n            attributes.value = maskInputValue({\n                element: n2,\n                type: getInputType(n2),\n                tagName: tagName,\n                value: value,\n                maskInputOptions: maskInputOptions,\n                maskInputFn: maskInputFn\n            });\n        } else if (checked) {\n            attributes.checked = checked;\n        }\n    }\n    if (tagName === \"option\") {\n        if (n2.selected && !maskInputOptions[\"select\"]) {\n            attributes.selected = true;\n        } else {\n            delete attributes.selected;\n        }\n    }\n    if (tagName === \"dialog\" && n2.open) {\n        attributes.rr_open_mode = n2.matches(\"dialog:modal\") ? \"modal\" : \"non-modal\";\n    }\n    if (tagName === \"canvas\" && recordCanvas) {\n        if (n2.__context === \"2d\") {\n            if (!is2DCanvasBlank(n2)) {\n                attributes.rr_dataURL = n2.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            }\n        } else if (!(\"__context\" in n2)) {\n            var canvasDataURL = n2.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            var blankCanvas = doc.createElement(\"canvas\");\n            blankCanvas.width = n2.width;\n            blankCanvas.height = n2.height;\n            var blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            if (canvasDataURL !== blankCanvasDataURL) {\n                attributes.rr_dataURL = canvasDataURL;\n            }\n        }\n    }\n    if (tagName === \"img\" && inlineImages) {\n        if (!canvasService) {\n            canvasService = doc.createElement(\"canvas\");\n            canvasCtx = canvasService.getContext(\"2d\");\n        }\n        var image = n2;\n        var imageSrc = image.currentSrc || image.getAttribute(\"src\") || \"<unknown-src>\";\n        var priorCrossOrigin = image.crossOrigin;\n        var recordInlineImage = function() {\n            image.removeEventListener(\"load\", recordInlineImage);\n            try {\n                canvasService.width = image.naturalWidth;\n                canvasService.height = image.naturalHeight;\n                canvasCtx.drawImage(image, 0, 0);\n                attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\n            } catch (err) {\n                if (image.crossOrigin !== \"anonymous\") {\n                    image.crossOrigin = \"anonymous\";\n                    if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n                    else image.addEventListener(\"load\", recordInlineImage);\n                    return;\n                } else {\n                    console.warn(\"Cannot inline img src=\" + imageSrc + \"! Error: \" + err);\n                }\n            }\n            if (image.crossOrigin === \"anonymous\") {\n                priorCrossOrigin ? attributes.crossOrigin = priorCrossOrigin : image.removeAttribute(\"crossorigin\");\n            }\n        };\n        if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n        else image.addEventListener(\"load\", recordInlineImage);\n    }\n    if (tagName === \"audio\" || tagName === \"video\") {\n        var mediaAttributes = attributes;\n        mediaAttributes.rr_mediaState = n2.paused ? \"paused\" : \"played\";\n        mediaAttributes.rr_mediaCurrentTime = n2.currentTime;\n        mediaAttributes.rr_mediaPlaybackRate = n2.playbackRate;\n        mediaAttributes.rr_mediaMuted = n2.muted;\n        mediaAttributes.rr_mediaLoop = n2.loop;\n        mediaAttributes.rr_mediaVolume = n2.volume;\n    }\n    if (!newlyAddedElement) {\n        if (n2.scrollLeft) {\n            attributes.rr_scrollLeft = n2.scrollLeft;\n        }\n        if (n2.scrollTop) {\n            attributes.rr_scrollTop = n2.scrollTop;\n        }\n    }\n    if (needBlock) {\n        var _n2_getBoundingClientRect = n2.getBoundingClientRect(), width = _n2_getBoundingClientRect.width, height = _n2_getBoundingClientRect.height;\n        attributes = {\n            class: attributes.class,\n            rr_width: \"\" + width + \"px\",\n            rr_height: \"\" + height + \"px\"\n        };\n    }\n    if (tagName === \"iframe\" && !keepIframeSrcFn(attributes.src)) {\n        if (!n2.contentDocument) {\n            attributes.rr_src = attributes.src;\n        }\n        delete attributes.src;\n    }\n    var isCustomElement;\n    try {\n        if (customElements.get(tagName)) isCustomElement = true;\n    } catch (e2) {}\n    return {\n        type: NodeType$3.Element,\n        tagName: tagName,\n        attributes: attributes,\n        childNodes: [],\n        isSVG: isSVGElement(n2) || void 0,\n        needBlock: needBlock,\n        rootId: rootId,\n        isCustom: isCustomElement\n    };\n}\nfunction lowerIfExists(maybeAttr) {\n    if (maybeAttr === void 0 || maybeAttr === null) {\n        return \"\";\n    } else {\n        return maybeAttr.toLowerCase();\n    }\n}\nfunction slimDOMExcluded(sn, slimDOMOptions) {\n    if (slimDOMOptions.comment && sn.type === NodeType$3.Comment) {\n        return true;\n    } else if (sn.type === NodeType$3.Element) {\n        if (slimDOMOptions.script && // script tag\n        (sn.tagName === \"script\" || // (module)preload link\n        sn.tagName === \"link\" && (sn.attributes.rel === \"preload\" || sn.attributes.rel === \"modulepreload\") && sn.attributes.as === \"script\" || // prefetch link\n        sn.tagName === \"link\" && sn.attributes.rel === \"prefetch\" && typeof sn.attributes.href === \"string\" && extractFileExtension(sn.attributes.href) === \"js\")) {\n            return true;\n        } else if (slimDOMOptions.headFavicon && (sn.tagName === \"link\" && sn.attributes.rel === \"shortcut icon\" || sn.tagName === \"meta\" && (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) || lowerIfExists(sn.attributes.name) === \"application-name\" || lowerIfExists(sn.attributes.rel) === \"icon\" || lowerIfExists(sn.attributes.rel) === \"apple-touch-icon\" || lowerIfExists(sn.attributes.rel) === \"shortcut icon\"))) {\n            return true;\n        } else if (sn.tagName === \"meta\") {\n            if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\n                return true;\n            } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n            lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === \"pinterest\")) {\n                return true;\n            } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === \"robots\" || lowerIfExists(sn.attributes.name) === \"googlebot\" || lowerIfExists(sn.attributes.name) === \"bingbot\")) {\n                return true;\n            } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes[\"http-equiv\"] !== void 0) {\n                return true;\n            } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === \"author\" || lowerIfExists(sn.attributes.name) === \"generator\" || lowerIfExists(sn.attributes.name) === \"framework\" || lowerIfExists(sn.attributes.name) === \"publisher\" || lowerIfExists(sn.attributes.name) === \"progid\" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {\n                return true;\n            } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === \"google-site-verification\" || lowerIfExists(sn.attributes.name) === \"yandex-verification\" || lowerIfExists(sn.attributes.name) === \"csrf-token\" || lowerIfExists(sn.attributes.name) === \"p:domain_verify\" || lowerIfExists(sn.attributes.name) === \"verify-v1\" || lowerIfExists(sn.attributes.name) === \"verification\" || lowerIfExists(sn.attributes.name) === \"shopify-checkout-api-token\")) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction serializeNodeWithId(n2, options) {\n    var doc = options.doc, mirror2 = options.mirror, blockClass = options.blockClass, blockSelector = options.blockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, _options_skipChild = options.skipChild, skipChild = _options_skipChild === void 0 ? false : _options_skipChild, _options_inlineStylesheet = options.inlineStylesheet, inlineStylesheet = _options_inlineStylesheet === void 0 ? true : _options_inlineStylesheet, _options_maskInputOptions = options.maskInputOptions, maskInputOptions = _options_maskInputOptions === void 0 ? {} : _options_maskInputOptions, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, slimDOMOptions = options.slimDOMOptions, _options_dataURLOptions = options.dataURLOptions, dataURLOptions = _options_dataURLOptions === void 0 ? {} : _options_dataURLOptions, _options_inlineImages = options.inlineImages, inlineImages = _options_inlineImages === void 0 ? false : _options_inlineImages, _options_recordCanvas = options.recordCanvas, recordCanvas = _options_recordCanvas === void 0 ? false : _options_recordCanvas, onSerialize = options.onSerialize, onIframeLoad = options.onIframeLoad, _options_iframeLoadTimeout = options.iframeLoadTimeout, iframeLoadTimeout = _options_iframeLoadTimeout === void 0 ? 5e3 : _options_iframeLoadTimeout, onStylesheetLoad = options.onStylesheetLoad, _options_stylesheetLoadTimeout = options.stylesheetLoadTimeout, stylesheetLoadTimeout = _options_stylesheetLoadTimeout === void 0 ? 5e3 : _options_stylesheetLoadTimeout, _options_keepIframeSrcFn = options.keepIframeSrcFn, keepIframeSrcFn = _options_keepIframeSrcFn === void 0 ? function() {\n        return false;\n    } : _options_keepIframeSrcFn, _options_newlyAddedElement = options.newlyAddedElement, newlyAddedElement = _options_newlyAddedElement === void 0 ? false : _options_newlyAddedElement, _options_cssCaptured = options.cssCaptured, cssCaptured = _options_cssCaptured === void 0 ? false : _options_cssCaptured;\n    var needsMask = options.needsMask;\n    var _options_preserveWhiteSpace = options.preserveWhiteSpace, preserveWhiteSpace = _options_preserveWhiteSpace === void 0 ? true : _options_preserveWhiteSpace;\n    if (!needsMask) {\n        var checkAncestors = needsMask === void 0;\n        needsMask = needMaskingText(n2, maskTextClass, maskTextSelector, checkAncestors);\n    }\n    var _serializedNode = serializeNode(n2, {\n        doc: doc,\n        mirror: mirror2,\n        blockClass: blockClass,\n        blockSelector: blockSelector,\n        needsMask: needsMask,\n        inlineStylesheet: inlineStylesheet,\n        maskInputOptions: maskInputOptions,\n        maskTextFn: maskTextFn,\n        maskInputFn: maskInputFn,\n        dataURLOptions: dataURLOptions,\n        inlineImages: inlineImages,\n        recordCanvas: recordCanvas,\n        keepIframeSrcFn: keepIframeSrcFn,\n        newlyAddedElement: newlyAddedElement,\n        cssCaptured: cssCaptured\n    });\n    if (!_serializedNode) {\n        console.warn(n2, \"not serialized\");\n        return null;\n    }\n    var id;\n    if (mirror2.hasNode(n2)) {\n        id = mirror2.getId(n2);\n    } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType$3.Text && !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, \"\").length) {\n        id = IGNORED_NODE;\n    } else {\n        id = genId();\n    }\n    var serializedNode = Object.assign(_serializedNode, {\n        id: id\n    });\n    mirror2.add(n2, serializedNode);\n    if (id === IGNORED_NODE) {\n        return null;\n    }\n    if (onSerialize) {\n        onSerialize(n2);\n    }\n    var recordChild = !skipChild;\n    if (serializedNode.type === NodeType$3.Element) {\n        recordChild = recordChild && !serializedNode.needBlock;\n        delete serializedNode.needBlock;\n        var shadowRootEl = index$1.shadowRoot(n2);\n        if (shadowRootEl && isNativeShadowDom(shadowRootEl)) serializedNode.isShadowHost = true;\n    }\n    if ((serializedNode.type === NodeType$3.Document || serializedNode.type === NodeType$3.Element) && recordChild) {\n        if (slimDOMOptions.headWhitespace && serializedNode.type === NodeType$3.Element && serializedNode.tagName === \"head\") {\n            preserveWhiteSpace = false;\n        }\n        var bypassOptions = {\n            doc: doc,\n            mirror: mirror2,\n            blockClass: blockClass,\n            blockSelector: blockSelector,\n            needsMask: needsMask,\n            maskTextClass: maskTextClass,\n            maskTextSelector: maskTextSelector,\n            skipChild: skipChild,\n            inlineStylesheet: inlineStylesheet,\n            maskInputOptions: maskInputOptions,\n            maskTextFn: maskTextFn,\n            maskInputFn: maskInputFn,\n            slimDOMOptions: slimDOMOptions,\n            dataURLOptions: dataURLOptions,\n            inlineImages: inlineImages,\n            recordCanvas: recordCanvas,\n            preserveWhiteSpace: preserveWhiteSpace,\n            onSerialize: onSerialize,\n            onIframeLoad: onIframeLoad,\n            iframeLoadTimeout: iframeLoadTimeout,\n            onStylesheetLoad: onStylesheetLoad,\n            stylesheetLoadTimeout: stylesheetLoadTimeout,\n            keepIframeSrcFn: keepIframeSrcFn,\n            cssCaptured: false\n        };\n        if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === \"textarea\" && serializedNode.attributes.value !== void 0) ;\n        else {\n            if (serializedNode.type === NodeType$3.Element && serializedNode.attributes._cssText !== void 0 && typeof serializedNode.attributes._cssText === \"string\") {\n                bypassOptions.cssCaptured = true;\n            }\n            for(var _iterator = _create_for_of_iterator_helper_loose(Array.from(index$1.childNodes(n2))), _step; !(_step = _iterator()).done;){\n                var childN = _step.value;\n                var serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n                if (serializedChildNode) {\n                    serializedNode.childNodes.push(serializedChildNode);\n                }\n            }\n        }\n        var shadowRootEl1 = null;\n        if (isElement(n2) && (shadowRootEl1 = index$1.shadowRoot(n2))) {\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(Array.from(index$1.childNodes(shadowRootEl1))), _step1; !(_step1 = _iterator1()).done;){\n                var childN1 = _step1.value;\n                var serializedChildNode1 = serializeNodeWithId(childN1, bypassOptions);\n                if (serializedChildNode1) {\n                    isNativeShadowDom(shadowRootEl1) && (serializedChildNode1.isShadow = true);\n                    serializedNode.childNodes.push(serializedChildNode1);\n                }\n            }\n        }\n    }\n    var parent = index$1.parentNode(n2);\n    if (parent && isShadowRoot(parent) && isNativeShadowDom(parent)) {\n        serializedNode.isShadow = true;\n    }\n    if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === \"iframe\") {\n        onceIframeLoaded(n2, function() {\n            var iframeDoc = n2.contentDocument;\n            if (iframeDoc && onIframeLoad) {\n                var serializedIframeNode = serializeNodeWithId(iframeDoc, {\n                    doc: iframeDoc,\n                    mirror: mirror2,\n                    blockClass: blockClass,\n                    blockSelector: blockSelector,\n                    needsMask: needsMask,\n                    maskTextClass: maskTextClass,\n                    maskTextSelector: maskTextSelector,\n                    skipChild: false,\n                    inlineStylesheet: inlineStylesheet,\n                    maskInputOptions: maskInputOptions,\n                    maskTextFn: maskTextFn,\n                    maskInputFn: maskInputFn,\n                    slimDOMOptions: slimDOMOptions,\n                    dataURLOptions: dataURLOptions,\n                    inlineImages: inlineImages,\n                    recordCanvas: recordCanvas,\n                    preserveWhiteSpace: preserveWhiteSpace,\n                    onSerialize: onSerialize,\n                    onIframeLoad: onIframeLoad,\n                    iframeLoadTimeout: iframeLoadTimeout,\n                    onStylesheetLoad: onStylesheetLoad,\n                    stylesheetLoadTimeout: stylesheetLoadTimeout,\n                    keepIframeSrcFn: keepIframeSrcFn\n                });\n                if (serializedIframeNode) {\n                    onIframeLoad(n2, serializedIframeNode);\n                }\n            }\n        }, iframeLoadTimeout);\n    }\n    if (serializedNode.type === NodeType$3.Element && serializedNode.tagName === \"link\" && typeof serializedNode.attributes.rel === \"string\" && (serializedNode.attributes.rel === \"stylesheet\" || serializedNode.attributes.rel === \"preload\" && typeof serializedNode.attributes.href === \"string\" && extractFileExtension(serializedNode.attributes.href) === \"css\")) {\n        onceStylesheetLoaded(n2, function() {\n            if (onStylesheetLoad) {\n                var serializedLinkNode = serializeNodeWithId(n2, {\n                    doc: doc,\n                    mirror: mirror2,\n                    blockClass: blockClass,\n                    blockSelector: blockSelector,\n                    needsMask: needsMask,\n                    maskTextClass: maskTextClass,\n                    maskTextSelector: maskTextSelector,\n                    skipChild: false,\n                    inlineStylesheet: inlineStylesheet,\n                    maskInputOptions: maskInputOptions,\n                    maskTextFn: maskTextFn,\n                    maskInputFn: maskInputFn,\n                    slimDOMOptions: slimDOMOptions,\n                    dataURLOptions: dataURLOptions,\n                    inlineImages: inlineImages,\n                    recordCanvas: recordCanvas,\n                    preserveWhiteSpace: preserveWhiteSpace,\n                    onSerialize: onSerialize,\n                    onIframeLoad: onIframeLoad,\n                    iframeLoadTimeout: iframeLoadTimeout,\n                    onStylesheetLoad: onStylesheetLoad,\n                    stylesheetLoadTimeout: stylesheetLoadTimeout,\n                    keepIframeSrcFn: keepIframeSrcFn\n                });\n                if (serializedLinkNode) {\n                    onStylesheetLoad(n2, serializedLinkNode);\n                }\n            }\n        }, stylesheetLoadTimeout);\n    }\n    return serializedNode;\n}\nfunction snapshot(n2, options) {\n    var _ref = options || {}, tmp = _ref.mirror, mirror2 = tmp === void 0 ? new Mirror() : tmp, _ref_blockClass = _ref.blockClass, blockClass = _ref_blockClass === void 0 ? \"rr-block\" : _ref_blockClass, _ref_blockSelector = _ref.blockSelector, blockSelector = _ref_blockSelector === void 0 ? null : _ref_blockSelector, _ref_maskTextClass = _ref.maskTextClass, maskTextClass = _ref_maskTextClass === void 0 ? \"rr-mask\" : _ref_maskTextClass, _ref_maskTextSelector = _ref.maskTextSelector, maskTextSelector = _ref_maskTextSelector === void 0 ? null : _ref_maskTextSelector, _ref_inlineStylesheet = _ref.inlineStylesheet, inlineStylesheet = _ref_inlineStylesheet === void 0 ? true : _ref_inlineStylesheet, _ref_inlineImages = _ref.inlineImages, inlineImages = _ref_inlineImages === void 0 ? false : _ref_inlineImages, _ref_recordCanvas = _ref.recordCanvas, recordCanvas = _ref_recordCanvas === void 0 ? false : _ref_recordCanvas, _ref_maskAllInputs = _ref.maskAllInputs, maskAllInputs = _ref_maskAllInputs === void 0 ? false : _ref_maskAllInputs, maskTextFn = _ref.maskTextFn, maskInputFn = _ref.maskInputFn, _ref_slimDOM = _ref.slimDOM, slimDOM = _ref_slimDOM === void 0 ? false : _ref_slimDOM, dataURLOptions = _ref.dataURLOptions, preserveWhiteSpace = _ref.preserveWhiteSpace, onSerialize = _ref.onSerialize, onIframeLoad = _ref.onIframeLoad, iframeLoadTimeout = _ref.iframeLoadTimeout, onStylesheetLoad = _ref.onStylesheetLoad, stylesheetLoadTimeout = _ref.stylesheetLoadTimeout, _ref_keepIframeSrcFn = _ref.keepIframeSrcFn, keepIframeSrcFn = _ref_keepIframeSrcFn === void 0 ? function() {\n        return false;\n    } : _ref_keepIframeSrcFn;\n    var maskInputOptions = maskAllInputs === true ? {\n        color: true,\n        date: true,\n        \"datetime-local\": true,\n        email: true,\n        month: true,\n        number: true,\n        range: true,\n        search: true,\n        tel: true,\n        text: true,\n        time: true,\n        url: true,\n        week: true,\n        textarea: true,\n        select: true,\n        password: true\n    } : maskAllInputs === false ? {\n        password: true\n    } : maskAllInputs;\n    var slimDOMOptions = slimDOM === true || slimDOM === \"all\" ? // if true: set of sensible options that should not throw away any information\n    {\n        script: true,\n        comment: true,\n        headFavicon: true,\n        headWhitespace: true,\n        headMetaDescKeywords: slimDOM === \"all\",\n        // destructive\n        headMetaSocial: true,\n        headMetaRobots: true,\n        headMetaHttpEquiv: true,\n        headMetaAuthorship: true,\n        headMetaVerification: true\n    } : slimDOM === false ? {} : slimDOM;\n    return serializeNodeWithId(n2, {\n        doc: n2,\n        mirror: mirror2,\n        blockClass: blockClass,\n        blockSelector: blockSelector,\n        maskTextClass: maskTextClass,\n        maskTextSelector: maskTextSelector,\n        skipChild: false,\n        inlineStylesheet: inlineStylesheet,\n        maskInputOptions: maskInputOptions,\n        maskTextFn: maskTextFn,\n        maskInputFn: maskInputFn,\n        slimDOMOptions: slimDOMOptions,\n        dataURLOptions: dataURLOptions,\n        inlineImages: inlineImages,\n        recordCanvas: recordCanvas,\n        preserveWhiteSpace: preserveWhiteSpace,\n        onSerialize: onSerialize,\n        onIframeLoad: onIframeLoad,\n        iframeLoadTimeout: iframeLoadTimeout,\n        onStylesheetLoad: onStylesheetLoad,\n        stylesheetLoadTimeout: stylesheetLoadTimeout,\n        keepIframeSrcFn: keepIframeSrcFn,\n        newlyAddedElement: false\n    });\n}\nfunction getDefaultExportFromCjs$1(x2) {\n    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, \"default\") ? x2[\"default\"] : x2;\n}\nfunction getAugmentedNamespace$1(n2) {\n    if (n2.__esModule) return n2;\n    var f2 = n2.default;\n    if (typeof f2 == \"function\") {\n        var a2 = function a22() {\n            if (_instanceof(this, a22)) {\n                return Reflect.construct(f2, arguments, this.constructor);\n            }\n            return f2.apply(this, arguments);\n        };\n        a2.prototype = f2.prototype;\n    } else a2 = {};\n    Object.defineProperty(a2, \"__esModule\", {\n        value: true\n    });\n    Object.keys(n2).forEach(function(k) {\n        var d = Object.getOwnPropertyDescriptor(n2, k);\n        Object.defineProperty(a2, k, d.get ? d : {\n            enumerable: true,\n            get: function get() {\n                return n2[k];\n            }\n        });\n    });\n    return a2;\n}\nvar picocolors_browser$1 = {\n    exports: {}\n};\nvar x$1 = String;\nvar create$1 = function create$1() {\n    return {\n        isColorSupported: false,\n        reset: x$1,\n        bold: x$1,\n        dim: x$1,\n        italic: x$1,\n        underline: x$1,\n        inverse: x$1,\n        hidden: x$1,\n        strikethrough: x$1,\n        black: x$1,\n        red: x$1,\n        green: x$1,\n        yellow: x$1,\n        blue: x$1,\n        magenta: x$1,\n        cyan: x$1,\n        white: x$1,\n        gray: x$1,\n        bgBlack: x$1,\n        bgRed: x$1,\n        bgGreen: x$1,\n        bgYellow: x$1,\n        bgBlue: x$1,\n        bgMagenta: x$1,\n        bgCyan: x$1,\n        bgWhite: x$1\n    };\n};\npicocolors_browser$1.exports = create$1();\npicocolors_browser$1.exports.createColors = create$1;\nvar picocolors_browserExports$1 = picocolors_browser$1.exports;\nvar __viteBrowserExternal$2 = {};\nvar __viteBrowserExternal$1$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n    __proto__: null,\n    default: __viteBrowserExternal$2\n}, Symbol.toStringTag, {\n    value: \"Module\"\n}));\nvar require$$2$1 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal$1$1);\nvar pico$1 = picocolors_browserExports$1;\nvar terminalHighlight$1$1 = require$$2$1;\nvar CssSyntaxError$3$1 = /*#__PURE__*/ function(Error1) {\n    _inherits(CssSyntaxError, Error1);\n    function CssSyntaxError(message, line, column, source, file, plugin22) {\n        var _this;\n        _this = Error1.call(this, message) || this;\n        _this.name = \"CssSyntaxError\";\n        _this.reason = message;\n        if (file) {\n            _this.file = file;\n        }\n        if (source) {\n            _this.source = source;\n        }\n        if (plugin22) {\n            _this.plugin = plugin22;\n        }\n        if (typeof line !== \"undefined\" && typeof column !== \"undefined\") {\n            if (typeof line === \"number\") {\n                _this.line = line;\n                _this.column = column;\n            } else {\n                _this.line = line.line;\n                _this.column = line.column;\n                _this.endLine = column.line;\n                _this.endColumn = column.column;\n            }\n        }\n        _this.setMessage();\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(_this, CssSyntaxError);\n        }\n        return _this;\n    }\n    var _proto = CssSyntaxError.prototype;\n    _proto.setMessage = function setMessage() {\n        this.message = this.plugin ? this.plugin + \": \" : \"\";\n        this.message += this.file ? this.file : \"<css input>\";\n        if (typeof this.line !== \"undefined\") {\n            this.message += \":\" + this.line + \":\" + this.column;\n        }\n        this.message += \": \" + this.reason;\n    };\n    _proto.showSourceCode = function showSourceCode(color) {\n        var _this = this;\n        if (!this.source) return \"\";\n        var css = this.source;\n        if (color == null) color = pico$1.isColorSupported;\n        if (terminalHighlight$1$1) {\n            if (color) css = terminalHighlight$1$1(css);\n        }\n        var lines = css.split(/\\r?\\n/);\n        var start = Math.max(this.line - 3, 0);\n        var end = Math.min(this.line + 2, lines.length);\n        var maxWidth = String(end).length;\n        var mark, aside;\n        if (color) {\n            var _pico$1_createColors = pico$1.createColors(true), bold = _pico$1_createColors.bold, gray = _pico$1_createColors.gray, red = _pico$1_createColors.red;\n            mark = function(text) {\n                return bold(red(text));\n            };\n            aside = function(text) {\n                return gray(text);\n            };\n        } else {\n            mark = aside = function(str) {\n                return str;\n            };\n        }\n        return lines.slice(start, end).map(function(line, index2) {\n            var number = start + 1 + index2;\n            var gutter = \" \" + (\" \" + number).slice(-maxWidth) + \" | \";\n            if (number === _this.line) {\n                var spacing = aside(gutter.replace(/\\d/g, \" \")) + line.slice(0, _this.column - 1).replace(/[^\\t]/g, \" \");\n                return mark(\">\") + aside(gutter) + line + \"\\n \" + spacing + mark(\"^\");\n            }\n            return \" \" + aside(gutter) + line;\n        }).join(\"\\n\");\n    };\n    _proto.toString = function toString() {\n        var code = this.showSourceCode();\n        if (code) {\n            code = \"\\n\\n\" + code + \"\\n\";\n        }\n        return this.name + \": \" + this.message + code;\n    };\n    return CssSyntaxError;\n}(_wrap_native_super(Error));\nvar cssSyntaxError$1 = CssSyntaxError$3$1;\nCssSyntaxError$3$1.default = CssSyntaxError$3$1;\nvar symbols$1 = {};\nsymbols$1.isClean = Symbol(\"isClean\");\nsymbols$1.my = Symbol(\"my\");\nvar DEFAULT_RAW$1 = {\n    after: \"\\n\",\n    beforeClose: \"\\n\",\n    beforeComment: \"\\n\",\n    beforeDecl: \"\\n\",\n    beforeOpen: \" \",\n    beforeRule: \"\\n\",\n    colon: \": \",\n    commentLeft: \" \",\n    commentRight: \" \",\n    emptyBody: \"\",\n    indent: \"    \",\n    semicolon: false\n};\nfunction capitalize$1(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\nvar Stringifier$2$1 = /*#__PURE__*/ function() {\n    function Stringifier(builder) {\n        this.builder = builder;\n    }\n    var _proto = Stringifier.prototype;\n    _proto.atrule = function atrule(node2, semicolon) {\n        var name = \"@\" + node2.name;\n        var params = node2.params ? this.rawValue(node2, \"params\") : \"\";\n        if (typeof node2.raws.afterName !== \"undefined\") {\n            name += node2.raws.afterName;\n        } else if (params) {\n            name += \" \";\n        }\n        if (node2.nodes) {\n            this.block(node2, name + params);\n        } else {\n            var end = (node2.raws.between || \"\") + (semicolon ? \";\" : \"\");\n            this.builder(name + params + end, node2);\n        }\n    };\n    _proto.beforeAfter = function beforeAfter(node2, detect) {\n        var value;\n        if (node2.type === \"decl\") {\n            value = this.raw(node2, null, \"beforeDecl\");\n        } else if (node2.type === \"comment\") {\n            value = this.raw(node2, null, \"beforeComment\");\n        } else if (detect === \"before\") {\n            value = this.raw(node2, null, \"beforeRule\");\n        } else {\n            value = this.raw(node2, null, \"beforeClose\");\n        }\n        var buf = node2.parent;\n        var depth = 0;\n        while(buf && buf.type !== \"root\"){\n            depth += 1;\n            buf = buf.parent;\n        }\n        if (value.includes(\"\\n\")) {\n            var indent = this.raw(node2, null, \"indent\");\n            if (indent.length) {\n                for(var step = 0; step < depth; step++)value += indent;\n            }\n        }\n        return value;\n    };\n    _proto.block = function block(node2, start) {\n        var between = this.raw(node2, \"between\", \"beforeOpen\");\n        this.builder(start + between + \"{\", node2, \"start\");\n        var after;\n        if (node2.nodes && node2.nodes.length) {\n            this.body(node2);\n            after = this.raw(node2, \"after\");\n        } else {\n            after = this.raw(node2, \"after\", \"emptyBody\");\n        }\n        if (after) this.builder(after);\n        this.builder(\"}\", node2, \"end\");\n    };\n    _proto.body = function body(node2) {\n        var last = node2.nodes.length - 1;\n        while(last > 0){\n            if (node2.nodes[last].type !== \"comment\") break;\n            last -= 1;\n        }\n        var semicolon = this.raw(node2, \"semicolon\");\n        for(var i2 = 0; i2 < node2.nodes.length; i2++){\n            var child = node2.nodes[i2];\n            var before = this.raw(child, \"before\");\n            if (before) this.builder(before);\n            this.stringify(child, last !== i2 || semicolon);\n        }\n    };\n    _proto.comment = function comment(node2) {\n        var left = this.raw(node2, \"left\", \"commentLeft\");\n        var right = this.raw(node2, \"right\", \"commentRight\");\n        this.builder(\"/*\" + left + node2.text + right + \"*/\", node2);\n    };\n    _proto.decl = function decl(node2, semicolon) {\n        var between = this.raw(node2, \"between\", \"colon\");\n        var string = node2.prop + between + this.rawValue(node2, \"value\");\n        if (node2.important) {\n            string += node2.raws.important || \" !important\";\n        }\n        if (semicolon) string += \";\";\n        this.builder(string, node2);\n    };\n    _proto.document = function document1(node2) {\n        this.body(node2);\n    };\n    _proto.raw = function raw(node2, own, detect) {\n        var value;\n        if (!detect) detect = own;\n        if (own) {\n            value = node2.raws[own];\n            if (typeof value !== \"undefined\") return value;\n        }\n        var parent = node2.parent;\n        if (detect === \"before\") {\n            if (!parent || parent.type === \"root\" && parent.first === node2) {\n                return \"\";\n            }\n            if (parent && parent.type === \"document\") {\n                return \"\";\n            }\n        }\n        if (!parent) return DEFAULT_RAW$1[detect];\n        var root2 = node2.root();\n        if (!root2.rawCache) root2.rawCache = {};\n        if (typeof root2.rawCache[detect] !== \"undefined\") {\n            return root2.rawCache[detect];\n        }\n        if (detect === \"before\" || detect === \"after\") {\n            return this.beforeAfter(node2, detect);\n        } else {\n            var method = \"raw\" + capitalize$1(detect);\n            if (this[method]) {\n                value = this[method](root2, node2);\n            } else {\n                root2.walk(function(i2) {\n                    value = i2.raws[own];\n                    if (typeof value !== \"undefined\") return false;\n                });\n            }\n        }\n        if (typeof value === \"undefined\") value = DEFAULT_RAW$1[detect];\n        root2.rawCache[detect] = value;\n        return value;\n    };\n    _proto.rawBeforeClose = function rawBeforeClose(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length > 0) {\n                if (typeof i2.raws.after !== \"undefined\") {\n                    value = i2.raws.after;\n                    if (value.includes(\"\\n\")) {\n                        value = value.replace(/[^\\n]+$/, \"\");\n                    }\n                    return false;\n                }\n            }\n        });\n        if (value) value = value.replace(/\\S/g, \"\");\n        return value;\n    };\n    _proto.rawBeforeComment = function rawBeforeComment(root2, node2) {\n        var value;\n        root2.walkComments(function(i2) {\n            if (typeof i2.raws.before !== \"undefined\") {\n                value = i2.raws.before;\n                if (value.includes(\"\\n\")) {\n                    value = value.replace(/[^\\n]+$/, \"\");\n                }\n                return false;\n            }\n        });\n        if (typeof value === \"undefined\") {\n            value = this.raw(node2, null, \"beforeDecl\");\n        } else if (value) {\n            value = value.replace(/\\S/g, \"\");\n        }\n        return value;\n    };\n    _proto.rawBeforeDecl = function rawBeforeDecl(root2, node2) {\n        var value;\n        root2.walkDecls(function(i2) {\n            if (typeof i2.raws.before !== \"undefined\") {\n                value = i2.raws.before;\n                if (value.includes(\"\\n\")) {\n                    value = value.replace(/[^\\n]+$/, \"\");\n                }\n                return false;\n            }\n        });\n        if (typeof value === \"undefined\") {\n            value = this.raw(node2, null, \"beforeRule\");\n        } else if (value) {\n            value = value.replace(/\\S/g, \"\");\n        }\n        return value;\n    };\n    _proto.rawBeforeOpen = function rawBeforeOpen(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.type !== \"decl\") {\n                value = i2.raws.between;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawBeforeRule = function rawBeforeRule(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {\n                if (typeof i2.raws.before !== \"undefined\") {\n                    value = i2.raws.before;\n                    if (value.includes(\"\\n\")) {\n                        value = value.replace(/[^\\n]+$/, \"\");\n                    }\n                    return false;\n                }\n            }\n        });\n        if (value) value = value.replace(/\\S/g, \"\");\n        return value;\n    };\n    _proto.rawColon = function rawColon(root2) {\n        var value;\n        root2.walkDecls(function(i2) {\n            if (typeof i2.raws.between !== \"undefined\") {\n                value = i2.raws.between.replace(/[^\\s:]/g, \"\");\n                return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawEmptyBody = function rawEmptyBody(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length === 0) {\n                value = i2.raws.after;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawIndent = function rawIndent(root2) {\n        if (root2.raws.indent) return root2.raws.indent;\n        var value;\n        root2.walk(function(i2) {\n            var p = i2.parent;\n            if (p && p !== root2 && p.parent && p.parent === root2) {\n                if (typeof i2.raws.before !== \"undefined\") {\n                    var parts = i2.raws.before.split(\"\\n\");\n                    value = parts[parts.length - 1];\n                    value = value.replace(/\\S/g, \"\");\n                    return false;\n                }\n            }\n        });\n        return value;\n    };\n    _proto.rawSemicolon = function rawSemicolon(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length && i2.last.type === \"decl\") {\n                value = i2.raws.semicolon;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawValue = function rawValue(node2, prop) {\n        var value = node2[prop];\n        var raw = node2.raws[prop];\n        if (raw && raw.value === value) {\n            return raw.raw;\n        }\n        return value;\n    };\n    _proto.root = function root(node2) {\n        this.body(node2);\n        if (node2.raws.after) this.builder(node2.raws.after);\n    };\n    _proto.rule = function rule(node2) {\n        this.block(node2, this.rawValue(node2, \"selector\"));\n        if (node2.raws.ownSemicolon) {\n            this.builder(node2.raws.ownSemicolon, node2, \"end\");\n        }\n    };\n    _proto.stringify = function stringify(node2, semicolon) {\n        if (!this[node2.type]) {\n            throw new Error(\"Unknown AST node type \" + node2.type + \". Maybe you need to change PostCSS stringifier.\");\n        }\n        this[node2.type](node2, semicolon);\n    };\n    return Stringifier;\n}();\nvar stringifier$1 = Stringifier$2$1;\nStringifier$2$1.default = Stringifier$2$1;\nvar Stringifier$1$1 = stringifier$1;\nfunction stringify$4$1(node2, builder) {\n    var str = new Stringifier$1$1(builder);\n    str.stringify(node2);\n}\nvar stringify_1$1 = stringify$4$1;\nstringify$4$1.default = stringify$4$1;\nvar isClean$2$1 = symbols$1.isClean, my$2$1 = symbols$1.my;\nvar CssSyntaxError$2$1 = cssSyntaxError$1;\nvar Stringifier2$1 = stringifier$1;\nvar stringify$3$1 = stringify_1$1;\nfunction cloneNode$1(obj, parent) {\n    var cloned = new obj.constructor();\n    for(var i2 in obj){\n        if (!Object.prototype.hasOwnProperty.call(obj, i2)) {\n            continue;\n        }\n        if (i2 === \"proxyCache\") continue;\n        var value = obj[i2];\n        var type = typeof value === \"undefined\" ? \"undefined\" : _type_of(value);\n        if (i2 === \"parent\" && type === \"object\") {\n            if (parent) cloned[i2] = parent;\n        } else if (i2 === \"source\") {\n            cloned[i2] = value;\n        } else if (Array.isArray(value)) {\n            cloned[i2] = value.map(function(j) {\n                return cloneNode$1(j, cloned);\n            });\n        } else {\n            if (type === \"object\" && value !== null) value = cloneNode$1(value);\n            cloned[i2] = value;\n        }\n    }\n    return cloned;\n}\nvar Node$4$1 = /*#__PURE__*/ function() {\n    function Node2(defaults) {\n        if (defaults === void 0) defaults = {};\n        this.raws = {};\n        this[isClean$2$1] = false;\n        this[my$2$1] = true;\n        for(var name in defaults){\n            if (name === \"nodes\") {\n                this.nodes = [];\n                for(var _iterator = _create_for_of_iterator_helper_loose(defaults[name]), _step; !(_step = _iterator()).done;){\n                    var node2 = _step.value;\n                    if (typeof node2.clone === \"function\") {\n                        this.append(node2.clone());\n                    } else {\n                        this.append(node2);\n                    }\n                }\n            } else {\n                this[name] = defaults[name];\n            }\n        }\n    }\n    var _proto = Node2.prototype;\n    _proto.addToError = function addToError(error) {\n        error.postcssNode = this;\n        if (error.stack && this.source && /\\n\\s{4}at /.test(error.stack)) {\n            var s2 = this.source;\n            error.stack = error.stack.replace(/\\n\\s{4}at /, \"$&\" + s2.input.from + \":\" + s2.start.line + \":\" + s2.start.column + \"$&\");\n        }\n        return error;\n    };\n    _proto.after = function after(add) {\n        this.parent.insertAfter(this, add);\n        return this;\n    };\n    _proto.assign = function assign(overrides) {\n        if (overrides === void 0) overrides = {};\n        for(var name in overrides){\n            this[name] = overrides[name];\n        }\n        return this;\n    };\n    _proto.before = function before(add) {\n        this.parent.insertBefore(this, add);\n        return this;\n    };\n    _proto.cleanRaws = function cleanRaws(keepBetween) {\n        delete this.raws.before;\n        delete this.raws.after;\n        if (!keepBetween) delete this.raws.between;\n    };\n    _proto.clone = function clone(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = cloneNode$1(this);\n        for(var name in overrides){\n            cloned[name] = overrides[name];\n        }\n        return cloned;\n    };\n    _proto.cloneAfter = function cloneAfter(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = this.clone(overrides);\n        this.parent.insertAfter(this, cloned);\n        return cloned;\n    };\n    _proto.cloneBefore = function cloneBefore(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = this.clone(overrides);\n        this.parent.insertBefore(this, cloned);\n        return cloned;\n    };\n    _proto.error = function error(message, opts) {\n        if (opts === void 0) opts = {};\n        if (this.source) {\n            var _this_rangeBy = this.rangeBy(opts), end = _this_rangeBy.end, start = _this_rangeBy.start;\n            return this.source.input.error(message, {\n                column: start.column,\n                line: start.line\n            }, {\n                column: end.column,\n                line: end.line\n            }, opts);\n        }\n        return new CssSyntaxError$2$1(message);\n    };\n    _proto.getProxyProcessor = function getProxyProcessor() {\n        return {\n            get: function get(node2, prop) {\n                if (prop === \"proxyOf\") {\n                    return node2;\n                } else if (prop === \"root\") {\n                    return function() {\n                        return node2.root().toProxy();\n                    };\n                } else {\n                    return node2[prop];\n                }\n            },\n            set: function set(node2, prop, value) {\n                if (node2[prop] === value) return true;\n                node2[prop] = value;\n                if (prop === \"prop\" || prop === \"value\" || prop === \"name\" || prop === \"params\" || prop === \"important\" || /* c8 ignore next */ prop === \"text\") {\n                    node2.markDirty();\n                }\n                return true;\n            }\n        };\n    };\n    _proto.markDirty = function markDirty() {\n        if (this[isClean$2$1]) {\n            this[isClean$2$1] = false;\n            var next = this;\n            while(next = next.parent){\n                next[isClean$2$1] = false;\n            }\n        }\n    };\n    _proto.next = function next() {\n        if (!this.parent) return void 0;\n        var index2 = this.parent.index(this);\n        return this.parent.nodes[index2 + 1];\n    };\n    _proto.positionBy = function positionBy(opts, stringRepresentation) {\n        var pos = this.source.start;\n        if (opts.index) {\n            pos = this.positionInside(opts.index, stringRepresentation);\n        } else if (opts.word) {\n            stringRepresentation = this.toString();\n            var index2 = stringRepresentation.indexOf(opts.word);\n            if (index2 !== -1) pos = this.positionInside(index2, stringRepresentation);\n        }\n        return pos;\n    };\n    _proto.positionInside = function positionInside(index2, stringRepresentation) {\n        var string = stringRepresentation || this.toString();\n        var column = this.source.start.column;\n        var line = this.source.start.line;\n        for(var i2 = 0; i2 < index2; i2++){\n            if (string[i2] === \"\\n\") {\n                column = 1;\n                line += 1;\n            } else {\n                column += 1;\n            }\n        }\n        return {\n            column: column,\n            line: line\n        };\n    };\n    _proto.prev = function prev() {\n        if (!this.parent) return void 0;\n        var index2 = this.parent.index(this);\n        return this.parent.nodes[index2 - 1];\n    };\n    _proto.rangeBy = function rangeBy(opts) {\n        var start = {\n            column: this.source.start.column,\n            line: this.source.start.line\n        };\n        var end = this.source.end ? {\n            column: this.source.end.column + 1,\n            line: this.source.end.line\n        } : {\n            column: start.column + 1,\n            line: start.line\n        };\n        if (opts.word) {\n            var stringRepresentation = this.toString();\n            var index2 = stringRepresentation.indexOf(opts.word);\n            if (index2 !== -1) {\n                start = this.positionInside(index2, stringRepresentation);\n                end = this.positionInside(index2 + opts.word.length, stringRepresentation);\n            }\n        } else {\n            if (opts.start) {\n                start = {\n                    column: opts.start.column,\n                    line: opts.start.line\n                };\n            } else if (opts.index) {\n                start = this.positionInside(opts.index);\n            }\n            if (opts.end) {\n                end = {\n                    column: opts.end.column,\n                    line: opts.end.line\n                };\n            } else if (typeof opts.endIndex === \"number\") {\n                end = this.positionInside(opts.endIndex);\n            } else if (opts.index) {\n                end = this.positionInside(opts.index + 1);\n            }\n        }\n        if (end.line < start.line || end.line === start.line && end.column <= start.column) {\n            end = {\n                column: start.column + 1,\n                line: start.line\n            };\n        }\n        return {\n            end: end,\n            start: start\n        };\n    };\n    _proto.raw = function raw(prop, defaultType) {\n        var str = new Stringifier2$1();\n        return str.raw(this, prop, defaultType);\n    };\n    _proto.remove = function remove() {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n        this.parent = void 0;\n        return this;\n    };\n    _proto.replaceWith = function replaceWith() {\n        for(var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++){\n            nodes[_key] = arguments[_key];\n        }\n        if (this.parent) {\n            var bookmark = this;\n            var foundSelf = false;\n            for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                var node2 = _step.value;\n                if (node2 === this) {\n                    foundSelf = true;\n                } else if (foundSelf) {\n                    this.parent.insertAfter(bookmark, node2);\n                    bookmark = node2;\n                } else {\n                    this.parent.insertBefore(bookmark, node2);\n                }\n            }\n            if (!foundSelf) {\n                this.remove();\n            }\n        }\n        return this;\n    };\n    _proto.root = function root() {\n        var result2 = this;\n        while(result2.parent && result2.parent.type !== \"document\"){\n            result2 = result2.parent;\n        }\n        return result2;\n    };\n    _proto.toJSON = function toJSON(_, inputs) {\n        var fixed = {};\n        var emitInputs = inputs == null;\n        inputs = inputs || /* @__PURE__ */ new Map();\n        var inputsNextIndex = 0;\n        for(var name in this){\n            if (!Object.prototype.hasOwnProperty.call(this, name)) {\n                continue;\n            }\n            if (name === \"parent\" || name === \"proxyCache\") continue;\n            var value = this[name];\n            if (Array.isArray(value)) {\n                fixed[name] = value.map(function(i2) {\n                    if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && i2.toJSON) {\n                        return i2.toJSON(null, inputs);\n                    } else {\n                        return i2;\n                    }\n                });\n            } else if ((typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === \"object\" && value.toJSON) {\n                fixed[name] = value.toJSON(null, inputs);\n            } else if (name === \"source\") {\n                var inputId = inputs.get(value.input);\n                if (inputId == null) {\n                    inputId = inputsNextIndex;\n                    inputs.set(value.input, inputsNextIndex);\n                    inputsNextIndex++;\n                }\n                fixed[name] = {\n                    end: value.end,\n                    inputId: inputId,\n                    start: value.start\n                };\n            } else {\n                fixed[name] = value;\n            }\n        }\n        if (emitInputs) {\n            fixed.inputs = [].concat(inputs.keys()).map(function(input2) {\n                return input2.toJSON();\n            });\n        }\n        return fixed;\n    };\n    _proto.toProxy = function toProxy() {\n        if (!this.proxyCache) {\n            this.proxyCache = new Proxy(this, this.getProxyProcessor());\n        }\n        return this.proxyCache;\n    };\n    _proto.toString = function toString(stringifier2) {\n        if (stringifier2 === void 0) stringifier2 = stringify$3$1;\n        if (stringifier2.stringify) stringifier2 = stringifier2.stringify;\n        var result2 = \"\";\n        stringifier2(this, function(i2) {\n            result2 += i2;\n        });\n        return result2;\n    };\n    _proto.warn = function warn(result2, text, opts) {\n        var data = {\n            node: this\n        };\n        for(var i2 in opts)data[i2] = opts[i2];\n        return result2.warn(text, data);\n    };\n    _create_class(Node2, [\n        {\n            key: \"proxyOf\",\n            get: function get() {\n                return this;\n            }\n        }\n    ]);\n    return Node2;\n}();\nvar node$1 = Node$4$1;\nNode$4$1.default = Node$4$1;\nvar Node$3$1 = node$1;\nvar Declaration$4$1 = /*#__PURE__*/ function(Node$3$1) {\n    _inherits(Declaration, Node$3$1);\n    function Declaration(defaults) {\n        var _this;\n        if (defaults && typeof defaults.value !== \"undefined\" && typeof defaults.value !== \"string\") {\n            defaults = _extends({}, defaults, {\n                value: String(defaults.value)\n            });\n        }\n        _this = Node$3$1.call(this, defaults) || this;\n        _this.type = \"decl\";\n        return _this;\n    }\n    _create_class(Declaration, [\n        {\n            key: \"variable\",\n            get: function get() {\n                return this.prop.startsWith(\"--\") || this.prop[0] === \"$\";\n            }\n        }\n    ]);\n    return Declaration;\n}(Node$3$1);\nvar declaration$1 = Declaration$4$1;\nDeclaration$4$1.default = Declaration$4$1;\nvar urlAlphabet$1 = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nvar nanoid$1$1 = function(size) {\n    if (size === void 0) size = 21;\n    var id = \"\";\n    var i2 = size;\n    while(i2--){\n        id += urlAlphabet$1[Math.random() * 64 | 0];\n    }\n    return id;\n};\nvar nonSecure$1 = {\n    nanoid: nanoid$1$1};\nvar SourceMapConsumer$2$1 = require$$2$1.SourceMapConsumer, SourceMapGenerator$2$1 = require$$2$1.SourceMapGenerator;\nvar existsSync$1 = require$$2$1.existsSync, readFileSync$1 = require$$2$1.readFileSync;\nvar dirname$1$1 = require$$2$1.dirname, join$1 = require$$2$1.join;\nfunction fromBase64$1(str) {\n    if (Buffer) {\n        return Buffer.from(str, \"base64\").toString();\n    } else {\n        return window.atob(str);\n    }\n}\nvar PreviousMap$2$1 = /*#__PURE__*/ function() {\n    function PreviousMap(css, opts) {\n        if (opts.map === false) return;\n        this.loadAnnotation(css);\n        this.inline = this.startWith(this.annotation, \"data:\");\n        var prev = opts.map ? opts.map.prev : void 0;\n        var text = this.loadMap(opts.from, prev);\n        if (!this.mapFile && opts.from) {\n            this.mapFile = opts.from;\n        }\n        if (this.mapFile) this.root = dirname$1$1(this.mapFile);\n        if (text) this.text = text;\n    }\n    var _proto = PreviousMap.prototype;\n    _proto.consumer = function consumer() {\n        if (!this.consumerCache) {\n            this.consumerCache = new SourceMapConsumer$2$1(this.text);\n        }\n        return this.consumerCache;\n    };\n    _proto.decodeInline = function decodeInline(text) {\n        var baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/;\n        var baseUri = /^data:application\\/json;base64,/;\n        var charsetUri = /^data:application\\/json;charset=utf-?8,/;\n        var uri = /^data:application\\/json,/;\n        if (charsetUri.test(text) || uri.test(text)) {\n            return decodeURIComponent(text.substr(RegExp.lastMatch.length));\n        }\n        if (baseCharsetUri.test(text) || baseUri.test(text)) {\n            return fromBase64$1(text.substr(RegExp.lastMatch.length));\n        }\n        var encoding = text.match(/data:application\\/json;([^,]+),/)[1];\n        throw new Error(\"Unsupported source map encoding \" + encoding);\n    };\n    _proto.getAnnotationURL = function getAnnotationURL(sourceMapString) {\n        return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, \"\").trim();\n    };\n    _proto.isMap = function isMap(map) {\n        if ((typeof map === \"undefined\" ? \"undefined\" : _type_of(map)) !== \"object\") return false;\n        return typeof map.mappings === \"string\" || typeof map._mappings === \"string\" || Array.isArray(map.sections);\n    };\n    _proto.loadAnnotation = function loadAnnotation(css) {\n        var comments = css.match(/\\/\\*\\s*# sourceMappingURL=/gm);\n        if (!comments) return;\n        var start = css.lastIndexOf(comments.pop());\n        var end = css.indexOf(\"*/\", start);\n        if (start > -1 && end > -1) {\n            this.annotation = this.getAnnotationURL(css.substring(start, end));\n        }\n    };\n    _proto.loadFile = function loadFile(path) {\n        this.root = dirname$1$1(path);\n        if (existsSync$1(path)) {\n            this.mapFile = path;\n            return readFileSync$1(path, \"utf-8\").toString().trim();\n        }\n    };\n    _proto.loadMap = function loadMap(file, prev) {\n        if (prev === false) return false;\n        if (prev) {\n            if (typeof prev === \"string\") {\n                return prev;\n            } else if (typeof prev === \"function\") {\n                var prevPath = prev(file);\n                if (prevPath) {\n                    var map = this.loadFile(prevPath);\n                    if (!map) {\n                        throw new Error(\"Unable to load previous source map: \" + prevPath.toString());\n                    }\n                    return map;\n                }\n            } else if (_instanceof(prev, SourceMapConsumer$2$1)) {\n                return SourceMapGenerator$2$1.fromSourceMap(prev).toString();\n            } else if (_instanceof(prev, SourceMapGenerator$2$1)) {\n                return prev.toString();\n            } else if (this.isMap(prev)) {\n                return JSON.stringify(prev);\n            } else {\n                throw new Error(\"Unsupported previous source map format: \" + prev.toString());\n            }\n        } else if (this.inline) {\n            return this.decodeInline(this.annotation);\n        } else if (this.annotation) {\n            var map1 = this.annotation;\n            if (file) map1 = join$1(dirname$1$1(file), map1);\n            return this.loadFile(map1);\n        }\n    };\n    _proto.startWith = function startWith(string, start) {\n        if (!string) return false;\n        return string.substr(0, start.length) === start;\n    };\n    _proto.withContent = function withContent() {\n        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);\n    };\n    return PreviousMap;\n}();\nvar previousMap$1 = PreviousMap$2$1;\nPreviousMap$2$1.default = PreviousMap$2$1;\nvar SourceMapConsumer$1$1 = require$$2$1.SourceMapConsumer, SourceMapGenerator$1$1 = require$$2$1.SourceMapGenerator;\nvar fileURLToPath$1 = require$$2$1.fileURLToPath, pathToFileURL$1$1 = require$$2$1.pathToFileURL;\nvar isAbsolute$1 = require$$2$1.isAbsolute, resolve$1$1 = require$$2$1.resolve;\nvar nanoid$2 = nonSecure$1.nanoid;\nvar terminalHighlight$2 = require$$2$1;\nvar CssSyntaxError$1$1 = cssSyntaxError$1;\nvar PreviousMap$1$1 = previousMap$1;\nvar fromOffsetCache$1 = Symbol(\"fromOffsetCache\");\nvar sourceMapAvailable$1$1 = Boolean(SourceMapConsumer$1$1 && SourceMapGenerator$1$1);\nvar pathAvailable$1$1 = Boolean(resolve$1$1 && isAbsolute$1);\nvar Input$4$1 = /*#__PURE__*/ function() {\n    function Input(css, opts) {\n        if (opts === void 0) opts = {};\n        if (css === null || typeof css === \"undefined\" || (typeof css === \"undefined\" ? \"undefined\" : _type_of(css)) === \"object\" && !css.toString) {\n            throw new Error(\"PostCSS received \" + css + \" instead of CSS string\");\n        }\n        this.css = css.toString();\n        if (this.css[0] === \"\\uFEFF\" || this.css[0] === \"\") {\n            this.hasBOM = true;\n            this.css = this.css.slice(1);\n        } else {\n            this.hasBOM = false;\n        }\n        if (opts.from) {\n            if (!pathAvailable$1$1 || /^\\w+:\\/\\//.test(opts.from) || isAbsolute$1(opts.from)) {\n                this.file = opts.from;\n            } else {\n                this.file = resolve$1$1(opts.from);\n            }\n        }\n        if (pathAvailable$1$1 && sourceMapAvailable$1$1) {\n            var map = new PreviousMap$1$1(this.css, opts);\n            if (map.text) {\n                this.map = map;\n                var file = map.consumer().file;\n                if (!this.file && file) this.file = this.mapResolve(file);\n            }\n        }\n        if (!this.file) {\n            this.id = \"<input css \" + nanoid$2(6) + \">\";\n        }\n        if (this.map) this.map.file = this.from;\n    }\n    var _proto = Input.prototype;\n    _proto.error = function error(message, line, column, opts) {\n        if (opts === void 0) opts = {};\n        var result2, endLine, endColumn;\n        if (line && (typeof line === \"undefined\" ? \"undefined\" : _type_of(line)) === \"object\") {\n            var start = line;\n            var end = column;\n            if (typeof start.offset === \"number\") {\n                var pos = this.fromOffset(start.offset);\n                line = pos.line;\n                column = pos.col;\n            } else {\n                line = start.line;\n                column = start.column;\n            }\n            if (typeof end.offset === \"number\") {\n                var pos1 = this.fromOffset(end.offset);\n                endLine = pos1.line;\n                endColumn = pos1.col;\n            } else {\n                endLine = end.line;\n                endColumn = end.column;\n            }\n        } else if (!column) {\n            var pos2 = this.fromOffset(line);\n            line = pos2.line;\n            column = pos2.col;\n        }\n        var origin = this.origin(line, column, endLine, endColumn);\n        if (origin) {\n            result2 = new CssSyntaxError$1$1(message, origin.endLine === void 0 ? origin.line : {\n                column: origin.column,\n                line: origin.line\n            }, origin.endLine === void 0 ? origin.column : {\n                column: origin.endColumn,\n                line: origin.endLine\n            }, origin.source, origin.file, opts.plugin);\n        } else {\n            result2 = new CssSyntaxError$1$1(message, endLine === void 0 ? line : {\n                column: column,\n                line: line\n            }, endLine === void 0 ? column : {\n                column: endColumn,\n                line: endLine\n            }, this.css, this.file, opts.plugin);\n        }\n        result2.input = {\n            column: column,\n            endColumn: endColumn,\n            endLine: endLine,\n            line: line,\n            source: this.css\n        };\n        if (this.file) {\n            if (pathToFileURL$1$1) {\n                result2.input.url = pathToFileURL$1$1(this.file).toString();\n            }\n            result2.input.file = this.file;\n        }\n        return result2;\n    };\n    _proto.fromOffset = function fromOffset(offset) {\n        var lastLine, lineToIndex;\n        if (!this[fromOffsetCache$1]) {\n            var lines = this.css.split(\"\\n\");\n            lineToIndex = new Array(lines.length);\n            var prevIndex = 0;\n            for(var i2 = 0, l2 = lines.length; i2 < l2; i2++){\n                lineToIndex[i2] = prevIndex;\n                prevIndex += lines[i2].length + 1;\n            }\n            this[fromOffsetCache$1] = lineToIndex;\n        } else {\n            lineToIndex = this[fromOffsetCache$1];\n        }\n        lastLine = lineToIndex[lineToIndex.length - 1];\n        var min = 0;\n        if (offset >= lastLine) {\n            min = lineToIndex.length - 1;\n        } else {\n            var max = lineToIndex.length - 2;\n            var mid;\n            while(min < max){\n                mid = min + (max - min >> 1);\n                if (offset < lineToIndex[mid]) {\n                    max = mid - 1;\n                } else if (offset >= lineToIndex[mid + 1]) {\n                    min = mid + 1;\n                } else {\n                    min = mid;\n                    break;\n                }\n            }\n        }\n        return {\n            col: offset - lineToIndex[min] + 1,\n            line: min + 1\n        };\n    };\n    _proto.mapResolve = function mapResolve(file) {\n        if (/^\\w+:\\/\\//.test(file)) {\n            return file;\n        }\n        return resolve$1$1(this.map.consumer().sourceRoot || this.map.root || \".\", file);\n    };\n    _proto.origin = function origin(line, column, endLine, endColumn) {\n        if (!this.map) return false;\n        var consumer = this.map.consumer();\n        var from = consumer.originalPositionFor({\n            column: column,\n            line: line\n        });\n        if (!from.source) return false;\n        var to;\n        if (typeof endLine === \"number\") {\n            to = consumer.originalPositionFor({\n                column: endColumn,\n                line: endLine\n            });\n        }\n        var fromUrl;\n        if (isAbsolute$1(from.source)) {\n            fromUrl = pathToFileURL$1$1(from.source);\n        } else {\n            fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL$1$1(this.map.mapFile));\n        }\n        var result2 = {\n            column: from.column,\n            endColumn: to && to.column,\n            endLine: to && to.line,\n            line: from.line,\n            url: fromUrl.toString()\n        };\n        if (fromUrl.protocol === \"file:\") {\n            if (fileURLToPath$1) {\n                result2.file = fileURLToPath$1(fromUrl);\n            } else {\n                throw new Error(\"file: protocol is not available in this PostCSS build\");\n            }\n        }\n        var source = consumer.sourceContentFor(from.source);\n        if (source) result2.source = source;\n        return result2;\n    };\n    _proto.toJSON = function toJSON() {\n        var json = {};\n        for(var _i = 0, _iter = [\n            \"hasBOM\",\n            \"css\",\n            \"file\",\n            \"id\"\n        ]; _i < _iter.length; _i++){\n            var name = _iter[_i];\n            if (this[name] != null) {\n                json[name] = this[name];\n            }\n        }\n        if (this.map) {\n            json.map = _extends({}, this.map);\n            if (json.map.consumerCache) {\n                json.map.consumerCache = void 0;\n            }\n        }\n        return json;\n    };\n    _create_class(Input, [\n        {\n            key: \"from\",\n            get: function get() {\n                return this.file || this.id;\n            }\n        }\n    ]);\n    return Input;\n}();\nvar input$1 = Input$4$1;\nInput$4$1.default = Input$4$1;\nif (terminalHighlight$2 && terminalHighlight$2.registerInput) {\n    terminalHighlight$2.registerInput(Input$4$1);\n}\nvar SourceMapConsumer$3 = require$$2$1.SourceMapConsumer, SourceMapGenerator$3 = require$$2$1.SourceMapGenerator;\nvar dirname$2 = require$$2$1.dirname, relative$1 = require$$2$1.relative, resolve$2 = require$$2$1.resolve, sep$1 = require$$2$1.sep;\nvar pathToFileURL$2 = require$$2$1.pathToFileURL;\nvar Input$3$1 = input$1;\nvar sourceMapAvailable$2 = Boolean(SourceMapConsumer$3 && SourceMapGenerator$3);\nvar pathAvailable$2 = Boolean(dirname$2 && resolve$2 && relative$1 && sep$1);\nvar MapGenerator$2$1 = /*#__PURE__*/ function() {\n    function MapGenerator(stringify2, root2, opts, cssString) {\n        this.stringify = stringify2;\n        this.mapOpts = opts.map || {};\n        this.root = root2;\n        this.opts = opts;\n        this.css = cssString;\n        this.originalCSS = cssString;\n        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;\n        this.memoizedFileURLs = /* @__PURE__ */ new Map();\n        this.memoizedPaths = /* @__PURE__ */ new Map();\n        this.memoizedURLs = /* @__PURE__ */ new Map();\n    }\n    var _proto = MapGenerator.prototype;\n    _proto.addAnnotation = function addAnnotation() {\n        var content;\n        if (this.isInline()) {\n            content = \"data:application/json;base64,\" + this.toBase64(this.map.toString());\n        } else if (typeof this.mapOpts.annotation === \"string\") {\n            content = this.mapOpts.annotation;\n        } else if (typeof this.mapOpts.annotation === \"function\") {\n            content = this.mapOpts.annotation(this.opts.to, this.root);\n        } else {\n            content = this.outputFile() + \".map\";\n        }\n        var eol = \"\\n\";\n        if (this.css.includes(\"\\r\\n\")) eol = \"\\r\\n\";\n        this.css += eol + \"/*# sourceMappingURL=\" + content + \" */\";\n    };\n    _proto.applyPrevMaps = function applyPrevMaps() {\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.previous()), _step; !(_step = _iterator()).done;){\n            var prev = _step.value;\n            var from = this.toUrl(this.path(prev.file));\n            var root2 = prev.root || dirname$2(prev.file);\n            var map = void 0;\n            if (this.mapOpts.sourcesContent === false) {\n                map = new SourceMapConsumer$3(prev.text);\n                if (map.sourcesContent) {\n                    map.sourcesContent = null;\n                }\n            } else {\n                map = prev.consumer();\n            }\n            this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));\n        }\n    };\n    _proto.clearAnnotation = function clearAnnotation() {\n        if (this.mapOpts.annotation === false) return;\n        if (this.root) {\n            var node2;\n            for(var i2 = this.root.nodes.length - 1; i2 >= 0; i2--){\n                node2 = this.root.nodes[i2];\n                if (node2.type !== \"comment\") continue;\n                if (node2.text.indexOf(\"# sourceMappingURL=\") === 0) {\n                    this.root.removeChild(i2);\n                }\n            }\n        } else if (this.css) {\n            this.css = this.css.replace(/\\n*?\\/\\*#[\\S\\s]*?\\*\\/$/gm, \"\");\n        }\n    };\n    _proto.generate = function generate() {\n        this.clearAnnotation();\n        if (pathAvailable$2 && sourceMapAvailable$2 && this.isMap()) {\n            return this.generateMap();\n        } else {\n            var result2 = \"\";\n            this.stringify(this.root, function(i2) {\n                result2 += i2;\n            });\n            return [\n                result2\n            ];\n        }\n    };\n    _proto.generateMap = function generateMap() {\n        if (this.root) {\n            this.generateString();\n        } else if (this.previous().length === 1) {\n            var prev = this.previous()[0].consumer();\n            prev.file = this.outputFile();\n            this.map = SourceMapGenerator$3.fromSourceMap(prev, {\n                ignoreInvalidMapping: true\n            });\n        } else {\n            this.map = new SourceMapGenerator$3({\n                file: this.outputFile(),\n                ignoreInvalidMapping: true\n            });\n            this.map.addMapping({\n                generated: {\n                    column: 0,\n                    line: 1\n                },\n                original: {\n                    column: 0,\n                    line: 1\n                },\n                source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : \"<no source>\"\n            });\n        }\n        if (this.isSourcesContent()) this.setSourcesContent();\n        if (this.root && this.previous().length > 0) this.applyPrevMaps();\n        if (this.isAnnotation()) this.addAnnotation();\n        if (this.isInline()) {\n            return [\n                this.css\n            ];\n        } else {\n            return [\n                this.css,\n                this.map\n            ];\n        }\n    };\n    _proto.generateString = function generateString() {\n        var _this = this;\n        this.css = \"\";\n        this.map = new SourceMapGenerator$3({\n            file: this.outputFile(),\n            ignoreInvalidMapping: true\n        });\n        var line = 1;\n        var column = 1;\n        var noSource = \"<no source>\";\n        var mapping = {\n            generated: {\n                column: 0,\n                line: 0\n            },\n            original: {\n                column: 0,\n                line: 0\n            },\n            source: \"\"\n        };\n        var lines, last;\n        this.stringify(this.root, function(str, node2, type) {\n            _this.css += str;\n            if (node2 && type !== \"end\") {\n                mapping.generated.line = line;\n                mapping.generated.column = column - 1;\n                if (node2.source && node2.source.start) {\n                    mapping.source = _this.sourcePath(node2);\n                    mapping.original.line = node2.source.start.line;\n                    mapping.original.column = node2.source.start.column - 1;\n                    _this.map.addMapping(mapping);\n                } else {\n                    mapping.source = noSource;\n                    mapping.original.line = 1;\n                    mapping.original.column = 0;\n                    _this.map.addMapping(mapping);\n                }\n            }\n            lines = str.match(/\\n/g);\n            if (lines) {\n                line += lines.length;\n                last = str.lastIndexOf(\"\\n\");\n                column = str.length - last;\n            } else {\n                column += str.length;\n            }\n            if (node2 && type !== \"start\") {\n                var p = node2.parent || {\n                    raws: {}\n                };\n                var childless = node2.type === \"decl\" || node2.type === \"atrule\" && !node2.nodes;\n                if (!childless || node2 !== p.last || p.raws.semicolon) {\n                    if (node2.source && node2.source.end) {\n                        mapping.source = _this.sourcePath(node2);\n                        mapping.original.line = node2.source.end.line;\n                        mapping.original.column = node2.source.end.column - 1;\n                        mapping.generated.line = line;\n                        mapping.generated.column = column - 2;\n                        _this.map.addMapping(mapping);\n                    } else {\n                        mapping.source = noSource;\n                        mapping.original.line = 1;\n                        mapping.original.column = 0;\n                        mapping.generated.line = line;\n                        mapping.generated.column = column - 1;\n                        _this.map.addMapping(mapping);\n                    }\n                }\n            }\n        });\n    };\n    _proto.isAnnotation = function isAnnotation() {\n        if (this.isInline()) {\n            return true;\n        }\n        if (typeof this.mapOpts.annotation !== \"undefined\") {\n            return this.mapOpts.annotation;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.annotation;\n            });\n        }\n        return true;\n    };\n    _proto.isInline = function isInline() {\n        if (typeof this.mapOpts.inline !== \"undefined\") {\n            return this.mapOpts.inline;\n        }\n        var annotation = this.mapOpts.annotation;\n        if (typeof annotation !== \"undefined\" && annotation !== true) {\n            return false;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.inline;\n            });\n        }\n        return true;\n    };\n    _proto.isMap = function isMap() {\n        if (typeof this.opts.map !== \"undefined\") {\n            return !!this.opts.map;\n        }\n        return this.previous().length > 0;\n    };\n    _proto.isSourcesContent = function isSourcesContent() {\n        if (typeof this.mapOpts.sourcesContent !== \"undefined\") {\n            return this.mapOpts.sourcesContent;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.withContent();\n            });\n        }\n        return true;\n    };\n    _proto.outputFile = function outputFile() {\n        if (this.opts.to) {\n            return this.path(this.opts.to);\n        } else if (this.opts.from) {\n            return this.path(this.opts.from);\n        } else {\n            return \"to.css\";\n        }\n    };\n    _proto.path = function path(file) {\n        if (this.mapOpts.absolute) return file;\n        if (file.charCodeAt(0) === 60) return file;\n        if (/^\\w+:\\/\\//.test(file)) return file;\n        var cached = this.memoizedPaths.get(file);\n        if (cached) return cached;\n        var from = this.opts.to ? dirname$2(this.opts.to) : \".\";\n        if (typeof this.mapOpts.annotation === \"string\") {\n            from = dirname$2(resolve$2(from, this.mapOpts.annotation));\n        }\n        var path = relative$1(from, file);\n        this.memoizedPaths.set(file, path);\n        return path;\n    };\n    _proto.previous = function previous() {\n        var _this = this;\n        if (!this.previousMaps) {\n            this.previousMaps = [];\n            if (this.root) {\n                this.root.walk(function(node2) {\n                    if (node2.source && node2.source.input.map) {\n                        var map = node2.source.input.map;\n                        if (!_this.previousMaps.includes(map)) {\n                            _this.previousMaps.push(map);\n                        }\n                    }\n                });\n            } else {\n                var input2 = new Input$3$1(this.originalCSS, this.opts);\n                if (input2.map) this.previousMaps.push(input2.map);\n            }\n        }\n        return this.previousMaps;\n    };\n    _proto.setSourcesContent = function setSourcesContent() {\n        var _this = this;\n        var already = {};\n        if (this.root) {\n            this.root.walk(function(node2) {\n                if (node2.source) {\n                    var from = node2.source.input.from;\n                    if (from && !already[from]) {\n                        already[from] = true;\n                        var fromUrl = _this.usesFileUrls ? _this.toFileUrl(from) : _this.toUrl(_this.path(from));\n                        _this.map.setSourceContent(fromUrl, node2.source.input.css);\n                    }\n                }\n            });\n        } else if (this.css) {\n            var from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : \"<no source>\";\n            this.map.setSourceContent(from, this.css);\n        }\n    };\n    _proto.sourcePath = function sourcePath(node2) {\n        if (this.mapOpts.from) {\n            return this.toUrl(this.mapOpts.from);\n        } else if (this.usesFileUrls) {\n            return this.toFileUrl(node2.source.input.from);\n        } else {\n            return this.toUrl(this.path(node2.source.input.from));\n        }\n    };\n    _proto.toBase64 = function toBase64(str) {\n        if (Buffer) {\n            return Buffer.from(str).toString(\"base64\");\n        } else {\n            return window.btoa(unescape(encodeURIComponent(str)));\n        }\n    };\n    _proto.toFileUrl = function toFileUrl(path) {\n        var cached = this.memoizedFileURLs.get(path);\n        if (cached) return cached;\n        if (pathToFileURL$2) {\n            var fileURL = pathToFileURL$2(path).toString();\n            this.memoizedFileURLs.set(path, fileURL);\n            return fileURL;\n        } else {\n            throw new Error(\"`map.absolute` option is not available in this PostCSS build\");\n        }\n    };\n    _proto.toUrl = function toUrl(path) {\n        var cached = this.memoizedURLs.get(path);\n        if (cached) return cached;\n        if (sep$1 === \"\\\\\") {\n            path = path.replace(/\\\\/g, \"/\");\n        }\n        var url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);\n        this.memoizedURLs.set(path, url);\n        return url;\n    };\n    return MapGenerator;\n}();\nvar mapGenerator$1 = MapGenerator$2$1;\nvar Node$2$1 = node$1;\nvar Comment$4$1 = /*#__PURE__*/ function(Node$2$1) {\n    _inherits(Comment, Node$2$1);\n    function Comment(defaults) {\n        var _this;\n        _this = Node$2$1.call(this, defaults) || this;\n        _this.type = \"comment\";\n        return _this;\n    }\n    return Comment;\n}(Node$2$1);\nvar comment$1 = Comment$4$1;\nComment$4$1.default = Comment$4$1;\nvar isClean$1$1 = symbols$1.isClean, my$1$1 = symbols$1.my;\nvar Declaration$3$1 = declaration$1;\nvar Comment$3$1 = comment$1;\nvar Node$1$1 = node$1;\nvar parse$4$1, Rule$4$1, AtRule$4$1, Root$6$1;\nfunction cleanSource$1(nodes) {\n    return nodes.map(function(i2) {\n        if (i2.nodes) i2.nodes = cleanSource$1(i2.nodes);\n        delete i2.source;\n        return i2;\n    });\n}\nfunction markDirtyUp$1(node2) {\n    node2[isClean$1$1] = false;\n    if (node2.proxyOf.nodes) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(node2.proxyOf.nodes), _step; !(_step = _iterator()).done;){\n            var i2 = _step.value;\n            markDirtyUp$1(i2);\n        }\n    }\n}\nvar Container$7$1 = /*#__PURE__*/ function(Node$1$1) {\n    _inherits(Container, Node$1$1);\n    function Container() {\n        return Node$1$1.apply(this, arguments) || this;\n    }\n    var _proto = Container.prototype;\n    _proto.append = function append() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        for(var _iterator = _create_for_of_iterator_helper_loose(children), _step; !(_step = _iterator()).done;){\n            var child = _step.value;\n            var nodes = this.normalize(child, this.last);\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var node2 = _step1.value;\n                this.proxyOf.nodes.push(node2);\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.cleanRaws = function cleanRaws(keepBetween) {\n        Node$1$1.prototype.cleanRaws.call(this, keepBetween);\n        if (this.nodes) {\n            for(var _iterator = _create_for_of_iterator_helper_loose(this.nodes), _step; !(_step = _iterator()).done;){\n                var node2 = _step.value;\n                node2.cleanRaws(keepBetween);\n            }\n        }\n    };\n    _proto.each = function each(callback) {\n        if (!this.proxyOf.nodes) return void 0;\n        var iterator = this.getIterator();\n        var index2, result2;\n        while(this.indexes[iterator] < this.proxyOf.nodes.length){\n            index2 = this.indexes[iterator];\n            result2 = callback(this.proxyOf.nodes[index2], index2);\n            if (result2 === false) break;\n            this.indexes[iterator] += 1;\n        }\n        delete this.indexes[iterator];\n        return result2;\n    };\n    _proto.every = function every(condition) {\n        return this.nodes.every(condition);\n    };\n    _proto.getIterator = function getIterator() {\n        if (!this.lastEach) this.lastEach = 0;\n        if (!this.indexes) this.indexes = {};\n        this.lastEach += 1;\n        var iterator = this.lastEach;\n        this.indexes[iterator] = 0;\n        return iterator;\n    };\n    _proto.getProxyProcessor = function getProxyProcessor() {\n        return {\n            get: function get(node2, prop) {\n                if (prop === \"proxyOf\") {\n                    return node2;\n                } else if (!node2[prop]) {\n                    return node2[prop];\n                } else if (prop === \"each\" || typeof prop === \"string\" && prop.startsWith(\"walk\")) {\n                    return function() {\n                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                            args[_key] = arguments[_key];\n                        }\n                        var _node2;\n                        return (_node2 = node2)[prop].apply(_node2, [].concat(args.map(function(i2) {\n                            if (typeof i2 === \"function\") {\n                                return function(child, index2) {\n                                    return i2(child.toProxy(), index2);\n                                };\n                            } else {\n                                return i2;\n                            }\n                        })));\n                    };\n                } else if (prop === \"every\" || prop === \"some\") {\n                    return function(cb) {\n                        return node2[prop](function(child) {\n                            for(var _len = arguments.length, other = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                                other[_key - 1] = arguments[_key];\n                            }\n                            return cb.apply(void 0, [].concat([\n                                child.toProxy()\n                            ], other));\n                        });\n                    };\n                } else if (prop === \"root\") {\n                    return function() {\n                        return node2.root().toProxy();\n                    };\n                } else if (prop === \"nodes\") {\n                    return node2.nodes.map(function(i2) {\n                        return i2.toProxy();\n                    });\n                } else if (prop === \"first\" || prop === \"last\") {\n                    return node2[prop].toProxy();\n                } else {\n                    return node2[prop];\n                }\n            },\n            set: function set(node2, prop, value) {\n                if (node2[prop] === value) return true;\n                node2[prop] = value;\n                if (prop === \"name\" || prop === \"params\" || prop === \"selector\") {\n                    node2.markDirty();\n                }\n                return true;\n            }\n        };\n    };\n    _proto.index = function index(child) {\n        if (typeof child === \"number\") return child;\n        if (child.proxyOf) child = child.proxyOf;\n        return this.proxyOf.nodes.indexOf(child);\n    };\n    _proto.insertAfter = function insertAfter(exist, add) {\n        var existIndex = this.index(exist);\n        var nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();\n        existIndex = this.index(exist);\n        for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            this.proxyOf.nodes.splice(existIndex + 1, 0, node2);\n        }\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (existIndex < index2) {\n                this.indexes[id] = index2 + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.insertBefore = function insertBefore(exist, add) {\n        var existIndex = this.index(exist);\n        var type = existIndex === 0 ? \"prepend\" : false;\n        var nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();\n        existIndex = this.index(exist);\n        for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            this.proxyOf.nodes.splice(existIndex, 0, node2);\n        }\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (existIndex <= index2) {\n                this.indexes[id] = index2 + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.normalize = function normalize(nodes, sample) {\n        var _this = this;\n        if (typeof nodes === \"string\") {\n            nodes = cleanSource$1(parse$4$1(nodes).nodes);\n        } else if (typeof nodes === \"undefined\") {\n            nodes = [];\n        } else if (Array.isArray(nodes)) {\n            nodes = nodes.slice(0);\n            for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                var i2 = _step.value;\n                if (i2.parent) i2.parent.removeChild(i2, \"ignore\");\n            }\n        } else if (nodes.type === \"root\" && this.type !== \"document\") {\n            nodes = nodes.nodes.slice(0);\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var i21 = _step1.value;\n                if (i21.parent) i21.parent.removeChild(i21, \"ignore\");\n            }\n        } else if (nodes.type) {\n            nodes = [\n                nodes\n            ];\n        } else if (nodes.prop) {\n            if (typeof nodes.value === \"undefined\") {\n                throw new Error(\"Value field is missed in node creation\");\n            } else if (typeof nodes.value !== \"string\") {\n                nodes.value = String(nodes.value);\n            }\n            nodes = [\n                new Declaration$3$1(nodes)\n            ];\n        } else if (nodes.selector) {\n            nodes = [\n                new Rule$4$1(nodes)\n            ];\n        } else if (nodes.name) {\n            nodes = [\n                new AtRule$4$1(nodes)\n            ];\n        } else if (nodes.text) {\n            nodes = [\n                new Comment$3$1(nodes)\n            ];\n        } else {\n            throw new Error(\"Unknown node type in node creation\");\n        }\n        var processed = nodes.map(function(i2) {\n            if (!i2[my$1$1]) Container.rebuild(i2);\n            i2 = i2.proxyOf;\n            if (i2.parent) i2.parent.removeChild(i2);\n            if (i2[isClean$1$1]) markDirtyUp$1(i2);\n            if (typeof i2.raws.before === \"undefined\") {\n                if (sample && typeof sample.raws.before !== \"undefined\") {\n                    i2.raws.before = sample.raws.before.replace(/\\S/g, \"\");\n                }\n            }\n            i2.parent = _this.proxyOf;\n            return i2;\n        });\n        return processed;\n    };\n    _proto.prepend = function prepend() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        children = children.reverse();\n        for(var _iterator = _create_for_of_iterator_helper_loose(children), _step; !(_step = _iterator()).done;){\n            var child = _step.value;\n            var nodes = this.normalize(child, this.first, \"prepend\").reverse();\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var node2 = _step1.value;\n                this.proxyOf.nodes.unshift(node2);\n            }\n            for(var id in this.indexes){\n                this.indexes[id] = this.indexes[id] + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.push = function push(child) {\n        child.parent = this;\n        this.proxyOf.nodes.push(child);\n        return this;\n    };\n    _proto.removeAll = function removeAll() {\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.proxyOf.nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            node2.parent = void 0;\n        }\n        this.proxyOf.nodes = [];\n        this.markDirty();\n        return this;\n    };\n    _proto.removeChild = function removeChild(child) {\n        child = this.index(child);\n        this.proxyOf.nodes[child].parent = void 0;\n        this.proxyOf.nodes.splice(child, 1);\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (index2 >= child) {\n                this.indexes[id] = index2 - 1;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.replaceValues = function replaceValues(pattern, opts, callback) {\n        if (!callback) {\n            callback = opts;\n            opts = {};\n        }\n        this.walkDecls(function(decl) {\n            if (opts.props && !opts.props.includes(decl.prop)) return;\n            if (opts.fast && !decl.value.includes(opts.fast)) return;\n            decl.value = decl.value.replace(pattern, callback);\n        });\n        this.markDirty();\n        return this;\n    };\n    _proto.some = function some(condition) {\n        return this.nodes.some(condition);\n    };\n    _proto.walk = function walk(callback) {\n        return this.each(function(child, i2) {\n            var result2;\n            try {\n                result2 = callback(child, i2);\n            } catch (e2) {\n                throw child.addToError(e2);\n            }\n            if (result2 !== false && child.walk) {\n                result2 = child.walk(callback);\n            }\n            return result2;\n        });\n    };\n    _proto.walkAtRules = function walkAtRules(name, callback) {\n        if (!callback) {\n            callback = name;\n            return this.walk(function(child, i2) {\n                if (child.type === \"atrule\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(name, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"atrule\" && name.test(child.name)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"atrule\" && child.name === name) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkComments = function walkComments(callback) {\n        return this.walk(function(child, i2) {\n            if (child.type === \"comment\") {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkDecls = function walkDecls(prop, callback) {\n        if (!callback) {\n            callback = prop;\n            return this.walk(function(child, i2) {\n                if (child.type === \"decl\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(prop, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"decl\" && prop.test(child.prop)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"decl\" && child.prop === prop) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkRules = function walkRules(selector, callback) {\n        if (!callback) {\n            callback = selector;\n            return this.walk(function(child, i2) {\n                if (child.type === \"rule\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(selector, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"rule\" && selector.test(child.selector)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"rule\" && child.selector === selector) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _create_class(Container, [\n        {\n            key: \"first\",\n            get: function get() {\n                if (!this.proxyOf.nodes) return void 0;\n                return this.proxyOf.nodes[0];\n            }\n        },\n        {\n            key: \"last\",\n            get: function get() {\n                if (!this.proxyOf.nodes) return void 0;\n                return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];\n            }\n        }\n    ]);\n    return Container;\n}(Node$1$1);\nContainer$7$1.registerParse = function(dependant) {\n    parse$4$1 = dependant;\n};\nContainer$7$1.registerRule = function(dependant) {\n    Rule$4$1 = dependant;\n};\nContainer$7$1.registerAtRule = function(dependant) {\n    AtRule$4$1 = dependant;\n};\nContainer$7$1.registerRoot = function(dependant) {\n    Root$6$1 = dependant;\n};\nvar container$1 = Container$7$1;\nContainer$7$1.default = Container$7$1;\nContainer$7$1.rebuild = function(node2) {\n    if (node2.type === \"atrule\") {\n        Object.setPrototypeOf(node2, AtRule$4$1.prototype);\n    } else if (node2.type === \"rule\") {\n        Object.setPrototypeOf(node2, Rule$4$1.prototype);\n    } else if (node2.type === \"decl\") {\n        Object.setPrototypeOf(node2, Declaration$3$1.prototype);\n    } else if (node2.type === \"comment\") {\n        Object.setPrototypeOf(node2, Comment$3$1.prototype);\n    } else if (node2.type === \"root\") {\n        Object.setPrototypeOf(node2, Root$6$1.prototype);\n    }\n    node2[my$1$1] = true;\n    if (node2.nodes) {\n        node2.nodes.forEach(function(child) {\n            Container$7$1.rebuild(child);\n        });\n    }\n};\nvar Container$6$1 = container$1;\nvar LazyResult$4$1, Processor$3$1;\nvar Document$3$1 = /*#__PURE__*/ function(Container$6$1) {\n    _inherits(Document2, Container$6$1);\n    function Document2(defaults) {\n        var _this;\n        _this = Container$6$1.call(this, _extends({\n            type: \"document\"\n        }, defaults)) || this;\n        if (!_this.nodes) {\n            _this.nodes = [];\n        }\n        return _this;\n    }\n    var _proto = Document2.prototype;\n    _proto.toResult = function toResult(opts) {\n        if (opts === void 0) opts = {};\n        var lazy = new LazyResult$4$1(new Processor$3$1(), this, opts);\n        return lazy.stringify();\n    };\n    return Document2;\n}(Container$6$1);\nDocument$3$1.registerLazyResult = function(dependant) {\n    LazyResult$4$1 = dependant;\n};\nDocument$3$1.registerProcessor = function(dependant) {\n    Processor$3$1 = dependant;\n};\nvar document$1$1 = Document$3$1;\nDocument$3$1.default = Document$3$1;\nvar printed$1 = {};\nvar warnOnce$2$1 = function warnOnce(message) {\n    if (printed$1[message]) return;\n    printed$1[message] = true;\n    if (typeof console !== \"undefined\" && console.warn) {\n        console.warn(message);\n    }\n};\nvar Warning$2$1 = /*#__PURE__*/ function() {\n    function Warning(text, opts) {\n        if (opts === void 0) opts = {};\n        this.type = \"warning\";\n        this.text = text;\n        if (opts.node && opts.node.source) {\n            var range = opts.node.rangeBy(opts);\n            this.line = range.start.line;\n            this.column = range.start.column;\n            this.endLine = range.end.line;\n            this.endColumn = range.end.column;\n        }\n        for(var opt in opts)this[opt] = opts[opt];\n    }\n    var _proto = Warning.prototype;\n    _proto.toString = function toString() {\n        if (this.node) {\n            return this.node.error(this.text, {\n                index: this.index,\n                plugin: this.plugin,\n                word: this.word\n            }).message;\n        }\n        if (this.plugin) {\n            return this.plugin + \": \" + this.text;\n        }\n        return this.text;\n    };\n    return Warning;\n}();\nvar warning$1 = Warning$2$1;\nWarning$2$1.default = Warning$2$1;\nvar Warning$1$1 = warning$1;\nvar Result$3$1 = /*#__PURE__*/ function() {\n    function Result(processor2, root2, opts) {\n        this.processor = processor2;\n        this.messages = [];\n        this.root = root2;\n        this.opts = opts;\n        this.css = void 0;\n        this.map = void 0;\n    }\n    var _proto = Result.prototype;\n    _proto.toString = function toString() {\n        return this.css;\n    };\n    _proto.warn = function warn(text, opts) {\n        if (opts === void 0) opts = {};\n        if (!opts.plugin) {\n            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {\n                opts.plugin = this.lastPlugin.postcssPlugin;\n            }\n        }\n        var warning2 = new Warning$1$1(text, opts);\n        this.messages.push(warning2);\n        return warning2;\n    };\n    _proto.warnings = function warnings() {\n        return this.messages.filter(function(i2) {\n            return i2.type === \"warning\";\n        });\n    };\n    _create_class(Result, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.css;\n            }\n        }\n    ]);\n    return Result;\n}();\nvar result$1 = Result$3$1;\nResult$3$1.default = Result$3$1;\nvar SINGLE_QUOTE$1 = \"'\".charCodeAt(0);\nvar DOUBLE_QUOTE$1 = '\"'.charCodeAt(0);\nvar BACKSLASH$1 = \"\\\\\".charCodeAt(0);\nvar SLASH$1 = \"/\".charCodeAt(0);\nvar NEWLINE$1 = \"\\n\".charCodeAt(0);\nvar SPACE$1 = \" \".charCodeAt(0);\nvar FEED$1 = \"\\f\".charCodeAt(0);\nvar TAB$1 = \"\t\".charCodeAt(0);\nvar CR$1 = \"\\r\".charCodeAt(0);\nvar OPEN_SQUARE$1 = \"[\".charCodeAt(0);\nvar CLOSE_SQUARE$1 = \"]\".charCodeAt(0);\nvar OPEN_PARENTHESES$1 = \"(\".charCodeAt(0);\nvar CLOSE_PARENTHESES$1 = \")\".charCodeAt(0);\nvar OPEN_CURLY$1 = \"{\".charCodeAt(0);\nvar CLOSE_CURLY$1 = \"}\".charCodeAt(0);\nvar SEMICOLON$1 = \";\".charCodeAt(0);\nvar ASTERISK$1 = \"*\".charCodeAt(0);\nvar COLON$1 = \":\".charCodeAt(0);\nvar AT$1 = \"@\".charCodeAt(0);\nvar RE_AT_END$1 = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g;\nvar RE_WORD_END$1 = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g;\nvar RE_BAD_BRACKET$1 = /.[\\r\\n\"'(/\\\\]/;\nvar RE_HEX_ESCAPE$1 = /[\\da-f]/i;\nvar tokenize$1 = function tokenizer(input2, options) {\n    if (options === void 0) options = {};\n    var css = input2.css.valueOf();\n    var ignore = options.ignoreErrors;\n    var code, next, quote, content, escape;\n    var escaped, escapePos, prev, n2, currentToken;\n    var length = css.length;\n    var pos = 0;\n    var buffer = [];\n    var returned = [];\n    function position() {\n        return pos;\n    }\n    function unclosed(what) {\n        throw input2.error(\"Unclosed \" + what, pos);\n    }\n    function endOfFile() {\n        return returned.length === 0 && pos >= length;\n    }\n    function nextToken(opts) {\n        if (returned.length) return returned.pop();\n        if (pos >= length) return;\n        var ignoreUnclosed = opts ? opts.ignoreUnclosed : false;\n        code = css.charCodeAt(pos);\n        switch(code){\n            case NEWLINE$1:\n            case SPACE$1:\n            case TAB$1:\n            case CR$1:\n            case FEED$1:\n                {\n                    next = pos;\n                    do {\n                        next += 1;\n                        code = css.charCodeAt(next);\n                    }while (code === SPACE$1 || code === NEWLINE$1 || code === TAB$1 || code === CR$1 || code === FEED$1);\n                    currentToken = [\n                        \"space\",\n                        css.slice(pos, next)\n                    ];\n                    pos = next - 1;\n                    break;\n                }\n            case OPEN_SQUARE$1:\n            case CLOSE_SQUARE$1:\n            case OPEN_CURLY$1:\n            case CLOSE_CURLY$1:\n            case COLON$1:\n            case SEMICOLON$1:\n            case CLOSE_PARENTHESES$1:\n                {\n                    var controlChar = String.fromCharCode(code);\n                    currentToken = [\n                        controlChar,\n                        controlChar,\n                        pos\n                    ];\n                    break;\n                }\n            case OPEN_PARENTHESES$1:\n                {\n                    prev = buffer.length ? buffer.pop()[1] : \"\";\n                    n2 = css.charCodeAt(pos + 1);\n                    if (prev === \"url\" && n2 !== SINGLE_QUOTE$1 && n2 !== DOUBLE_QUOTE$1 && n2 !== SPACE$1 && n2 !== NEWLINE$1 && n2 !== TAB$1 && n2 !== FEED$1 && n2 !== CR$1) {\n                        next = pos;\n                        do {\n                            escaped = false;\n                            next = css.indexOf(\")\", next + 1);\n                            if (next === -1) {\n                                if (ignore || ignoreUnclosed) {\n                                    next = pos;\n                                    break;\n                                } else {\n                                    unclosed(\"bracket\");\n                                }\n                            }\n                            escapePos = next;\n                            while(css.charCodeAt(escapePos - 1) === BACKSLASH$1){\n                                escapePos -= 1;\n                                escaped = !escaped;\n                            }\n                        }while (escaped);\n                        currentToken = [\n                            \"brackets\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        pos = next;\n                    } else {\n                        next = css.indexOf(\")\", pos + 1);\n                        content = css.slice(pos, next + 1);\n                        if (next === -1 || RE_BAD_BRACKET$1.test(content)) {\n                            currentToken = [\n                                \"(\",\n                                \"(\",\n                                pos\n                            ];\n                        } else {\n                            currentToken = [\n                                \"brackets\",\n                                content,\n                                pos,\n                                next\n                            ];\n                            pos = next;\n                        }\n                    }\n                    break;\n                }\n            case SINGLE_QUOTE$1:\n            case DOUBLE_QUOTE$1:\n                {\n                    quote = code === SINGLE_QUOTE$1 ? \"'\" : '\"';\n                    next = pos;\n                    do {\n                        escaped = false;\n                        next = css.indexOf(quote, next + 1);\n                        if (next === -1) {\n                            if (ignore || ignoreUnclosed) {\n                                next = pos + 1;\n                                break;\n                            } else {\n                                unclosed(\"string\");\n                            }\n                        }\n                        escapePos = next;\n                        while(css.charCodeAt(escapePos - 1) === BACKSLASH$1){\n                            escapePos -= 1;\n                            escaped = !escaped;\n                        }\n                    }while (escaped);\n                    currentToken = [\n                        \"string\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            case AT$1:\n                {\n                    RE_AT_END$1.lastIndex = pos + 1;\n                    RE_AT_END$1.test(css);\n                    if (RE_AT_END$1.lastIndex === 0) {\n                        next = css.length - 1;\n                    } else {\n                        next = RE_AT_END$1.lastIndex - 2;\n                    }\n                    currentToken = [\n                        \"at-word\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            case BACKSLASH$1:\n                {\n                    next = pos;\n                    escape = true;\n                    while(css.charCodeAt(next + 1) === BACKSLASH$1){\n                        next += 1;\n                        escape = !escape;\n                    }\n                    code = css.charCodeAt(next + 1);\n                    if (escape && code !== SLASH$1 && code !== SPACE$1 && code !== NEWLINE$1 && code !== TAB$1 && code !== CR$1 && code !== FEED$1) {\n                        next += 1;\n                        if (RE_HEX_ESCAPE$1.test(css.charAt(next))) {\n                            while(RE_HEX_ESCAPE$1.test(css.charAt(next + 1))){\n                                next += 1;\n                            }\n                            if (css.charCodeAt(next + 1) === SPACE$1) {\n                                next += 1;\n                            }\n                        }\n                    }\n                    currentToken = [\n                        \"word\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            default:\n                {\n                    if (code === SLASH$1 && css.charCodeAt(pos + 1) === ASTERISK$1) {\n                        next = css.indexOf(\"*/\", pos + 2) + 1;\n                        if (next === 0) {\n                            if (ignore || ignoreUnclosed) {\n                                next = css.length;\n                            } else {\n                                unclosed(\"comment\");\n                            }\n                        }\n                        currentToken = [\n                            \"comment\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        pos = next;\n                    } else {\n                        RE_WORD_END$1.lastIndex = pos + 1;\n                        RE_WORD_END$1.test(css);\n                        if (RE_WORD_END$1.lastIndex === 0) {\n                            next = css.length - 1;\n                        } else {\n                            next = RE_WORD_END$1.lastIndex - 2;\n                        }\n                        currentToken = [\n                            \"word\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        buffer.push(currentToken);\n                        pos = next;\n                    }\n                    break;\n                }\n        }\n        pos++;\n        return currentToken;\n    }\n    function back(token) {\n        returned.push(token);\n    }\n    return {\n        back: back,\n        endOfFile: endOfFile,\n        nextToken: nextToken,\n        position: position\n    };\n};\nvar Container$5$1 = container$1;\nvar AtRule$3$1 = /*#__PURE__*/ function(Container$5$1) {\n    _inherits(AtRule, Container$5$1);\n    function AtRule(defaults) {\n        var _this;\n        _this = Container$5$1.call(this, defaults) || this;\n        _this.type = \"atrule\";\n        return _this;\n    }\n    var _proto = AtRule.prototype;\n    _proto.append = function append() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        var _Container$5$1_prototype_append;\n        if (!this.proxyOf.nodes) this.nodes = [];\n        return (_Container$5$1_prototype_append = Container$5$1.prototype.append).call.apply(_Container$5$1_prototype_append, [].concat([\n            this\n        ], children));\n    };\n    _proto.prepend = function prepend() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        var _Container$5$1_prototype_prepend;\n        if (!this.proxyOf.nodes) this.nodes = [];\n        return (_Container$5$1_prototype_prepend = Container$5$1.prototype.prepend).call.apply(_Container$5$1_prototype_prepend, [].concat([\n            this\n        ], children));\n    };\n    return AtRule;\n}(Container$5$1);\nvar atRule$1 = AtRule$3$1;\nAtRule$3$1.default = AtRule$3$1;\nContainer$5$1.registerAtRule(AtRule$3$1);\nvar Container$4$1 = container$1;\nvar LazyResult$3$1, Processor$2$1;\nvar Root$5$1 = /*#__PURE__*/ function(Container$4$1) {\n    _inherits(Root, Container$4$1);\n    function Root(defaults) {\n        var _this;\n        _this = Container$4$1.call(this, defaults) || this;\n        _this.type = \"root\";\n        if (!_this.nodes) _this.nodes = [];\n        return _this;\n    }\n    var _proto = Root.prototype;\n    _proto.normalize = function normalize(child, sample, type) {\n        var nodes = Container$4$1.prototype.normalize.call(this, child);\n        if (sample) {\n            if (type === \"prepend\") {\n                if (this.nodes.length > 1) {\n                    sample.raws.before = this.nodes[1].raws.before;\n                } else {\n                    delete sample.raws.before;\n                }\n            } else if (this.first !== sample) {\n                for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                    var node2 = _step.value;\n                    node2.raws.before = sample.raws.before;\n                }\n            }\n        }\n        return nodes;\n    };\n    _proto.removeChild = function removeChild(child, ignore) {\n        var index2 = this.index(child);\n        if (!ignore && index2 === 0 && this.nodes.length > 1) {\n            this.nodes[1].raws.before = this.nodes[index2].raws.before;\n        }\n        return Container$4$1.prototype.removeChild.call(this, child);\n    };\n    _proto.toResult = function toResult(opts) {\n        if (opts === void 0) opts = {};\n        var lazy = new LazyResult$3$1(new Processor$2$1(), this, opts);\n        return lazy.stringify();\n    };\n    return Root;\n}(Container$4$1);\nRoot$5$1.registerLazyResult = function(dependant) {\n    LazyResult$3$1 = dependant;\n};\nRoot$5$1.registerProcessor = function(dependant) {\n    Processor$2$1 = dependant;\n};\nvar root$1 = Root$5$1;\nRoot$5$1.default = Root$5$1;\nContainer$4$1.registerRoot(Root$5$1);\nvar list$2$1 = {\n    comma: function comma(string) {\n        return list$2$1.split(string, [\n            \",\"\n        ], true);\n    },\n    space: function space(string) {\n        var spaces = [\n            \" \",\n            \"\\n\",\n            \"\t\"\n        ];\n        return list$2$1.split(string, spaces);\n    },\n    split: function split(string, separators, last) {\n        var array = [];\n        var current = \"\";\n        var split = false;\n        var func = 0;\n        var inQuote = false;\n        var prevQuote = \"\";\n        var escape = false;\n        for(var _iterator = _create_for_of_iterator_helper_loose(string), _step; !(_step = _iterator()).done;){\n            var letter = _step.value;\n            if (escape) {\n                escape = false;\n            } else if (letter === \"\\\\\") {\n                escape = true;\n            } else if (inQuote) {\n                if (letter === prevQuote) {\n                    inQuote = false;\n                }\n            } else if (letter === '\"' || letter === \"'\") {\n                inQuote = true;\n                prevQuote = letter;\n            } else if (letter === \"(\") {\n                func += 1;\n            } else if (letter === \")\") {\n                if (func > 0) func -= 1;\n            } else if (func === 0) {\n                if (separators.includes(letter)) split = true;\n            }\n            if (split) {\n                if (current !== \"\") array.push(current.trim());\n                current = \"\";\n                split = false;\n            } else {\n                current += letter;\n            }\n        }\n        if (last || current !== \"\") array.push(current.trim());\n        return array;\n    }\n};\nvar list_1$1 = list$2$1;\nlist$2$1.default = list$2$1;\nvar Container$3$1 = container$1;\nvar list$1$1 = list_1$1;\nvar Rule$3$1 = /*#__PURE__*/ function(Container$3$1) {\n    _inherits(Rule, Container$3$1);\n    function Rule(defaults) {\n        var _this;\n        _this = Container$3$1.call(this, defaults) || this;\n        _this.type = \"rule\";\n        if (!_this.nodes) _this.nodes = [];\n        return _this;\n    }\n    _create_class(Rule, [\n        {\n            key: \"selectors\",\n            get: function get() {\n                return list$1$1.comma(this.selector);\n            },\n            set: function set(values) {\n                var match = this.selector ? this.selector.match(/,\\s*/) : null;\n                var sep2 = match ? match[0] : \",\" + this.raw(\"between\", \"beforeOpen\");\n                this.selector = values.join(sep2);\n            }\n        }\n    ]);\n    return Rule;\n}(Container$3$1);\nvar rule$1 = Rule$3$1;\nRule$3$1.default = Rule$3$1;\nContainer$3$1.registerRule(Rule$3$1);\nvar Declaration$2$1 = declaration$1;\nvar tokenizer2$1 = tokenize$1;\nvar Comment$2$1 = comment$1;\nvar AtRule$2$1 = atRule$1;\nvar Root$4$1 = root$1;\nvar Rule$2$1 = rule$1;\nvar SAFE_COMMENT_NEIGHBOR$1 = {\n    empty: true,\n    space: true\n};\nfunction findLastWithPosition$1(tokens) {\n    for(var i2 = tokens.length - 1; i2 >= 0; i2--){\n        var token = tokens[i2];\n        var pos = token[3] || token[2];\n        if (pos) return pos;\n    }\n}\nvar Parser$1$1 = /*#__PURE__*/ function() {\n    function Parser(input2) {\n        this.input = input2;\n        this.root = new Root$4$1();\n        this.current = this.root;\n        this.spaces = \"\";\n        this.semicolon = false;\n        this.createTokenizer();\n        this.root.source = {\n            input: input2,\n            start: {\n                column: 1,\n                line: 1,\n                offset: 0\n            }\n        };\n    }\n    var _proto = Parser.prototype;\n    _proto.atrule = function atrule(token) {\n        var node2 = new AtRule$2$1();\n        node2.name = token[1].slice(1);\n        if (node2.name === \"\") {\n            this.unnamedAtrule(node2, token);\n        }\n        this.init(node2, token[2]);\n        var type;\n        var prev;\n        var shift;\n        var last = false;\n        var open = false;\n        var params = [];\n        var brackets = [];\n        while(!this.tokenizer.endOfFile()){\n            token = this.tokenizer.nextToken();\n            type = token[0];\n            if (type === \"(\" || type === \"[\") {\n                brackets.push(type === \"(\" ? \")\" : \"]\");\n            } else if (type === \"{\" && brackets.length > 0) {\n                brackets.push(\"}\");\n            } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n            }\n            if (brackets.length === 0) {\n                if (type === \";\") {\n                    node2.source.end = this.getPosition(token[2]);\n                    node2.source.end.offset++;\n                    this.semicolon = true;\n                    break;\n                } else if (type === \"{\") {\n                    open = true;\n                    break;\n                } else if (type === \"}\") {\n                    if (params.length > 0) {\n                        shift = params.length - 1;\n                        prev = params[shift];\n                        while(prev && prev[0] === \"space\"){\n                            prev = params[--shift];\n                        }\n                        if (prev) {\n                            node2.source.end = this.getPosition(prev[3] || prev[2]);\n                            node2.source.end.offset++;\n                        }\n                    }\n                    this.end(token);\n                    break;\n                } else {\n                    params.push(token);\n                }\n            } else {\n                params.push(token);\n            }\n            if (this.tokenizer.endOfFile()) {\n                last = true;\n                break;\n            }\n        }\n        node2.raws.between = this.spacesAndCommentsFromEnd(params);\n        if (params.length) {\n            node2.raws.afterName = this.spacesAndCommentsFromStart(params);\n            this.raw(node2, \"params\", params);\n            if (last) {\n                token = params[params.length - 1];\n                node2.source.end = this.getPosition(token[3] || token[2]);\n                node2.source.end.offset++;\n                this.spaces = node2.raws.between;\n                node2.raws.between = \"\";\n            }\n        } else {\n            node2.raws.afterName = \"\";\n            node2.params = \"\";\n        }\n        if (open) {\n            node2.nodes = [];\n            this.current = node2;\n        }\n    };\n    _proto.checkMissedSemicolon = function checkMissedSemicolon(tokens) {\n        var colon = this.colon(tokens);\n        if (colon === false) return;\n        var founded = 0;\n        var token;\n        for(var j = colon - 1; j >= 0; j--){\n            token = tokens[j];\n            if (token[0] !== \"space\") {\n                founded += 1;\n                if (founded === 2) break;\n            }\n        }\n        throw this.input.error(\"Missed semicolon\", token[0] === \"word\" ? token[3] + 1 : token[2]);\n    };\n    _proto.colon = function colon(tokens) {\n        var brackets = 0;\n        var token, type, prev;\n        for(var _iterator = _create_for_of_iterator_helper_loose(tokens.entries()), _step; !(_step = _iterator()).done;){\n            var _step_value = _step.value, i2 = _step_value[0], element = _step_value[1];\n            token = element;\n            type = token[0];\n            if (type === \"(\") {\n                brackets += 1;\n            }\n            if (type === \")\") {\n                brackets -= 1;\n            }\n            if (brackets === 0 && type === \":\") {\n                if (!prev) {\n                    this.doubleColon(token);\n                } else if (prev[0] === \"word\" && prev[1] === \"progid\") {\n                    continue;\n                } else {\n                    return i2;\n                }\n            }\n            prev = token;\n        }\n        return false;\n    };\n    _proto.comment = function comment(token) {\n        var node2 = new Comment$2$1();\n        this.init(node2, token[2]);\n        node2.source.end = this.getPosition(token[3] || token[2]);\n        node2.source.end.offset++;\n        var text = token[1].slice(2, -2);\n        if (/^\\s*$/.test(text)) {\n            node2.text = \"\";\n            node2.raws.left = text;\n            node2.raws.right = \"\";\n        } else {\n            var match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/);\n            node2.text = match[2];\n            node2.raws.left = match[1];\n            node2.raws.right = match[3];\n        }\n    };\n    _proto.createTokenizer = function createTokenizer() {\n        this.tokenizer = tokenizer2$1(this.input);\n    };\n    _proto.decl = function decl(tokens, customProperty) {\n        var node2 = new Declaration$2$1();\n        this.init(node2, tokens[0][2]);\n        var last = tokens[tokens.length - 1];\n        if (last[0] === \";\") {\n            this.semicolon = true;\n            tokens.pop();\n        }\n        node2.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition$1(tokens));\n        node2.source.end.offset++;\n        while(tokens[0][0] !== \"word\"){\n            if (tokens.length === 1) this.unknownWord(tokens);\n            node2.raws.before += tokens.shift()[1];\n        }\n        node2.source.start = this.getPosition(tokens[0][2]);\n        node2.prop = \"\";\n        while(tokens.length){\n            var type = tokens[0][0];\n            if (type === \":\" || type === \"space\" || type === \"comment\") {\n                break;\n            }\n            node2.prop += tokens.shift()[1];\n        }\n        node2.raws.between = \"\";\n        var token;\n        while(tokens.length){\n            token = tokens.shift();\n            if (token[0] === \":\") {\n                node2.raws.between += token[1];\n                break;\n            } else {\n                if (token[0] === \"word\" && /\\w/.test(token[1])) {\n                    this.unknownWord([\n                        token\n                    ]);\n                }\n                node2.raws.between += token[1];\n            }\n        }\n        if (node2.prop[0] === \"_\" || node2.prop[0] === \"*\") {\n            node2.raws.before += node2.prop[0];\n            node2.prop = node2.prop.slice(1);\n        }\n        var firstSpaces = [];\n        var next;\n        while(tokens.length){\n            next = tokens[0][0];\n            if (next !== \"space\" && next !== \"comment\") break;\n            firstSpaces.push(tokens.shift());\n        }\n        this.precheckMissedSemicolon(tokens);\n        for(var i2 = tokens.length - 1; i2 >= 0; i2--){\n            token = tokens[i2];\n            if (token[1].toLowerCase() === \"!important\") {\n                node2.important = true;\n                var string = this.stringFrom(tokens, i2);\n                string = this.spacesFromEnd(tokens) + string;\n                if (string !== \" !important\") node2.raws.important = string;\n                break;\n            } else if (token[1].toLowerCase() === \"important\") {\n                var cache = tokens.slice(0);\n                var str = \"\";\n                for(var j = i2; j > 0; j--){\n                    var type1 = cache[j][0];\n                    if (str.trim().indexOf(\"!\") === 0 && type1 !== \"space\") {\n                        break;\n                    }\n                    str = cache.pop()[1] + str;\n                }\n                if (str.trim().indexOf(\"!\") === 0) {\n                    node2.important = true;\n                    node2.raws.important = str;\n                    tokens = cache;\n                }\n            }\n            if (token[0] !== \"space\" && token[0] !== \"comment\") {\n                break;\n            }\n        }\n        var hasWord = tokens.some(function(i2) {\n            return i2[0] !== \"space\" && i2[0] !== \"comment\";\n        });\n        if (hasWord) {\n            node2.raws.between += firstSpaces.map(function(i2) {\n                return i2[1];\n            }).join(\"\");\n            firstSpaces = [];\n        }\n        this.raw(node2, \"value\", firstSpaces.concat(tokens), customProperty);\n        if (node2.value.includes(\":\") && !customProperty) {\n            this.checkMissedSemicolon(tokens);\n        }\n    };\n    _proto.doubleColon = function doubleColon(token) {\n        throw this.input.error(\"Double colon\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + token[1].length\n        });\n    };\n    _proto.emptyRule = function emptyRule(token) {\n        var node2 = new Rule$2$1();\n        this.init(node2, token[2]);\n        node2.selector = \"\";\n        node2.raws.between = \"\";\n        this.current = node2;\n    };\n    _proto.end = function end(token) {\n        if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.semicolon = false;\n        this.current.raws.after = (this.current.raws.after || \"\") + this.spaces;\n        this.spaces = \"\";\n        if (this.current.parent) {\n            this.current.source.end = this.getPosition(token[2]);\n            this.current.source.end.offset++;\n            this.current = this.current.parent;\n        } else {\n            this.unexpectedClose(token);\n        }\n    };\n    _proto.endFile = function endFile() {\n        if (this.current.parent) this.unclosedBlock();\n        if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.current.raws.after = (this.current.raws.after || \"\") + this.spaces;\n        this.root.source.end = this.getPosition(this.tokenizer.position());\n    };\n    _proto.freeSemicolon = function freeSemicolon(token) {\n        this.spaces += token[1];\n        if (this.current.nodes) {\n            var prev = this.current.nodes[this.current.nodes.length - 1];\n            if (prev && prev.type === \"rule\" && !prev.raws.ownSemicolon) {\n                prev.raws.ownSemicolon = this.spaces;\n                this.spaces = \"\";\n            }\n        }\n    };\n    // Helpers\n    _proto.getPosition = function getPosition(offset) {\n        var pos = this.input.fromOffset(offset);\n        return {\n            column: pos.col,\n            line: pos.line,\n            offset: offset\n        };\n    };\n    _proto.init = function init(node2, offset) {\n        this.current.push(node2);\n        node2.source = {\n            input: this.input,\n            start: this.getPosition(offset)\n        };\n        node2.raws.before = this.spaces;\n        this.spaces = \"\";\n        if (node2.type !== \"comment\") this.semicolon = false;\n    };\n    _proto.other = function other(start) {\n        var end = false;\n        var type = null;\n        var colon = false;\n        var bracket = null;\n        var brackets = [];\n        var customProperty = start[1].startsWith(\"--\");\n        var tokens = [];\n        var token = start;\n        while(token){\n            type = token[0];\n            tokens.push(token);\n            if (type === \"(\" || type === \"[\") {\n                if (!bracket) bracket = token;\n                brackets.push(type === \"(\" ? \")\" : \"]\");\n            } else if (customProperty && colon && type === \"{\") {\n                if (!bracket) bracket = token;\n                brackets.push(\"}\");\n            } else if (brackets.length === 0) {\n                if (type === \";\") {\n                    if (colon) {\n                        this.decl(tokens, customProperty);\n                        return;\n                    } else {\n                        break;\n                    }\n                } else if (type === \"{\") {\n                    this.rule(tokens);\n                    return;\n                } else if (type === \"}\") {\n                    this.tokenizer.back(tokens.pop());\n                    end = true;\n                    break;\n                } else if (type === \":\") {\n                    colon = true;\n                }\n            } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n                if (brackets.length === 0) bracket = null;\n            }\n            token = this.tokenizer.nextToken();\n        }\n        if (this.tokenizer.endOfFile()) end = true;\n        if (brackets.length > 0) this.unclosedBracket(bracket);\n        if (end && colon) {\n            if (!customProperty) {\n                while(tokens.length){\n                    token = tokens[tokens.length - 1][0];\n                    if (token !== \"space\" && token !== \"comment\") break;\n                    this.tokenizer.back(tokens.pop());\n                }\n            }\n            this.decl(tokens, customProperty);\n        } else {\n            this.unknownWord(tokens);\n        }\n    };\n    _proto.parse = function parse() {\n        var token;\n        while(!this.tokenizer.endOfFile()){\n            token = this.tokenizer.nextToken();\n            switch(token[0]){\n                case \"space\":\n                    this.spaces += token[1];\n                    break;\n                case \";\":\n                    this.freeSemicolon(token);\n                    break;\n                case \"}\":\n                    this.end(token);\n                    break;\n                case \"comment\":\n                    this.comment(token);\n                    break;\n                case \"at-word\":\n                    this.atrule(token);\n                    break;\n                case \"{\":\n                    this.emptyRule(token);\n                    break;\n                default:\n                    this.other(token);\n                    break;\n            }\n        }\n        this.endFile();\n    };\n    _proto.precheckMissedSemicolon = function precheckMissedSemicolon() {};\n    _proto.raw = function raw(node2, prop, tokens, customProperty) {\n        var token, type;\n        var length = tokens.length;\n        var value = \"\";\n        var clean = true;\n        var next, prev;\n        for(var i2 = 0; i2 < length; i2 += 1){\n            token = tokens[i2];\n            type = token[0];\n            if (type === \"space\" && i2 === length - 1 && !customProperty) {\n                clean = false;\n            } else if (type === \"comment\") {\n                prev = tokens[i2 - 1] ? tokens[i2 - 1][0] : \"empty\";\n                next = tokens[i2 + 1] ? tokens[i2 + 1][0] : \"empty\";\n                if (!SAFE_COMMENT_NEIGHBOR$1[prev] && !SAFE_COMMENT_NEIGHBOR$1[next]) {\n                    if (value.slice(-1) === \",\") {\n                        clean = false;\n                    } else {\n                        value += token[1];\n                    }\n                } else {\n                    clean = false;\n                }\n            } else {\n                value += token[1];\n            }\n        }\n        if (!clean) {\n            var raw = tokens.reduce(function(all, i2) {\n                return all + i2[1];\n            }, \"\");\n            node2.raws[prop] = {\n                raw: raw,\n                value: value\n            };\n        }\n        node2[prop] = value;\n    };\n    _proto.rule = function rule(tokens) {\n        tokens.pop();\n        var node2 = new Rule$2$1();\n        this.init(node2, tokens[0][2]);\n        node2.raws.between = this.spacesAndCommentsFromEnd(tokens);\n        this.raw(node2, \"selector\", tokens);\n        this.current = node2;\n    };\n    _proto.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {\n        var lastTokenType;\n        var spaces = \"\";\n        while(tokens.length){\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== \"space\" && lastTokenType !== \"comment\") break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    };\n    // Errors\n    _proto.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {\n        var next;\n        var spaces = \"\";\n        while(tokens.length){\n            next = tokens[0][0];\n            if (next !== \"space\" && next !== \"comment\") break;\n            spaces += tokens.shift()[1];\n        }\n        return spaces;\n    };\n    _proto.spacesFromEnd = function spacesFromEnd(tokens) {\n        var lastTokenType;\n        var spaces = \"\";\n        while(tokens.length){\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== \"space\") break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    };\n    _proto.stringFrom = function stringFrom(tokens, from) {\n        var result2 = \"\";\n        for(var i2 = from; i2 < tokens.length; i2++){\n            result2 += tokens[i2][1];\n        }\n        tokens.splice(from, tokens.length - from);\n        return result2;\n    };\n    _proto.unclosedBlock = function unclosedBlock() {\n        var pos = this.current.source.start;\n        throw this.input.error(\"Unclosed block\", pos.line, pos.column);\n    };\n    _proto.unclosedBracket = function unclosedBracket(bracket) {\n        throw this.input.error(\"Unclosed bracket\", {\n            offset: bracket[2]\n        }, {\n            offset: bracket[2] + 1\n        });\n    };\n    _proto.unexpectedClose = function unexpectedClose(token) {\n        throw this.input.error(\"Unexpected }\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + 1\n        });\n    };\n    _proto.unknownWord = function unknownWord(tokens) {\n        throw this.input.error(\"Unknown word\", {\n            offset: tokens[0][2]\n        }, {\n            offset: tokens[0][2] + tokens[0][1].length\n        });\n    };\n    _proto.unnamedAtrule = function unnamedAtrule(node2, token) {\n        throw this.input.error(\"At-rule without name\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + token[1].length\n        });\n    };\n    return Parser;\n}();\nvar parser$1 = Parser$1$1;\nvar Container$2$1 = container$1;\nvar Parser2$1 = parser$1;\nvar Input$2$1 = input$1;\nfunction parse$3$1(css, opts) {\n    var input2 = new Input$2$1(css, opts);\n    var parser2 = new Parser2$1(input2);\n    try {\n        parser2.parse();\n    } catch (e2) {\n        if (true) {\n            if (e2.name === \"CssSyntaxError\" && opts && opts.from) {\n                if (/\\.scss$/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser\";\n                } else if (/\\.sass/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser\";\n                } else if (/\\.less$/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser\";\n                }\n            }\n        }\n        throw e2;\n    }\n    return parser2.root;\n}\nvar parse_1$1 = parse$3$1;\nparse$3$1.default = parse$3$1;\nContainer$2$1.registerParse(parse$3$1);\nvar isClean$3 = symbols$1.isClean, my$3 = symbols$1.my;\nvar MapGenerator$1$1 = mapGenerator$1;\nvar stringify$2$1 = stringify_1$1;\nvar Container$1$1 = container$1;\nvar Document$2$1 = document$1$1;\nvar warnOnce$1$1 = warnOnce$2$1;\nvar Result$2$1 = result$1;\nvar parse$2$1 = parse_1$1;\nvar Root$3$1 = root$1;\nvar TYPE_TO_CLASS_NAME$1 = {\n    atrule: \"AtRule\",\n    comment: \"Comment\",\n    decl: \"Declaration\",\n    document: \"Document\",\n    root: \"Root\",\n    rule: \"Rule\"\n};\nvar PLUGIN_PROPS$1 = {\n    AtRule: true,\n    AtRuleExit: true,\n    Comment: true,\n    CommentExit: true,\n    Declaration: true,\n    DeclarationExit: true,\n    Document: true,\n    DocumentExit: true,\n    Once: true,\n    OnceExit: true,\n    postcssPlugin: true,\n    prepare: true,\n    Root: true,\n    RootExit: true,\n    Rule: true,\n    RuleExit: true\n};\nvar NOT_VISITORS$1 = {\n    Once: true,\n    postcssPlugin: true,\n    prepare: true\n};\nvar CHILDREN$1 = 0;\nfunction isPromise$1(obj) {\n    return (typeof obj === \"undefined\" ? \"undefined\" : _type_of(obj)) === \"object\" && typeof obj.then === \"function\";\n}\nfunction getEvents$1(node2) {\n    var key = false;\n    var type = TYPE_TO_CLASS_NAME$1[node2.type];\n    if (node2.type === \"decl\") {\n        key = node2.prop.toLowerCase();\n    } else if (node2.type === \"atrule\") {\n        key = node2.name.toLowerCase();\n    }\n    if (key && node2.append) {\n        return [\n            type,\n            type + \"-\" + key,\n            CHILDREN$1,\n            type + \"Exit\",\n            type + \"Exit-\" + key\n        ];\n    } else if (key) {\n        return [\n            type,\n            type + \"-\" + key,\n            type + \"Exit\",\n            type + \"Exit-\" + key\n        ];\n    } else if (node2.append) {\n        return [\n            type,\n            CHILDREN$1,\n            type + \"Exit\"\n        ];\n    } else {\n        return [\n            type,\n            type + \"Exit\"\n        ];\n    }\n}\nfunction toStack$1(node2) {\n    var events;\n    if (node2.type === \"document\") {\n        events = [\n            \"Document\",\n            CHILDREN$1,\n            \"DocumentExit\"\n        ];\n    } else if (node2.type === \"root\") {\n        events = [\n            \"Root\",\n            CHILDREN$1,\n            \"RootExit\"\n        ];\n    } else {\n        events = getEvents$1(node2);\n    }\n    return {\n        eventIndex: 0,\n        events: events,\n        iterator: 0,\n        node: node2,\n        visitorIndex: 0,\n        visitors: []\n    };\n}\nfunction cleanMarks$1(node2) {\n    node2[isClean$3] = false;\n    if (node2.nodes) node2.nodes.forEach(function(i2) {\n        return cleanMarks$1(i2);\n    });\n    return node2;\n}\nvar postcss$2$1 = {};\nvar LazyResult$2$1 = /*#__PURE__*/ function() {\n    function LazyResult(processor2, css, opts) {\n        var _this = this;\n        this.stringified = false;\n        this.processed = false;\n        var root2;\n        if ((typeof css === \"undefined\" ? \"undefined\" : _type_of(css)) === \"object\" && css !== null && (css.type === \"root\" || css.type === \"document\")) {\n            root2 = cleanMarks$1(css);\n        } else if (_instanceof(css, LazyResult) || _instanceof(css, Result$2$1)) {\n            root2 = cleanMarks$1(css.root);\n            if (css.map) {\n                if (typeof opts.map === \"undefined\") opts.map = {};\n                if (!opts.map.inline) opts.map.inline = false;\n                opts.map.prev = css.map;\n            }\n        } else {\n            var parser2 = parse$2$1;\n            if (opts.syntax) parser2 = opts.syntax.parse;\n            if (opts.parser) parser2 = opts.parser;\n            if (parser2.parse) parser2 = parser2.parse;\n            try {\n                root2 = parser2(css, opts);\n            } catch (error) {\n                this.processed = true;\n                this.error = error;\n            }\n            if (root2 && !root2[my$3]) {\n                Container$1$1.rebuild(root2);\n            }\n        }\n        this.result = new Result$2$1(processor2, root2, opts);\n        this.helpers = _extends({}, postcss$2$1, {\n            postcss: postcss$2$1,\n            result: this.result\n        });\n        this.plugins = this.processor.plugins.map(function(plugin22) {\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\" && plugin22.prepare) {\n                return _extends({}, plugin22, plugin22.prepare(_this.result));\n            } else {\n                return plugin22;\n            }\n        });\n    }\n    var _proto = LazyResult.prototype;\n    _proto.async = function async() {\n        if (this.error) return Promise.reject(this.error);\n        if (this.processed) return Promise.resolve(this.result);\n        if (!this.processing) {\n            this.processing = this.runAsync();\n        }\n        return this.processing;\n    };\n    _proto.catch = function _catch(onRejected) {\n        return this.async().catch(onRejected);\n    };\n    _proto.finally = function _finally(onFinally) {\n        return this.async().then(onFinally, onFinally);\n    };\n    _proto.getAsyncError = function getAsyncError() {\n        throw new Error(\"Use process(css).then(cb) to work with async plugins\");\n    };\n    _proto.handleError = function handleError(error, node2) {\n        var plugin22 = this.result.lastPlugin;\n        try {\n            if (node2) node2.addToError(error);\n            this.error = error;\n            if (error.name === \"CssSyntaxError\" && !error.plugin) {\n                error.plugin = plugin22.postcssPlugin;\n                error.setMessage();\n            } else if (plugin22.postcssVersion) {\n                if (true) {\n                    var pluginName = plugin22.postcssPlugin;\n                    var pluginVer = plugin22.postcssVersion;\n                    var runtimeVer = this.result.processor.version;\n                    var a2 = pluginVer.split(\".\");\n                    var b = runtimeVer.split(\".\");\n                    if (a2[0] !== b[0] || parseInt(a2[1]) > parseInt(b[1])) {\n                        console.error(\"Unknown error from PostCSS plugin. Your current PostCSS version is \" + runtimeVer + \", but \" + pluginName + \" uses \" + pluginVer + \". Perhaps this is the source of the error below.\");\n                    }\n                }\n            }\n        } catch (err) {\n            if (console && console.error) console.error(err);\n        }\n        return error;\n    };\n    _proto.prepareVisitors = function prepareVisitors() {\n        var _this = this;\n        this.listeners = {};\n        var add = function(plugin22, type, cb) {\n            if (!_this.listeners[type]) _this.listeners[type] = [];\n            _this.listeners[type].push([\n                plugin22,\n                cb\n            ]);\n        };\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.plugins), _step; !(_step = _iterator()).done;){\n            var plugin22 = _step.value;\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\") {\n                for(var event in plugin22){\n                    if (!PLUGIN_PROPS$1[event] && /^[A-Z]/.test(event)) {\n                        throw new Error(\"Unknown event \" + event + \" in \" + plugin22.postcssPlugin + \". Try to update PostCSS (\" + this.processor.version + \" now).\");\n                    }\n                    if (!NOT_VISITORS$1[event]) {\n                        if (_type_of(plugin22[event]) === \"object\") {\n                            for(var filter in plugin22[event]){\n                                if (filter === \"*\") {\n                                    add(plugin22, event, plugin22[event][filter]);\n                                } else {\n                                    add(plugin22, event + \"-\" + filter.toLowerCase(), plugin22[event][filter]);\n                                }\n                            }\n                        } else if (typeof plugin22[event] === \"function\") {\n                            add(plugin22, event, plugin22[event]);\n                        }\n                    }\n                }\n            }\n        }\n        this.hasListener = Object.keys(this.listeners).length > 0;\n    };\n    _proto.runAsync = function runAsync() {\n        var _this = this;\n        return _async_to_generator(function() {\n            var i2, plugin22, promise, error, root2, stack, promise1, e2, node2, _loop, _iterator, _step;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        _this.plugin = 0;\n                        i2 = 0;\n                        _state.label = 1;\n                    case 1:\n                        if (!(i2 < _this.plugins.length)) return [\n                            3,\n                            6\n                        ];\n                        plugin22 = _this.plugins[i2];\n                        promise = _this.runOnRoot(plugin22);\n                        if (!isPromise$1(promise)) return [\n                            3,\n                            5\n                        ];\n                        _state.label = 2;\n                    case 2:\n                        _state.trys.push([\n                            2,\n                            4,\n                            ,\n                            5\n                        ]);\n                        return [\n                            4,\n                            promise\n                        ];\n                    case 3:\n                        _state.sent();\n                        return [\n                            3,\n                            5\n                        ];\n                    case 4:\n                        error = _state.sent();\n                        throw _this.handleError(error);\n                    case 5:\n                        i2++;\n                        return [\n                            3,\n                            1\n                        ];\n                    case 6:\n                        _this.prepareVisitors();\n                        if (!_this.hasListener) return [\n                            3,\n                            18\n                        ];\n                        root2 = _this.result.root;\n                        _state.label = 7;\n                    case 7:\n                        if (!!root2[isClean$3]) return [\n                            3,\n                            14\n                        ];\n                        root2[isClean$3] = true;\n                        stack = [\n                            toStack$1(root2)\n                        ];\n                        _state.label = 8;\n                    case 8:\n                        if (!(stack.length > 0)) return [\n                            3,\n                            13\n                        ];\n                        promise1 = _this.visitTick(stack);\n                        if (!isPromise$1(promise1)) return [\n                            3,\n                            12\n                        ];\n                        _state.label = 9;\n                    case 9:\n                        _state.trys.push([\n                            9,\n                            11,\n                            ,\n                            12\n                        ]);\n                        return [\n                            4,\n                            promise1\n                        ];\n                    case 10:\n                        _state.sent();\n                        return [\n                            3,\n                            12\n                        ];\n                    case 11:\n                        e2 = _state.sent();\n                        node2 = stack[stack.length - 1].node;\n                        throw _this.handleError(e2, node2);\n                    case 12:\n                        return [\n                            3,\n                            8\n                        ];\n                    case 13:\n                        return [\n                            3,\n                            7\n                        ];\n                    case 14:\n                        if (!_this.listeners.OnceExit) return [\n                            3,\n                            18\n                        ];\n                        _loop = function() {\n                            var _step_value, plugin22, visitor, roots, e2;\n                            return _ts_generator(this, function(_state) {\n                                switch(_state.label){\n                                    case 0:\n                                        _step_value = _step.value, plugin22 = _step_value[0], visitor = _step_value[1];\n                                        _this.result.lastPlugin = plugin22;\n                                        _state.label = 1;\n                                    case 1:\n                                        _state.trys.push([\n                                            1,\n                                            6,\n                                            ,\n                                            7\n                                        ]);\n                                        if (!(root2.type === \"document\")) return [\n                                            3,\n                                            3\n                                        ];\n                                        roots = root2.nodes.map(function(subRoot) {\n                                            return visitor(subRoot, _this.helpers);\n                                        });\n                                        return [\n                                            4,\n                                            Promise.all(roots)\n                                        ];\n                                    case 2:\n                                        _state.sent();\n                                        return [\n                                            3,\n                                            5\n                                        ];\n                                    case 3:\n                                        return [\n                                            4,\n                                            visitor(root2, _this.helpers)\n                                        ];\n                                    case 4:\n                                        _state.sent();\n                                        _state.label = 5;\n                                    case 5:\n                                        return [\n                                            3,\n                                            7\n                                        ];\n                                    case 6:\n                                        e2 = _state.sent();\n                                        throw _this.handleError(e2);\n                                    case 7:\n                                        return [\n                                            2\n                                        ];\n                                }\n                            });\n                        };\n                        _iterator = _create_for_of_iterator_helper_loose(_this.listeners.OnceExit);\n                        _state.label = 15;\n                    case 15:\n                        if (!!(_step = _iterator()).done) return [\n                            3,\n                            18\n                        ];\n                        return [\n                            5,\n                            _ts_values(_loop())\n                        ];\n                    case 16:\n                        _state.sent();\n                        _state.label = 17;\n                    case 17:\n                        return [\n                            3,\n                            15\n                        ];\n                    case 18:\n                        _this.processed = true;\n                        return [\n                            2,\n                            _this.stringify()\n                        ];\n                }\n            });\n        })();\n    };\n    _proto.runOnRoot = function runOnRoot(plugin22) {\n        var _this = this;\n        this.result.lastPlugin = plugin22;\n        try {\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\" && plugin22.Once) {\n                if (this.result.root.type === \"document\") {\n                    var roots = this.result.root.nodes.map(function(root2) {\n                        return plugin22.Once(root2, _this.helpers);\n                    });\n                    if (isPromise$1(roots[0])) {\n                        return Promise.all(roots);\n                    }\n                    return roots;\n                }\n                return plugin22.Once(this.result.root, this.helpers);\n            } else if (typeof plugin22 === \"function\") {\n                return plugin22(this.result.root, this.result);\n            }\n        } catch (error) {\n            throw this.handleError(error);\n        }\n    };\n    _proto.stringify = function stringify() {\n        if (this.error) throw this.error;\n        if (this.stringified) return this.result;\n        this.stringified = true;\n        this.sync();\n        var opts = this.result.opts;\n        var str = stringify$2$1;\n        if (opts.syntax) str = opts.syntax.stringify;\n        if (opts.stringifier) str = opts.stringifier;\n        if (str.stringify) str = str.stringify;\n        var map = new MapGenerator$1$1(str, this.result.root, this.result.opts);\n        var data = map.generate();\n        this.result.css = data[0];\n        this.result.map = data[1];\n        return this.result;\n    };\n    _proto.sync = function sync() {\n        if (this.error) throw this.error;\n        if (this.processed) return this.result;\n        this.processed = true;\n        if (this.processing) {\n            throw this.getAsyncError();\n        }\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.plugins), _step; !(_step = _iterator()).done;){\n            var plugin22 = _step.value;\n            var promise = this.runOnRoot(plugin22);\n            if (isPromise$1(promise)) {\n                throw this.getAsyncError();\n            }\n        }\n        this.prepareVisitors();\n        if (this.hasListener) {\n            var root2 = this.result.root;\n            while(!root2[isClean$3]){\n                root2[isClean$3] = true;\n                this.walkSync(root2);\n            }\n            if (this.listeners.OnceExit) {\n                if (root2.type === \"document\") {\n                    for(var _iterator1 = _create_for_of_iterator_helper_loose(root2.nodes), _step1; !(_step1 = _iterator1()).done;){\n                        var subRoot = _step1.value;\n                        this.visitSync(this.listeners.OnceExit, subRoot);\n                    }\n                } else {\n                    this.visitSync(this.listeners.OnceExit, root2);\n                }\n            }\n        }\n        return this.result;\n    };\n    _proto.then = function then(onFulfilled, onRejected) {\n        if (true) {\n            if (!(\"from\" in this.opts)) {\n                warnOnce$1$1(\"Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.\");\n            }\n        }\n        return this.async().then(onFulfilled, onRejected);\n    };\n    _proto.toString = function toString() {\n        return this.css;\n    };\n    _proto.visitSync = function visitSync(visitors, node2) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(visitors), _step; !(_step = _iterator()).done;){\n            var _step_value = _step.value, plugin22 = _step_value[0], visitor = _step_value[1];\n            this.result.lastPlugin = plugin22;\n            var promise = void 0;\n            try {\n                promise = visitor(node2, this.helpers);\n            } catch (e2) {\n                throw this.handleError(e2, node2.proxyOf);\n            }\n            if (node2.type !== \"root\" && node2.type !== \"document\" && !node2.parent) {\n                return true;\n            }\n            if (isPromise$1(promise)) {\n                throw this.getAsyncError();\n            }\n        }\n    };\n    _proto.visitTick = function visitTick(stack) {\n        var visit2 = stack[stack.length - 1];\n        var node2 = visit2.node, visitors = visit2.visitors;\n        if (node2.type !== \"root\" && node2.type !== \"document\" && !node2.parent) {\n            stack.pop();\n            return;\n        }\n        if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {\n            var _visitors_visit2_visitorIndex = visitors[visit2.visitorIndex], plugin22 = _visitors_visit2_visitorIndex[0], visitor = _visitors_visit2_visitorIndex[1];\n            visit2.visitorIndex += 1;\n            if (visit2.visitorIndex === visitors.length) {\n                visit2.visitors = [];\n                visit2.visitorIndex = 0;\n            }\n            this.result.lastPlugin = plugin22;\n            try {\n                return visitor(node2.toProxy(), this.helpers);\n            } catch (e2) {\n                throw this.handleError(e2, node2);\n            }\n        }\n        if (visit2.iterator !== 0) {\n            var iterator = visit2.iterator;\n            var child;\n            while(child = node2.nodes[node2.indexes[iterator]]){\n                node2.indexes[iterator] += 1;\n                if (!child[isClean$3]) {\n                    child[isClean$3] = true;\n                    stack.push(toStack$1(child));\n                    return;\n                }\n            }\n            visit2.iterator = 0;\n            delete node2.indexes[iterator];\n        }\n        var events = visit2.events;\n        while(visit2.eventIndex < events.length){\n            var event = events[visit2.eventIndex];\n            visit2.eventIndex += 1;\n            if (event === CHILDREN$1) {\n                if (node2.nodes && node2.nodes.length) {\n                    node2[isClean$3] = true;\n                    visit2.iterator = node2.getIterator();\n                }\n                return;\n            } else if (this.listeners[event]) {\n                visit2.visitors = this.listeners[event];\n                return;\n            }\n        }\n        stack.pop();\n    };\n    _proto.walkSync = function walkSync(node2) {\n        var _this = this;\n        node2[isClean$3] = true;\n        var events = getEvents$1(node2);\n        for(var _iterator = _create_for_of_iterator_helper_loose(events), _step; !(_step = _iterator()).done;){\n            var event = _step.value;\n            if (event === CHILDREN$1) {\n                if (node2.nodes) {\n                    node2.each(function(child) {\n                        if (!child[isClean$3]) _this.walkSync(child);\n                    });\n                }\n            } else {\n                var visitors = this.listeners[event];\n                if (visitors) {\n                    if (this.visitSync(visitors, node2.toProxy())) return;\n                }\n            }\n        }\n    };\n    _proto.warnings = function warnings() {\n        return this.sync().warnings();\n    };\n    _create_class(LazyResult, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.stringify().content;\n            }\n        },\n        {\n            key: \"css\",\n            get: function get() {\n                return this.stringify().css;\n            }\n        },\n        {\n            key: \"map\",\n            get: function get() {\n                return this.stringify().map;\n            }\n        },\n        {\n            key: \"messages\",\n            get: function get() {\n                return this.sync().messages;\n            }\n        },\n        {\n            key: \"opts\",\n            get: function get() {\n                return this.result.opts;\n            }\n        },\n        {\n            key: \"processor\",\n            get: function get() {\n                return this.result.processor;\n            }\n        },\n        {\n            key: \"root\",\n            get: function get() {\n                return this.sync().root;\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"LazyResult\";\n            }\n        }\n    ]);\n    return LazyResult;\n}();\nLazyResult$2$1.registerPostcss = function(dependant) {\n    postcss$2$1 = dependant;\n};\nvar lazyResult$1 = LazyResult$2$1;\nLazyResult$2$1.default = LazyResult$2$1;\nRoot$3$1.registerLazyResult(LazyResult$2$1);\nDocument$2$1.registerLazyResult(LazyResult$2$1);\nvar MapGenerator2$1 = mapGenerator$1;\nvar stringify$1$1 = stringify_1$1;\nvar warnOnce2$1 = warnOnce$2$1;\nvar parse$1$1 = parse_1$1;\nvar Result$1$1 = result$1;\nvar NoWorkResult$1$1 = /*#__PURE__*/ function() {\n    function NoWorkResult(processor2, css, opts) {\n        css = css.toString();\n        this.stringified = false;\n        this._processor = processor2;\n        this._css = css;\n        this._opts = opts;\n        this._map = void 0;\n        var root2;\n        var str = stringify$1$1;\n        this.result = new Result$1$1(this._processor, root2, this._opts);\n        this.result.css = css;\n        var self = this;\n        Object.defineProperty(this.result, \"root\", {\n            get: function get() {\n                return self.root;\n            }\n        });\n        var map = new MapGenerator2$1(str, root2, this._opts, css);\n        if (map.isMap()) {\n            var _map_generate = map.generate(), generatedCSS = _map_generate[0], generatedMap = _map_generate[1];\n            if (generatedCSS) {\n                this.result.css = generatedCSS;\n            }\n            if (generatedMap) {\n                this.result.map = generatedMap;\n            }\n        } else {\n            map.clearAnnotation();\n            this.result.css = map.css;\n        }\n    }\n    var _proto = NoWorkResult.prototype;\n    _proto.async = function async() {\n        if (this.error) return Promise.reject(this.error);\n        return Promise.resolve(this.result);\n    };\n    _proto.catch = function _catch(onRejected) {\n        return this.async().catch(onRejected);\n    };\n    _proto.finally = function _finally(onFinally) {\n        return this.async().then(onFinally, onFinally);\n    };\n    _proto.sync = function sync() {\n        if (this.error) throw this.error;\n        return this.result;\n    };\n    _proto.then = function then(onFulfilled, onRejected) {\n        if (true) {\n            if (!(\"from\" in this._opts)) {\n                warnOnce2$1(\"Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.\");\n            }\n        }\n        return this.async().then(onFulfilled, onRejected);\n    };\n    _proto.toString = function toString() {\n        return this._css;\n    };\n    _proto.warnings = function warnings() {\n        return [];\n    };\n    _create_class(NoWorkResult, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.result.css;\n            }\n        },\n        {\n            key: \"css\",\n            get: function get() {\n                return this.result.css;\n            }\n        },\n        {\n            key: \"map\",\n            get: function get() {\n                return this.result.map;\n            }\n        },\n        {\n            key: \"messages\",\n            get: function get() {\n                return [];\n            }\n        },\n        {\n            key: \"opts\",\n            get: function get() {\n                return this.result.opts;\n            }\n        },\n        {\n            key: \"processor\",\n            get: function get() {\n                return this.result.processor;\n            }\n        },\n        {\n            key: \"root\",\n            get: function get() {\n                if (this._root) {\n                    return this._root;\n                }\n                var root2;\n                var parser2 = parse$1$1;\n                try {\n                    root2 = parser2(this._css, this._opts);\n                } catch (error) {\n                    this.error = error;\n                }\n                if (this.error) {\n                    throw this.error;\n                } else {\n                    this._root = root2;\n                    return root2;\n                }\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"NoWorkResult\";\n            }\n        }\n    ]);\n    return NoWorkResult;\n}();\nvar noWorkResult$1 = NoWorkResult$1$1;\nNoWorkResult$1$1.default = NoWorkResult$1$1;\nvar NoWorkResult2$1 = noWorkResult$1;\nvar LazyResult$1$1 = lazyResult$1;\nvar Document$1$1 = document$1$1;\nvar Root$2$1 = root$1;\nvar Processor$1$1 = /*#__PURE__*/ function() {\n    function Processor(plugins) {\n        if (plugins === void 0) plugins = [];\n        this.version = \"8.4.38\";\n        this.plugins = this.normalize(plugins);\n    }\n    var _proto = Processor.prototype;\n    _proto.normalize = function normalize(plugins) {\n        var normalized = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(plugins), _step; !(_step = _iterator()).done;){\n            var i2 = _step.value;\n            if (i2.postcss === true) {\n                i2 = i2();\n            } else if (i2.postcss) {\n                i2 = i2.postcss;\n            }\n            if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && Array.isArray(i2.plugins)) {\n                normalized = normalized.concat(i2.plugins);\n            } else if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && i2.postcssPlugin) {\n                normalized.push(i2);\n            } else if (typeof i2 === \"function\") {\n                normalized.push(i2);\n            } else if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && (i2.parse || i2.stringify)) {\n                if (true) {\n                    throw new Error(\"PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.\");\n                }\n            } else {\n                throw new Error(i2 + \" is not a PostCSS plugin\");\n            }\n        }\n        return normalized;\n    };\n    _proto.process = function process1(css, opts) {\n        if (opts === void 0) opts = {};\n        if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {\n            return new NoWorkResult2$1(this, css, opts);\n        } else {\n            return new LazyResult$1$1(this, css, opts);\n        }\n    };\n    _proto.use = function use(plugin22) {\n        this.plugins = this.plugins.concat(this.normalize([\n            plugin22\n        ]));\n        return this;\n    };\n    return Processor;\n}();\nvar processor$1 = Processor$1$1;\nProcessor$1$1.default = Processor$1$1;\nRoot$2$1.registerProcessor(Processor$1$1);\nDocument$1$1.registerProcessor(Processor$1$1);\nvar Declaration$1$1 = declaration$1;\nvar PreviousMap2$1 = previousMap$1;\nvar Comment$1$1 = comment$1;\nvar AtRule$1$1 = atRule$1;\nvar Input$1$1 = input$1;\nvar Root$1$1 = root$1;\nvar Rule$1$1 = rule$1;\nfunction fromJSON$1$1(json, inputs) {\n    if (Array.isArray(json)) return json.map(function(n2) {\n        return fromJSON$1$1(n2);\n    });\n    var ownInputs = json.inputs, defaults = _object_without_properties_loose(json, [\n        \"inputs\"\n    ]);\n    if (ownInputs) {\n        inputs = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(ownInputs), _step; !(_step = _iterator()).done;){\n            var input2 = _step.value;\n            var inputHydrated = _extends({}, input2, {\n                __proto__: Input$1$1.prototype\n            });\n            if (inputHydrated.map) {\n                inputHydrated.map = _extends({}, inputHydrated.map, {\n                    __proto__: PreviousMap2$1.prototype\n                });\n            }\n            inputs.push(inputHydrated);\n        }\n    }\n    if (defaults.nodes) {\n        defaults.nodes = json.nodes.map(function(n2) {\n            return fromJSON$1$1(n2, inputs);\n        });\n    }\n    if (defaults.source) {\n        var _defaults_source = defaults.source, inputId = _defaults_source.inputId, source = _object_without_properties_loose(_defaults_source, [\n            \"inputId\"\n        ]);\n        defaults.source = source;\n        if (inputId != null) {\n            defaults.source.input = inputs[inputId];\n        }\n    }\n    if (defaults.type === \"root\") {\n        return new Root$1$1(defaults);\n    } else if (defaults.type === \"decl\") {\n        return new Declaration$1$1(defaults);\n    } else if (defaults.type === \"rule\") {\n        return new Rule$1$1(defaults);\n    } else if (defaults.type === \"comment\") {\n        return new Comment$1$1(defaults);\n    } else if (defaults.type === \"atrule\") {\n        return new AtRule$1$1(defaults);\n    } else {\n        throw new Error(\"Unknown node type: \" + json.type);\n    }\n}\nvar fromJSON_1$1 = fromJSON$1$1;\nfromJSON$1$1.default = fromJSON$1$1;\nvar CssSyntaxError2$1 = cssSyntaxError$1;\nvar Declaration2$1 = declaration$1;\nvar LazyResult2$1 = lazyResult$1;\nvar Container2$1 = container$1;\nvar Processor2$1 = processor$1;\nvar stringify$5 = stringify_1$1;\nvar fromJSON$2 = fromJSON_1$1;\nvar Document22 = document$1$1;\nvar Warning2$1 = warning$1;\nvar Comment2$1 = comment$1;\nvar AtRule2$1 = atRule$1;\nvar Result2$1 = result$1;\nvar Input2$1 = input$1;\nvar parse$5 = parse_1$1;\nvar list$3 = list_1$1;\nvar Rule2$1 = rule$1;\nvar Root2$1 = root$1;\nvar Node2$1 = node$1;\nfunction postcss$3() {\n    for(var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++){\n        plugins[_key] = arguments[_key];\n    }\n    if (plugins.length === 1 && Array.isArray(plugins[0])) {\n        plugins = plugins[0];\n    }\n    return new Processor2$1(plugins);\n}\npostcss$3.plugin = function plugin(name, initializer) {\n    var warningPrinted = false;\n    function creator() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (console && console.warn && !warningPrinted) {\n            warningPrinted = true;\n            console.warn(name + \": postcss.plugin was deprecated. Migration guide:\\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration\");\n            if (process.env.LANG && process.env.LANG.startsWith(\"cn\")) {\n                console.warn(name + \":  postcss.plugin . :\\nhttps://www.w3ctech.com/topic/2226\");\n            }\n        }\n        var transformer = initializer.apply(void 0, [].concat(args));\n        transformer.postcssPlugin = name;\n        transformer.postcssVersion = new Processor2$1().version;\n        return transformer;\n    }\n    var cache;\n    Object.defineProperty(creator, \"postcss\", {\n        get: function get() {\n            if (!cache) cache = creator();\n            return cache;\n        }\n    });\n    creator.process = function(css, processOpts, pluginOpts) {\n        return postcss$3([\n            creator(pluginOpts)\n        ]).process(css, processOpts);\n    };\n    return creator;\n};\npostcss$3.stringify = stringify$5;\npostcss$3.parse = parse$5;\npostcss$3.fromJSON = fromJSON$2;\npostcss$3.list = list$3;\npostcss$3.comment = function(defaults) {\n    return new Comment2$1(defaults);\n};\npostcss$3.atRule = function(defaults) {\n    return new AtRule2$1(defaults);\n};\npostcss$3.decl = function(defaults) {\n    return new Declaration2$1(defaults);\n};\npostcss$3.rule = function(defaults) {\n    return new Rule2$1(defaults);\n};\npostcss$3.root = function(defaults) {\n    return new Root2$1(defaults);\n};\npostcss$3.document = function(defaults) {\n    return new Document22(defaults);\n};\npostcss$3.CssSyntaxError = CssSyntaxError2$1;\npostcss$3.Declaration = Declaration2$1;\npostcss$3.Container = Container2$1;\npostcss$3.Processor = Processor2$1;\npostcss$3.Document = Document22;\npostcss$3.Comment = Comment2$1;\npostcss$3.Warning = Warning2$1;\npostcss$3.AtRule = AtRule2$1;\npostcss$3.Result = Result2$1;\npostcss$3.Input = Input2$1;\npostcss$3.Rule = Rule2$1;\npostcss$3.Root = Root2$1;\npostcss$3.Node = Node2$1;\nLazyResult2$1.registerPostcss(postcss$3);\nvar postcss_1$1 = postcss$3;\npostcss$3.default = postcss$3;\nvar postcss$1$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(postcss_1$1);\npostcss$1$1.stringify;\npostcss$1$1.fromJSON;\npostcss$1$1.plugin;\npostcss$1$1.parse;\npostcss$1$1.list;\npostcss$1$1.document;\npostcss$1$1.comment;\npostcss$1$1.atRule;\npostcss$1$1.rule;\npostcss$1$1.decl;\npostcss$1$1.root;\npostcss$1$1.CssSyntaxError;\npostcss$1$1.Declaration;\npostcss$1$1.Container;\npostcss$1$1.Processor;\npostcss$1$1.Document;\npostcss$1$1.Comment;\npostcss$1$1.Warning;\npostcss$1$1.AtRule;\npostcss$1$1.Result;\npostcss$1$1.Input;\npostcss$1$1.Rule;\npostcss$1$1.Root;\npostcss$1$1.Node;\nvar __defProp2 = Object.defineProperty;\nvar __defNormalProp2 = function(obj, key, value) {\n    return key in obj ? __defProp2(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: value\n    }) : obj[key] = value;\n};\nvar __publicField2 = function(obj, key, value) {\n    return __defNormalProp2(obj, (typeof key === \"undefined\" ? \"undefined\" : _type_of(key)) !== \"symbol\" ? key + \"\" : key, value);\n};\nfunction getDefaultExportFromCjs(x2) {\n    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, \"default\") ? x2[\"default\"] : x2;\n}\nfunction getAugmentedNamespace(n2) {\n    if (n2.__esModule) return n2;\n    var f2 = n2.default;\n    if (typeof f2 == \"function\") {\n        var a2 = function a22() {\n            if (_instanceof(this, a22)) {\n                return Reflect.construct(f2, arguments, this.constructor);\n            }\n            return f2.apply(this, arguments);\n        };\n        a2.prototype = f2.prototype;\n    } else a2 = {};\n    Object.defineProperty(a2, \"__esModule\", {\n        value: true\n    });\n    Object.keys(n2).forEach(function(k) {\n        var d = Object.getOwnPropertyDescriptor(n2, k);\n        Object.defineProperty(a2, k, d.get ? d : {\n            enumerable: true,\n            get: function get() {\n                return n2[k];\n            }\n        });\n    });\n    return a2;\n}\nvar picocolors_browser = {\n    exports: {}\n};\nvar x = String;\nvar create = function create() {\n    return {\n        isColorSupported: false,\n        reset: x,\n        bold: x,\n        dim: x,\n        italic: x,\n        underline: x,\n        inverse: x,\n        hidden: x,\n        strikethrough: x,\n        black: x,\n        red: x,\n        green: x,\n        yellow: x,\n        blue: x,\n        magenta: x,\n        cyan: x,\n        white: x,\n        gray: x,\n        bgBlack: x,\n        bgRed: x,\n        bgGreen: x,\n        bgYellow: x,\n        bgBlue: x,\n        bgMagenta: x,\n        bgCyan: x,\n        bgWhite: x\n    };\n};\npicocolors_browser.exports = create();\npicocolors_browser.exports.createColors = create;\nvar picocolors_browserExports = picocolors_browser.exports;\nvar __viteBrowserExternal = {};\nvar __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n    __proto__: null,\n    default: __viteBrowserExternal\n}, Symbol.toStringTag, {\n    value: \"Module\"\n}));\nvar require$$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);\nvar pico = picocolors_browserExports;\nvar terminalHighlight$1 = require$$2;\nvar CssSyntaxError$3 = /*#__PURE__*/ function(Error1) {\n    _inherits(CssSyntaxError2, Error1);\n    function CssSyntaxError2(message, line, column, source, file, plugin22) {\n        var _this;\n        _this = Error1.call(this, message) || this;\n        _this.name = \"CssSyntaxError\";\n        _this.reason = message;\n        if (file) {\n            _this.file = file;\n        }\n        if (source) {\n            _this.source = source;\n        }\n        if (plugin22) {\n            _this.plugin = plugin22;\n        }\n        if (typeof line !== \"undefined\" && typeof column !== \"undefined\") {\n            if (typeof line === \"number\") {\n                _this.line = line;\n                _this.column = column;\n            } else {\n                _this.line = line.line;\n                _this.column = line.column;\n                _this.endLine = column.line;\n                _this.endColumn = column.column;\n            }\n        }\n        _this.setMessage();\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(_this, CssSyntaxError2);\n        }\n        return _this;\n    }\n    var _proto = CssSyntaxError2.prototype;\n    _proto.setMessage = function setMessage() {\n        this.message = this.plugin ? this.plugin + \": \" : \"\";\n        this.message += this.file ? this.file : \"<css input>\";\n        if (typeof this.line !== \"undefined\") {\n            this.message += \":\" + this.line + \":\" + this.column;\n        }\n        this.message += \": \" + this.reason;\n    };\n    _proto.showSourceCode = function showSourceCode(color) {\n        var _this = this;\n        if (!this.source) return \"\";\n        var css = this.source;\n        if (color == null) color = pico.isColorSupported;\n        if (terminalHighlight$1) {\n            if (color) css = terminalHighlight$1(css);\n        }\n        var lines = css.split(/\\r?\\n/);\n        var start = Math.max(this.line - 3, 0);\n        var end = Math.min(this.line + 2, lines.length);\n        var maxWidth = String(end).length;\n        var mark, aside;\n        if (color) {\n            var _pico_createColors = pico.createColors(true), bold = _pico_createColors.bold, gray = _pico_createColors.gray, red = _pico_createColors.red;\n            mark = function(text) {\n                return bold(red(text));\n            };\n            aside = function(text) {\n                return gray(text);\n            };\n        } else {\n            mark = aside = function(str) {\n                return str;\n            };\n        }\n        return lines.slice(start, end).map(function(line, index2) {\n            var number = start + 1 + index2;\n            var gutter = \" \" + (\" \" + number).slice(-maxWidth) + \" | \";\n            if (number === _this.line) {\n                var spacing = aside(gutter.replace(/\\d/g, \" \")) + line.slice(0, _this.column - 1).replace(/[^\\t]/g, \" \");\n                return mark(\">\") + aside(gutter) + line + \"\\n \" + spacing + mark(\"^\");\n            }\n            return \" \" + aside(gutter) + line;\n        }).join(\"\\n\");\n    };\n    _proto.toString = function toString() {\n        var code = this.showSourceCode();\n        if (code) {\n            code = \"\\n\\n\" + code + \"\\n\";\n        }\n        return this.name + \": \" + this.message + code;\n    };\n    return CssSyntaxError2;\n}(_wrap_native_super(Error));\nvar cssSyntaxError = CssSyntaxError$3;\nCssSyntaxError$3.default = CssSyntaxError$3;\nvar symbols = {};\nsymbols.isClean = Symbol(\"isClean\");\nsymbols.my = Symbol(\"my\");\nvar DEFAULT_RAW = {\n    after: \"\\n\",\n    beforeClose: \"\\n\",\n    beforeComment: \"\\n\",\n    beforeDecl: \"\\n\",\n    beforeOpen: \" \",\n    beforeRule: \"\\n\",\n    colon: \": \",\n    commentLeft: \" \",\n    commentRight: \" \",\n    emptyBody: \"\",\n    indent: \"    \",\n    semicolon: false\n};\nfunction capitalize(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\nvar Stringifier$2 = /*#__PURE__*/ function() {\n    function Stringifier2(builder) {\n        this.builder = builder;\n    }\n    var _proto = Stringifier2.prototype;\n    _proto.atrule = function atrule(node2, semicolon) {\n        var name = \"@\" + node2.name;\n        var params = node2.params ? this.rawValue(node2, \"params\") : \"\";\n        if (typeof node2.raws.afterName !== \"undefined\") {\n            name += node2.raws.afterName;\n        } else if (params) {\n            name += \" \";\n        }\n        if (node2.nodes) {\n            this.block(node2, name + params);\n        } else {\n            var end = (node2.raws.between || \"\") + (semicolon ? \";\" : \"\");\n            this.builder(name + params + end, node2);\n        }\n    };\n    _proto.beforeAfter = function beforeAfter(node2, detect) {\n        var value;\n        if (node2.type === \"decl\") {\n            value = this.raw(node2, null, \"beforeDecl\");\n        } else if (node2.type === \"comment\") {\n            value = this.raw(node2, null, \"beforeComment\");\n        } else if (detect === \"before\") {\n            value = this.raw(node2, null, \"beforeRule\");\n        } else {\n            value = this.raw(node2, null, \"beforeClose\");\n        }\n        var buf = node2.parent;\n        var depth = 0;\n        while(buf && buf.type !== \"root\"){\n            depth += 1;\n            buf = buf.parent;\n        }\n        if (value.includes(\"\\n\")) {\n            var indent = this.raw(node2, null, \"indent\");\n            if (indent.length) {\n                for(var step = 0; step < depth; step++)value += indent;\n            }\n        }\n        return value;\n    };\n    _proto.block = function block(node2, start) {\n        var between = this.raw(node2, \"between\", \"beforeOpen\");\n        this.builder(start + between + \"{\", node2, \"start\");\n        var after;\n        if (node2.nodes && node2.nodes.length) {\n            this.body(node2);\n            after = this.raw(node2, \"after\");\n        } else {\n            after = this.raw(node2, \"after\", \"emptyBody\");\n        }\n        if (after) this.builder(after);\n        this.builder(\"}\", node2, \"end\");\n    };\n    _proto.body = function body(node2) {\n        var last = node2.nodes.length - 1;\n        while(last > 0){\n            if (node2.nodes[last].type !== \"comment\") break;\n            last -= 1;\n        }\n        var semicolon = this.raw(node2, \"semicolon\");\n        for(var i2 = 0; i2 < node2.nodes.length; i2++){\n            var child = node2.nodes[i2];\n            var before = this.raw(child, \"before\");\n            if (before) this.builder(before);\n            this.stringify(child, last !== i2 || semicolon);\n        }\n    };\n    _proto.comment = function comment(node2) {\n        var left = this.raw(node2, \"left\", \"commentLeft\");\n        var right = this.raw(node2, \"right\", \"commentRight\");\n        this.builder(\"/*\" + left + node2.text + right + \"*/\", node2);\n    };\n    _proto.decl = function decl(node2, semicolon) {\n        var between = this.raw(node2, \"between\", \"colon\");\n        var string = node2.prop + between + this.rawValue(node2, \"value\");\n        if (node2.important) {\n            string += node2.raws.important || \" !important\";\n        }\n        if (semicolon) string += \";\";\n        this.builder(string, node2);\n    };\n    _proto.document = function document1(node2) {\n        this.body(node2);\n    };\n    _proto.raw = function raw(node2, own, detect) {\n        var value;\n        if (!detect) detect = own;\n        if (own) {\n            value = node2.raws[own];\n            if (typeof value !== \"undefined\") return value;\n        }\n        var parent = node2.parent;\n        if (detect === \"before\") {\n            if (!parent || parent.type === \"root\" && parent.first === node2) {\n                return \"\";\n            }\n            if (parent && parent.type === \"document\") {\n                return \"\";\n            }\n        }\n        if (!parent) return DEFAULT_RAW[detect];\n        var root2 = node2.root();\n        if (!root2.rawCache) root2.rawCache = {};\n        if (typeof root2.rawCache[detect] !== \"undefined\") {\n            return root2.rawCache[detect];\n        }\n        if (detect === \"before\" || detect === \"after\") {\n            return this.beforeAfter(node2, detect);\n        } else {\n            var method = \"raw\" + capitalize(detect);\n            if (this[method]) {\n                value = this[method](root2, node2);\n            } else {\n                root2.walk(function(i2) {\n                    value = i2.raws[own];\n                    if (typeof value !== \"undefined\") return false;\n                });\n            }\n        }\n        if (typeof value === \"undefined\") value = DEFAULT_RAW[detect];\n        root2.rawCache[detect] = value;\n        return value;\n    };\n    _proto.rawBeforeClose = function rawBeforeClose(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length > 0) {\n                if (typeof i2.raws.after !== \"undefined\") {\n                    value = i2.raws.after;\n                    if (value.includes(\"\\n\")) {\n                        value = value.replace(/[^\\n]+$/, \"\");\n                    }\n                    return false;\n                }\n            }\n        });\n        if (value) value = value.replace(/\\S/g, \"\");\n        return value;\n    };\n    _proto.rawBeforeComment = function rawBeforeComment(root2, node2) {\n        var value;\n        root2.walkComments(function(i2) {\n            if (typeof i2.raws.before !== \"undefined\") {\n                value = i2.raws.before;\n                if (value.includes(\"\\n\")) {\n                    value = value.replace(/[^\\n]+$/, \"\");\n                }\n                return false;\n            }\n        });\n        if (typeof value === \"undefined\") {\n            value = this.raw(node2, null, \"beforeDecl\");\n        } else if (value) {\n            value = value.replace(/\\S/g, \"\");\n        }\n        return value;\n    };\n    _proto.rawBeforeDecl = function rawBeforeDecl(root2, node2) {\n        var value;\n        root2.walkDecls(function(i2) {\n            if (typeof i2.raws.before !== \"undefined\") {\n                value = i2.raws.before;\n                if (value.includes(\"\\n\")) {\n                    value = value.replace(/[^\\n]+$/, \"\");\n                }\n                return false;\n            }\n        });\n        if (typeof value === \"undefined\") {\n            value = this.raw(node2, null, \"beforeRule\");\n        } else if (value) {\n            value = value.replace(/\\S/g, \"\");\n        }\n        return value;\n    };\n    _proto.rawBeforeOpen = function rawBeforeOpen(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.type !== \"decl\") {\n                value = i2.raws.between;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawBeforeRule = function rawBeforeRule(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && (i2.parent !== root2 || root2.first !== i2)) {\n                if (typeof i2.raws.before !== \"undefined\") {\n                    value = i2.raws.before;\n                    if (value.includes(\"\\n\")) {\n                        value = value.replace(/[^\\n]+$/, \"\");\n                    }\n                    return false;\n                }\n            }\n        });\n        if (value) value = value.replace(/\\S/g, \"\");\n        return value;\n    };\n    _proto.rawColon = function rawColon(root2) {\n        var value;\n        root2.walkDecls(function(i2) {\n            if (typeof i2.raws.between !== \"undefined\") {\n                value = i2.raws.between.replace(/[^\\s:]/g, \"\");\n                return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawEmptyBody = function rawEmptyBody(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length === 0) {\n                value = i2.raws.after;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawIndent = function rawIndent(root2) {\n        if (root2.raws.indent) return root2.raws.indent;\n        var value;\n        root2.walk(function(i2) {\n            var p = i2.parent;\n            if (p && p !== root2 && p.parent && p.parent === root2) {\n                if (typeof i2.raws.before !== \"undefined\") {\n                    var parts = i2.raws.before.split(\"\\n\");\n                    value = parts[parts.length - 1];\n                    value = value.replace(/\\S/g, \"\");\n                    return false;\n                }\n            }\n        });\n        return value;\n    };\n    _proto.rawSemicolon = function rawSemicolon(root2) {\n        var value;\n        root2.walk(function(i2) {\n            if (i2.nodes && i2.nodes.length && i2.last.type === \"decl\") {\n                value = i2.raws.semicolon;\n                if (typeof value !== \"undefined\") return false;\n            }\n        });\n        return value;\n    };\n    _proto.rawValue = function rawValue(node2, prop) {\n        var value = node2[prop];\n        var raw = node2.raws[prop];\n        if (raw && raw.value === value) {\n            return raw.raw;\n        }\n        return value;\n    };\n    _proto.root = function root(node2) {\n        this.body(node2);\n        if (node2.raws.after) this.builder(node2.raws.after);\n    };\n    _proto.rule = function rule(node2) {\n        this.block(node2, this.rawValue(node2, \"selector\"));\n        if (node2.raws.ownSemicolon) {\n            this.builder(node2.raws.ownSemicolon, node2, \"end\");\n        }\n    };\n    _proto.stringify = function stringify(node2, semicolon) {\n        if (!this[node2.type]) {\n            throw new Error(\"Unknown AST node type \" + node2.type + \". Maybe you need to change PostCSS stringifier.\");\n        }\n        this[node2.type](node2, semicolon);\n    };\n    return Stringifier2;\n}();\nvar stringifier = Stringifier$2;\nStringifier$2.default = Stringifier$2;\nvar Stringifier$1 = stringifier;\nfunction stringify$4(node2, builder) {\n    var str = new Stringifier$1(builder);\n    str.stringify(node2);\n}\nvar stringify_1 = stringify$4;\nstringify$4.default = stringify$4;\nvar isClean$2 = symbols.isClean, my$2 = symbols.my;\nvar CssSyntaxError$2 = cssSyntaxError;\nvar Stringifier22 = stringifier;\nvar stringify$3 = stringify_1;\nfunction cloneNode(obj, parent) {\n    var cloned = new obj.constructor();\n    for(var i2 in obj){\n        if (!Object.prototype.hasOwnProperty.call(obj, i2)) {\n            continue;\n        }\n        if (i2 === \"proxyCache\") continue;\n        var value = obj[i2];\n        var type = typeof value === \"undefined\" ? \"undefined\" : _type_of(value);\n        if (i2 === \"parent\" && type === \"object\") {\n            if (parent) cloned[i2] = parent;\n        } else if (i2 === \"source\") {\n            cloned[i2] = value;\n        } else if (Array.isArray(value)) {\n            cloned[i2] = value.map(function(j) {\n                return cloneNode(j, cloned);\n            });\n        } else {\n            if (type === \"object\" && value !== null) value = cloneNode(value);\n            cloned[i2] = value;\n        }\n    }\n    return cloned;\n}\nvar Node$4 = /*#__PURE__*/ function() {\n    function Node3(defaults) {\n        if (defaults === void 0) defaults = {};\n        this.raws = {};\n        this[isClean$2] = false;\n        this[my$2] = true;\n        for(var name in defaults){\n            if (name === \"nodes\") {\n                this.nodes = [];\n                for(var _iterator = _create_for_of_iterator_helper_loose(defaults[name]), _step; !(_step = _iterator()).done;){\n                    var node2 = _step.value;\n                    if (typeof node2.clone === \"function\") {\n                        this.append(node2.clone());\n                    } else {\n                        this.append(node2);\n                    }\n                }\n            } else {\n                this[name] = defaults[name];\n            }\n        }\n    }\n    var _proto = Node3.prototype;\n    _proto.addToError = function addToError(error) {\n        error.postcssNode = this;\n        if (error.stack && this.source && /\\n\\s{4}at /.test(error.stack)) {\n            var s2 = this.source;\n            error.stack = error.stack.replace(/\\n\\s{4}at /, \"$&\" + s2.input.from + \":\" + s2.start.line + \":\" + s2.start.column + \"$&\");\n        }\n        return error;\n    };\n    _proto.after = function after(add) {\n        this.parent.insertAfter(this, add);\n        return this;\n    };\n    _proto.assign = function assign(overrides) {\n        if (overrides === void 0) overrides = {};\n        for(var name in overrides){\n            this[name] = overrides[name];\n        }\n        return this;\n    };\n    _proto.before = function before(add) {\n        this.parent.insertBefore(this, add);\n        return this;\n    };\n    _proto.cleanRaws = function cleanRaws(keepBetween) {\n        delete this.raws.before;\n        delete this.raws.after;\n        if (!keepBetween) delete this.raws.between;\n    };\n    _proto.clone = function clone(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = cloneNode(this);\n        for(var name in overrides){\n            cloned[name] = overrides[name];\n        }\n        return cloned;\n    };\n    _proto.cloneAfter = function cloneAfter(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = this.clone(overrides);\n        this.parent.insertAfter(this, cloned);\n        return cloned;\n    };\n    _proto.cloneBefore = function cloneBefore(overrides) {\n        if (overrides === void 0) overrides = {};\n        var cloned = this.clone(overrides);\n        this.parent.insertBefore(this, cloned);\n        return cloned;\n    };\n    _proto.error = function error(message, opts) {\n        if (opts === void 0) opts = {};\n        if (this.source) {\n            var _this_rangeBy = this.rangeBy(opts), end = _this_rangeBy.end, start = _this_rangeBy.start;\n            return this.source.input.error(message, {\n                column: start.column,\n                line: start.line\n            }, {\n                column: end.column,\n                line: end.line\n            }, opts);\n        }\n        return new CssSyntaxError$2(message);\n    };\n    _proto.getProxyProcessor = function getProxyProcessor() {\n        return {\n            get: function get(node2, prop) {\n                if (prop === \"proxyOf\") {\n                    return node2;\n                } else if (prop === \"root\") {\n                    return function() {\n                        return node2.root().toProxy();\n                    };\n                } else {\n                    return node2[prop];\n                }\n            },\n            set: function set(node2, prop, value) {\n                if (node2[prop] === value) return true;\n                node2[prop] = value;\n                if (prop === \"prop\" || prop === \"value\" || prop === \"name\" || prop === \"params\" || prop === \"important\" || /* c8 ignore next */ prop === \"text\") {\n                    node2.markDirty();\n                }\n                return true;\n            }\n        };\n    };\n    _proto.markDirty = function markDirty() {\n        if (this[isClean$2]) {\n            this[isClean$2] = false;\n            var next = this;\n            while(next = next.parent){\n                next[isClean$2] = false;\n            }\n        }\n    };\n    _proto.next = function next() {\n        if (!this.parent) return void 0;\n        var index2 = this.parent.index(this);\n        return this.parent.nodes[index2 + 1];\n    };\n    _proto.positionBy = function positionBy(opts, stringRepresentation) {\n        var pos = this.source.start;\n        if (opts.index) {\n            pos = this.positionInside(opts.index, stringRepresentation);\n        } else if (opts.word) {\n            stringRepresentation = this.toString();\n            var index2 = stringRepresentation.indexOf(opts.word);\n            if (index2 !== -1) pos = this.positionInside(index2, stringRepresentation);\n        }\n        return pos;\n    };\n    _proto.positionInside = function positionInside(index2, stringRepresentation) {\n        var string = stringRepresentation || this.toString();\n        var column = this.source.start.column;\n        var line = this.source.start.line;\n        for(var i2 = 0; i2 < index2; i2++){\n            if (string[i2] === \"\\n\") {\n                column = 1;\n                line += 1;\n            } else {\n                column += 1;\n            }\n        }\n        return {\n            column: column,\n            line: line\n        };\n    };\n    _proto.prev = function prev() {\n        if (!this.parent) return void 0;\n        var index2 = this.parent.index(this);\n        return this.parent.nodes[index2 - 1];\n    };\n    _proto.rangeBy = function rangeBy(opts) {\n        var start = {\n            column: this.source.start.column,\n            line: this.source.start.line\n        };\n        var end = this.source.end ? {\n            column: this.source.end.column + 1,\n            line: this.source.end.line\n        } : {\n            column: start.column + 1,\n            line: start.line\n        };\n        if (opts.word) {\n            var stringRepresentation = this.toString();\n            var index2 = stringRepresentation.indexOf(opts.word);\n            if (index2 !== -1) {\n                start = this.positionInside(index2, stringRepresentation);\n                end = this.positionInside(index2 + opts.word.length, stringRepresentation);\n            }\n        } else {\n            if (opts.start) {\n                start = {\n                    column: opts.start.column,\n                    line: opts.start.line\n                };\n            } else if (opts.index) {\n                start = this.positionInside(opts.index);\n            }\n            if (opts.end) {\n                end = {\n                    column: opts.end.column,\n                    line: opts.end.line\n                };\n            } else if (typeof opts.endIndex === \"number\") {\n                end = this.positionInside(opts.endIndex);\n            } else if (opts.index) {\n                end = this.positionInside(opts.index + 1);\n            }\n        }\n        if (end.line < start.line || end.line === start.line && end.column <= start.column) {\n            end = {\n                column: start.column + 1,\n                line: start.line\n            };\n        }\n        return {\n            end: end,\n            start: start\n        };\n    };\n    _proto.raw = function raw(prop, defaultType) {\n        var str = new Stringifier22();\n        return str.raw(this, prop, defaultType);\n    };\n    _proto.remove = function remove() {\n        if (this.parent) {\n            this.parent.removeChild(this);\n        }\n        this.parent = void 0;\n        return this;\n    };\n    _proto.replaceWith = function replaceWith() {\n        for(var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++){\n            nodes[_key] = arguments[_key];\n        }\n        if (this.parent) {\n            var bookmark = this;\n            var foundSelf = false;\n            for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                var node2 = _step.value;\n                if (node2 === this) {\n                    foundSelf = true;\n                } else if (foundSelf) {\n                    this.parent.insertAfter(bookmark, node2);\n                    bookmark = node2;\n                } else {\n                    this.parent.insertBefore(bookmark, node2);\n                }\n            }\n            if (!foundSelf) {\n                this.remove();\n            }\n        }\n        return this;\n    };\n    _proto.root = function root() {\n        var result2 = this;\n        while(result2.parent && result2.parent.type !== \"document\"){\n            result2 = result2.parent;\n        }\n        return result2;\n    };\n    _proto.toJSON = function toJSON(_, inputs) {\n        var fixed = {};\n        var emitInputs = inputs == null;\n        inputs = inputs || /* @__PURE__ */ new Map();\n        var inputsNextIndex = 0;\n        for(var name in this){\n            if (!Object.prototype.hasOwnProperty.call(this, name)) {\n                continue;\n            }\n            if (name === \"parent\" || name === \"proxyCache\") continue;\n            var value = this[name];\n            if (Array.isArray(value)) {\n                fixed[name] = value.map(function(i2) {\n                    if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && i2.toJSON) {\n                        return i2.toJSON(null, inputs);\n                    } else {\n                        return i2;\n                    }\n                });\n            } else if ((typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === \"object\" && value.toJSON) {\n                fixed[name] = value.toJSON(null, inputs);\n            } else if (name === \"source\") {\n                var inputId = inputs.get(value.input);\n                if (inputId == null) {\n                    inputId = inputsNextIndex;\n                    inputs.set(value.input, inputsNextIndex);\n                    inputsNextIndex++;\n                }\n                fixed[name] = {\n                    end: value.end,\n                    inputId: inputId,\n                    start: value.start\n                };\n            } else {\n                fixed[name] = value;\n            }\n        }\n        if (emitInputs) {\n            fixed.inputs = [].concat(inputs.keys()).map(function(input2) {\n                return input2.toJSON();\n            });\n        }\n        return fixed;\n    };\n    _proto.toProxy = function toProxy() {\n        if (!this.proxyCache) {\n            this.proxyCache = new Proxy(this, this.getProxyProcessor());\n        }\n        return this.proxyCache;\n    };\n    _proto.toString = function toString(stringifier2) {\n        if (stringifier2 === void 0) stringifier2 = stringify$3;\n        if (stringifier2.stringify) stringifier2 = stringifier2.stringify;\n        var result2 = \"\";\n        stringifier2(this, function(i2) {\n            result2 += i2;\n        });\n        return result2;\n    };\n    _proto.warn = function warn(result2, text, opts) {\n        var data = {\n            node: this\n        };\n        for(var i2 in opts)data[i2] = opts[i2];\n        return result2.warn(text, data);\n    };\n    _create_class(Node3, [\n        {\n            key: \"proxyOf\",\n            get: function get() {\n                return this;\n            }\n        }\n    ]);\n    return Node3;\n}();\nvar node = Node$4;\nNode$4.default = Node$4;\nvar Node$3 = node;\nvar Declaration$4 = /*#__PURE__*/ function(Node$3) {\n    _inherits(Declaration2, Node$3);\n    function Declaration2(defaults) {\n        var _this;\n        if (defaults && typeof defaults.value !== \"undefined\" && typeof defaults.value !== \"string\") {\n            defaults = _extends({}, defaults, {\n                value: String(defaults.value)\n            });\n        }\n        _this = Node$3.call(this, defaults) || this;\n        _this.type = \"decl\";\n        return _this;\n    }\n    _create_class(Declaration2, [\n        {\n            key: \"variable\",\n            get: function get() {\n                return this.prop.startsWith(\"--\") || this.prop[0] === \"$\";\n            }\n        }\n    ]);\n    return Declaration2;\n}(Node$3);\nvar declaration = Declaration$4;\nDeclaration$4.default = Declaration$4;\nvar urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nvar nanoid$1 = function(size) {\n    if (size === void 0) size = 21;\n    var id = \"\";\n    var i2 = size;\n    while(i2--){\n        id += urlAlphabet[Math.random() * 64 | 0];\n    }\n    return id;\n};\nvar nonSecure = {\n    nanoid: nanoid$1};\nvar SourceMapConsumer$2 = require$$2.SourceMapConsumer, SourceMapGenerator$2 = require$$2.SourceMapGenerator;\nvar existsSync = require$$2.existsSync, readFileSync = require$$2.readFileSync;\nvar dirname$1 = require$$2.dirname, join = require$$2.join;\nfunction fromBase64(str) {\n    if (Buffer) {\n        return Buffer.from(str, \"base64\").toString();\n    } else {\n        return window.atob(str);\n    }\n}\nvar PreviousMap$2 = /*#__PURE__*/ function() {\n    function PreviousMap2(css, opts) {\n        if (opts.map === false) return;\n        this.loadAnnotation(css);\n        this.inline = this.startWith(this.annotation, \"data:\");\n        var prev = opts.map ? opts.map.prev : void 0;\n        var text = this.loadMap(opts.from, prev);\n        if (!this.mapFile && opts.from) {\n            this.mapFile = opts.from;\n        }\n        if (this.mapFile) this.root = dirname$1(this.mapFile);\n        if (text) this.text = text;\n    }\n    var _proto = PreviousMap2.prototype;\n    _proto.consumer = function consumer() {\n        if (!this.consumerCache) {\n            this.consumerCache = new SourceMapConsumer$2(this.text);\n        }\n        return this.consumerCache;\n    };\n    _proto.decodeInline = function decodeInline(text) {\n        var baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/;\n        var baseUri = /^data:application\\/json;base64,/;\n        var charsetUri = /^data:application\\/json;charset=utf-?8,/;\n        var uri = /^data:application\\/json,/;\n        if (charsetUri.test(text) || uri.test(text)) {\n            return decodeURIComponent(text.substr(RegExp.lastMatch.length));\n        }\n        if (baseCharsetUri.test(text) || baseUri.test(text)) {\n            return fromBase64(text.substr(RegExp.lastMatch.length));\n        }\n        var encoding = text.match(/data:application\\/json;([^,]+),/)[1];\n        throw new Error(\"Unsupported source map encoding \" + encoding);\n    };\n    _proto.getAnnotationURL = function getAnnotationURL(sourceMapString) {\n        return sourceMapString.replace(/^\\/\\*\\s*# sourceMappingURL=/, \"\").trim();\n    };\n    _proto.isMap = function isMap(map) {\n        if ((typeof map === \"undefined\" ? \"undefined\" : _type_of(map)) !== \"object\") return false;\n        return typeof map.mappings === \"string\" || typeof map._mappings === \"string\" || Array.isArray(map.sections);\n    };\n    _proto.loadAnnotation = function loadAnnotation(css) {\n        var comments = css.match(/\\/\\*\\s*# sourceMappingURL=/gm);\n        if (!comments) return;\n        var start = css.lastIndexOf(comments.pop());\n        var end = css.indexOf(\"*/\", start);\n        if (start > -1 && end > -1) {\n            this.annotation = this.getAnnotationURL(css.substring(start, end));\n        }\n    };\n    _proto.loadFile = function loadFile(path) {\n        this.root = dirname$1(path);\n        if (existsSync(path)) {\n            this.mapFile = path;\n            return readFileSync(path, \"utf-8\").toString().trim();\n        }\n    };\n    _proto.loadMap = function loadMap(file, prev) {\n        if (prev === false) return false;\n        if (prev) {\n            if (typeof prev === \"string\") {\n                return prev;\n            } else if (typeof prev === \"function\") {\n                var prevPath = prev(file);\n                if (prevPath) {\n                    var map = this.loadFile(prevPath);\n                    if (!map) {\n                        throw new Error(\"Unable to load previous source map: \" + prevPath.toString());\n                    }\n                    return map;\n                }\n            } else if (_instanceof(prev, SourceMapConsumer$2)) {\n                return SourceMapGenerator$2.fromSourceMap(prev).toString();\n            } else if (_instanceof(prev, SourceMapGenerator$2)) {\n                return prev.toString();\n            } else if (this.isMap(prev)) {\n                return JSON.stringify(prev);\n            } else {\n                throw new Error(\"Unsupported previous source map format: \" + prev.toString());\n            }\n        } else if (this.inline) {\n            return this.decodeInline(this.annotation);\n        } else if (this.annotation) {\n            var map1 = this.annotation;\n            if (file) map1 = join(dirname$1(file), map1);\n            return this.loadFile(map1);\n        }\n    };\n    _proto.startWith = function startWith(string, start) {\n        if (!string) return false;\n        return string.substr(0, start.length) === start;\n    };\n    _proto.withContent = function withContent() {\n        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);\n    };\n    return PreviousMap2;\n}();\nvar previousMap = PreviousMap$2;\nPreviousMap$2.default = PreviousMap$2;\nvar SourceMapConsumer$1 = require$$2.SourceMapConsumer, SourceMapGenerator$1 = require$$2.SourceMapGenerator;\nvar fileURLToPath = require$$2.fileURLToPath, pathToFileURL$1 = require$$2.pathToFileURL;\nvar isAbsolute = require$$2.isAbsolute, resolve$1 = require$$2.resolve;\nvar nanoid = nonSecure.nanoid;\nvar terminalHighlight = require$$2;\nvar CssSyntaxError$1 = cssSyntaxError;\nvar PreviousMap$1 = previousMap;\nvar fromOffsetCache = Symbol(\"fromOffsetCache\");\nvar sourceMapAvailable$1 = Boolean(SourceMapConsumer$1 && SourceMapGenerator$1);\nvar pathAvailable$1 = Boolean(resolve$1 && isAbsolute);\nvar Input$4 = /*#__PURE__*/ function() {\n    function Input2(css, opts) {\n        if (opts === void 0) opts = {};\n        if (css === null || typeof css === \"undefined\" || (typeof css === \"undefined\" ? \"undefined\" : _type_of(css)) === \"object\" && !css.toString) {\n            throw new Error(\"PostCSS received \" + css + \" instead of CSS string\");\n        }\n        this.css = css.toString();\n        if (this.css[0] === \"\\uFEFF\" || this.css[0] === \"\") {\n            this.hasBOM = true;\n            this.css = this.css.slice(1);\n        } else {\n            this.hasBOM = false;\n        }\n        if (opts.from) {\n            if (!pathAvailable$1 || /^\\w+:\\/\\//.test(opts.from) || isAbsolute(opts.from)) {\n                this.file = opts.from;\n            } else {\n                this.file = resolve$1(opts.from);\n            }\n        }\n        if (pathAvailable$1 && sourceMapAvailable$1) {\n            var map = new PreviousMap$1(this.css, opts);\n            if (map.text) {\n                this.map = map;\n                var file = map.consumer().file;\n                if (!this.file && file) this.file = this.mapResolve(file);\n            }\n        }\n        if (!this.file) {\n            this.id = \"<input css \" + nanoid(6) + \">\";\n        }\n        if (this.map) this.map.file = this.from;\n    }\n    var _proto = Input2.prototype;\n    _proto.error = function error(message, line, column, opts) {\n        if (opts === void 0) opts = {};\n        var result2, endLine, endColumn;\n        if (line && (typeof line === \"undefined\" ? \"undefined\" : _type_of(line)) === \"object\") {\n            var start = line;\n            var end = column;\n            if (typeof start.offset === \"number\") {\n                var pos = this.fromOffset(start.offset);\n                line = pos.line;\n                column = pos.col;\n            } else {\n                line = start.line;\n                column = start.column;\n            }\n            if (typeof end.offset === \"number\") {\n                var pos1 = this.fromOffset(end.offset);\n                endLine = pos1.line;\n                endColumn = pos1.col;\n            } else {\n                endLine = end.line;\n                endColumn = end.column;\n            }\n        } else if (!column) {\n            var pos2 = this.fromOffset(line);\n            line = pos2.line;\n            column = pos2.col;\n        }\n        var origin = this.origin(line, column, endLine, endColumn);\n        if (origin) {\n            result2 = new CssSyntaxError$1(message, origin.endLine === void 0 ? origin.line : {\n                column: origin.column,\n                line: origin.line\n            }, origin.endLine === void 0 ? origin.column : {\n                column: origin.endColumn,\n                line: origin.endLine\n            }, origin.source, origin.file, opts.plugin);\n        } else {\n            result2 = new CssSyntaxError$1(message, endLine === void 0 ? line : {\n                column: column,\n                line: line\n            }, endLine === void 0 ? column : {\n                column: endColumn,\n                line: endLine\n            }, this.css, this.file, opts.plugin);\n        }\n        result2.input = {\n            column: column,\n            endColumn: endColumn,\n            endLine: endLine,\n            line: line,\n            source: this.css\n        };\n        if (this.file) {\n            if (pathToFileURL$1) {\n                result2.input.url = pathToFileURL$1(this.file).toString();\n            }\n            result2.input.file = this.file;\n        }\n        return result2;\n    };\n    _proto.fromOffset = function fromOffset(offset) {\n        var lastLine, lineToIndex;\n        if (!this[fromOffsetCache]) {\n            var lines = this.css.split(\"\\n\");\n            lineToIndex = new Array(lines.length);\n            var prevIndex = 0;\n            for(var i2 = 0, l2 = lines.length; i2 < l2; i2++){\n                lineToIndex[i2] = prevIndex;\n                prevIndex += lines[i2].length + 1;\n            }\n            this[fromOffsetCache] = lineToIndex;\n        } else {\n            lineToIndex = this[fromOffsetCache];\n        }\n        lastLine = lineToIndex[lineToIndex.length - 1];\n        var min = 0;\n        if (offset >= lastLine) {\n            min = lineToIndex.length - 1;\n        } else {\n            var max = lineToIndex.length - 2;\n            var mid;\n            while(min < max){\n                mid = min + (max - min >> 1);\n                if (offset < lineToIndex[mid]) {\n                    max = mid - 1;\n                } else if (offset >= lineToIndex[mid + 1]) {\n                    min = mid + 1;\n                } else {\n                    min = mid;\n                    break;\n                }\n            }\n        }\n        return {\n            col: offset - lineToIndex[min] + 1,\n            line: min + 1\n        };\n    };\n    _proto.mapResolve = function mapResolve(file) {\n        if (/^\\w+:\\/\\//.test(file)) {\n            return file;\n        }\n        return resolve$1(this.map.consumer().sourceRoot || this.map.root || \".\", file);\n    };\n    _proto.origin = function origin(line, column, endLine, endColumn) {\n        if (!this.map) return false;\n        var consumer = this.map.consumer();\n        var from = consumer.originalPositionFor({\n            column: column,\n            line: line\n        });\n        if (!from.source) return false;\n        var to;\n        if (typeof endLine === \"number\") {\n            to = consumer.originalPositionFor({\n                column: endColumn,\n                line: endLine\n            });\n        }\n        var fromUrl;\n        if (isAbsolute(from.source)) {\n            fromUrl = pathToFileURL$1(from.source);\n        } else {\n            fromUrl = new URL(from.source, this.map.consumer().sourceRoot || pathToFileURL$1(this.map.mapFile));\n        }\n        var result2 = {\n            column: from.column,\n            endColumn: to && to.column,\n            endLine: to && to.line,\n            line: from.line,\n            url: fromUrl.toString()\n        };\n        if (fromUrl.protocol === \"file:\") {\n            if (fileURLToPath) {\n                result2.file = fileURLToPath(fromUrl);\n            } else {\n                throw new Error(\"file: protocol is not available in this PostCSS build\");\n            }\n        }\n        var source = consumer.sourceContentFor(from.source);\n        if (source) result2.source = source;\n        return result2;\n    };\n    _proto.toJSON = function toJSON() {\n        var json = {};\n        for(var _i = 0, _iter = [\n            \"hasBOM\",\n            \"css\",\n            \"file\",\n            \"id\"\n        ]; _i < _iter.length; _i++){\n            var name = _iter[_i];\n            if (this[name] != null) {\n                json[name] = this[name];\n            }\n        }\n        if (this.map) {\n            json.map = _extends({}, this.map);\n            if (json.map.consumerCache) {\n                json.map.consumerCache = void 0;\n            }\n        }\n        return json;\n    };\n    _create_class(Input2, [\n        {\n            key: \"from\",\n            get: function get() {\n                return this.file || this.id;\n            }\n        }\n    ]);\n    return Input2;\n}();\nvar input = Input$4;\nInput$4.default = Input$4;\nif (terminalHighlight && terminalHighlight.registerInput) {\n    terminalHighlight.registerInput(Input$4);\n}\nvar SourceMapConsumer = require$$2.SourceMapConsumer, SourceMapGenerator = require$$2.SourceMapGenerator;\nvar dirname = require$$2.dirname, relative = require$$2.relative, resolve$3 = require$$2.resolve, sep = require$$2.sep;\nvar pathToFileURL = require$$2.pathToFileURL;\nvar Input$3 = input;\nvar sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);\nvar pathAvailable = Boolean(dirname && resolve$3 && relative && sep);\nvar MapGenerator$2 = /*#__PURE__*/ function() {\n    function MapGenerator2(stringify2, root2, opts, cssString) {\n        this.stringify = stringify2;\n        this.mapOpts = opts.map || {};\n        this.root = root2;\n        this.opts = opts;\n        this.css = cssString;\n        this.originalCSS = cssString;\n        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;\n        this.memoizedFileURLs = /* @__PURE__ */ new Map();\n        this.memoizedPaths = /* @__PURE__ */ new Map();\n        this.memoizedURLs = /* @__PURE__ */ new Map();\n    }\n    var _proto = MapGenerator2.prototype;\n    _proto.addAnnotation = function addAnnotation() {\n        var content;\n        if (this.isInline()) {\n            content = \"data:application/json;base64,\" + this.toBase64(this.map.toString());\n        } else if (typeof this.mapOpts.annotation === \"string\") {\n            content = this.mapOpts.annotation;\n        } else if (typeof this.mapOpts.annotation === \"function\") {\n            content = this.mapOpts.annotation(this.opts.to, this.root);\n        } else {\n            content = this.outputFile() + \".map\";\n        }\n        var eol = \"\\n\";\n        if (this.css.includes(\"\\r\\n\")) eol = \"\\r\\n\";\n        this.css += eol + \"/*# sourceMappingURL=\" + content + \" */\";\n    };\n    _proto.applyPrevMaps = function applyPrevMaps() {\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.previous()), _step; !(_step = _iterator()).done;){\n            var prev = _step.value;\n            var from = this.toUrl(this.path(prev.file));\n            var root2 = prev.root || dirname(prev.file);\n            var map = void 0;\n            if (this.mapOpts.sourcesContent === false) {\n                map = new SourceMapConsumer(prev.text);\n                if (map.sourcesContent) {\n                    map.sourcesContent = null;\n                }\n            } else {\n                map = prev.consumer();\n            }\n            this.map.applySourceMap(map, from, this.toUrl(this.path(root2)));\n        }\n    };\n    _proto.clearAnnotation = function clearAnnotation() {\n        if (this.mapOpts.annotation === false) return;\n        if (this.root) {\n            var node2;\n            for(var i2 = this.root.nodes.length - 1; i2 >= 0; i2--){\n                node2 = this.root.nodes[i2];\n                if (node2.type !== \"comment\") continue;\n                if (node2.text.indexOf(\"# sourceMappingURL=\") === 0) {\n                    this.root.removeChild(i2);\n                }\n            }\n        } else if (this.css) {\n            this.css = this.css.replace(/\\n*?\\/\\*#[\\S\\s]*?\\*\\/$/gm, \"\");\n        }\n    };\n    _proto.generate = function generate() {\n        this.clearAnnotation();\n        if (pathAvailable && sourceMapAvailable && this.isMap()) {\n            return this.generateMap();\n        } else {\n            var result2 = \"\";\n            this.stringify(this.root, function(i2) {\n                result2 += i2;\n            });\n            return [\n                result2\n            ];\n        }\n    };\n    _proto.generateMap = function generateMap() {\n        if (this.root) {\n            this.generateString();\n        } else if (this.previous().length === 1) {\n            var prev = this.previous()[0].consumer();\n            prev.file = this.outputFile();\n            this.map = SourceMapGenerator.fromSourceMap(prev, {\n                ignoreInvalidMapping: true\n            });\n        } else {\n            this.map = new SourceMapGenerator({\n                file: this.outputFile(),\n                ignoreInvalidMapping: true\n            });\n            this.map.addMapping({\n                generated: {\n                    column: 0,\n                    line: 1\n                },\n                original: {\n                    column: 0,\n                    line: 1\n                },\n                source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : \"<no source>\"\n            });\n        }\n        if (this.isSourcesContent()) this.setSourcesContent();\n        if (this.root && this.previous().length > 0) this.applyPrevMaps();\n        if (this.isAnnotation()) this.addAnnotation();\n        if (this.isInline()) {\n            return [\n                this.css\n            ];\n        } else {\n            return [\n                this.css,\n                this.map\n            ];\n        }\n    };\n    _proto.generateString = function generateString() {\n        var _this = this;\n        this.css = \"\";\n        this.map = new SourceMapGenerator({\n            file: this.outputFile(),\n            ignoreInvalidMapping: true\n        });\n        var line = 1;\n        var column = 1;\n        var noSource = \"<no source>\";\n        var mapping = {\n            generated: {\n                column: 0,\n                line: 0\n            },\n            original: {\n                column: 0,\n                line: 0\n            },\n            source: \"\"\n        };\n        var lines, last;\n        this.stringify(this.root, function(str, node2, type) {\n            _this.css += str;\n            if (node2 && type !== \"end\") {\n                mapping.generated.line = line;\n                mapping.generated.column = column - 1;\n                if (node2.source && node2.source.start) {\n                    mapping.source = _this.sourcePath(node2);\n                    mapping.original.line = node2.source.start.line;\n                    mapping.original.column = node2.source.start.column - 1;\n                    _this.map.addMapping(mapping);\n                } else {\n                    mapping.source = noSource;\n                    mapping.original.line = 1;\n                    mapping.original.column = 0;\n                    _this.map.addMapping(mapping);\n                }\n            }\n            lines = str.match(/\\n/g);\n            if (lines) {\n                line += lines.length;\n                last = str.lastIndexOf(\"\\n\");\n                column = str.length - last;\n            } else {\n                column += str.length;\n            }\n            if (node2 && type !== \"start\") {\n                var p = node2.parent || {\n                    raws: {}\n                };\n                var childless = node2.type === \"decl\" || node2.type === \"atrule\" && !node2.nodes;\n                if (!childless || node2 !== p.last || p.raws.semicolon) {\n                    if (node2.source && node2.source.end) {\n                        mapping.source = _this.sourcePath(node2);\n                        mapping.original.line = node2.source.end.line;\n                        mapping.original.column = node2.source.end.column - 1;\n                        mapping.generated.line = line;\n                        mapping.generated.column = column - 2;\n                        _this.map.addMapping(mapping);\n                    } else {\n                        mapping.source = noSource;\n                        mapping.original.line = 1;\n                        mapping.original.column = 0;\n                        mapping.generated.line = line;\n                        mapping.generated.column = column - 1;\n                        _this.map.addMapping(mapping);\n                    }\n                }\n            }\n        });\n    };\n    _proto.isAnnotation = function isAnnotation() {\n        if (this.isInline()) {\n            return true;\n        }\n        if (typeof this.mapOpts.annotation !== \"undefined\") {\n            return this.mapOpts.annotation;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.annotation;\n            });\n        }\n        return true;\n    };\n    _proto.isInline = function isInline() {\n        if (typeof this.mapOpts.inline !== \"undefined\") {\n            return this.mapOpts.inline;\n        }\n        var annotation = this.mapOpts.annotation;\n        if (typeof annotation !== \"undefined\" && annotation !== true) {\n            return false;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.inline;\n            });\n        }\n        return true;\n    };\n    _proto.isMap = function isMap() {\n        if (typeof this.opts.map !== \"undefined\") {\n            return !!this.opts.map;\n        }\n        return this.previous().length > 0;\n    };\n    _proto.isSourcesContent = function isSourcesContent() {\n        if (typeof this.mapOpts.sourcesContent !== \"undefined\") {\n            return this.mapOpts.sourcesContent;\n        }\n        if (this.previous().length) {\n            return this.previous().some(function(i2) {\n                return i2.withContent();\n            });\n        }\n        return true;\n    };\n    _proto.outputFile = function outputFile() {\n        if (this.opts.to) {\n            return this.path(this.opts.to);\n        } else if (this.opts.from) {\n            return this.path(this.opts.from);\n        } else {\n            return \"to.css\";\n        }\n    };\n    _proto.path = function path(file) {\n        if (this.mapOpts.absolute) return file;\n        if (file.charCodeAt(0) === 60) return file;\n        if (/^\\w+:\\/\\//.test(file)) return file;\n        var cached = this.memoizedPaths.get(file);\n        if (cached) return cached;\n        var from = this.opts.to ? dirname(this.opts.to) : \".\";\n        if (typeof this.mapOpts.annotation === \"string\") {\n            from = dirname(resolve$3(from, this.mapOpts.annotation));\n        }\n        var path = relative(from, file);\n        this.memoizedPaths.set(file, path);\n        return path;\n    };\n    _proto.previous = function previous() {\n        var _this = this;\n        if (!this.previousMaps) {\n            this.previousMaps = [];\n            if (this.root) {\n                this.root.walk(function(node2) {\n                    if (node2.source && node2.source.input.map) {\n                        var map = node2.source.input.map;\n                        if (!_this.previousMaps.includes(map)) {\n                            _this.previousMaps.push(map);\n                        }\n                    }\n                });\n            } else {\n                var input2 = new Input$3(this.originalCSS, this.opts);\n                if (input2.map) this.previousMaps.push(input2.map);\n            }\n        }\n        return this.previousMaps;\n    };\n    _proto.setSourcesContent = function setSourcesContent() {\n        var _this = this;\n        var already = {};\n        if (this.root) {\n            this.root.walk(function(node2) {\n                if (node2.source) {\n                    var from = node2.source.input.from;\n                    if (from && !already[from]) {\n                        already[from] = true;\n                        var fromUrl = _this.usesFileUrls ? _this.toFileUrl(from) : _this.toUrl(_this.path(from));\n                        _this.map.setSourceContent(fromUrl, node2.source.input.css);\n                    }\n                }\n            });\n        } else if (this.css) {\n            var from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : \"<no source>\";\n            this.map.setSourceContent(from, this.css);\n        }\n    };\n    _proto.sourcePath = function sourcePath(node2) {\n        if (this.mapOpts.from) {\n            return this.toUrl(this.mapOpts.from);\n        } else if (this.usesFileUrls) {\n            return this.toFileUrl(node2.source.input.from);\n        } else {\n            return this.toUrl(this.path(node2.source.input.from));\n        }\n    };\n    _proto.toBase64 = function toBase64(str) {\n        if (Buffer) {\n            return Buffer.from(str).toString(\"base64\");\n        } else {\n            return window.btoa(unescape(encodeURIComponent(str)));\n        }\n    };\n    _proto.toFileUrl = function toFileUrl(path) {\n        var cached = this.memoizedFileURLs.get(path);\n        if (cached) return cached;\n        if (pathToFileURL) {\n            var fileURL = pathToFileURL(path).toString();\n            this.memoizedFileURLs.set(path, fileURL);\n            return fileURL;\n        } else {\n            throw new Error(\"`map.absolute` option is not available in this PostCSS build\");\n        }\n    };\n    _proto.toUrl = function toUrl(path) {\n        var cached = this.memoizedURLs.get(path);\n        if (cached) return cached;\n        if (sep === \"\\\\\") {\n            path = path.replace(/\\\\/g, \"/\");\n        }\n        var url = encodeURI(path).replace(/[#?]/g, encodeURIComponent);\n        this.memoizedURLs.set(path, url);\n        return url;\n    };\n    return MapGenerator2;\n}();\nvar mapGenerator = MapGenerator$2;\nvar Node$2 = node;\nvar Comment$4 = /*#__PURE__*/ function(Node$2) {\n    _inherits(Comment2, Node$2);\n    function Comment2(defaults) {\n        var _this;\n        _this = Node$2.call(this, defaults) || this;\n        _this.type = \"comment\";\n        return _this;\n    }\n    return Comment2;\n}(Node$2);\nvar comment = Comment$4;\nComment$4.default = Comment$4;\nvar isClean$1 = symbols.isClean, my$1 = symbols.my;\nvar Declaration$3 = declaration;\nvar Comment$3 = comment;\nvar Node$1 = node;\nvar parse$4, Rule$4, AtRule$4, Root$6;\nfunction cleanSource(nodes) {\n    return nodes.map(function(i2) {\n        if (i2.nodes) i2.nodes = cleanSource(i2.nodes);\n        delete i2.source;\n        return i2;\n    });\n}\nfunction markDirtyUp(node2) {\n    node2[isClean$1] = false;\n    if (node2.proxyOf.nodes) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(node2.proxyOf.nodes), _step; !(_step = _iterator()).done;){\n            var i2 = _step.value;\n            markDirtyUp(i2);\n        }\n    }\n}\nvar Container$7 = /*#__PURE__*/ function(Node$1) {\n    _inherits(Container2, Node$1);\n    function Container2() {\n        return Node$1.apply(this, arguments) || this;\n    }\n    var _proto = Container2.prototype;\n    _proto.append = function append() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        for(var _iterator = _create_for_of_iterator_helper_loose(children), _step; !(_step = _iterator()).done;){\n            var child = _step.value;\n            var nodes = this.normalize(child, this.last);\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var node2 = _step1.value;\n                this.proxyOf.nodes.push(node2);\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.cleanRaws = function cleanRaws(keepBetween) {\n        Node$1.prototype.cleanRaws.call(this, keepBetween);\n        if (this.nodes) {\n            for(var _iterator = _create_for_of_iterator_helper_loose(this.nodes), _step; !(_step = _iterator()).done;){\n                var node2 = _step.value;\n                node2.cleanRaws(keepBetween);\n            }\n        }\n    };\n    _proto.each = function each(callback) {\n        if (!this.proxyOf.nodes) return void 0;\n        var iterator = this.getIterator();\n        var index2, result2;\n        while(this.indexes[iterator] < this.proxyOf.nodes.length){\n            index2 = this.indexes[iterator];\n            result2 = callback(this.proxyOf.nodes[index2], index2);\n            if (result2 === false) break;\n            this.indexes[iterator] += 1;\n        }\n        delete this.indexes[iterator];\n        return result2;\n    };\n    _proto.every = function every(condition) {\n        return this.nodes.every(condition);\n    };\n    _proto.getIterator = function getIterator() {\n        if (!this.lastEach) this.lastEach = 0;\n        if (!this.indexes) this.indexes = {};\n        this.lastEach += 1;\n        var iterator = this.lastEach;\n        this.indexes[iterator] = 0;\n        return iterator;\n    };\n    _proto.getProxyProcessor = function getProxyProcessor() {\n        return {\n            get: function get(node2, prop) {\n                if (prop === \"proxyOf\") {\n                    return node2;\n                } else if (!node2[prop]) {\n                    return node2[prop];\n                } else if (prop === \"each\" || typeof prop === \"string\" && prop.startsWith(\"walk\")) {\n                    return function() {\n                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                            args[_key] = arguments[_key];\n                        }\n                        var _node2;\n                        return (_node2 = node2)[prop].apply(_node2, [].concat(args.map(function(i2) {\n                            if (typeof i2 === \"function\") {\n                                return function(child, index2) {\n                                    return i2(child.toProxy(), index2);\n                                };\n                            } else {\n                                return i2;\n                            }\n                        })));\n                    };\n                } else if (prop === \"every\" || prop === \"some\") {\n                    return function(cb) {\n                        return node2[prop](function(child) {\n                            for(var _len = arguments.length, other = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                                other[_key - 1] = arguments[_key];\n                            }\n                            return cb.apply(void 0, [].concat([\n                                child.toProxy()\n                            ], other));\n                        });\n                    };\n                } else if (prop === \"root\") {\n                    return function() {\n                        return node2.root().toProxy();\n                    };\n                } else if (prop === \"nodes\") {\n                    return node2.nodes.map(function(i2) {\n                        return i2.toProxy();\n                    });\n                } else if (prop === \"first\" || prop === \"last\") {\n                    return node2[prop].toProxy();\n                } else {\n                    return node2[prop];\n                }\n            },\n            set: function set(node2, prop, value) {\n                if (node2[prop] === value) return true;\n                node2[prop] = value;\n                if (prop === \"name\" || prop === \"params\" || prop === \"selector\") {\n                    node2.markDirty();\n                }\n                return true;\n            }\n        };\n    };\n    _proto.index = function index(child) {\n        if (typeof child === \"number\") return child;\n        if (child.proxyOf) child = child.proxyOf;\n        return this.proxyOf.nodes.indexOf(child);\n    };\n    _proto.insertAfter = function insertAfter(exist, add) {\n        var existIndex = this.index(exist);\n        var nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();\n        existIndex = this.index(exist);\n        for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            this.proxyOf.nodes.splice(existIndex + 1, 0, node2);\n        }\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (existIndex < index2) {\n                this.indexes[id] = index2 + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.insertBefore = function insertBefore(exist, add) {\n        var existIndex = this.index(exist);\n        var type = existIndex === 0 ? \"prepend\" : false;\n        var nodes = this.normalize(add, this.proxyOf.nodes[existIndex], type).reverse();\n        existIndex = this.index(exist);\n        for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            this.proxyOf.nodes.splice(existIndex, 0, node2);\n        }\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (existIndex <= index2) {\n                this.indexes[id] = index2 + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.normalize = function normalize(nodes, sample) {\n        var _this = this;\n        if (typeof nodes === \"string\") {\n            nodes = cleanSource(parse$4(nodes).nodes);\n        } else if (typeof nodes === \"undefined\") {\n            nodes = [];\n        } else if (Array.isArray(nodes)) {\n            nodes = nodes.slice(0);\n            for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                var i2 = _step.value;\n                if (i2.parent) i2.parent.removeChild(i2, \"ignore\");\n            }\n        } else if (nodes.type === \"root\" && this.type !== \"document\") {\n            nodes = nodes.nodes.slice(0);\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var i21 = _step1.value;\n                if (i21.parent) i21.parent.removeChild(i21, \"ignore\");\n            }\n        } else if (nodes.type) {\n            nodes = [\n                nodes\n            ];\n        } else if (nodes.prop) {\n            if (typeof nodes.value === \"undefined\") {\n                throw new Error(\"Value field is missed in node creation\");\n            } else if (typeof nodes.value !== \"string\") {\n                nodes.value = String(nodes.value);\n            }\n            nodes = [\n                new Declaration$3(nodes)\n            ];\n        } else if (nodes.selector) {\n            nodes = [\n                new Rule$4(nodes)\n            ];\n        } else if (nodes.name) {\n            nodes = [\n                new AtRule$4(nodes)\n            ];\n        } else if (nodes.text) {\n            nodes = [\n                new Comment$3(nodes)\n            ];\n        } else {\n            throw new Error(\"Unknown node type in node creation\");\n        }\n        var processed = nodes.map(function(i2) {\n            if (!i2[my$1]) Container2.rebuild(i2);\n            i2 = i2.proxyOf;\n            if (i2.parent) i2.parent.removeChild(i2);\n            if (i2[isClean$1]) markDirtyUp(i2);\n            if (typeof i2.raws.before === \"undefined\") {\n                if (sample && typeof sample.raws.before !== \"undefined\") {\n                    i2.raws.before = sample.raws.before.replace(/\\S/g, \"\");\n                }\n            }\n            i2.parent = _this.proxyOf;\n            return i2;\n        });\n        return processed;\n    };\n    _proto.prepend = function prepend() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        children = children.reverse();\n        for(var _iterator = _create_for_of_iterator_helper_loose(children), _step; !(_step = _iterator()).done;){\n            var child = _step.value;\n            var nodes = this.normalize(child, this.first, \"prepend\").reverse();\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(nodes), _step1; !(_step1 = _iterator1()).done;){\n                var node2 = _step1.value;\n                this.proxyOf.nodes.unshift(node2);\n            }\n            for(var id in this.indexes){\n                this.indexes[id] = this.indexes[id] + nodes.length;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.push = function push(child) {\n        child.parent = this;\n        this.proxyOf.nodes.push(child);\n        return this;\n    };\n    _proto.removeAll = function removeAll() {\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.proxyOf.nodes), _step; !(_step = _iterator()).done;){\n            var node2 = _step.value;\n            node2.parent = void 0;\n        }\n        this.proxyOf.nodes = [];\n        this.markDirty();\n        return this;\n    };\n    _proto.removeChild = function removeChild(child) {\n        child = this.index(child);\n        this.proxyOf.nodes[child].parent = void 0;\n        this.proxyOf.nodes.splice(child, 1);\n        var index2;\n        for(var id in this.indexes){\n            index2 = this.indexes[id];\n            if (index2 >= child) {\n                this.indexes[id] = index2 - 1;\n            }\n        }\n        this.markDirty();\n        return this;\n    };\n    _proto.replaceValues = function replaceValues(pattern, opts, callback) {\n        if (!callback) {\n            callback = opts;\n            opts = {};\n        }\n        this.walkDecls(function(decl) {\n            if (opts.props && !opts.props.includes(decl.prop)) return;\n            if (opts.fast && !decl.value.includes(opts.fast)) return;\n            decl.value = decl.value.replace(pattern, callback);\n        });\n        this.markDirty();\n        return this;\n    };\n    _proto.some = function some(condition) {\n        return this.nodes.some(condition);\n    };\n    _proto.walk = function walk(callback) {\n        return this.each(function(child, i2) {\n            var result2;\n            try {\n                result2 = callback(child, i2);\n            } catch (e2) {\n                throw child.addToError(e2);\n            }\n            if (result2 !== false && child.walk) {\n                result2 = child.walk(callback);\n            }\n            return result2;\n        });\n    };\n    _proto.walkAtRules = function walkAtRules(name, callback) {\n        if (!callback) {\n            callback = name;\n            return this.walk(function(child, i2) {\n                if (child.type === \"atrule\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(name, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"atrule\" && name.test(child.name)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"atrule\" && child.name === name) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkComments = function walkComments(callback) {\n        return this.walk(function(child, i2) {\n            if (child.type === \"comment\") {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkDecls = function walkDecls(prop, callback) {\n        if (!callback) {\n            callback = prop;\n            return this.walk(function(child, i2) {\n                if (child.type === \"decl\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(prop, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"decl\" && prop.test(child.prop)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"decl\" && child.prop === prop) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _proto.walkRules = function walkRules(selector, callback) {\n        if (!callback) {\n            callback = selector;\n            return this.walk(function(child, i2) {\n                if (child.type === \"rule\") {\n                    return callback(child, i2);\n                }\n            });\n        }\n        if (_instanceof(selector, RegExp)) {\n            return this.walk(function(child, i2) {\n                if (child.type === \"rule\" && selector.test(child.selector)) {\n                    return callback(child, i2);\n                }\n            });\n        }\n        return this.walk(function(child, i2) {\n            if (child.type === \"rule\" && child.selector === selector) {\n                return callback(child, i2);\n            }\n        });\n    };\n    _create_class(Container2, [\n        {\n            key: \"first\",\n            get: function get() {\n                if (!this.proxyOf.nodes) return void 0;\n                return this.proxyOf.nodes[0];\n            }\n        },\n        {\n            key: \"last\",\n            get: function get() {\n                if (!this.proxyOf.nodes) return void 0;\n                return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];\n            }\n        }\n    ]);\n    return Container2;\n}(Node$1);\nContainer$7.registerParse = function(dependant) {\n    parse$4 = dependant;\n};\nContainer$7.registerRule = function(dependant) {\n    Rule$4 = dependant;\n};\nContainer$7.registerAtRule = function(dependant) {\n    AtRule$4 = dependant;\n};\nContainer$7.registerRoot = function(dependant) {\n    Root$6 = dependant;\n};\nvar container = Container$7;\nContainer$7.default = Container$7;\nContainer$7.rebuild = function(node2) {\n    if (node2.type === \"atrule\") {\n        Object.setPrototypeOf(node2, AtRule$4.prototype);\n    } else if (node2.type === \"rule\") {\n        Object.setPrototypeOf(node2, Rule$4.prototype);\n    } else if (node2.type === \"decl\") {\n        Object.setPrototypeOf(node2, Declaration$3.prototype);\n    } else if (node2.type === \"comment\") {\n        Object.setPrototypeOf(node2, Comment$3.prototype);\n    } else if (node2.type === \"root\") {\n        Object.setPrototypeOf(node2, Root$6.prototype);\n    }\n    node2[my$1] = true;\n    if (node2.nodes) {\n        node2.nodes.forEach(function(child) {\n            Container$7.rebuild(child);\n        });\n    }\n};\nvar Container$6 = container;\nvar LazyResult$4, Processor$3;\nvar Document$3 = /*#__PURE__*/ function(Container$6) {\n    _inherits(Document23, Container$6);\n    function Document23(defaults) {\n        var _this;\n        _this = Container$6.call(this, _extends({\n            type: \"document\"\n        }, defaults)) || this;\n        if (!_this.nodes) {\n            _this.nodes = [];\n        }\n        return _this;\n    }\n    var _proto = Document23.prototype;\n    _proto.toResult = function toResult(opts) {\n        if (opts === void 0) opts = {};\n        var lazy = new LazyResult$4(new Processor$3(), this, opts);\n        return lazy.stringify();\n    };\n    return Document23;\n}(Container$6);\nDocument$3.registerLazyResult = function(dependant) {\n    LazyResult$4 = dependant;\n};\nDocument$3.registerProcessor = function(dependant) {\n    Processor$3 = dependant;\n};\nvar document$1$2 = Document$3;\nDocument$3.default = Document$3;\nvar printed = {};\nvar warnOnce$2 = function warnOnce2(message) {\n    if (printed[message]) return;\n    printed[message] = true;\n    if (typeof console !== \"undefined\" && console.warn) {\n        console.warn(message);\n    }\n};\nvar Warning$2 = /*#__PURE__*/ function() {\n    function Warning2(text, opts) {\n        if (opts === void 0) opts = {};\n        this.type = \"warning\";\n        this.text = text;\n        if (opts.node && opts.node.source) {\n            var range = opts.node.rangeBy(opts);\n            this.line = range.start.line;\n            this.column = range.start.column;\n            this.endLine = range.end.line;\n            this.endColumn = range.end.column;\n        }\n        for(var opt in opts)this[opt] = opts[opt];\n    }\n    var _proto = Warning2.prototype;\n    _proto.toString = function toString() {\n        if (this.node) {\n            return this.node.error(this.text, {\n                index: this.index,\n                plugin: this.plugin,\n                word: this.word\n            }).message;\n        }\n        if (this.plugin) {\n            return this.plugin + \": \" + this.text;\n        }\n        return this.text;\n    };\n    return Warning2;\n}();\nvar warning = Warning$2;\nWarning$2.default = Warning$2;\nvar Warning$1 = warning;\nvar Result$3 = /*#__PURE__*/ function() {\n    function Result2(processor2, root2, opts) {\n        this.processor = processor2;\n        this.messages = [];\n        this.root = root2;\n        this.opts = opts;\n        this.css = void 0;\n        this.map = void 0;\n    }\n    var _proto = Result2.prototype;\n    _proto.toString = function toString() {\n        return this.css;\n    };\n    _proto.warn = function warn(text, opts) {\n        if (opts === void 0) opts = {};\n        if (!opts.plugin) {\n            if (this.lastPlugin && this.lastPlugin.postcssPlugin) {\n                opts.plugin = this.lastPlugin.postcssPlugin;\n            }\n        }\n        var warning2 = new Warning$1(text, opts);\n        this.messages.push(warning2);\n        return warning2;\n    };\n    _proto.warnings = function warnings() {\n        return this.messages.filter(function(i2) {\n            return i2.type === \"warning\";\n        });\n    };\n    _create_class(Result2, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.css;\n            }\n        }\n    ]);\n    return Result2;\n}();\nvar result = Result$3;\nResult$3.default = Result$3;\nvar SINGLE_QUOTE = \"'\".charCodeAt(0);\nvar DOUBLE_QUOTE = '\"'.charCodeAt(0);\nvar BACKSLASH = \"\\\\\".charCodeAt(0);\nvar SLASH = \"/\".charCodeAt(0);\nvar NEWLINE = \"\\n\".charCodeAt(0);\nvar SPACE = \" \".charCodeAt(0);\nvar FEED = \"\\f\".charCodeAt(0);\nvar TAB = \"\t\".charCodeAt(0);\nvar CR = \"\\r\".charCodeAt(0);\nvar OPEN_SQUARE = \"[\".charCodeAt(0);\nvar CLOSE_SQUARE = \"]\".charCodeAt(0);\nvar OPEN_PARENTHESES = \"(\".charCodeAt(0);\nvar CLOSE_PARENTHESES = \")\".charCodeAt(0);\nvar OPEN_CURLY = \"{\".charCodeAt(0);\nvar CLOSE_CURLY = \"}\".charCodeAt(0);\nvar SEMICOLON = \";\".charCodeAt(0);\nvar ASTERISK = \"*\".charCodeAt(0);\nvar COLON = \":\".charCodeAt(0);\nvar AT = \"@\".charCodeAt(0);\nvar RE_AT_END = /[\\t\\n\\f\\r \"#'()/;[\\\\\\]{}]/g;\nvar RE_WORD_END = /[\\t\\n\\f\\r !\"#'():;@[\\\\\\]{}]|\\/(?=\\*)/g;\nvar RE_BAD_BRACKET = /.[\\r\\n\"'(/\\\\]/;\nvar RE_HEX_ESCAPE = /[\\da-f]/i;\nvar tokenize = function tokenizer2(input2, options) {\n    if (options === void 0) options = {};\n    var css = input2.css.valueOf();\n    var ignore = options.ignoreErrors;\n    var code, next, quote, content, escape;\n    var escaped, escapePos, prev, n2, currentToken;\n    var length = css.length;\n    var pos = 0;\n    var buffer = [];\n    var returned = [];\n    function position() {\n        return pos;\n    }\n    function unclosed(what) {\n        throw input2.error(\"Unclosed \" + what, pos);\n    }\n    function endOfFile() {\n        return returned.length === 0 && pos >= length;\n    }\n    function nextToken(opts) {\n        if (returned.length) return returned.pop();\n        if (pos >= length) return;\n        var ignoreUnclosed = opts ? opts.ignoreUnclosed : false;\n        code = css.charCodeAt(pos);\n        switch(code){\n            case NEWLINE:\n            case SPACE:\n            case TAB:\n            case CR:\n            case FEED:\n                {\n                    next = pos;\n                    do {\n                        next += 1;\n                        code = css.charCodeAt(next);\n                    }while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);\n                    currentToken = [\n                        \"space\",\n                        css.slice(pos, next)\n                    ];\n                    pos = next - 1;\n                    break;\n                }\n            case OPEN_SQUARE:\n            case CLOSE_SQUARE:\n            case OPEN_CURLY:\n            case CLOSE_CURLY:\n            case COLON:\n            case SEMICOLON:\n            case CLOSE_PARENTHESES:\n                {\n                    var controlChar = String.fromCharCode(code);\n                    currentToken = [\n                        controlChar,\n                        controlChar,\n                        pos\n                    ];\n                    break;\n                }\n            case OPEN_PARENTHESES:\n                {\n                    prev = buffer.length ? buffer.pop()[1] : \"\";\n                    n2 = css.charCodeAt(pos + 1);\n                    if (prev === \"url\" && n2 !== SINGLE_QUOTE && n2 !== DOUBLE_QUOTE && n2 !== SPACE && n2 !== NEWLINE && n2 !== TAB && n2 !== FEED && n2 !== CR) {\n                        next = pos;\n                        do {\n                            escaped = false;\n                            next = css.indexOf(\")\", next + 1);\n                            if (next === -1) {\n                                if (ignore || ignoreUnclosed) {\n                                    next = pos;\n                                    break;\n                                } else {\n                                    unclosed(\"bracket\");\n                                }\n                            }\n                            escapePos = next;\n                            while(css.charCodeAt(escapePos - 1) === BACKSLASH){\n                                escapePos -= 1;\n                                escaped = !escaped;\n                            }\n                        }while (escaped);\n                        currentToken = [\n                            \"brackets\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        pos = next;\n                    } else {\n                        next = css.indexOf(\")\", pos + 1);\n                        content = css.slice(pos, next + 1);\n                        if (next === -1 || RE_BAD_BRACKET.test(content)) {\n                            currentToken = [\n                                \"(\",\n                                \"(\",\n                                pos\n                            ];\n                        } else {\n                            currentToken = [\n                                \"brackets\",\n                                content,\n                                pos,\n                                next\n                            ];\n                            pos = next;\n                        }\n                    }\n                    break;\n                }\n            case SINGLE_QUOTE:\n            case DOUBLE_QUOTE:\n                {\n                    quote = code === SINGLE_QUOTE ? \"'\" : '\"';\n                    next = pos;\n                    do {\n                        escaped = false;\n                        next = css.indexOf(quote, next + 1);\n                        if (next === -1) {\n                            if (ignore || ignoreUnclosed) {\n                                next = pos + 1;\n                                break;\n                            } else {\n                                unclosed(\"string\");\n                            }\n                        }\n                        escapePos = next;\n                        while(css.charCodeAt(escapePos - 1) === BACKSLASH){\n                            escapePos -= 1;\n                            escaped = !escaped;\n                        }\n                    }while (escaped);\n                    currentToken = [\n                        \"string\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            case AT:\n                {\n                    RE_AT_END.lastIndex = pos + 1;\n                    RE_AT_END.test(css);\n                    if (RE_AT_END.lastIndex === 0) {\n                        next = css.length - 1;\n                    } else {\n                        next = RE_AT_END.lastIndex - 2;\n                    }\n                    currentToken = [\n                        \"at-word\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            case BACKSLASH:\n                {\n                    next = pos;\n                    escape = true;\n                    while(css.charCodeAt(next + 1) === BACKSLASH){\n                        next += 1;\n                        escape = !escape;\n                    }\n                    code = css.charCodeAt(next + 1);\n                    if (escape && code !== SLASH && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {\n                        next += 1;\n                        if (RE_HEX_ESCAPE.test(css.charAt(next))) {\n                            while(RE_HEX_ESCAPE.test(css.charAt(next + 1))){\n                                next += 1;\n                            }\n                            if (css.charCodeAt(next + 1) === SPACE) {\n                                next += 1;\n                            }\n                        }\n                    }\n                    currentToken = [\n                        \"word\",\n                        css.slice(pos, next + 1),\n                        pos,\n                        next\n                    ];\n                    pos = next;\n                    break;\n                }\n            default:\n                {\n                    if (code === SLASH && css.charCodeAt(pos + 1) === ASTERISK) {\n                        next = css.indexOf(\"*/\", pos + 2) + 1;\n                        if (next === 0) {\n                            if (ignore || ignoreUnclosed) {\n                                next = css.length;\n                            } else {\n                                unclosed(\"comment\");\n                            }\n                        }\n                        currentToken = [\n                            \"comment\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        pos = next;\n                    } else {\n                        RE_WORD_END.lastIndex = pos + 1;\n                        RE_WORD_END.test(css);\n                        if (RE_WORD_END.lastIndex === 0) {\n                            next = css.length - 1;\n                        } else {\n                            next = RE_WORD_END.lastIndex - 2;\n                        }\n                        currentToken = [\n                            \"word\",\n                            css.slice(pos, next + 1),\n                            pos,\n                            next\n                        ];\n                        buffer.push(currentToken);\n                        pos = next;\n                    }\n                    break;\n                }\n        }\n        pos++;\n        return currentToken;\n    }\n    function back(token) {\n        returned.push(token);\n    }\n    return {\n        back: back,\n        endOfFile: endOfFile,\n        nextToken: nextToken,\n        position: position\n    };\n};\nvar Container$5 = container;\nvar AtRule$3 = /*#__PURE__*/ function(Container$5) {\n    _inherits(AtRule2, Container$5);\n    function AtRule2(defaults) {\n        var _this;\n        _this = Container$5.call(this, defaults) || this;\n        _this.type = \"atrule\";\n        return _this;\n    }\n    var _proto = AtRule2.prototype;\n    _proto.append = function append() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        var _Container$5_prototype_append;\n        if (!this.proxyOf.nodes) this.nodes = [];\n        return (_Container$5_prototype_append = Container$5.prototype.append).call.apply(_Container$5_prototype_append, [].concat([\n            this\n        ], children));\n    };\n    _proto.prepend = function prepend() {\n        for(var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++){\n            children[_key] = arguments[_key];\n        }\n        var _Container$5_prototype_prepend;\n        if (!this.proxyOf.nodes) this.nodes = [];\n        return (_Container$5_prototype_prepend = Container$5.prototype.prepend).call.apply(_Container$5_prototype_prepend, [].concat([\n            this\n        ], children));\n    };\n    return AtRule2;\n}(Container$5);\nvar atRule = AtRule$3;\nAtRule$3.default = AtRule$3;\nContainer$5.registerAtRule(AtRule$3);\nvar Container$4 = container;\nvar LazyResult$3, Processor$2;\nvar Root$5 = /*#__PURE__*/ function(Container$4) {\n    _inherits(Root2, Container$4);\n    function Root2(defaults) {\n        var _this;\n        _this = Container$4.call(this, defaults) || this;\n        _this.type = \"root\";\n        if (!_this.nodes) _this.nodes = [];\n        return _this;\n    }\n    var _proto = Root2.prototype;\n    _proto.normalize = function normalize(child, sample, type) {\n        var nodes = Container$4.prototype.normalize.call(this, child);\n        if (sample) {\n            if (type === \"prepend\") {\n                if (this.nodes.length > 1) {\n                    sample.raws.before = this.nodes[1].raws.before;\n                } else {\n                    delete sample.raws.before;\n                }\n            } else if (this.first !== sample) {\n                for(var _iterator = _create_for_of_iterator_helper_loose(nodes), _step; !(_step = _iterator()).done;){\n                    var node2 = _step.value;\n                    node2.raws.before = sample.raws.before;\n                }\n            }\n        }\n        return nodes;\n    };\n    _proto.removeChild = function removeChild(child, ignore) {\n        var index2 = this.index(child);\n        if (!ignore && index2 === 0 && this.nodes.length > 1) {\n            this.nodes[1].raws.before = this.nodes[index2].raws.before;\n        }\n        return Container$4.prototype.removeChild.call(this, child);\n    };\n    _proto.toResult = function toResult(opts) {\n        if (opts === void 0) opts = {};\n        var lazy = new LazyResult$3(new Processor$2(), this, opts);\n        return lazy.stringify();\n    };\n    return Root2;\n}(Container$4);\nRoot$5.registerLazyResult = function(dependant) {\n    LazyResult$3 = dependant;\n};\nRoot$5.registerProcessor = function(dependant) {\n    Processor$2 = dependant;\n};\nvar root = Root$5;\nRoot$5.default = Root$5;\nContainer$4.registerRoot(Root$5);\nvar list$2 = {\n    comma: function comma(string) {\n        return list$2.split(string, [\n            \",\"\n        ], true);\n    },\n    space: function space(string) {\n        var spaces = [\n            \" \",\n            \"\\n\",\n            \"\t\"\n        ];\n        return list$2.split(string, spaces);\n    },\n    split: function split(string, separators, last) {\n        var array = [];\n        var current = \"\";\n        var split = false;\n        var func = 0;\n        var inQuote = false;\n        var prevQuote = \"\";\n        var escape = false;\n        for(var _iterator = _create_for_of_iterator_helper_loose(string), _step; !(_step = _iterator()).done;){\n            var letter = _step.value;\n            if (escape) {\n                escape = false;\n            } else if (letter === \"\\\\\") {\n                escape = true;\n            } else if (inQuote) {\n                if (letter === prevQuote) {\n                    inQuote = false;\n                }\n            } else if (letter === '\"' || letter === \"'\") {\n                inQuote = true;\n                prevQuote = letter;\n            } else if (letter === \"(\") {\n                func += 1;\n            } else if (letter === \")\") {\n                if (func > 0) func -= 1;\n            } else if (func === 0) {\n                if (separators.includes(letter)) split = true;\n            }\n            if (split) {\n                if (current !== \"\") array.push(current.trim());\n                current = \"\";\n                split = false;\n            } else {\n                current += letter;\n            }\n        }\n        if (last || current !== \"\") array.push(current.trim());\n        return array;\n    }\n};\nvar list_1 = list$2;\nlist$2.default = list$2;\nvar Container$3 = container;\nvar list$1 = list_1;\nvar Rule$3 = /*#__PURE__*/ function(Container$3) {\n    _inherits(Rule2, Container$3);\n    function Rule2(defaults) {\n        var _this;\n        _this = Container$3.call(this, defaults) || this;\n        _this.type = \"rule\";\n        if (!_this.nodes) _this.nodes = [];\n        return _this;\n    }\n    _create_class(Rule2, [\n        {\n            key: \"selectors\",\n            get: function get() {\n                return list$1.comma(this.selector);\n            },\n            set: function set(values) {\n                var match = this.selector ? this.selector.match(/,\\s*/) : null;\n                var sep2 = match ? match[0] : \",\" + this.raw(\"between\", \"beforeOpen\");\n                this.selector = values.join(sep2);\n            }\n        }\n    ]);\n    return Rule2;\n}(Container$3);\nvar rule = Rule$3;\nRule$3.default = Rule$3;\nContainer$3.registerRule(Rule$3);\nvar Declaration$2 = declaration;\nvar tokenizer22 = tokenize;\nvar Comment$2 = comment;\nvar AtRule$2 = atRule;\nvar Root$4 = root;\nvar Rule$2 = rule;\nvar SAFE_COMMENT_NEIGHBOR = {\n    empty: true,\n    space: true\n};\nfunction findLastWithPosition(tokens) {\n    for(var i2 = tokens.length - 1; i2 >= 0; i2--){\n        var token = tokens[i2];\n        var pos = token[3] || token[2];\n        if (pos) return pos;\n    }\n}\nvar Parser$1 = /*#__PURE__*/ function() {\n    function Parser2(input2) {\n        this.input = input2;\n        this.root = new Root$4();\n        this.current = this.root;\n        this.spaces = \"\";\n        this.semicolon = false;\n        this.createTokenizer();\n        this.root.source = {\n            input: input2,\n            start: {\n                column: 1,\n                line: 1,\n                offset: 0\n            }\n        };\n    }\n    var _proto = Parser2.prototype;\n    _proto.atrule = function atrule(token) {\n        var node2 = new AtRule$2();\n        node2.name = token[1].slice(1);\n        if (node2.name === \"\") {\n            this.unnamedAtrule(node2, token);\n        }\n        this.init(node2, token[2]);\n        var type;\n        var prev;\n        var shift;\n        var last = false;\n        var open = false;\n        var params = [];\n        var brackets = [];\n        while(!this.tokenizer.endOfFile()){\n            token = this.tokenizer.nextToken();\n            type = token[0];\n            if (type === \"(\" || type === \"[\") {\n                brackets.push(type === \"(\" ? \")\" : \"]\");\n            } else if (type === \"{\" && brackets.length > 0) {\n                brackets.push(\"}\");\n            } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n            }\n            if (brackets.length === 0) {\n                if (type === \";\") {\n                    node2.source.end = this.getPosition(token[2]);\n                    node2.source.end.offset++;\n                    this.semicolon = true;\n                    break;\n                } else if (type === \"{\") {\n                    open = true;\n                    break;\n                } else if (type === \"}\") {\n                    if (params.length > 0) {\n                        shift = params.length - 1;\n                        prev = params[shift];\n                        while(prev && prev[0] === \"space\"){\n                            prev = params[--shift];\n                        }\n                        if (prev) {\n                            node2.source.end = this.getPosition(prev[3] || prev[2]);\n                            node2.source.end.offset++;\n                        }\n                    }\n                    this.end(token);\n                    break;\n                } else {\n                    params.push(token);\n                }\n            } else {\n                params.push(token);\n            }\n            if (this.tokenizer.endOfFile()) {\n                last = true;\n                break;\n            }\n        }\n        node2.raws.between = this.spacesAndCommentsFromEnd(params);\n        if (params.length) {\n            node2.raws.afterName = this.spacesAndCommentsFromStart(params);\n            this.raw(node2, \"params\", params);\n            if (last) {\n                token = params[params.length - 1];\n                node2.source.end = this.getPosition(token[3] || token[2]);\n                node2.source.end.offset++;\n                this.spaces = node2.raws.between;\n                node2.raws.between = \"\";\n            }\n        } else {\n            node2.raws.afterName = \"\";\n            node2.params = \"\";\n        }\n        if (open) {\n            node2.nodes = [];\n            this.current = node2;\n        }\n    };\n    _proto.checkMissedSemicolon = function checkMissedSemicolon(tokens) {\n        var colon = this.colon(tokens);\n        if (colon === false) return;\n        var founded = 0;\n        var token;\n        for(var j = colon - 1; j >= 0; j--){\n            token = tokens[j];\n            if (token[0] !== \"space\") {\n                founded += 1;\n                if (founded === 2) break;\n            }\n        }\n        throw this.input.error(\"Missed semicolon\", token[0] === \"word\" ? token[3] + 1 : token[2]);\n    };\n    _proto.colon = function colon(tokens) {\n        var brackets = 0;\n        var token, type, prev;\n        for(var _iterator = _create_for_of_iterator_helper_loose(tokens.entries()), _step; !(_step = _iterator()).done;){\n            var _step_value = _step.value, i2 = _step_value[0], element = _step_value[1];\n            token = element;\n            type = token[0];\n            if (type === \"(\") {\n                brackets += 1;\n            }\n            if (type === \")\") {\n                brackets -= 1;\n            }\n            if (brackets === 0 && type === \":\") {\n                if (!prev) {\n                    this.doubleColon(token);\n                } else if (prev[0] === \"word\" && prev[1] === \"progid\") {\n                    continue;\n                } else {\n                    return i2;\n                }\n            }\n            prev = token;\n        }\n        return false;\n    };\n    _proto.comment = function comment(token) {\n        var node2 = new Comment$2();\n        this.init(node2, token[2]);\n        node2.source.end = this.getPosition(token[3] || token[2]);\n        node2.source.end.offset++;\n        var text = token[1].slice(2, -2);\n        if (/^\\s*$/.test(text)) {\n            node2.text = \"\";\n            node2.raws.left = text;\n            node2.raws.right = \"\";\n        } else {\n            var match = text.match(/^(\\s*)([^]*\\S)(\\s*)$/);\n            node2.text = match[2];\n            node2.raws.left = match[1];\n            node2.raws.right = match[3];\n        }\n    };\n    _proto.createTokenizer = function createTokenizer() {\n        this.tokenizer = tokenizer22(this.input);\n    };\n    _proto.decl = function decl(tokens, customProperty) {\n        var node2 = new Declaration$2();\n        this.init(node2, tokens[0][2]);\n        var last = tokens[tokens.length - 1];\n        if (last[0] === \";\") {\n            this.semicolon = true;\n            tokens.pop();\n        }\n        node2.source.end = this.getPosition(last[3] || last[2] || findLastWithPosition(tokens));\n        node2.source.end.offset++;\n        while(tokens[0][0] !== \"word\"){\n            if (tokens.length === 1) this.unknownWord(tokens);\n            node2.raws.before += tokens.shift()[1];\n        }\n        node2.source.start = this.getPosition(tokens[0][2]);\n        node2.prop = \"\";\n        while(tokens.length){\n            var type = tokens[0][0];\n            if (type === \":\" || type === \"space\" || type === \"comment\") {\n                break;\n            }\n            node2.prop += tokens.shift()[1];\n        }\n        node2.raws.between = \"\";\n        var token;\n        while(tokens.length){\n            token = tokens.shift();\n            if (token[0] === \":\") {\n                node2.raws.between += token[1];\n                break;\n            } else {\n                if (token[0] === \"word\" && /\\w/.test(token[1])) {\n                    this.unknownWord([\n                        token\n                    ]);\n                }\n                node2.raws.between += token[1];\n            }\n        }\n        if (node2.prop[0] === \"_\" || node2.prop[0] === \"*\") {\n            node2.raws.before += node2.prop[0];\n            node2.prop = node2.prop.slice(1);\n        }\n        var firstSpaces = [];\n        var next;\n        while(tokens.length){\n            next = tokens[0][0];\n            if (next !== \"space\" && next !== \"comment\") break;\n            firstSpaces.push(tokens.shift());\n        }\n        this.precheckMissedSemicolon(tokens);\n        for(var i2 = tokens.length - 1; i2 >= 0; i2--){\n            token = tokens[i2];\n            if (token[1].toLowerCase() === \"!important\") {\n                node2.important = true;\n                var string = this.stringFrom(tokens, i2);\n                string = this.spacesFromEnd(tokens) + string;\n                if (string !== \" !important\") node2.raws.important = string;\n                break;\n            } else if (token[1].toLowerCase() === \"important\") {\n                var cache = tokens.slice(0);\n                var str = \"\";\n                for(var j = i2; j > 0; j--){\n                    var type1 = cache[j][0];\n                    if (str.trim().indexOf(\"!\") === 0 && type1 !== \"space\") {\n                        break;\n                    }\n                    str = cache.pop()[1] + str;\n                }\n                if (str.trim().indexOf(\"!\") === 0) {\n                    node2.important = true;\n                    node2.raws.important = str;\n                    tokens = cache;\n                }\n            }\n            if (token[0] !== \"space\" && token[0] !== \"comment\") {\n                break;\n            }\n        }\n        var hasWord = tokens.some(function(i2) {\n            return i2[0] !== \"space\" && i2[0] !== \"comment\";\n        });\n        if (hasWord) {\n            node2.raws.between += firstSpaces.map(function(i2) {\n                return i2[1];\n            }).join(\"\");\n            firstSpaces = [];\n        }\n        this.raw(node2, \"value\", firstSpaces.concat(tokens), customProperty);\n        if (node2.value.includes(\":\") && !customProperty) {\n            this.checkMissedSemicolon(tokens);\n        }\n    };\n    _proto.doubleColon = function doubleColon(token) {\n        throw this.input.error(\"Double colon\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + token[1].length\n        });\n    };\n    _proto.emptyRule = function emptyRule(token) {\n        var node2 = new Rule$2();\n        this.init(node2, token[2]);\n        node2.selector = \"\";\n        node2.raws.between = \"\";\n        this.current = node2;\n    };\n    _proto.end = function end(token) {\n        if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.semicolon = false;\n        this.current.raws.after = (this.current.raws.after || \"\") + this.spaces;\n        this.spaces = \"\";\n        if (this.current.parent) {\n            this.current.source.end = this.getPosition(token[2]);\n            this.current.source.end.offset++;\n            this.current = this.current.parent;\n        } else {\n            this.unexpectedClose(token);\n        }\n    };\n    _proto.endFile = function endFile() {\n        if (this.current.parent) this.unclosedBlock();\n        if (this.current.nodes && this.current.nodes.length) {\n            this.current.raws.semicolon = this.semicolon;\n        }\n        this.current.raws.after = (this.current.raws.after || \"\") + this.spaces;\n        this.root.source.end = this.getPosition(this.tokenizer.position());\n    };\n    _proto.freeSemicolon = function freeSemicolon(token) {\n        this.spaces += token[1];\n        if (this.current.nodes) {\n            var prev = this.current.nodes[this.current.nodes.length - 1];\n            if (prev && prev.type === \"rule\" && !prev.raws.ownSemicolon) {\n                prev.raws.ownSemicolon = this.spaces;\n                this.spaces = \"\";\n            }\n        }\n    };\n    // Helpers\n    _proto.getPosition = function getPosition(offset) {\n        var pos = this.input.fromOffset(offset);\n        return {\n            column: pos.col,\n            line: pos.line,\n            offset: offset\n        };\n    };\n    _proto.init = function init(node2, offset) {\n        this.current.push(node2);\n        node2.source = {\n            input: this.input,\n            start: this.getPosition(offset)\n        };\n        node2.raws.before = this.spaces;\n        this.spaces = \"\";\n        if (node2.type !== \"comment\") this.semicolon = false;\n    };\n    _proto.other = function other(start) {\n        var end = false;\n        var type = null;\n        var colon = false;\n        var bracket = null;\n        var brackets = [];\n        var customProperty = start[1].startsWith(\"--\");\n        var tokens = [];\n        var token = start;\n        while(token){\n            type = token[0];\n            tokens.push(token);\n            if (type === \"(\" || type === \"[\") {\n                if (!bracket) bracket = token;\n                brackets.push(type === \"(\" ? \")\" : \"]\");\n            } else if (customProperty && colon && type === \"{\") {\n                if (!bracket) bracket = token;\n                brackets.push(\"}\");\n            } else if (brackets.length === 0) {\n                if (type === \";\") {\n                    if (colon) {\n                        this.decl(tokens, customProperty);\n                        return;\n                    } else {\n                        break;\n                    }\n                } else if (type === \"{\") {\n                    this.rule(tokens);\n                    return;\n                } else if (type === \"}\") {\n                    this.tokenizer.back(tokens.pop());\n                    end = true;\n                    break;\n                } else if (type === \":\") {\n                    colon = true;\n                }\n            } else if (type === brackets[brackets.length - 1]) {\n                brackets.pop();\n                if (brackets.length === 0) bracket = null;\n            }\n            token = this.tokenizer.nextToken();\n        }\n        if (this.tokenizer.endOfFile()) end = true;\n        if (brackets.length > 0) this.unclosedBracket(bracket);\n        if (end && colon) {\n            if (!customProperty) {\n                while(tokens.length){\n                    token = tokens[tokens.length - 1][0];\n                    if (token !== \"space\" && token !== \"comment\") break;\n                    this.tokenizer.back(tokens.pop());\n                }\n            }\n            this.decl(tokens, customProperty);\n        } else {\n            this.unknownWord(tokens);\n        }\n    };\n    _proto.parse = function parse() {\n        var token;\n        while(!this.tokenizer.endOfFile()){\n            token = this.tokenizer.nextToken();\n            switch(token[0]){\n                case \"space\":\n                    this.spaces += token[1];\n                    break;\n                case \";\":\n                    this.freeSemicolon(token);\n                    break;\n                case \"}\":\n                    this.end(token);\n                    break;\n                case \"comment\":\n                    this.comment(token);\n                    break;\n                case \"at-word\":\n                    this.atrule(token);\n                    break;\n                case \"{\":\n                    this.emptyRule(token);\n                    break;\n                default:\n                    this.other(token);\n                    break;\n            }\n        }\n        this.endFile();\n    };\n    _proto.precheckMissedSemicolon = function precheckMissedSemicolon() {};\n    _proto.raw = function raw(node2, prop, tokens, customProperty) {\n        var token, type;\n        var length = tokens.length;\n        var value = \"\";\n        var clean = true;\n        var next, prev;\n        for(var i2 = 0; i2 < length; i2 += 1){\n            token = tokens[i2];\n            type = token[0];\n            if (type === \"space\" && i2 === length - 1 && !customProperty) {\n                clean = false;\n            } else if (type === \"comment\") {\n                prev = tokens[i2 - 1] ? tokens[i2 - 1][0] : \"empty\";\n                next = tokens[i2 + 1] ? tokens[i2 + 1][0] : \"empty\";\n                if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {\n                    if (value.slice(-1) === \",\") {\n                        clean = false;\n                    } else {\n                        value += token[1];\n                    }\n                } else {\n                    clean = false;\n                }\n            } else {\n                value += token[1];\n            }\n        }\n        if (!clean) {\n            var raw = tokens.reduce(function(all, i2) {\n                return all + i2[1];\n            }, \"\");\n            node2.raws[prop] = {\n                raw: raw,\n                value: value\n            };\n        }\n        node2[prop] = value;\n    };\n    _proto.rule = function rule(tokens) {\n        tokens.pop();\n        var node2 = new Rule$2();\n        this.init(node2, tokens[0][2]);\n        node2.raws.between = this.spacesAndCommentsFromEnd(tokens);\n        this.raw(node2, \"selector\", tokens);\n        this.current = node2;\n    };\n    _proto.spacesAndCommentsFromEnd = function spacesAndCommentsFromEnd(tokens) {\n        var lastTokenType;\n        var spaces = \"\";\n        while(tokens.length){\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== \"space\" && lastTokenType !== \"comment\") break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    };\n    // Errors\n    _proto.spacesAndCommentsFromStart = function spacesAndCommentsFromStart(tokens) {\n        var next;\n        var spaces = \"\";\n        while(tokens.length){\n            next = tokens[0][0];\n            if (next !== \"space\" && next !== \"comment\") break;\n            spaces += tokens.shift()[1];\n        }\n        return spaces;\n    };\n    _proto.spacesFromEnd = function spacesFromEnd(tokens) {\n        var lastTokenType;\n        var spaces = \"\";\n        while(tokens.length){\n            lastTokenType = tokens[tokens.length - 1][0];\n            if (lastTokenType !== \"space\") break;\n            spaces = tokens.pop()[1] + spaces;\n        }\n        return spaces;\n    };\n    _proto.stringFrom = function stringFrom(tokens, from) {\n        var result2 = \"\";\n        for(var i2 = from; i2 < tokens.length; i2++){\n            result2 += tokens[i2][1];\n        }\n        tokens.splice(from, tokens.length - from);\n        return result2;\n    };\n    _proto.unclosedBlock = function unclosedBlock() {\n        var pos = this.current.source.start;\n        throw this.input.error(\"Unclosed block\", pos.line, pos.column);\n    };\n    _proto.unclosedBracket = function unclosedBracket(bracket) {\n        throw this.input.error(\"Unclosed bracket\", {\n            offset: bracket[2]\n        }, {\n            offset: bracket[2] + 1\n        });\n    };\n    _proto.unexpectedClose = function unexpectedClose(token) {\n        throw this.input.error(\"Unexpected }\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + 1\n        });\n    };\n    _proto.unknownWord = function unknownWord(tokens) {\n        throw this.input.error(\"Unknown word\", {\n            offset: tokens[0][2]\n        }, {\n            offset: tokens[0][2] + tokens[0][1].length\n        });\n    };\n    _proto.unnamedAtrule = function unnamedAtrule(node2, token) {\n        throw this.input.error(\"At-rule without name\", {\n            offset: token[2]\n        }, {\n            offset: token[2] + token[1].length\n        });\n    };\n    return Parser2;\n}();\nvar parser = Parser$1;\nvar Container$2 = container;\nvar Parser22 = parser;\nvar Input$2 = input;\nfunction parse$3(css, opts) {\n    var input2 = new Input$2(css, opts);\n    var parser2 = new Parser22(input2);\n    try {\n        parser2.parse();\n    } catch (e2) {\n        if (true) {\n            if (e2.name === \"CssSyntaxError\" && opts && opts.from) {\n                if (/\\.scss$/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser\";\n                } else if (/\\.sass/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser\";\n                } else if (/\\.less$/i.test(opts.from)) {\n                    e2.message += \"\\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser\";\n                }\n            }\n        }\n        throw e2;\n    }\n    return parser2.root;\n}\nvar parse_1 = parse$3;\nparse$3.default = parse$3;\nContainer$2.registerParse(parse$3);\nvar isClean = symbols.isClean, my = symbols.my;\nvar MapGenerator$1 = mapGenerator;\nvar stringify$2 = stringify_1;\nvar Container$1 = container;\nvar Document$2 = document$1$2;\nvar warnOnce$1 = warnOnce$2;\nvar Result$2 = result;\nvar parse$2 = parse_1;\nvar Root$3 = root;\nvar TYPE_TO_CLASS_NAME = {\n    atrule: \"AtRule\",\n    comment: \"Comment\",\n    decl: \"Declaration\",\n    document: \"Document\",\n    root: \"Root\",\n    rule: \"Rule\"\n};\nvar PLUGIN_PROPS = {\n    AtRule: true,\n    AtRuleExit: true,\n    Comment: true,\n    CommentExit: true,\n    Declaration: true,\n    DeclarationExit: true,\n    Document: true,\n    DocumentExit: true,\n    Once: true,\n    OnceExit: true,\n    postcssPlugin: true,\n    prepare: true,\n    Root: true,\n    RootExit: true,\n    Rule: true,\n    RuleExit: true\n};\nvar NOT_VISITORS = {\n    Once: true,\n    postcssPlugin: true,\n    prepare: true\n};\nvar CHILDREN = 0;\nfunction isPromise(obj) {\n    return (typeof obj === \"undefined\" ? \"undefined\" : _type_of(obj)) === \"object\" && typeof obj.then === \"function\";\n}\nfunction getEvents(node2) {\n    var key = false;\n    var type = TYPE_TO_CLASS_NAME[node2.type];\n    if (node2.type === \"decl\") {\n        key = node2.prop.toLowerCase();\n    } else if (node2.type === \"atrule\") {\n        key = node2.name.toLowerCase();\n    }\n    if (key && node2.append) {\n        return [\n            type,\n            type + \"-\" + key,\n            CHILDREN,\n            type + \"Exit\",\n            type + \"Exit-\" + key\n        ];\n    } else if (key) {\n        return [\n            type,\n            type + \"-\" + key,\n            type + \"Exit\",\n            type + \"Exit-\" + key\n        ];\n    } else if (node2.append) {\n        return [\n            type,\n            CHILDREN,\n            type + \"Exit\"\n        ];\n    } else {\n        return [\n            type,\n            type + \"Exit\"\n        ];\n    }\n}\nfunction toStack(node2) {\n    var events;\n    if (node2.type === \"document\") {\n        events = [\n            \"Document\",\n            CHILDREN,\n            \"DocumentExit\"\n        ];\n    } else if (node2.type === \"root\") {\n        events = [\n            \"Root\",\n            CHILDREN,\n            \"RootExit\"\n        ];\n    } else {\n        events = getEvents(node2);\n    }\n    return {\n        eventIndex: 0,\n        events: events,\n        iterator: 0,\n        node: node2,\n        visitorIndex: 0,\n        visitors: []\n    };\n}\nfunction cleanMarks(node2) {\n    node2[isClean] = false;\n    if (node2.nodes) node2.nodes.forEach(function(i2) {\n        return cleanMarks(i2);\n    });\n    return node2;\n}\nvar postcss$2 = {};\nvar LazyResult$2 = /*#__PURE__*/ function() {\n    function LazyResult2(processor2, css, opts) {\n        var _this = this;\n        this.stringified = false;\n        this.processed = false;\n        var root2;\n        if ((typeof css === \"undefined\" ? \"undefined\" : _type_of(css)) === \"object\" && css !== null && (css.type === \"root\" || css.type === \"document\")) {\n            root2 = cleanMarks(css);\n        } else if (_instanceof(css, LazyResult2) || _instanceof(css, Result$2)) {\n            root2 = cleanMarks(css.root);\n            if (css.map) {\n                if (typeof opts.map === \"undefined\") opts.map = {};\n                if (!opts.map.inline) opts.map.inline = false;\n                opts.map.prev = css.map;\n            }\n        } else {\n            var parser2 = parse$2;\n            if (opts.syntax) parser2 = opts.syntax.parse;\n            if (opts.parser) parser2 = opts.parser;\n            if (parser2.parse) parser2 = parser2.parse;\n            try {\n                root2 = parser2(css, opts);\n            } catch (error) {\n                this.processed = true;\n                this.error = error;\n            }\n            if (root2 && !root2[my]) {\n                Container$1.rebuild(root2);\n            }\n        }\n        this.result = new Result$2(processor2, root2, opts);\n        this.helpers = _extends({}, postcss$2, {\n            postcss: postcss$2,\n            result: this.result\n        });\n        this.plugins = this.processor.plugins.map(function(plugin22) {\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\" && plugin22.prepare) {\n                return _extends({}, plugin22, plugin22.prepare(_this.result));\n            } else {\n                return plugin22;\n            }\n        });\n    }\n    var _proto = LazyResult2.prototype;\n    _proto.async = function async() {\n        if (this.error) return Promise.reject(this.error);\n        if (this.processed) return Promise.resolve(this.result);\n        if (!this.processing) {\n            this.processing = this.runAsync();\n        }\n        return this.processing;\n    };\n    _proto.catch = function _catch(onRejected) {\n        return this.async().catch(onRejected);\n    };\n    _proto.finally = function _finally(onFinally) {\n        return this.async().then(onFinally, onFinally);\n    };\n    _proto.getAsyncError = function getAsyncError() {\n        throw new Error(\"Use process(css).then(cb) to work with async plugins\");\n    };\n    _proto.handleError = function handleError(error, node2) {\n        var plugin22 = this.result.lastPlugin;\n        try {\n            if (node2) node2.addToError(error);\n            this.error = error;\n            if (error.name === \"CssSyntaxError\" && !error.plugin) {\n                error.plugin = plugin22.postcssPlugin;\n                error.setMessage();\n            } else if (plugin22.postcssVersion) {\n                if (true) {\n                    var pluginName = plugin22.postcssPlugin;\n                    var pluginVer = plugin22.postcssVersion;\n                    var runtimeVer = this.result.processor.version;\n                    var a2 = pluginVer.split(\".\");\n                    var b = runtimeVer.split(\".\");\n                    if (a2[0] !== b[0] || parseInt(a2[1]) > parseInt(b[1])) {\n                        console.error(\"Unknown error from PostCSS plugin. Your current PostCSS version is \" + runtimeVer + \", but \" + pluginName + \" uses \" + pluginVer + \". Perhaps this is the source of the error below.\");\n                    }\n                }\n            }\n        } catch (err) {\n            if (console && console.error) console.error(err);\n        }\n        return error;\n    };\n    _proto.prepareVisitors = function prepareVisitors() {\n        var _this = this;\n        this.listeners = {};\n        var add = function(plugin22, type, cb) {\n            if (!_this.listeners[type]) _this.listeners[type] = [];\n            _this.listeners[type].push([\n                plugin22,\n                cb\n            ]);\n        };\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.plugins), _step; !(_step = _iterator()).done;){\n            var plugin22 = _step.value;\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\") {\n                for(var event in plugin22){\n                    if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {\n                        throw new Error(\"Unknown event \" + event + \" in \" + plugin22.postcssPlugin + \". Try to update PostCSS (\" + this.processor.version + \" now).\");\n                    }\n                    if (!NOT_VISITORS[event]) {\n                        if (_type_of(plugin22[event]) === \"object\") {\n                            for(var filter in plugin22[event]){\n                                if (filter === \"*\") {\n                                    add(plugin22, event, plugin22[event][filter]);\n                                } else {\n                                    add(plugin22, event + \"-\" + filter.toLowerCase(), plugin22[event][filter]);\n                                }\n                            }\n                        } else if (typeof plugin22[event] === \"function\") {\n                            add(plugin22, event, plugin22[event]);\n                        }\n                    }\n                }\n            }\n        }\n        this.hasListener = Object.keys(this.listeners).length > 0;\n    };\n    _proto.runAsync = function runAsync() {\n        var _this = this;\n        return _async_to_generator(function() {\n            var i2, plugin22, promise, error, root2, stack, promise1, e2, node2, _loop, _iterator, _step;\n            return _ts_generator(this, function(_state) {\n                switch(_state.label){\n                    case 0:\n                        _this.plugin = 0;\n                        i2 = 0;\n                        _state.label = 1;\n                    case 1:\n                        if (!(i2 < _this.plugins.length)) return [\n                            3,\n                            6\n                        ];\n                        plugin22 = _this.plugins[i2];\n                        promise = _this.runOnRoot(plugin22);\n                        if (!isPromise(promise)) return [\n                            3,\n                            5\n                        ];\n                        _state.label = 2;\n                    case 2:\n                        _state.trys.push([\n                            2,\n                            4,\n                            ,\n                            5\n                        ]);\n                        return [\n                            4,\n                            promise\n                        ];\n                    case 3:\n                        _state.sent();\n                        return [\n                            3,\n                            5\n                        ];\n                    case 4:\n                        error = _state.sent();\n                        throw _this.handleError(error);\n                    case 5:\n                        i2++;\n                        return [\n                            3,\n                            1\n                        ];\n                    case 6:\n                        _this.prepareVisitors();\n                        if (!_this.hasListener) return [\n                            3,\n                            18\n                        ];\n                        root2 = _this.result.root;\n                        _state.label = 7;\n                    case 7:\n                        if (!!root2[isClean]) return [\n                            3,\n                            14\n                        ];\n                        root2[isClean] = true;\n                        stack = [\n                            toStack(root2)\n                        ];\n                        _state.label = 8;\n                    case 8:\n                        if (!(stack.length > 0)) return [\n                            3,\n                            13\n                        ];\n                        promise1 = _this.visitTick(stack);\n                        if (!isPromise(promise1)) return [\n                            3,\n                            12\n                        ];\n                        _state.label = 9;\n                    case 9:\n                        _state.trys.push([\n                            9,\n                            11,\n                            ,\n                            12\n                        ]);\n                        return [\n                            4,\n                            promise1\n                        ];\n                    case 10:\n                        _state.sent();\n                        return [\n                            3,\n                            12\n                        ];\n                    case 11:\n                        e2 = _state.sent();\n                        node2 = stack[stack.length - 1].node;\n                        throw _this.handleError(e2, node2);\n                    case 12:\n                        return [\n                            3,\n                            8\n                        ];\n                    case 13:\n                        return [\n                            3,\n                            7\n                        ];\n                    case 14:\n                        if (!_this.listeners.OnceExit) return [\n                            3,\n                            18\n                        ];\n                        _loop = function() {\n                            var _step_value, plugin22, visitor, roots, e2;\n                            return _ts_generator(this, function(_state) {\n                                switch(_state.label){\n                                    case 0:\n                                        _step_value = _step.value, plugin22 = _step_value[0], visitor = _step_value[1];\n                                        _this.result.lastPlugin = plugin22;\n                                        _state.label = 1;\n                                    case 1:\n                                        _state.trys.push([\n                                            1,\n                                            6,\n                                            ,\n                                            7\n                                        ]);\n                                        if (!(root2.type === \"document\")) return [\n                                            3,\n                                            3\n                                        ];\n                                        roots = root2.nodes.map(function(subRoot) {\n                                            return visitor(subRoot, _this.helpers);\n                                        });\n                                        return [\n                                            4,\n                                            Promise.all(roots)\n                                        ];\n                                    case 2:\n                                        _state.sent();\n                                        return [\n                                            3,\n                                            5\n                                        ];\n                                    case 3:\n                                        return [\n                                            4,\n                                            visitor(root2, _this.helpers)\n                                        ];\n                                    case 4:\n                                        _state.sent();\n                                        _state.label = 5;\n                                    case 5:\n                                        return [\n                                            3,\n                                            7\n                                        ];\n                                    case 6:\n                                        e2 = _state.sent();\n                                        throw _this.handleError(e2);\n                                    case 7:\n                                        return [\n                                            2\n                                        ];\n                                }\n                            });\n                        };\n                        _iterator = _create_for_of_iterator_helper_loose(_this.listeners.OnceExit);\n                        _state.label = 15;\n                    case 15:\n                        if (!!(_step = _iterator()).done) return [\n                            3,\n                            18\n                        ];\n                        return [\n                            5,\n                            _ts_values(_loop())\n                        ];\n                    case 16:\n                        _state.sent();\n                        _state.label = 17;\n                    case 17:\n                        return [\n                            3,\n                            15\n                        ];\n                    case 18:\n                        _this.processed = true;\n                        return [\n                            2,\n                            _this.stringify()\n                        ];\n                }\n            });\n        })();\n    };\n    _proto.runOnRoot = function runOnRoot(plugin22) {\n        var _this = this;\n        this.result.lastPlugin = plugin22;\n        try {\n            if ((typeof plugin22 === \"undefined\" ? \"undefined\" : _type_of(plugin22)) === \"object\" && plugin22.Once) {\n                if (this.result.root.type === \"document\") {\n                    var roots = this.result.root.nodes.map(function(root2) {\n                        return plugin22.Once(root2, _this.helpers);\n                    });\n                    if (isPromise(roots[0])) {\n                        return Promise.all(roots);\n                    }\n                    return roots;\n                }\n                return plugin22.Once(this.result.root, this.helpers);\n            } else if (typeof plugin22 === \"function\") {\n                return plugin22(this.result.root, this.result);\n            }\n        } catch (error) {\n            throw this.handleError(error);\n        }\n    };\n    _proto.stringify = function stringify() {\n        if (this.error) throw this.error;\n        if (this.stringified) return this.result;\n        this.stringified = true;\n        this.sync();\n        var opts = this.result.opts;\n        var str = stringify$2;\n        if (opts.syntax) str = opts.syntax.stringify;\n        if (opts.stringifier) str = opts.stringifier;\n        if (str.stringify) str = str.stringify;\n        var map = new MapGenerator$1(str, this.result.root, this.result.opts);\n        var data = map.generate();\n        this.result.css = data[0];\n        this.result.map = data[1];\n        return this.result;\n    };\n    _proto.sync = function sync() {\n        if (this.error) throw this.error;\n        if (this.processed) return this.result;\n        this.processed = true;\n        if (this.processing) {\n            throw this.getAsyncError();\n        }\n        for(var _iterator = _create_for_of_iterator_helper_loose(this.plugins), _step; !(_step = _iterator()).done;){\n            var plugin22 = _step.value;\n            var promise = this.runOnRoot(plugin22);\n            if (isPromise(promise)) {\n                throw this.getAsyncError();\n            }\n        }\n        this.prepareVisitors();\n        if (this.hasListener) {\n            var root2 = this.result.root;\n            while(!root2[isClean]){\n                root2[isClean] = true;\n                this.walkSync(root2);\n            }\n            if (this.listeners.OnceExit) {\n                if (root2.type === \"document\") {\n                    for(var _iterator1 = _create_for_of_iterator_helper_loose(root2.nodes), _step1; !(_step1 = _iterator1()).done;){\n                        var subRoot = _step1.value;\n                        this.visitSync(this.listeners.OnceExit, subRoot);\n                    }\n                } else {\n                    this.visitSync(this.listeners.OnceExit, root2);\n                }\n            }\n        }\n        return this.result;\n    };\n    _proto.then = function then(onFulfilled, onRejected) {\n        if (true) {\n            if (!(\"from\" in this.opts)) {\n                warnOnce$1(\"Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.\");\n            }\n        }\n        return this.async().then(onFulfilled, onRejected);\n    };\n    _proto.toString = function toString() {\n        return this.css;\n    };\n    _proto.visitSync = function visitSync(visitors, node2) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(visitors), _step; !(_step = _iterator()).done;){\n            var _step_value = _step.value, plugin22 = _step_value[0], visitor = _step_value[1];\n            this.result.lastPlugin = plugin22;\n            var promise = void 0;\n            try {\n                promise = visitor(node2, this.helpers);\n            } catch (e2) {\n                throw this.handleError(e2, node2.proxyOf);\n            }\n            if (node2.type !== \"root\" && node2.type !== \"document\" && !node2.parent) {\n                return true;\n            }\n            if (isPromise(promise)) {\n                throw this.getAsyncError();\n            }\n        }\n    };\n    _proto.visitTick = function visitTick(stack) {\n        var visit2 = stack[stack.length - 1];\n        var node2 = visit2.node, visitors = visit2.visitors;\n        if (node2.type !== \"root\" && node2.type !== \"document\" && !node2.parent) {\n            stack.pop();\n            return;\n        }\n        if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {\n            var _visitors_visit2_visitorIndex = visitors[visit2.visitorIndex], plugin22 = _visitors_visit2_visitorIndex[0], visitor = _visitors_visit2_visitorIndex[1];\n            visit2.visitorIndex += 1;\n            if (visit2.visitorIndex === visitors.length) {\n                visit2.visitors = [];\n                visit2.visitorIndex = 0;\n            }\n            this.result.lastPlugin = plugin22;\n            try {\n                return visitor(node2.toProxy(), this.helpers);\n            } catch (e2) {\n                throw this.handleError(e2, node2);\n            }\n        }\n        if (visit2.iterator !== 0) {\n            var iterator = visit2.iterator;\n            var child;\n            while(child = node2.nodes[node2.indexes[iterator]]){\n                node2.indexes[iterator] += 1;\n                if (!child[isClean]) {\n                    child[isClean] = true;\n                    stack.push(toStack(child));\n                    return;\n                }\n            }\n            visit2.iterator = 0;\n            delete node2.indexes[iterator];\n        }\n        var events = visit2.events;\n        while(visit2.eventIndex < events.length){\n            var event = events[visit2.eventIndex];\n            visit2.eventIndex += 1;\n            if (event === CHILDREN) {\n                if (node2.nodes && node2.nodes.length) {\n                    node2[isClean] = true;\n                    visit2.iterator = node2.getIterator();\n                }\n                return;\n            } else if (this.listeners[event]) {\n                visit2.visitors = this.listeners[event];\n                return;\n            }\n        }\n        stack.pop();\n    };\n    _proto.walkSync = function walkSync(node2) {\n        var _this = this;\n        node2[isClean] = true;\n        var events = getEvents(node2);\n        for(var _iterator = _create_for_of_iterator_helper_loose(events), _step; !(_step = _iterator()).done;){\n            var event = _step.value;\n            if (event === CHILDREN) {\n                if (node2.nodes) {\n                    node2.each(function(child) {\n                        if (!child[isClean]) _this.walkSync(child);\n                    });\n                }\n            } else {\n                var visitors = this.listeners[event];\n                if (visitors) {\n                    if (this.visitSync(visitors, node2.toProxy())) return;\n                }\n            }\n        }\n    };\n    _proto.warnings = function warnings() {\n        return this.sync().warnings();\n    };\n    _create_class(LazyResult2, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.stringify().content;\n            }\n        },\n        {\n            key: \"css\",\n            get: function get() {\n                return this.stringify().css;\n            }\n        },\n        {\n            key: \"map\",\n            get: function get() {\n                return this.stringify().map;\n            }\n        },\n        {\n            key: \"messages\",\n            get: function get() {\n                return this.sync().messages;\n            }\n        },\n        {\n            key: \"opts\",\n            get: function get() {\n                return this.result.opts;\n            }\n        },\n        {\n            key: \"processor\",\n            get: function get() {\n                return this.result.processor;\n            }\n        },\n        {\n            key: \"root\",\n            get: function get() {\n                return this.sync().root;\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"LazyResult\";\n            }\n        }\n    ]);\n    return LazyResult2;\n}();\nLazyResult$2.registerPostcss = function(dependant) {\n    postcss$2 = dependant;\n};\nvar lazyResult = LazyResult$2;\nLazyResult$2.default = LazyResult$2;\nRoot$3.registerLazyResult(LazyResult$2);\nDocument$2.registerLazyResult(LazyResult$2);\nvar MapGenerator22 = mapGenerator;\nvar stringify$1 = stringify_1;\nvar warnOnce22 = warnOnce$2;\nvar parse$1 = parse_1;\nvar Result$1 = result;\nvar NoWorkResult$1 = /*#__PURE__*/ function() {\n    function NoWorkResult2(processor2, css, opts) {\n        css = css.toString();\n        this.stringified = false;\n        this._processor = processor2;\n        this._css = css;\n        this._opts = opts;\n        this._map = void 0;\n        var root2;\n        var str = stringify$1;\n        this.result = new Result$1(this._processor, root2, this._opts);\n        this.result.css = css;\n        var self = this;\n        Object.defineProperty(this.result, \"root\", {\n            get: function get() {\n                return self.root;\n            }\n        });\n        var map = new MapGenerator22(str, root2, this._opts, css);\n        if (map.isMap()) {\n            var _map_generate = map.generate(), generatedCSS = _map_generate[0], generatedMap = _map_generate[1];\n            if (generatedCSS) {\n                this.result.css = generatedCSS;\n            }\n            if (generatedMap) {\n                this.result.map = generatedMap;\n            }\n        } else {\n            map.clearAnnotation();\n            this.result.css = map.css;\n        }\n    }\n    var _proto = NoWorkResult2.prototype;\n    _proto.async = function async() {\n        if (this.error) return Promise.reject(this.error);\n        return Promise.resolve(this.result);\n    };\n    _proto.catch = function _catch(onRejected) {\n        return this.async().catch(onRejected);\n    };\n    _proto.finally = function _finally(onFinally) {\n        return this.async().then(onFinally, onFinally);\n    };\n    _proto.sync = function sync() {\n        if (this.error) throw this.error;\n        return this.result;\n    };\n    _proto.then = function then(onFulfilled, onRejected) {\n        if (true) {\n            if (!(\"from\" in this._opts)) {\n                warnOnce22(\"Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning.\");\n            }\n        }\n        return this.async().then(onFulfilled, onRejected);\n    };\n    _proto.toString = function toString() {\n        return this._css;\n    };\n    _proto.warnings = function warnings() {\n        return [];\n    };\n    _create_class(NoWorkResult2, [\n        {\n            key: \"content\",\n            get: function get() {\n                return this.result.css;\n            }\n        },\n        {\n            key: \"css\",\n            get: function get() {\n                return this.result.css;\n            }\n        },\n        {\n            key: \"map\",\n            get: function get() {\n                return this.result.map;\n            }\n        },\n        {\n            key: \"messages\",\n            get: function get() {\n                return [];\n            }\n        },\n        {\n            key: \"opts\",\n            get: function get() {\n                return this.result.opts;\n            }\n        },\n        {\n            key: \"processor\",\n            get: function get() {\n                return this.result.processor;\n            }\n        },\n        {\n            key: \"root\",\n            get: function get() {\n                if (this._root) {\n                    return this._root;\n                }\n                var root2;\n                var parser2 = parse$1;\n                try {\n                    root2 = parser2(this._css, this._opts);\n                } catch (error) {\n                    this.error = error;\n                }\n                if (this.error) {\n                    throw this.error;\n                } else {\n                    this._root = root2;\n                    return root2;\n                }\n            }\n        },\n        {\n            key: Symbol.toStringTag,\n            get: function get() {\n                return \"NoWorkResult\";\n            }\n        }\n    ]);\n    return NoWorkResult2;\n}();\nvar noWorkResult = NoWorkResult$1;\nNoWorkResult$1.default = NoWorkResult$1;\nvar NoWorkResult22 = noWorkResult;\nvar LazyResult$1 = lazyResult;\nvar Document$1 = document$1$2;\nvar Root$2 = root;\nvar Processor$1 = /*#__PURE__*/ function() {\n    function Processor2(plugins) {\n        if (plugins === void 0) plugins = [];\n        this.version = \"8.4.38\";\n        this.plugins = this.normalize(plugins);\n    }\n    var _proto = Processor2.prototype;\n    _proto.normalize = function normalize(plugins) {\n        var normalized = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(plugins), _step; !(_step = _iterator()).done;){\n            var i2 = _step.value;\n            if (i2.postcss === true) {\n                i2 = i2();\n            } else if (i2.postcss) {\n                i2 = i2.postcss;\n            }\n            if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && Array.isArray(i2.plugins)) {\n                normalized = normalized.concat(i2.plugins);\n            } else if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && i2.postcssPlugin) {\n                normalized.push(i2);\n            } else if (typeof i2 === \"function\") {\n                normalized.push(i2);\n            } else if ((typeof i2 === \"undefined\" ? \"undefined\" : _type_of(i2)) === \"object\" && (i2.parse || i2.stringify)) {\n                if (true) {\n                    throw new Error(\"PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation.\");\n                }\n            } else {\n                throw new Error(i2 + \" is not a PostCSS plugin\");\n            }\n        }\n        return normalized;\n    };\n    _proto.process = function process1(css, opts) {\n        if (opts === void 0) opts = {};\n        if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {\n            return new NoWorkResult22(this, css, opts);\n        } else {\n            return new LazyResult$1(this, css, opts);\n        }\n    };\n    _proto.use = function use(plugin22) {\n        this.plugins = this.plugins.concat(this.normalize([\n            plugin22\n        ]));\n        return this;\n    };\n    return Processor2;\n}();\nvar processor = Processor$1;\nProcessor$1.default = Processor$1;\nRoot$2.registerProcessor(Processor$1);\nDocument$1.registerProcessor(Processor$1);\nvar Declaration$1 = declaration;\nvar PreviousMap22 = previousMap;\nvar Comment$1 = comment;\nvar AtRule$1 = atRule;\nvar Input$1 = input;\nvar Root$1 = root;\nvar Rule$1 = rule;\nfunction fromJSON$1(json, inputs) {\n    if (Array.isArray(json)) return json.map(function(n2) {\n        return fromJSON$1(n2);\n    });\n    var ownInputs = json.inputs, defaults = _object_without_properties_loose(json, [\n        \"inputs\"\n    ]);\n    if (ownInputs) {\n        inputs = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(ownInputs), _step; !(_step = _iterator()).done;){\n            var input2 = _step.value;\n            var inputHydrated = _extends({}, input2, {\n                __proto__: Input$1.prototype\n            });\n            if (inputHydrated.map) {\n                inputHydrated.map = _extends({}, inputHydrated.map, {\n                    __proto__: PreviousMap22.prototype\n                });\n            }\n            inputs.push(inputHydrated);\n        }\n    }\n    if (defaults.nodes) {\n        defaults.nodes = json.nodes.map(function(n2) {\n            return fromJSON$1(n2, inputs);\n        });\n    }\n    if (defaults.source) {\n        var _defaults_source = defaults.source, inputId = _defaults_source.inputId, source = _object_without_properties_loose(_defaults_source, [\n            \"inputId\"\n        ]);\n        defaults.source = source;\n        if (inputId != null) {\n            defaults.source.input = inputs[inputId];\n        }\n    }\n    if (defaults.type === \"root\") {\n        return new Root$1(defaults);\n    } else if (defaults.type === \"decl\") {\n        return new Declaration$1(defaults);\n    } else if (defaults.type === \"rule\") {\n        return new Rule$1(defaults);\n    } else if (defaults.type === \"comment\") {\n        return new Comment$1(defaults);\n    } else if (defaults.type === \"atrule\") {\n        return new AtRule$1(defaults);\n    } else {\n        throw new Error(\"Unknown node type: \" + json.type);\n    }\n}\nvar fromJSON_1 = fromJSON$1;\nfromJSON$1.default = fromJSON$1;\nvar CssSyntaxError22 = cssSyntaxError;\nvar Declaration22 = declaration;\nvar LazyResult22 = lazyResult;\nvar Container22 = container;\nvar Processor22 = processor;\nvar stringify = stringify_1;\nvar fromJSON = fromJSON_1;\nvar Document222 = document$1$2;\nvar Warning22 = warning;\nvar Comment22 = comment;\nvar AtRule22 = atRule;\nvar Result22 = result;\nvar Input22 = input;\nvar parse = parse_1;\nvar list = list_1;\nvar Rule22 = rule;\nvar Root22 = root;\nvar Node22 = node;\nfunction postcss() {\n    for(var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++){\n        plugins[_key] = arguments[_key];\n    }\n    if (plugins.length === 1 && Array.isArray(plugins[0])) {\n        plugins = plugins[0];\n    }\n    return new Processor22(plugins);\n}\npostcss.plugin = function plugin2(name, initializer) {\n    var warningPrinted = false;\n    function creator() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (console && console.warn && !warningPrinted) {\n            warningPrinted = true;\n            console.warn(name + \": postcss.plugin was deprecated. Migration guide:\\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration\");\n            if (process.env.LANG && process.env.LANG.startsWith(\"cn\")) {\n                console.warn(name + \":  postcss.plugin . :\\nhttps://www.w3ctech.com/topic/2226\");\n            }\n        }\n        var transformer = initializer.apply(void 0, [].concat(args));\n        transformer.postcssPlugin = name;\n        transformer.postcssVersion = new Processor22().version;\n        return transformer;\n    }\n    var cache;\n    Object.defineProperty(creator, \"postcss\", {\n        get: function get() {\n            if (!cache) cache = creator();\n            return cache;\n        }\n    });\n    creator.process = function(css, processOpts, pluginOpts) {\n        return postcss([\n            creator(pluginOpts)\n        ]).process(css, processOpts);\n    };\n    return creator;\n};\npostcss.stringify = stringify;\npostcss.parse = parse;\npostcss.fromJSON = fromJSON;\npostcss.list = list;\npostcss.comment = function(defaults) {\n    return new Comment22(defaults);\n};\npostcss.atRule = function(defaults) {\n    return new AtRule22(defaults);\n};\npostcss.decl = function(defaults) {\n    return new Declaration22(defaults);\n};\npostcss.rule = function(defaults) {\n    return new Rule22(defaults);\n};\npostcss.root = function(defaults) {\n    return new Root22(defaults);\n};\npostcss.document = function(defaults) {\n    return new Document222(defaults);\n};\npostcss.CssSyntaxError = CssSyntaxError22;\npostcss.Declaration = Declaration22;\npostcss.Container = Container22;\npostcss.Processor = Processor22;\npostcss.Document = Document222;\npostcss.Comment = Comment22;\npostcss.Warning = Warning22;\npostcss.AtRule = AtRule22;\npostcss.Result = Result22;\npostcss.Input = Input22;\npostcss.Rule = Rule22;\npostcss.Root = Root22;\npostcss.Node = Node22;\nLazyResult22.registerPostcss(postcss);\nvar postcss_1 = postcss;\npostcss.default = postcss;\nvar postcss$1 = /* @__PURE__ */ getDefaultExportFromCjs(postcss_1);\npostcss$1.stringify;\npostcss$1.fromJSON;\npostcss$1.plugin;\npostcss$1.parse;\npostcss$1.list;\npostcss$1.document;\npostcss$1.comment;\npostcss$1.atRule;\npostcss$1.rule;\npostcss$1.decl;\npostcss$1.root;\npostcss$1.CssSyntaxError;\npostcss$1.Declaration;\npostcss$1.Container;\npostcss$1.Processor;\npostcss$1.Document;\npostcss$1.Comment;\npostcss$1.Warning;\npostcss$1.AtRule;\npostcss$1.Result;\npostcss$1.Input;\npostcss$1.Rule;\npostcss$1.Root;\npostcss$1.Node;\nvar BaseRRNode = /*#__PURE__*/ function() {\n    function BaseRRNode() {\n        for(var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++){\n            _args[_key] = arguments[_key];\n        }\n        __publicField2(this, \"parentElement\", null);\n        __publicField2(this, \"parentNode\", null);\n        __publicField2(this, \"ownerDocument\");\n        __publicField2(this, \"firstChild\", null);\n        __publicField2(this, \"lastChild\", null);\n        __publicField2(this, \"previousSibling\", null);\n        __publicField2(this, \"nextSibling\", null);\n        __publicField2(this, \"ELEMENT_NODE\", 1);\n        __publicField2(this, \"TEXT_NODE\", 3);\n        __publicField2(this, \"nodeType\");\n        __publicField2(this, \"nodeName\");\n        __publicField2(this, \"RRNodeType\");\n    }\n    var _proto = BaseRRNode.prototype;\n    _proto.contains = function contains(node2) {\n        if (!_instanceof(node2, BaseRRNode)) return false;\n        else if (node2.ownerDocument !== this.ownerDocument) return false;\n        else if (node2 === this) return true;\n        while(node2.parentNode){\n            if (node2.parentNode === this) return true;\n            node2 = node2.parentNode;\n        }\n        return false;\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _proto.appendChild = function appendChild(_newChild) {\n        throw new Error(\"RRDomException: Failed to execute 'appendChild' on 'RRNode': This RRNode type does not support this method.\");\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _proto.insertBefore = function insertBefore(_newChild, _refChild) {\n        throw new Error(\"RRDomException: Failed to execute 'insertBefore' on 'RRNode': This RRNode type does not support this method.\");\n    };\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _proto.removeChild = function removeChild(_node) {\n        throw new Error(\"RRDomException: Failed to execute 'removeChild' on 'RRNode': This RRNode type does not support this method.\");\n    };\n    _proto.toString = function toString() {\n        return \"RRNode\";\n    };\n    _create_class(BaseRRNode, [\n        {\n            key: \"childNodes\",\n            get: function get() {\n                var childNodes2 = [];\n                var childIterator = this.firstChild;\n                while(childIterator){\n                    childNodes2.push(childIterator);\n                    childIterator = childIterator.nextSibling;\n                }\n                return childNodes2;\n            }\n        }\n    ]);\n    return BaseRRNode;\n}();\nvar testableAccessors = {\n    Node: [\n        \"childNodes\",\n        \"parentNode\",\n        \"parentElement\",\n        \"textContent\"\n    ],\n    ShadowRoot: [\n        \"host\",\n        \"styleSheets\"\n    ],\n    Element: [\n        \"shadowRoot\",\n        \"querySelector\",\n        \"querySelectorAll\"\n    ],\n    MutationObserver: []\n};\nvar testableMethods = {\n    Node: [\n        \"contains\",\n        \"getRootNode\"\n    ],\n    ShadowRoot: [\n        \"getSelection\"\n    ],\n    Element: [],\n    MutationObserver: [\n        \"constructor\"\n    ]\n};\nvar untaintedBasePrototype = {};\nvar isAngularZonePresent = function() {\n    return !!globalThis.Zone;\n};\nfunction getUntaintedPrototype(key) {\n    if (untaintedBasePrototype[key]) return untaintedBasePrototype[key];\n    var defaultObj = globalThis[key];\n    var defaultPrototype = defaultObj.prototype;\n    var accessorNames = key in testableAccessors ? testableAccessors[key] : void 0;\n    var isUntaintedAccessors = Boolean(accessorNames && // @ts-expect-error 2345\n    accessorNames.every(function(accessor) {\n        var _a2, _b;\n        return Boolean((_b = (_a2 = Object.getOwnPropertyDescriptor(defaultPrototype, accessor)) == null ? void 0 : _a2.get) == null ? void 0 : _b.toString().includes(\"[native code]\"));\n    }));\n    var methodNames = key in testableMethods ? testableMethods[key] : void 0;\n    var isUntaintedMethods = Boolean(methodNames && methodNames.every(// @ts-expect-error 2345\n    function(method) {\n        var _a2;\n        return typeof defaultPrototype[method] === \"function\" && ((_a2 = defaultPrototype[method]) == null ? void 0 : _a2.toString().includes(\"[native code]\"));\n    }));\n    if (isUntaintedAccessors && isUntaintedMethods && !isAngularZonePresent()) {\n        untaintedBasePrototype[key] = defaultObj.prototype;\n        return defaultObj.prototype;\n    }\n    try {\n        var iframeEl = document.createElement(\"iframe\");\n        document.body.appendChild(iframeEl);\n        var win = iframeEl.contentWindow;\n        if (!win) return defaultObj.prototype;\n        var untaintedObject = win[key].prototype;\n        document.body.removeChild(iframeEl);\n        if (!untaintedObject) return defaultPrototype;\n        return untaintedBasePrototype[key] = untaintedObject;\n    } catch (e) {\n        return defaultPrototype;\n    }\n}\nvar untaintedAccessorCache = {};\nfunction getUntaintedAccessor(key, instance, accessor) {\n    var _a2;\n    var cacheKey = key + \".\" + String(accessor);\n    if (untaintedAccessorCache[cacheKey]) return untaintedAccessorCache[cacheKey].call(instance);\n    var untaintedPrototype = getUntaintedPrototype(key);\n    var untaintedAccessor = (_a2 = Object.getOwnPropertyDescriptor(untaintedPrototype, accessor)) == null ? void 0 : _a2.get;\n    if (!untaintedAccessor) return instance[accessor];\n    untaintedAccessorCache[cacheKey] = untaintedAccessor;\n    return untaintedAccessor.call(instance);\n}\nvar untaintedMethodCache = {};\nfunction getUntaintedMethod(key, instance, method) {\n    var cacheKey = key + \".\" + String(method);\n    if (untaintedMethodCache[cacheKey]) return untaintedMethodCache[cacheKey].bind(instance);\n    var untaintedPrototype = getUntaintedPrototype(key);\n    var untaintedMethod = untaintedPrototype[method];\n    if (typeof untaintedMethod !== \"function\") return instance[method];\n    untaintedMethodCache[cacheKey] = untaintedMethod;\n    return untaintedMethod.bind(instance);\n}\nfunction childNodes(n2) {\n    return getUntaintedAccessor(\"Node\", n2, \"childNodes\");\n}\nfunction parentNode(n2) {\n    return getUntaintedAccessor(\"Node\", n2, \"parentNode\");\n}\nfunction parentElement(n2) {\n    return getUntaintedAccessor(\"Node\", n2, \"parentElement\");\n}\nfunction textContent(n2) {\n    return getUntaintedAccessor(\"Node\", n2, \"textContent\");\n}\nfunction contains(n2, other) {\n    return getUntaintedMethod(\"Node\", n2, \"contains\")(other);\n}\nfunction getRootNode(n2) {\n    return getUntaintedMethod(\"Node\", n2, \"getRootNode\")();\n}\nfunction host(n2) {\n    if (!n2 || !(\"host\" in n2)) return null;\n    return getUntaintedAccessor(\"ShadowRoot\", n2, \"host\");\n}\nfunction styleSheets(n2) {\n    return n2.styleSheets;\n}\nfunction shadowRoot(n2) {\n    if (!n2 || !(\"shadowRoot\" in n2)) return null;\n    return getUntaintedAccessor(\"Element\", n2, \"shadowRoot\");\n}\nfunction querySelector(n2, selectors) {\n    return getUntaintedAccessor(\"Element\", n2, \"querySelector\")(selectors);\n}\nfunction querySelectorAll(n2, selectors) {\n    return getUntaintedAccessor(\"Element\", n2, \"querySelectorAll\")(selectors);\n}\nfunction mutationObserverCtor() {\n    return getUntaintedPrototype(\"MutationObserver\").constructor;\n}\nvar index = {\n    childNodes: childNodes,\n    parentNode: parentNode,\n    parentElement: parentElement,\n    textContent: textContent,\n    contains: contains,\n    getRootNode: getRootNode,\n    host: host,\n    styleSheets: styleSheets,\n    shadowRoot: shadowRoot,\n    querySelector: querySelector,\n    querySelectorAll: querySelectorAll,\n    mutationObserver: mutationObserverCtor\n};\nfunction on(type, fn, target) {\n    if (target === void 0) target = document;\n    var options = {\n        capture: true,\n        passive: true\n    };\n    target.addEventListener(type, fn, options);\n    return function() {\n        return target.removeEventListener(type, fn, options);\n    };\n}\nvar DEPARTED_MIRROR_ACCESS_WARNING = \"Please stop import mirror directly. Instead of that,\\r\\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\\r\\nor you can use record.mirror to access the mirror instance during recording.\";\nvar _mirror = {\n    map: {},\n    getId: function getId() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        return -1;\n    },\n    getNode: function getNode() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        return null;\n    },\n    removeNodeFromMap: function removeNodeFromMap() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    },\n    has: function has() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n        return false;\n    },\n    reset: function reset() {\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n    }\n};\nif (typeof window !== \"undefined\" && window.Proxy && window.Reflect) {\n    _mirror = new Proxy(_mirror, {\n        get: function get(target, prop, receiver) {\n            if (prop === \"map\") {\n                console.error(DEPARTED_MIRROR_ACCESS_WARNING);\n            }\n            return Reflect.get(target, prop, receiver);\n        }\n    });\n}\nfunction throttle(func, wait, options) {\n    if (options === void 0) options = {};\n    var timeout = null;\n    var previous = 0;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        var now = Date.now();\n        if (!previous && options.leading === false) {\n            previous = now;\n        }\n        var remaining = wait - (now - previous);\n        var context = this;\n        if (remaining <= 0 || remaining > wait) {\n            if (timeout) {\n                clearTimeout(timeout);\n                timeout = null;\n            }\n            previous = now;\n            func.apply(context, args);\n        } else if (!timeout && options.trailing !== false) {\n            timeout = setTimeout(function() {\n                previous = options.leading === false ? 0 : Date.now();\n                timeout = null;\n                func.apply(context, args);\n            }, remaining);\n        }\n    };\n}\nfunction hookSetter(target, key, d, isRevoked, win) {\n    if (win === void 0) win = window;\n    var original = win.Object.getOwnPropertyDescriptor(target, key);\n    win.Object.defineProperty(target, key, isRevoked ? d : {\n        set: function set(value) {\n            var _this = this;\n            setTimeout(function() {\n                d.set.call(_this, value);\n            }, 0);\n            if (original && original.set) {\n                original.set.call(this, value);\n            }\n        }\n    });\n    return function() {\n        return hookSetter(target, key, original || {}, true);\n    };\n}\nfunction patch(source, name, replacement) {\n    try {\n        if (!(name in source)) {\n            return function() {};\n        }\n        var original = source[name];\n        var wrapped = replacement(original);\n        if (typeof wrapped === \"function\") {\n            wrapped.prototype = wrapped.prototype || {};\n            Object.defineProperties(wrapped, {\n                __rrweb_original__: {\n                    enumerable: false,\n                    value: original\n                }\n            });\n        }\n        source[name] = wrapped;\n        return function() {\n            source[name] = original;\n        };\n    } catch (e) {\n        return function() {};\n    }\n}\nvar nowTimestamp = Date.now;\nif (!/* @__PURE__ */ /[1-9][0-9]{12}/.test(Date.now().toString())) {\n    nowTimestamp = function() {\n        return /* @__PURE__ */ new Date().getTime();\n    };\n}\nfunction getWindowScroll(win) {\n    var _a2, _b, _c, _d;\n    var doc = win.document;\n    return {\n        left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== void 0 ? win.pageXOffset : doc.documentElement.scrollLeft || (doc == null ? void 0 : doc.body) && ((_a2 = index.parentElement(doc.body)) == null ? void 0 : _a2.scrollLeft) || ((_b = doc == null ? void 0 : doc.body) == null ? void 0 : _b.scrollLeft) || 0,\n        top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== void 0 ? win.pageYOffset : (doc == null ? void 0 : doc.documentElement.scrollTop) || (doc == null ? void 0 : doc.body) && ((_c = index.parentElement(doc.body)) == null ? void 0 : _c.scrollTop) || ((_d = doc == null ? void 0 : doc.body) == null ? void 0 : _d.scrollTop) || 0\n    };\n}\nfunction getWindowHeight() {\n    return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;\n}\nfunction getWindowWidth() {\n    return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;\n}\nfunction closestElementOfNode(node2) {\n    if (!node2) {\n        return null;\n    }\n    var el = node2.nodeType === node2.ELEMENT_NODE ? node2 : index.parentElement(node2);\n    return el;\n}\nfunction isBlocked(node2, blockClass, blockSelector, checkAncestors) {\n    if (!node2) {\n        return false;\n    }\n    var el = closestElementOfNode(node2);\n    if (!el) {\n        return false;\n    }\n    try {\n        if (typeof blockClass === \"string\") {\n            if (el.classList.contains(blockClass)) return true;\n            if (checkAncestors && el.closest(\".\" + blockClass) !== null) return true;\n        } else {\n            if (classMatchesRegex(el, blockClass, checkAncestors)) return true;\n        }\n    } catch (e2) {}\n    if (blockSelector) {\n        if (el.matches(blockSelector)) return true;\n        if (checkAncestors && el.closest(blockSelector) !== null) return true;\n    }\n    return false;\n}\nfunction isSerialized(n2, mirror2) {\n    return mirror2.getId(n2) !== -1;\n}\nfunction isIgnored(n2, mirror2, slimDOMOptions) {\n    if (n2.tagName === \"TITLE\" && slimDOMOptions.headTitleMutations) {\n        return true;\n    }\n    return mirror2.getId(n2) === IGNORED_NODE;\n}\nfunction isAncestorRemoved(target, mirror2) {\n    if (isShadowRoot(target)) {\n        return false;\n    }\n    var id = mirror2.getId(target);\n    if (!mirror2.has(id)) {\n        return true;\n    }\n    var parent = index.parentNode(target);\n    if (parent && parent.nodeType === target.DOCUMENT_NODE) {\n        return false;\n    }\n    if (!parent) {\n        return true;\n    }\n    return isAncestorRemoved(parent, mirror2);\n}\nfunction legacy_isTouchEvent(event) {\n    return Boolean(event.changedTouches);\n}\nfunction polyfill$1(win) {\n    if (win === void 0) win = window;\n    if (\"NodeList\" in win && !win.NodeList.prototype.forEach) {\n        win.NodeList.prototype.forEach = Array.prototype.forEach;\n    }\n    if (\"DOMTokenList\" in win && !win.DOMTokenList.prototype.forEach) {\n        win.DOMTokenList.prototype.forEach = Array.prototype.forEach;\n    }\n}\nfunction isSerializedIframe(n2, mirror2) {\n    return Boolean(n2.nodeName === \"IFRAME\" && mirror2.getMeta(n2));\n}\nfunction isSerializedStylesheet(n2, mirror2) {\n    return Boolean(n2.nodeName === \"LINK\" && n2.nodeType === n2.ELEMENT_NODE && n2.getAttribute && n2.getAttribute(\"rel\") === \"stylesheet\" && mirror2.getMeta(n2));\n}\nfunction hasShadowRoot(n2) {\n    if (!n2) return false;\n    if (_instanceof(n2, BaseRRNode) && \"shadowRoot\" in n2) {\n        return Boolean(n2.shadowRoot);\n    }\n    return Boolean(index.shadowRoot(n2));\n}\nvar StyleSheetMirror = /*#__PURE__*/ function() {\n    function StyleSheetMirror() {\n        __publicField(this, \"id\", 1);\n        __publicField(this, \"styleIDMap\", /* @__PURE__ */ new WeakMap());\n        __publicField(this, \"idStyleMap\", /* @__PURE__ */ new Map());\n    }\n    var _proto = StyleSheetMirror.prototype;\n    _proto.getId = function getId(stylesheet) {\n        var _this_styleIDMap_get;\n        return (_this_styleIDMap_get = this.styleIDMap.get(stylesheet)) != null ? _this_styleIDMap_get : -1;\n    };\n    _proto.has = function has(stylesheet) {\n        return this.styleIDMap.has(stylesheet);\n    };\n    /**\n   * @returns If the stylesheet is in the mirror, returns the id of the stylesheet. If not, return the new assigned id.\n   */ _proto.add = function add(stylesheet, id) {\n        if (this.has(stylesheet)) return this.getId(stylesheet);\n        var newId;\n        if (id === void 0) {\n            newId = this.id++;\n        } else newId = id;\n        this.styleIDMap.set(stylesheet, newId);\n        this.idStyleMap.set(newId, stylesheet);\n        return newId;\n    };\n    _proto.getStyle = function getStyle(id) {\n        return this.idStyleMap.get(id) || null;\n    };\n    _proto.reset = function reset() {\n        this.styleIDMap = /* @__PURE__ */ new WeakMap();\n        this.idStyleMap = /* @__PURE__ */ new Map();\n        this.id = 1;\n    };\n    _proto.generateId = function generateId() {\n        return this.id++;\n    };\n    return StyleSheetMirror;\n}();\nfunction getShadowHost(n2) {\n    var _a2;\n    var shadowHost = null;\n    if (\"getRootNode\" in n2 && ((_a2 = index.getRootNode(n2)) == null ? void 0 : _a2.nodeType) === Node.DOCUMENT_FRAGMENT_NODE && index.host(index.getRootNode(n2))) shadowHost = index.host(index.getRootNode(n2));\n    return shadowHost;\n}\nfunction getRootShadowHost(n2) {\n    var rootShadowHost = n2;\n    var shadowHost;\n    while(shadowHost = getShadowHost(rootShadowHost))rootShadowHost = shadowHost;\n    return rootShadowHost;\n}\nfunction shadowHostInDom(n2) {\n    var doc = n2.ownerDocument;\n    if (!doc) return false;\n    var shadowHost = getRootShadowHost(n2);\n    return index.contains(doc, shadowHost);\n}\nfunction inDom(n2) {\n    var doc = n2.ownerDocument;\n    if (!doc) return false;\n    return index.contains(doc, n2) || shadowHostInDom(n2);\n}\nvar EventType = /* @__PURE__ */ function(EventType2) {\n    EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n    EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n    EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n    EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n    EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n    EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n    EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n    return EventType2;\n}(EventType || {});\nvar IncrementalSource = /* @__PURE__ */ function(IncrementalSource2) {\n    IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n    IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n    IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n    IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n    IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n    IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n    IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n    IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n    IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n    IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n    IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n    IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n    IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n    IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n    IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n    IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n    IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n    return IncrementalSource2;\n}(IncrementalSource || {});\nvar MouseInteractions = /* @__PURE__ */ function(MouseInteractions2) {\n    MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n    MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n    MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n    MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n    MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n    MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n    MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n    MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n    MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n    MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n    MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n    return MouseInteractions2;\n}(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */ function(PointerTypes2) {\n    PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n    PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n    PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n    return PointerTypes2;\n}(PointerTypes || {});\nvar CanvasContext = /* @__PURE__ */ function(CanvasContext2) {\n    CanvasContext2[CanvasContext2[\"2D\"] = 0] = \"2D\";\n    CanvasContext2[CanvasContext2[\"WebGL\"] = 1] = \"WebGL\";\n    CanvasContext2[CanvasContext2[\"WebGL2\"] = 2] = \"WebGL2\";\n    return CanvasContext2;\n}(CanvasContext || {});\nvar MediaInteractions = /* @__PURE__ */ function(MediaInteractions2) {\n    MediaInteractions2[MediaInteractions2[\"Play\"] = 0] = \"Play\";\n    MediaInteractions2[MediaInteractions2[\"Pause\"] = 1] = \"Pause\";\n    MediaInteractions2[MediaInteractions2[\"Seeked\"] = 2] = \"Seeked\";\n    MediaInteractions2[MediaInteractions2[\"VolumeChange\"] = 3] = \"VolumeChange\";\n    MediaInteractions2[MediaInteractions2[\"RateChange\"] = 4] = \"RateChange\";\n    return MediaInteractions2;\n}(MediaInteractions || {});\nvar NodeType = /* @__PURE__ */ function(NodeType2) {\n    NodeType2[NodeType2[\"Document\"] = 0] = \"Document\";\n    NodeType2[NodeType2[\"DocumentType\"] = 1] = \"DocumentType\";\n    NodeType2[NodeType2[\"Element\"] = 2] = \"Element\";\n    NodeType2[NodeType2[\"Text\"] = 3] = \"Text\";\n    NodeType2[NodeType2[\"CDATA\"] = 4] = \"CDATA\";\n    NodeType2[NodeType2[\"Comment\"] = 5] = \"Comment\";\n    return NodeType2;\n}(NodeType || {});\nfunction isNodeInLinkedList(n2) {\n    return \"__ln\" in n2;\n}\nvar DoubleLinkedList = /*#__PURE__*/ function() {\n    function DoubleLinkedList() {\n        __publicField(this, \"length\", 0);\n        __publicField(this, \"head\", null);\n        __publicField(this, \"tail\", null);\n    }\n    var _proto = DoubleLinkedList.prototype;\n    _proto.get = function get(position) {\n        if (position >= this.length) {\n            throw new Error(\"Position outside of list range\");\n        }\n        var current = this.head;\n        for(var index2 = 0; index2 < position; index2++){\n            current = (current == null ? void 0 : current.next) || null;\n        }\n        return current;\n    };\n    _proto.addNode = function addNode(n2) {\n        var node2 = {\n            value: n2,\n            previous: null,\n            next: null\n        };\n        n2.__ln = node2;\n        if (n2.previousSibling && isNodeInLinkedList(n2.previousSibling)) {\n            var current = n2.previousSibling.__ln.next;\n            node2.next = current;\n            node2.previous = n2.previousSibling.__ln;\n            n2.previousSibling.__ln.next = node2;\n            if (current) {\n                current.previous = node2;\n            }\n        } else if (n2.nextSibling && isNodeInLinkedList(n2.nextSibling) && n2.nextSibling.__ln.previous) {\n            var current1 = n2.nextSibling.__ln.previous;\n            node2.previous = current1;\n            node2.next = n2.nextSibling.__ln;\n            n2.nextSibling.__ln.previous = node2;\n            if (current1) {\n                current1.next = node2;\n            }\n        } else {\n            if (this.head) {\n                this.head.previous = node2;\n            }\n            node2.next = this.head;\n            this.head = node2;\n        }\n        if (node2.next === null) {\n            this.tail = node2;\n        }\n        this.length++;\n    };\n    _proto.removeNode = function removeNode(n2) {\n        var current = n2.__ln;\n        if (!this.head) {\n            return;\n        }\n        if (!current.previous) {\n            this.head = current.next;\n            if (this.head) {\n                this.head.previous = null;\n            } else {\n                this.tail = null;\n            }\n        } else {\n            current.previous.next = current.next;\n            if (current.next) {\n                current.next.previous = current.previous;\n            } else {\n                this.tail = current.previous;\n            }\n        }\n        if (n2.__ln) {\n            delete n2.__ln;\n        }\n        this.length--;\n    };\n    return DoubleLinkedList;\n}();\nvar moveKey = function(id, parentId) {\n    return id + \"@\" + parentId;\n};\nvar MutationBuffer = /*#__PURE__*/ function() {\n    function MutationBuffer() {\n        var _this = this;\n        __publicField(this, \"frozen\", false);\n        __publicField(this, \"locked\", false);\n        __publicField(this, \"texts\", []);\n        __publicField(this, \"attributes\", []);\n        __publicField(this, \"attributeMap\", /* @__PURE__ */ new WeakMap());\n        __publicField(this, \"removes\", []);\n        __publicField(this, \"mapRemoves\", []);\n        __publicField(this, \"movedMap\", {});\n        /**\n     * the browser MutationObserver emits multiple mutations after\n     * a delay for performance reasons, making tracing added nodes hard\n     * in our `processMutations` callback function.\n     * For example, if we append an element el_1 into body, and then append\n     * another element el_2 into el_1, these two mutations may be passed to the\n     * callback function together when the two operations were done.\n     * Generally we need to trace child nodes of newly added nodes, but in this\n     * case if we count el_2 as el_1's child node in the first mutation record,\n     * then we will count el_2 again in the second mutation record which was\n     * duplicated.\n     * To avoid of duplicate counting added nodes, we use a Set to store\n     * added nodes and its child nodes during iterate mutation records. Then\n     * collect added nodes from the Set which have no duplicate copy. But\n     * this also causes newly added nodes will not be serialized with id ASAP,\n     * which means all the id related calculation should be lazy too.\n     */ __publicField(this, \"addedSet\", /* @__PURE__ */ new Set());\n        __publicField(this, \"movedSet\", /* @__PURE__ */ new Set());\n        __publicField(this, \"droppedSet\", /* @__PURE__ */ new Set());\n        __publicField(this, \"removesSubTreeCache\", /* @__PURE__ */ new Set());\n        __publicField(this, \"mutationCb\");\n        __publicField(this, \"blockClass\");\n        __publicField(this, \"blockSelector\");\n        __publicField(this, \"maskTextClass\");\n        __publicField(this, \"maskTextSelector\");\n        __publicField(this, \"inlineStylesheet\");\n        __publicField(this, \"maskInputOptions\");\n        __publicField(this, \"maskTextFn\");\n        __publicField(this, \"maskInputFn\");\n        __publicField(this, \"keepIframeSrcFn\");\n        __publicField(this, \"recordCanvas\");\n        __publicField(this, \"inlineImages\");\n        __publicField(this, \"slimDOMOptions\");\n        __publicField(this, \"dataURLOptions\");\n        __publicField(this, \"doc\");\n        __publicField(this, \"mirror\");\n        __publicField(this, \"iframeManager\");\n        __publicField(this, \"stylesheetManager\");\n        __publicField(this, \"shadowDomManager\");\n        __publicField(this, \"canvasManager\");\n        __publicField(this, \"processedNodeManager\");\n        __publicField(this, \"unattachedDoc\");\n        __publicField(this, \"processMutations\", function(mutations) {\n            mutations.forEach(_this.processMutation);\n            _this.emit();\n        });\n        __publicField(this, \"emit\", function() {\n            if (_this.frozen || _this.locked) {\n                return;\n            }\n            var adds = [];\n            var addedIds = /* @__PURE__ */ new Set();\n            var addList = new DoubleLinkedList();\n            var getNextId = function(n2) {\n                var ns = n2;\n                var nextId = IGNORED_NODE;\n                while(nextId === IGNORED_NODE){\n                    ns = ns && ns.nextSibling;\n                    nextId = ns && _this.mirror.getId(ns);\n                }\n                return nextId;\n            };\n            var pushAdd = function(n2) {\n                var parent = index.parentNode(n2);\n                if (!parent || !inDom(n2)) {\n                    return;\n                }\n                var cssCaptured = false;\n                if (n2.nodeType === Node.TEXT_NODE) {\n                    var parentTag = parent.tagName;\n                    if (parentTag === \"TEXTAREA\") {\n                        return;\n                    } else if (parentTag === \"STYLE\" && _this.addedSet.has(parent)) {\n                        cssCaptured = true;\n                    }\n                }\n                var parentId = isShadowRoot(parent) ? _this.mirror.getId(getShadowHost(n2)) : _this.mirror.getId(parent);\n                var nextId = getNextId(n2);\n                if (parentId === -1 || nextId === -1) {\n                    return addList.addNode(n2);\n                }\n                var sn = serializeNodeWithId(n2, {\n                    doc: _this.doc,\n                    mirror: _this.mirror,\n                    blockClass: _this.blockClass,\n                    blockSelector: _this.blockSelector,\n                    maskTextClass: _this.maskTextClass,\n                    maskTextSelector: _this.maskTextSelector,\n                    skipChild: true,\n                    newlyAddedElement: true,\n                    inlineStylesheet: _this.inlineStylesheet,\n                    maskInputOptions: _this.maskInputOptions,\n                    maskTextFn: _this.maskTextFn,\n                    maskInputFn: _this.maskInputFn,\n                    slimDOMOptions: _this.slimDOMOptions,\n                    dataURLOptions: _this.dataURLOptions,\n                    recordCanvas: _this.recordCanvas,\n                    inlineImages: _this.inlineImages,\n                    onSerialize: function(currentN) {\n                        if (isSerializedIframe(currentN, _this.mirror)) {\n                            _this.iframeManager.addIframe(currentN);\n                        }\n                        if (isSerializedStylesheet(currentN, _this.mirror)) {\n                            _this.stylesheetManager.trackLinkElement(currentN);\n                        }\n                        if (hasShadowRoot(n2)) {\n                            _this.shadowDomManager.addShadowRoot(index.shadowRoot(n2), _this.doc);\n                        }\n                    },\n                    onIframeLoad: function(iframe, childSn) {\n                        _this.iframeManager.attachIframe(iframe, childSn);\n                        _this.shadowDomManager.observeAttachShadow(iframe);\n                    },\n                    onStylesheetLoad: function(link, childSn) {\n                        _this.stylesheetManager.attachLinkElement(link, childSn);\n                    },\n                    cssCaptured: cssCaptured\n                });\n                if (sn) {\n                    adds.push({\n                        parentId: parentId,\n                        nextId: nextId,\n                        node: sn\n                    });\n                    addedIds.add(sn.id);\n                }\n            };\n            while(_this.mapRemoves.length){\n                _this.mirror.removeNodeFromMap(_this.mapRemoves.shift());\n            }\n            for(var _iterator = _create_for_of_iterator_helper_loose(_this.movedSet), _step; !(_step = _iterator()).done;){\n                var n2 = _step.value;\n                if (isParentRemoved(_this.removesSubTreeCache, n2, _this.mirror) && !_this.movedSet.has(index.parentNode(n2))) {\n                    continue;\n                }\n                pushAdd(n2);\n            }\n            for(var _iterator1 = _create_for_of_iterator_helper_loose(_this.addedSet), _step1; !(_step1 = _iterator1()).done;){\n                var n21 = _step1.value;\n                if (!isAncestorInSet(_this.droppedSet, n21) && !isParentRemoved(_this.removesSubTreeCache, n21, _this.mirror)) {\n                    pushAdd(n21);\n                } else if (isAncestorInSet(_this.movedSet, n21)) {\n                    pushAdd(n21);\n                } else {\n                    _this.droppedSet.add(n21);\n                }\n            }\n            var candidate = null;\n            while(addList.length){\n                var node2 = null;\n                if (candidate) {\n                    var parentId = _this.mirror.getId(index.parentNode(candidate.value));\n                    var nextId = getNextId(candidate.value);\n                    if (parentId !== -1 && nextId !== -1) {\n                        node2 = candidate;\n                    }\n                }\n                if (!node2) {\n                    var tailNode = addList.tail;\n                    while(tailNode){\n                        var _node = tailNode;\n                        tailNode = tailNode.previous;\n                        if (_node) {\n                            var parentId1 = _this.mirror.getId(index.parentNode(_node.value));\n                            var nextId1 = getNextId(_node.value);\n                            if (nextId1 === -1) continue;\n                            else if (parentId1 !== -1) {\n                                node2 = _node;\n                                break;\n                            } else {\n                                var unhandledNode = _node.value;\n                                var parent = index.parentNode(unhandledNode);\n                                if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                                    var shadowHost = index.host(parent);\n                                    var parentId2 = _this.mirror.getId(shadowHost);\n                                    if (parentId2 !== -1) {\n                                        node2 = _node;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!node2) {\n                    while(addList.head){\n                        addList.removeNode(addList.head.value);\n                    }\n                    break;\n                }\n                candidate = node2.previous;\n                addList.removeNode(node2.value);\n                pushAdd(node2.value);\n            }\n            var payload = {\n                texts: _this.texts.map(function(text) {\n                    var n2 = text.node;\n                    var parent = index.parentNode(n2);\n                    if (parent && parent.tagName === \"TEXTAREA\") {\n                        _this.genTextAreaValueMutation(parent);\n                    }\n                    return {\n                        id: _this.mirror.getId(n2),\n                        value: text.value\n                    };\n                }).filter(function(text) {\n                    return !addedIds.has(text.id);\n                }).filter(function(text) {\n                    return _this.mirror.has(text.id);\n                }),\n                attributes: _this.attributes.map(function(attribute) {\n                    var attributes = attribute.attributes;\n                    if (typeof attributes.style === \"string\") {\n                        var diffAsStr = JSON.stringify(attribute.styleDiff);\n                        var unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\n                        if (diffAsStr.length < attributes.style.length) {\n                            if ((diffAsStr + unchangedAsStr).split(\"var(\").length === attributes.style.split(\"var(\").length) {\n                                attributes.style = attribute.styleDiff;\n                            }\n                        }\n                    }\n                    return {\n                        id: _this.mirror.getId(attribute.node),\n                        attributes: attributes\n                    };\n                }).filter(function(attribute) {\n                    return !addedIds.has(attribute.id);\n                }).filter(function(attribute) {\n                    return _this.mirror.has(attribute.id);\n                }),\n                removes: _this.removes,\n                adds: adds\n            };\n            if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {\n                return;\n            }\n            _this.texts = [];\n            _this.attributes = [];\n            _this.attributeMap = /* @__PURE__ */ new WeakMap();\n            _this.removes = [];\n            _this.addedSet = /* @__PURE__ */ new Set();\n            _this.movedSet = /* @__PURE__ */ new Set();\n            _this.droppedSet = /* @__PURE__ */ new Set();\n            _this.removesSubTreeCache = /* @__PURE__ */ new Set();\n            _this.movedMap = {};\n            _this.mutationCb(payload);\n        });\n        __publicField(this, \"genTextAreaValueMutation\", function(textarea) {\n            var item = _this.attributeMap.get(textarea);\n            if (!item) {\n                item = {\n                    node: textarea,\n                    attributes: {},\n                    styleDiff: {},\n                    _unchangedStyles: {}\n                };\n                _this.attributes.push(item);\n                _this.attributeMap.set(textarea, item);\n            }\n            item.attributes.value = Array.from(index.childNodes(textarea), function(cn) {\n                return index.textContent(cn) || \"\";\n            }).join(\"\");\n        });\n        __publicField(this, \"processMutation\", function(m) {\n            if (isIgnored(m.target, _this.mirror, _this.slimDOMOptions)) {\n                return;\n            }\n            switch(m.type){\n                case \"characterData\":\n                    {\n                        var value = index.textContent(m.target);\n                        if (!isBlocked(m.target, _this.blockClass, _this.blockSelector, false) && value !== m.oldValue) {\n                            _this.texts.push({\n                                value: needMaskingText(m.target, _this.maskTextClass, _this.maskTextSelector, true) && value ? _this.maskTextFn ? _this.maskTextFn(value, closestElementOfNode(m.target)) : value.replace(/[\\S]/g, \"*\") : value,\n                                node: m.target\n                            });\n                        }\n                        break;\n                    }\n                case \"attributes\":\n                    {\n                        var target = m.target;\n                        var attributeName = m.attributeName;\n                        var value1 = m.target.getAttribute(attributeName);\n                        if (attributeName === \"value\") {\n                            var type = getInputType(target);\n                            value1 = maskInputValue({\n                                element: target,\n                                maskInputOptions: _this.maskInputOptions,\n                                tagName: target.tagName,\n                                type: type,\n                                value: value1,\n                                maskInputFn: _this.maskInputFn\n                            });\n                        }\n                        if (isBlocked(m.target, _this.blockClass, _this.blockSelector, false) || value1 === m.oldValue) {\n                            return;\n                        }\n                        var item = _this.attributeMap.get(m.target);\n                        if (target.tagName === \"IFRAME\" && attributeName === \"src\" && !_this.keepIframeSrcFn(value1)) {\n                            if (!target.contentDocument) {\n                                attributeName = \"rr_src\";\n                            } else {\n                                return;\n                            }\n                        }\n                        if (!item) {\n                            item = {\n                                node: m.target,\n                                attributes: {},\n                                styleDiff: {},\n                                _unchangedStyles: {}\n                            };\n                            _this.attributes.push(item);\n                            _this.attributeMap.set(m.target, item);\n                        }\n                        if (attributeName === \"type\" && target.tagName === \"INPUT\" && (m.oldValue || \"\").toLowerCase() === \"password\") {\n                            target.setAttribute(\"data-rr-is-password\", \"true\");\n                        }\n                        if (!ignoreAttribute(target.tagName, attributeName)) {\n                            item.attributes[attributeName] = transformAttribute(_this.doc, toLowerCase(target.tagName), toLowerCase(attributeName), value1);\n                            if (attributeName === \"style\") {\n                                if (!_this.unattachedDoc) {\n                                    try {\n                                        _this.unattachedDoc = document.implementation.createHTMLDocument();\n                                    } catch (e2) {\n                                        _this.unattachedDoc = _this.doc;\n                                    }\n                                }\n                                var old = _this.unattachedDoc.createElement(\"span\");\n                                if (m.oldValue) {\n                                    old.setAttribute(\"style\", m.oldValue);\n                                }\n                                for(var _iterator = _create_for_of_iterator_helper_loose(Array.from(target.style)), _step; !(_step = _iterator()).done;){\n                                    var pname = _step.value;\n                                    var newValue = target.style.getPropertyValue(pname);\n                                    var newPriority = target.style.getPropertyPriority(pname);\n                                    if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {\n                                        if (newPriority === \"\") {\n                                            item.styleDiff[pname] = newValue;\n                                        } else {\n                                            item.styleDiff[pname] = [\n                                                newValue,\n                                                newPriority\n                                            ];\n                                        }\n                                    } else {\n                                        item._unchangedStyles[pname] = [\n                                            newValue,\n                                            newPriority\n                                        ];\n                                    }\n                                }\n                                for(var _iterator1 = _create_for_of_iterator_helper_loose(Array.from(old.style)), _step1; !(_step1 = _iterator1()).done;){\n                                    var pname1 = _step1.value;\n                                    if (target.style.getPropertyValue(pname1) === \"\") {\n                                        item.styleDiff[pname1] = false;\n                                    }\n                                }\n                            } else if (attributeName === \"open\" && target.tagName === \"DIALOG\") {\n                                if (target.matches(\"dialog:modal\")) {\n                                    item.attributes[\"rr_open_mode\"] = \"modal\";\n                                } else {\n                                    item.attributes[\"rr_open_mode\"] = \"non-modal\";\n                                }\n                            }\n                        }\n                        break;\n                    }\n                case \"childList\":\n                    {\n                        if (isBlocked(m.target, _this.blockClass, _this.blockSelector, true)) return;\n                        if (m.target.tagName === \"TEXTAREA\") {\n                            _this.genTextAreaValueMutation(m.target);\n                            return;\n                        }\n                        m.addedNodes.forEach(function(n2) {\n                            return _this.genAdds(n2, m.target);\n                        });\n                        m.removedNodes.forEach(function(n2) {\n                            var nodeId = _this.mirror.getId(n2);\n                            var parentId = isShadowRoot(m.target) ? _this.mirror.getId(index.host(m.target)) : _this.mirror.getId(m.target);\n                            if (isBlocked(m.target, _this.blockClass, _this.blockSelector, false) || isIgnored(n2, _this.mirror, _this.slimDOMOptions) || !isSerialized(n2, _this.mirror)) {\n                                return;\n                            }\n                            if (_this.addedSet.has(n2)) {\n                                deepDelete(_this.addedSet, n2);\n                                _this.droppedSet.add(n2);\n                            } else if (_this.addedSet.has(m.target) && nodeId === -1) ;\n                            else if (isAncestorRemoved(m.target, _this.mirror)) ;\n                            else if (_this.movedSet.has(n2) && _this.movedMap[moveKey(nodeId, parentId)]) {\n                                deepDelete(_this.movedSet, n2);\n                            } else {\n                                _this.removes.push({\n                                    parentId: parentId,\n                                    id: nodeId,\n                                    isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : void 0\n                                });\n                                processRemoves(n2, _this.removesSubTreeCache);\n                            }\n                            _this.mapRemoves.push(n2);\n                        });\n                        break;\n                    }\n            }\n        });\n        /**\n     * Make sure you check if `n`'s parent is blocked before calling this function\n     * */ __publicField(this, \"genAdds\", function(n2, target) {\n            if (_this.processedNodeManager.inOtherBuffer(n2, _this)) return;\n            if (_this.addedSet.has(n2) || _this.movedSet.has(n2)) return;\n            if (_this.mirror.hasNode(n2)) {\n                if (isIgnored(n2, _this.mirror, _this.slimDOMOptions)) {\n                    return;\n                }\n                _this.movedSet.add(n2);\n                var targetId = null;\n                if (target && _this.mirror.hasNode(target)) {\n                    targetId = _this.mirror.getId(target);\n                }\n                if (targetId && targetId !== -1) {\n                    _this.movedMap[moveKey(_this.mirror.getId(n2), targetId)] = true;\n                }\n            } else {\n                _this.addedSet.add(n2);\n                _this.droppedSet.delete(n2);\n            }\n            if (!isBlocked(n2, _this.blockClass, _this.blockSelector, false)) {\n                index.childNodes(n2).forEach(function(childN) {\n                    return _this.genAdds(childN);\n                });\n                if (hasShadowRoot(n2)) {\n                    index.childNodes(index.shadowRoot(n2)).forEach(function(childN) {\n                        _this.processedNodeManager.add(childN, _this);\n                        _this.genAdds(childN, n2);\n                    });\n                }\n            }\n        });\n    }\n    var _proto = MutationBuffer.prototype;\n    _proto.init = function init(options) {\n        var _this = this;\n        [\n            \"mutationCb\",\n            \"blockClass\",\n            \"blockSelector\",\n            \"maskTextClass\",\n            \"maskTextSelector\",\n            \"inlineStylesheet\",\n            \"maskInputOptions\",\n            \"maskTextFn\",\n            \"maskInputFn\",\n            \"keepIframeSrcFn\",\n            \"recordCanvas\",\n            \"inlineImages\",\n            \"slimDOMOptions\",\n            \"dataURLOptions\",\n            \"doc\",\n            \"mirror\",\n            \"iframeManager\",\n            \"stylesheetManager\",\n            \"shadowDomManager\",\n            \"canvasManager\",\n            \"processedNodeManager\"\n        ].forEach(function(key) {\n            _this[key] = options[key];\n        });\n    };\n    _proto.freeze = function freeze() {\n        this.frozen = true;\n        this.canvasManager.freeze();\n    };\n    _proto.unfreeze = function unfreeze() {\n        this.frozen = false;\n        this.canvasManager.unfreeze();\n        this.emit();\n    };\n    _proto.isFrozen = function isFrozen() {\n        return this.frozen;\n    };\n    _proto.lock = function lock() {\n        this.locked = true;\n        this.canvasManager.lock();\n    };\n    _proto.unlock = function unlock() {\n        this.locked = false;\n        this.canvasManager.unlock();\n        this.emit();\n    };\n    _proto.reset = function reset() {\n        this.shadowDomManager.reset();\n        this.canvasManager.reset();\n    };\n    return MutationBuffer;\n}();\nfunction deepDelete(addsSet, n2) {\n    addsSet.delete(n2);\n    index.childNodes(n2).forEach(function(childN) {\n        return deepDelete(addsSet, childN);\n    });\n}\nfunction processRemoves(n2, cache) {\n    var queue = [\n        n2\n    ];\n    while(queue.length){\n        var next = queue.pop();\n        if (cache.has(next)) continue;\n        cache.add(next);\n        index.childNodes(next).forEach(function(n22) {\n            return queue.push(n22);\n        });\n    }\n    return;\n}\nfunction isParentRemoved(removes, n2, mirror2) {\n    if (removes.size === 0) return false;\n    return _isParentRemoved(removes, n2);\n}\nfunction _isParentRemoved(removes, n2, _mirror2) {\n    var node2 = index.parentNode(n2);\n    if (!node2) return false;\n    return removes.has(node2);\n}\nfunction isAncestorInSet(set, n2) {\n    if (set.size === 0) return false;\n    return _isAncestorInSet(set, n2);\n}\nfunction _isAncestorInSet(set, n2) {\n    var parent = index.parentNode(n2);\n    if (!parent) {\n        return false;\n    }\n    if (set.has(parent)) {\n        return true;\n    }\n    return _isAncestorInSet(set, parent);\n}\nvar errorHandler;\nfunction registerErrorHandler(handler) {\n    errorHandler = handler;\n}\nfunction unregisterErrorHandler() {\n    errorHandler = void 0;\n}\nvar callbackWrapper = function(cb) {\n    if (!errorHandler) {\n        return cb;\n    }\n    var rrwebWrapped = function() {\n        for(var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++){\n            rest[_key] = arguments[_key];\n        }\n        try {\n            return cb.apply(void 0, [].concat(rest));\n        } catch (error) {\n            if (errorHandler && errorHandler(error) === true) {\n                return;\n            }\n            throw error;\n        }\n    };\n    return rrwebWrapped;\n};\nvar mutationBuffers = [];\nfunction getEventTarget(event) {\n    try {\n        if (\"composedPath\" in event) {\n            var path = event.composedPath();\n            if (path.length) {\n                return path[0];\n            }\n        } else if (\"path\" in event && event.path.length) {\n            return event.path[0];\n        }\n    } catch (e) {}\n    return event && event.target;\n}\nfunction initMutationObserver(options, rootEl) {\n    var mutationBuffer = new MutationBuffer();\n    mutationBuffers.push(mutationBuffer);\n    mutationBuffer.init(options);\n    var observer = new (mutationObserverCtor())(callbackWrapper(mutationBuffer.processMutations.bind(mutationBuffer)));\n    observer.observe(rootEl, {\n        attributes: true,\n        attributeOldValue: true,\n        characterData: true,\n        characterDataOldValue: true,\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nfunction initMoveObserver(param) {\n    var mousemoveCb = param.mousemoveCb, sampling = param.sampling, doc = param.doc, mirror2 = param.mirror;\n    if (sampling.mousemove === false) {\n        return function() {};\n    }\n    var threshold = typeof sampling.mousemove === \"number\" ? sampling.mousemove : 50;\n    var callbackThreshold = typeof sampling.mousemoveCallback === \"number\" ? sampling.mousemoveCallback : 500;\n    var positions = [];\n    var timeBaseline;\n    var wrappedCb = throttle(callbackWrapper(function(source) {\n        var totalOffset = Date.now() - timeBaseline;\n        mousemoveCb(positions.map(function(p) {\n            p.timeOffset -= totalOffset;\n            return p;\n        }), source);\n        positions = [];\n        timeBaseline = null;\n    }), callbackThreshold);\n    var updatePosition = callbackWrapper(throttle(callbackWrapper(function(evt) {\n        var target = getEventTarget(evt);\n        var _ref = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt, clientX = _ref.clientX, clientY = _ref.clientY;\n        if (!timeBaseline) {\n            timeBaseline = nowTimestamp();\n        }\n        positions.push({\n            x: clientX,\n            y: clientY,\n            id: mirror2.getId(target),\n            timeOffset: nowTimestamp() - timeBaseline\n        });\n        wrappedCb(typeof DragEvent !== \"undefined\" && _instanceof(evt, DragEvent) ? IncrementalSource.Drag : _instanceof(evt, MouseEvent) ? IncrementalSource.MouseMove : IncrementalSource.TouchMove);\n    }), threshold, {\n        trailing: false\n    }));\n    var handlers = [\n        on(\"mousemove\", updatePosition, doc),\n        on(\"touchmove\", updatePosition, doc),\n        on(\"drag\", updatePosition, doc)\n    ];\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction initMouseInteractionObserver(param) {\n    var mouseInteractionCb = param.mouseInteractionCb, doc = param.doc, mirror2 = param.mirror, blockClass = param.blockClass, blockSelector = param.blockSelector, sampling = param.sampling;\n    if (sampling.mouseInteraction === false) {\n        return function() {};\n    }\n    var disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === void 0 ? {} : sampling.mouseInteraction;\n    var handlers = [];\n    var currentPointerType = null;\n    var getHandler = function(eventKey) {\n        return function(event) {\n            var target = getEventTarget(event);\n            if (isBlocked(target, blockClass, blockSelector, true)) {\n                return;\n            }\n            var pointerType = null;\n            var thisEventKey = eventKey;\n            if (\"pointerType\" in event) {\n                switch(event.pointerType){\n                    case \"mouse\":\n                        pointerType = PointerTypes.Mouse;\n                        break;\n                    case \"touch\":\n                        pointerType = PointerTypes.Touch;\n                        break;\n                    case \"pen\":\n                        pointerType = PointerTypes.Pen;\n                        break;\n                }\n                if (pointerType === PointerTypes.Touch) {\n                    if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\n                        thisEventKey = \"TouchStart\";\n                    } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\n                        thisEventKey = \"TouchEnd\";\n                    }\n                } else if (pointerType === PointerTypes.Pen) ;\n            } else if (legacy_isTouchEvent(event)) {\n                pointerType = PointerTypes.Touch;\n            }\n            if (pointerType !== null) {\n                currentPointerType = pointerType;\n                if (thisEventKey.startsWith(\"Touch\") && pointerType === PointerTypes.Touch || thisEventKey.startsWith(\"Mouse\") && pointerType === PointerTypes.Mouse) {\n                    pointerType = null;\n                }\n            } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\n                pointerType = currentPointerType;\n                currentPointerType = null;\n            }\n            var e2 = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\n            if (!e2) {\n                return;\n            }\n            var id = mirror2.getId(target);\n            var clientX = e2.clientX, clientY = e2.clientY;\n            callbackWrapper(mouseInteractionCb)(_extends({\n                type: MouseInteractions[thisEventKey],\n                id: id,\n                x: clientX,\n                y: clientY\n            }, pointerType !== null && {\n                pointerType: pointerType\n            }));\n        };\n    };\n    Object.keys(MouseInteractions).filter(function(key) {\n        return Number.isNaN(Number(key)) && !key.endsWith(\"_Departed\") && disableMap[key] !== false;\n    }).forEach(function(eventKey) {\n        var eventName = toLowerCase(eventKey);\n        var handler = getHandler(eventKey);\n        if (window.PointerEvent) {\n            switch(MouseInteractions[eventKey]){\n                case MouseInteractions.MouseDown:\n                case MouseInteractions.MouseUp:\n                    eventName = eventName.replace(\"mouse\", \"pointer\");\n                    break;\n                case MouseInteractions.TouchStart:\n                case MouseInteractions.TouchEnd:\n                    return;\n            }\n        }\n        handlers.push(on(eventName, handler, doc));\n    });\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction initScrollObserver(param) {\n    var scrollCb = param.scrollCb, doc = param.doc, mirror2 = param.mirror, blockClass = param.blockClass, blockSelector = param.blockSelector, sampling = param.sampling;\n    var updatePosition = callbackWrapper(throttle(callbackWrapper(function(evt) {\n        var target = getEventTarget(evt);\n        if (!target || isBlocked(target, blockClass, blockSelector, true)) {\n            return;\n        }\n        var id = mirror2.getId(target);\n        if (target === doc && doc.defaultView) {\n            var scrollLeftTop = getWindowScroll(doc.defaultView);\n            scrollCb({\n                id: id,\n                x: scrollLeftTop.left,\n                y: scrollLeftTop.top\n            });\n        } else {\n            scrollCb({\n                id: id,\n                x: target.scrollLeft,\n                y: target.scrollTop\n            });\n        }\n    }), sampling.scroll || 100));\n    return on(\"scroll\", updatePosition, doc);\n}\nfunction initViewportResizeObserver(param, param1) {\n    var viewportResizeCb = param.viewportResizeCb;\n    var win = param1.win;\n    var lastH = -1;\n    var lastW = -1;\n    var updateDimension = callbackWrapper(throttle(callbackWrapper(function() {\n        var height = getWindowHeight();\n        var width = getWindowWidth();\n        if (lastH !== height || lastW !== width) {\n            viewportResizeCb({\n                width: Number(width),\n                height: Number(height)\n            });\n            lastH = height;\n            lastW = width;\n        }\n    }), 200));\n    return on(\"resize\", updateDimension, win);\n}\nvar INPUT_TAGS = [\n    \"INPUT\",\n    \"TEXTAREA\",\n    \"SELECT\"\n];\nvar lastInputValueMap = /* @__PURE__ */ new WeakMap();\nfunction initInputObserver(param) {\n    var inputCb = param.inputCb, doc = param.doc, mirror2 = param.mirror, blockClass = param.blockClass, blockSelector = param.blockSelector, ignoreClass = param.ignoreClass, ignoreSelector = param.ignoreSelector, maskInputOptions = param.maskInputOptions, maskInputFn = param.maskInputFn, sampling = param.sampling, userTriggeredOnInput = param.userTriggeredOnInput;\n    function eventHandler(event) {\n        var target = getEventTarget(event);\n        var userTriggered = event.isTrusted;\n        var tagName = target && target.tagName;\n        if (target && tagName === \"OPTION\") {\n            target = index.parentElement(target);\n        }\n        if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(target, blockClass, blockSelector, true)) {\n            return;\n        }\n        if (target.classList.contains(ignoreClass) || ignoreSelector && target.matches(ignoreSelector)) {\n            return;\n        }\n        var text = target.value;\n        var isChecked = false;\n        var type = getInputType(target) || \"\";\n        if (type === \"radio\" || type === \"checkbox\") {\n            isChecked = target.checked;\n        } else if (maskInputOptions[tagName.toLowerCase()] || maskInputOptions[type]) {\n            text = maskInputValue({\n                element: target,\n                maskInputOptions: maskInputOptions,\n                tagName: tagName,\n                type: type,\n                value: text,\n                maskInputFn: maskInputFn\n            });\n        }\n        cbWithDedup(target, userTriggeredOnInput ? {\n            text: text,\n            isChecked: isChecked,\n            userTriggered: userTriggered\n        } : {\n            text: text,\n            isChecked: isChecked\n        });\n        var name = target.name;\n        if (type === \"radio\" && name && isChecked) {\n            doc.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]').forEach(function(el) {\n                if (el !== target) {\n                    var text2 = el.value;\n                    cbWithDedup(el, userTriggeredOnInput ? {\n                        text: text2,\n                        isChecked: !isChecked,\n                        userTriggered: false\n                    } : {\n                        text: text2,\n                        isChecked: !isChecked\n                    });\n                }\n            });\n        }\n    }\n    function cbWithDedup(target, v2) {\n        var lastInputValue = lastInputValueMap.get(target);\n        if (!lastInputValue || lastInputValue.text !== v2.text || lastInputValue.isChecked !== v2.isChecked) {\n            lastInputValueMap.set(target, v2);\n            var id = mirror2.getId(target);\n            callbackWrapper(inputCb)(_extends({}, v2, {\n                id: id\n            }));\n        }\n    }\n    var events = sampling.input === \"last\" ? [\n        \"change\"\n    ] : [\n        \"input\",\n        \"change\"\n    ];\n    var handlers = events.map(function(eventName) {\n        return on(eventName, callbackWrapper(eventHandler), doc);\n    });\n    var currentWindow = doc.defaultView;\n    if (!currentWindow) {\n        return function() {\n            handlers.forEach(function(h) {\n                return h();\n            });\n        };\n    }\n    var propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(currentWindow.HTMLInputElement.prototype, \"value\");\n    var hookProperties = [\n        [\n            currentWindow.HTMLInputElement.prototype,\n            \"value\"\n        ],\n        [\n            currentWindow.HTMLInputElement.prototype,\n            \"checked\"\n        ],\n        [\n            currentWindow.HTMLSelectElement.prototype,\n            \"value\"\n        ],\n        [\n            currentWindow.HTMLTextAreaElement.prototype,\n            \"value\"\n        ],\n        // Some UI library use selectedIndex to set select value\n        [\n            currentWindow.HTMLSelectElement.prototype,\n            \"selectedIndex\"\n        ],\n        [\n            currentWindow.HTMLOptionElement.prototype,\n            \"selected\"\n        ]\n    ];\n    if (propertyDescriptor && propertyDescriptor.set) {\n        var _handlers;\n        (_handlers = handlers).push.apply(_handlers, [].concat(hookProperties.map(function(p) {\n            return hookSetter(p[0], p[1], {\n                set: function set() {\n                    callbackWrapper(eventHandler)({\n                        target: this,\n                        isTrusted: false\n                    });\n                }\n            }, false, currentWindow);\n        })));\n    }\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction getNestedCSSRulePositions(rule2) {\n    var positions = [];\n    function recurse(childRule, pos) {\n        if (hasNestedCSSRule(\"CSSGroupingRule\") && _instanceof(childRule.parentRule, CSSGroupingRule) || hasNestedCSSRule(\"CSSMediaRule\") && _instanceof(childRule.parentRule, CSSMediaRule) || hasNestedCSSRule(\"CSSSupportsRule\") && _instanceof(childRule.parentRule, CSSSupportsRule) || hasNestedCSSRule(\"CSSConditionRule\") && _instanceof(childRule.parentRule, CSSConditionRule)) {\n            var rules2 = Array.from(childRule.parentRule.cssRules);\n            var index2 = rules2.indexOf(childRule);\n            pos.unshift(index2);\n        } else if (childRule.parentStyleSheet) {\n            var rules21 = Array.from(childRule.parentStyleSheet.cssRules);\n            var index21 = rules21.indexOf(childRule);\n            pos.unshift(index21);\n        }\n        return pos;\n    }\n    return recurse(rule2, positions);\n}\nfunction getIdAndStyleId(sheet, mirror2, styleMirror) {\n    var id, styleId;\n    if (!sheet) return {};\n    if (sheet.ownerNode) id = mirror2.getId(sheet.ownerNode);\n    else styleId = styleMirror.getId(sheet);\n    return {\n        styleId: styleId,\n        id: id\n    };\n}\nfunction initStyleSheetObserver(param, param1) {\n    var styleSheetRuleCb = param.styleSheetRuleCb, mirror2 = param.mirror, stylesheetManager = param.stylesheetManager;\n    var win = param1.win;\n    if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\n        return function() {};\n    }\n    var insertRule = win.CSSStyleSheet.prototype.insertRule;\n    win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\n        apply: callbackWrapper(function(target, thisArg, argumentsList) {\n            var rule2 = argumentsList[0], index2 = argumentsList[1];\n            var _getIdAndStyleId = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleSheetRuleCb({\n                    id: id,\n                    styleId: styleId,\n                    adds: [\n                        {\n                            rule: rule2,\n                            index: index2\n                        }\n                    ]\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    win.CSSStyleSheet.prototype.addRule = function(selector, styleBlock, index2) {\n        if (index2 === void 0) index2 = this.cssRules.length;\n        var rule2 = selector + \" { \" + styleBlock + \" }\";\n        return win.CSSStyleSheet.prototype.insertRule.apply(this, [\n            rule2,\n            index2\n        ]);\n    };\n    var deleteRule = win.CSSStyleSheet.prototype.deleteRule;\n    win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\n        apply: callbackWrapper(function(target, thisArg, argumentsList) {\n            var index2 = argumentsList[0];\n            var _getIdAndStyleId = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleSheetRuleCb({\n                    id: id,\n                    styleId: styleId,\n                    removes: [\n                        {\n                            index: index2\n                        }\n                    ]\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    win.CSSStyleSheet.prototype.removeRule = function(index2) {\n        return win.CSSStyleSheet.prototype.deleteRule.apply(this, [\n            index2\n        ]);\n    };\n    var replace;\n    if (win.CSSStyleSheet.prototype.replace) {\n        replace = win.CSSStyleSheet.prototype.replace;\n        win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\n            apply: callbackWrapper(function(target, thisArg, argumentsList) {\n                var text = argumentsList[0];\n                var _getIdAndStyleId = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id: id,\n                        styleId: styleId,\n                        replace: text\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n    }\n    var replaceSync;\n    if (win.CSSStyleSheet.prototype.replaceSync) {\n        replaceSync = win.CSSStyleSheet.prototype.replaceSync;\n        win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\n            apply: callbackWrapper(function(target, thisArg, argumentsList) {\n                var text = argumentsList[0];\n                var _getIdAndStyleId = getIdAndStyleId(thisArg, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id: id,\n                        styleId: styleId,\n                        replaceSync: text\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n    }\n    var supportedNestedCSSRuleTypes = {};\n    if (canMonkeyPatchNestedCSSRule(\"CSSGroupingRule\")) {\n        supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\n    } else {\n        if (canMonkeyPatchNestedCSSRule(\"CSSMediaRule\")) {\n            supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\n        }\n        if (canMonkeyPatchNestedCSSRule(\"CSSConditionRule\")) {\n            supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\n        }\n        if (canMonkeyPatchNestedCSSRule(\"CSSSupportsRule\")) {\n            supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\n        }\n    }\n    var unmodifiedFunctions = {};\n    Object.entries(supportedNestedCSSRuleTypes).forEach(function(param) {\n        var typeKey = param[0], type = param[1];\n        unmodifiedFunctions[typeKey] = {\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            insertRule: type.prototype.insertRule,\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            deleteRule: type.prototype.deleteRule\n        };\n        type.prototype.insertRule = new Proxy(unmodifiedFunctions[typeKey].insertRule, {\n            apply: callbackWrapper(function(target, thisArg, argumentsList) {\n                var rule2 = argumentsList[0], index2 = argumentsList[1];\n                var _getIdAndStyleId = getIdAndStyleId(thisArg.parentStyleSheet, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id: id,\n                        styleId: styleId,\n                        adds: [\n                            {\n                                rule: rule2,\n                                index: [].concat(getNestedCSSRulePositions(thisArg), [\n                                    index2 || 0\n                                ])\n                            }\n                        ]\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n        type.prototype.deleteRule = new Proxy(unmodifiedFunctions[typeKey].deleteRule, {\n            apply: callbackWrapper(function(target, thisArg, argumentsList) {\n                var index2 = argumentsList[0];\n                var _getIdAndStyleId = getIdAndStyleId(thisArg.parentStyleSheet, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n                if (id && id !== -1 || styleId && styleId !== -1) {\n                    styleSheetRuleCb({\n                        id: id,\n                        styleId: styleId,\n                        removes: [\n                            {\n                                index: [].concat(getNestedCSSRulePositions(thisArg), [\n                                    index2\n                                ])\n                            }\n                        ]\n                    });\n                }\n                return target.apply(thisArg, argumentsList);\n            })\n        });\n    });\n    return callbackWrapper(function() {\n        win.CSSStyleSheet.prototype.insertRule = insertRule;\n        win.CSSStyleSheet.prototype.deleteRule = deleteRule;\n        replace && (win.CSSStyleSheet.prototype.replace = replace);\n        replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\n        Object.entries(supportedNestedCSSRuleTypes).forEach(function(param) {\n            var typeKey = param[0], type = param[1];\n            type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\n            type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\n        });\n    });\n}\nfunction initAdoptedStyleSheetObserver(param, host2) {\n    var mirror2 = param.mirror, stylesheetManager = param.stylesheetManager;\n    var _a2, _b, _c;\n    var hostId = null;\n    if (host2.nodeName === \"#document\") hostId = mirror2.getId(host2);\n    else hostId = mirror2.getId(index.host(host2));\n    var patchTarget = host2.nodeName === \"#document\" ? (_a2 = host2.defaultView) == null ? void 0 : _a2.Document : (_c = (_b = host2.ownerDocument) == null ? void 0 : _b.defaultView) == null ? void 0 : _c.ShadowRoot;\n    var originalPropertyDescriptor = (patchTarget == null ? void 0 : patchTarget.prototype) ? Object.getOwnPropertyDescriptor(patchTarget == null ? void 0 : patchTarget.prototype, \"adoptedStyleSheets\") : void 0;\n    if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor) return function() {};\n    Object.defineProperty(host2, \"adoptedStyleSheets\", {\n        configurable: originalPropertyDescriptor.configurable,\n        enumerable: originalPropertyDescriptor.enumerable,\n        get: function get() {\n            var _a3;\n            return (_a3 = originalPropertyDescriptor.get) == null ? void 0 : _a3.call(this);\n        },\n        set: function set(sheets) {\n            var _a3;\n            var result2 = (_a3 = originalPropertyDescriptor.set) == null ? void 0 : _a3.call(this, sheets);\n            if (hostId !== null && hostId !== -1) {\n                try {\n                    stylesheetManager.adoptStyleSheets(sheets, hostId);\n                } catch (e2) {}\n            }\n            return result2;\n        }\n    });\n    return callbackWrapper(function() {\n        Object.defineProperty(host2, \"adoptedStyleSheets\", {\n            configurable: originalPropertyDescriptor.configurable,\n            enumerable: originalPropertyDescriptor.enumerable,\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            get: originalPropertyDescriptor.get,\n            // eslint-disable-next-line @typescript-eslint/unbound-method\n            set: originalPropertyDescriptor.set\n        });\n    });\n}\nfunction initStyleDeclarationObserver(param, param1) {\n    var styleDeclarationCb = param.styleDeclarationCb, mirror2 = param.mirror, ignoreCSSAttributes = param.ignoreCSSAttributes, stylesheetManager = param.stylesheetManager;\n    var win = param1.win;\n    var setProperty = win.CSSStyleDeclaration.prototype.setProperty;\n    win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\n        apply: callbackWrapper(function(target, thisArg, argumentsList) {\n            var _a2;\n            var property = argumentsList[0], value = argumentsList[1], priority = argumentsList[2];\n            if (ignoreCSSAttributes.has(property)) {\n                return setProperty.apply(thisArg, [\n                    property,\n                    value,\n                    priority\n                ]);\n            }\n            var _getIdAndStyleId = getIdAndStyleId((_a2 = thisArg.parentRule) == null ? void 0 : _a2.parentStyleSheet, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleDeclarationCb({\n                    id: id,\n                    styleId: styleId,\n                    set: {\n                        property: property,\n                        value: value,\n                        priority: priority\n                    },\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    index: getNestedCSSRulePositions(thisArg.parentRule)\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    var removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\n    win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\n        apply: callbackWrapper(function(target, thisArg, argumentsList) {\n            var _a2;\n            var property = argumentsList[0];\n            if (ignoreCSSAttributes.has(property)) {\n                return removeProperty.apply(thisArg, [\n                    property\n                ]);\n            }\n            var _getIdAndStyleId = getIdAndStyleId((_a2 = thisArg.parentRule) == null ? void 0 : _a2.parentStyleSheet, mirror2, stylesheetManager.styleMirror), id = _getIdAndStyleId.id, styleId = _getIdAndStyleId.styleId;\n            if (id && id !== -1 || styleId && styleId !== -1) {\n                styleDeclarationCb({\n                    id: id,\n                    styleId: styleId,\n                    remove: {\n                        property: property\n                    },\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    index: getNestedCSSRulePositions(thisArg.parentRule)\n                });\n            }\n            return target.apply(thisArg, argumentsList);\n        })\n    });\n    return callbackWrapper(function() {\n        win.CSSStyleDeclaration.prototype.setProperty = setProperty;\n        win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\n    });\n}\nfunction initMediaInteractionObserver(param) {\n    var mediaInteractionCb = param.mediaInteractionCb, blockClass = param.blockClass, blockSelector = param.blockSelector, mirror2 = param.mirror, sampling = param.sampling, doc = param.doc;\n    var handler = callbackWrapper(function(type) {\n        return throttle(callbackWrapper(function(event) {\n            var target = getEventTarget(event);\n            if (!target || isBlocked(target, blockClass, blockSelector, true)) {\n                return;\n            }\n            var currentTime = target.currentTime, volume = target.volume, muted = target.muted, playbackRate = target.playbackRate, loop = target.loop;\n            mediaInteractionCb({\n                type: type,\n                id: mirror2.getId(target),\n                currentTime: currentTime,\n                volume: volume,\n                muted: muted,\n                playbackRate: playbackRate,\n                loop: loop\n            });\n        }), sampling.media || 500);\n    });\n    var handlers = [\n        on(\"play\", handler(MediaInteractions.Play), doc),\n        on(\"pause\", handler(MediaInteractions.Pause), doc),\n        on(\"seeked\", handler(MediaInteractions.Seeked), doc),\n        on(\"volumechange\", handler(MediaInteractions.VolumeChange), doc),\n        on(\"ratechange\", handler(MediaInteractions.RateChange), doc)\n    ];\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction initFontObserver(param) {\n    var fontCb = param.fontCb, doc = param.doc;\n    var win = doc.defaultView;\n    if (!win) {\n        return function() {};\n    }\n    var handlers = [];\n    var fontMap = /* @__PURE__ */ new WeakMap();\n    var originalFontFace = win.FontFace;\n    win.FontFace = function FontFace2(family, source, descriptors) {\n        var fontFace = new originalFontFace(family, source, descriptors);\n        fontMap.set(fontFace, {\n            family: family,\n            buffer: typeof source !== \"string\",\n            descriptors: descriptors,\n            fontSource: typeof source === \"string\" ? source : JSON.stringify(Array.from(new Uint8Array(source)))\n        });\n        return fontFace;\n    };\n    var restoreHandler = patch(doc.fonts, \"add\", function(original) {\n        return function(fontFace) {\n            setTimeout(callbackWrapper(function() {\n                var p = fontMap.get(fontFace);\n                if (p) {\n                    fontCb(p);\n                    fontMap.delete(fontFace);\n                }\n            }), 0);\n            return original.apply(this, [\n                fontFace\n            ]);\n        };\n    });\n    handlers.push(function() {\n        win.FontFace = originalFontFace;\n    });\n    handlers.push(restoreHandler);\n    return callbackWrapper(function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction initSelectionObserver(param) {\n    var doc = param.doc, mirror2 = param.mirror, blockClass = param.blockClass, blockSelector = param.blockSelector, selectionCb = param.selectionCb;\n    var collapsed = true;\n    var updateSelection = callbackWrapper(function() {\n        var selection = doc.getSelection();\n        if (!selection || collapsed && (selection == null ? void 0 : selection.isCollapsed)) return;\n        collapsed = selection.isCollapsed || false;\n        var ranges = [];\n        var count = selection.rangeCount || 0;\n        for(var i2 = 0; i2 < count; i2++){\n            var range = selection.getRangeAt(i2);\n            var startContainer = range.startContainer, startOffset = range.startOffset, endContainer = range.endContainer, endOffset = range.endOffset;\n            var blocked = isBlocked(startContainer, blockClass, blockSelector, true) || isBlocked(endContainer, blockClass, blockSelector, true);\n            if (blocked) continue;\n            ranges.push({\n                start: mirror2.getId(startContainer),\n                startOffset: startOffset,\n                end: mirror2.getId(endContainer),\n                endOffset: endOffset\n            });\n        }\n        selectionCb({\n            ranges: ranges\n        });\n    });\n    updateSelection();\n    return on(\"selectionchange\", updateSelection);\n}\nfunction initCustomElementObserver(param) {\n    var doc = param.doc, customElementCb = param.customElementCb;\n    var win = doc.defaultView;\n    if (!win || !win.customElements) return function() {};\n    var restoreHandler = patch(win.customElements, \"define\", function(original) {\n        return function(name, constructor, options) {\n            try {\n                customElementCb({\n                    define: {\n                        name: name\n                    }\n                });\n            } catch (e2) {\n                console.warn(\"Custom element callback failed for \" + name);\n            }\n            return original.apply(this, [\n                name,\n                constructor,\n                options\n            ]);\n        };\n    });\n    return restoreHandler;\n}\nfunction mergeHooks(o2, hooks) {\n    var mutationCb = o2.mutationCb, mousemoveCb = o2.mousemoveCb, mouseInteractionCb = o2.mouseInteractionCb, scrollCb = o2.scrollCb, viewportResizeCb = o2.viewportResizeCb, inputCb = o2.inputCb, mediaInteractionCb = o2.mediaInteractionCb, styleSheetRuleCb = o2.styleSheetRuleCb, styleDeclarationCb = o2.styleDeclarationCb, canvasMutationCb = o2.canvasMutationCb, fontCb = o2.fontCb, selectionCb = o2.selectionCb, customElementCb = o2.customElementCb;\n    o2.mutationCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mutation) {\n            var _hooks;\n            (_hooks = hooks).mutation.apply(_hooks, [].concat(p));\n        }\n        mutationCb.apply(void 0, [].concat(p));\n    };\n    o2.mousemoveCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mousemove) {\n            var _hooks;\n            (_hooks = hooks).mousemove.apply(_hooks, [].concat(p));\n        }\n        mousemoveCb.apply(void 0, [].concat(p));\n    };\n    o2.mouseInteractionCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mouseInteraction) {\n            var _hooks;\n            (_hooks = hooks).mouseInteraction.apply(_hooks, [].concat(p));\n        }\n        mouseInteractionCb.apply(void 0, [].concat(p));\n    };\n    o2.scrollCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.scroll) {\n            var _hooks;\n            (_hooks = hooks).scroll.apply(_hooks, [].concat(p));\n        }\n        scrollCb.apply(void 0, [].concat(p));\n    };\n    o2.viewportResizeCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.viewportResize) {\n            var _hooks;\n            (_hooks = hooks).viewportResize.apply(_hooks, [].concat(p));\n        }\n        viewportResizeCb.apply(void 0, [].concat(p));\n    };\n    o2.inputCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.input) {\n            var _hooks;\n            (_hooks = hooks).input.apply(_hooks, [].concat(p));\n        }\n        inputCb.apply(void 0, [].concat(p));\n    };\n    o2.mediaInteractionCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.mediaInteaction) {\n            var _hooks;\n            (_hooks = hooks).mediaInteaction.apply(_hooks, [].concat(p));\n        }\n        mediaInteractionCb.apply(void 0, [].concat(p));\n    };\n    o2.styleSheetRuleCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.styleSheetRule) {\n            var _hooks;\n            (_hooks = hooks).styleSheetRule.apply(_hooks, [].concat(p));\n        }\n        styleSheetRuleCb.apply(void 0, [].concat(p));\n    };\n    o2.styleDeclarationCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.styleDeclaration) {\n            var _hooks;\n            (_hooks = hooks).styleDeclaration.apply(_hooks, [].concat(p));\n        }\n        styleDeclarationCb.apply(void 0, [].concat(p));\n    };\n    o2.canvasMutationCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.canvasMutation) {\n            var _hooks;\n            (_hooks = hooks).canvasMutation.apply(_hooks, [].concat(p));\n        }\n        canvasMutationCb.apply(void 0, [].concat(p));\n    };\n    o2.fontCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.font) {\n            var _hooks;\n            (_hooks = hooks).font.apply(_hooks, [].concat(p));\n        }\n        fontCb.apply(void 0, [].concat(p));\n    };\n    o2.selectionCb = function() {\n        for(var _len = arguments.length, p = new Array(_len), _key = 0; _key < _len; _key++){\n            p[_key] = arguments[_key];\n        }\n        if (hooks.selection) {\n            var _hooks;\n            (_hooks = hooks).selection.apply(_hooks, [].concat(p));\n        }\n        selectionCb.apply(void 0, [].concat(p));\n    };\n    o2.customElementCb = function() {\n        for(var _len = arguments.length, c2 = new Array(_len), _key = 0; _key < _len; _key++){\n            c2[_key] = arguments[_key];\n        }\n        if (hooks.customElement) {\n            var _hooks;\n            (_hooks = hooks).customElement.apply(_hooks, [].concat(c2));\n        }\n        customElementCb.apply(void 0, [].concat(c2));\n    };\n}\nfunction initObservers(o2, hooks) {\n    if (hooks === void 0) hooks = {};\n    var currentWindow = o2.doc.defaultView;\n    if (!currentWindow) {\n        return function() {};\n    }\n    mergeHooks(o2, hooks);\n    var mutationObserver;\n    if (o2.recordDOM) {\n        mutationObserver = initMutationObserver(o2, o2.doc);\n    }\n    var mousemoveHandler = initMoveObserver(o2);\n    var mouseInteractionHandler = initMouseInteractionObserver(o2);\n    var scrollHandler = initScrollObserver(o2);\n    var viewportResizeHandler = initViewportResizeObserver(o2, {\n        win: currentWindow\n    });\n    var inputHandler = initInputObserver(o2);\n    var mediaInteractionHandler = initMediaInteractionObserver(o2);\n    var styleSheetObserver = function() {};\n    var adoptedStyleSheetObserver = function() {};\n    var styleDeclarationObserver = function() {};\n    var fontObserver = function() {};\n    if (o2.recordDOM) {\n        styleSheetObserver = initStyleSheetObserver(o2, {\n            win: currentWindow\n        });\n        adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o2, o2.doc);\n        styleDeclarationObserver = initStyleDeclarationObserver(o2, {\n            win: currentWindow\n        });\n        if (o2.collectFonts) {\n            fontObserver = initFontObserver(o2);\n        }\n    }\n    var selectionObserver = initSelectionObserver(o2);\n    var customElementObserver = initCustomElementObserver(o2);\n    var pluginHandlers = [];\n    for(var _iterator = _create_for_of_iterator_helper_loose(o2.plugins), _step; !(_step = _iterator()).done;){\n        var plugin3 = _step.value;\n        pluginHandlers.push(plugin3.observer(plugin3.callback, currentWindow, plugin3.options));\n    }\n    return callbackWrapper(function() {\n        mutationBuffers.forEach(function(b) {\n            return b.reset();\n        });\n        mutationObserver == null ? void 0 : mutationObserver.disconnect();\n        mousemoveHandler();\n        mouseInteractionHandler();\n        scrollHandler();\n        viewportResizeHandler();\n        inputHandler();\n        mediaInteractionHandler();\n        styleSheetObserver();\n        adoptedStyleSheetObserver();\n        styleDeclarationObserver();\n        fontObserver();\n        selectionObserver();\n        customElementObserver();\n        pluginHandlers.forEach(function(h) {\n            return h();\n        });\n    });\n}\nfunction hasNestedCSSRule(prop) {\n    return typeof window[prop] !== \"undefined\";\n}\nfunction canMonkeyPatchNestedCSSRule(prop) {\n    return Boolean(typeof window[prop] !== \"undefined\" && // Note: Generally, this check _shouldn't_ be necessary\n    // However, in some scenarios (e.g. jsdom) this can sometimes fail, so we check for it here\n    window[prop].prototype && \"insertRule\" in window[prop].prototype && \"deleteRule\" in window[prop].prototype);\n}\nvar CrossOriginIframeMirror = /*#__PURE__*/ function() {\n    function CrossOriginIframeMirror(generateIdFn) {\n        __publicField(this, \"iframeIdToRemoteIdMap\", /* @__PURE__ */ new WeakMap());\n        __publicField(this, \"iframeRemoteIdToIdMap\", /* @__PURE__ */ new WeakMap());\n        this.generateIdFn = generateIdFn;\n    }\n    var _proto = CrossOriginIframeMirror.prototype;\n    _proto.getId = function getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\n        var idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\n        var remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\n        var id = idToRemoteIdMap.get(remoteId);\n        if (!id) {\n            id = this.generateIdFn();\n            idToRemoteIdMap.set(remoteId, id);\n            remoteIdToIdMap.set(id, remoteId);\n        }\n        return id;\n    };\n    _proto.getIds = function getIds(iframe, remoteId) {\n        var _this = this;\n        var idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\n        var remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n        return remoteId.map(function(id) {\n            return _this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap);\n        });\n    };\n    _proto.getRemoteId = function getRemoteId(iframe, id, map) {\n        var remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\n        if (typeof id !== \"number\") return id;\n        var remoteId = remoteIdToIdMap.get(id);\n        if (!remoteId) return -1;\n        return remoteId;\n    };\n    _proto.getRemoteIds = function getRemoteIds(iframe, ids) {\n        var _this = this;\n        var remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\n        return ids.map(function(id) {\n            return _this.getRemoteId(iframe, id, remoteIdToIdMap);\n        });\n    };\n    _proto.reset = function reset(iframe) {\n        if (!iframe) {\n            this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();\n            this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();\n            return;\n        }\n        this.iframeIdToRemoteIdMap.delete(iframe);\n        this.iframeRemoteIdToIdMap.delete(iframe);\n    };\n    _proto.getIdToRemoteIdMap = function getIdToRemoteIdMap(iframe) {\n        var idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\n        if (!idToRemoteIdMap) {\n            idToRemoteIdMap = /* @__PURE__ */ new Map();\n            this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\n        }\n        return idToRemoteIdMap;\n    };\n    _proto.getRemoteIdToIdMap = function getRemoteIdToIdMap(iframe) {\n        var remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\n        if (!remoteIdToIdMap) {\n            remoteIdToIdMap = /* @__PURE__ */ new Map();\n            this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\n        }\n        return remoteIdToIdMap;\n    };\n    return CrossOriginIframeMirror;\n}();\nvar IframeManager = /*#__PURE__*/ function() {\n    function IframeManager(options) {\n        __publicField(this, \"iframes\", /* @__PURE__ */ new WeakMap());\n        __publicField(this, \"crossOriginIframeMap\", /* @__PURE__ */ new WeakMap());\n        __publicField(this, \"crossOriginIframeMirror\", new CrossOriginIframeMirror(genId));\n        __publicField(this, \"crossOriginIframeStyleMirror\");\n        __publicField(this, \"crossOriginIframeRootIdMap\", /* @__PURE__ */ new WeakMap());\n        __publicField(this, \"mirror\");\n        __publicField(this, \"mutationCb\");\n        __publicField(this, \"wrappedEmit\");\n        __publicField(this, \"loadListener\");\n        __publicField(this, \"stylesheetManager\");\n        __publicField(this, \"recordCrossOriginIframes\");\n        this.mutationCb = options.mutationCb;\n        this.wrappedEmit = options.wrappedEmit;\n        this.stylesheetManager = options.stylesheetManager;\n        this.recordCrossOriginIframes = options.recordCrossOriginIframes;\n        this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror));\n        this.mirror = options.mirror;\n        if (this.recordCrossOriginIframes) {\n            window.addEventListener(\"message\", this.handleMessage.bind(this));\n        }\n    }\n    var _proto = IframeManager.prototype;\n    _proto.addIframe = function addIframe(iframeEl) {\n        this.iframes.set(iframeEl, true);\n        if (iframeEl.contentWindow) this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\n    };\n    _proto.addLoadListener = function addLoadListener(cb) {\n        this.loadListener = cb;\n    };\n    _proto.attachIframe = function attachIframe(iframeEl, childSn) {\n        var _a2, _b;\n        this.mutationCb({\n            adds: [\n                {\n                    parentId: this.mirror.getId(iframeEl),\n                    nextId: null,\n                    node: childSn\n                }\n            ],\n            removes: [],\n            texts: [],\n            attributes: [],\n            isAttachIframe: true\n        });\n        if (this.recordCrossOriginIframes) (_a2 = iframeEl.contentWindow) == null ? void 0 : _a2.addEventListener(\"message\", this.handleMessage.bind(this));\n        (_b = this.loadListener) == null ? void 0 : _b.call(this, iframeEl);\n        if (iframeEl.contentDocument && iframeEl.contentDocument.adoptedStyleSheets && iframeEl.contentDocument.adoptedStyleSheets.length > 0) this.stylesheetManager.adoptStyleSheets(iframeEl.contentDocument.adoptedStyleSheets, this.mirror.getId(iframeEl.contentDocument));\n    };\n    _proto.handleMessage = function handleMessage(message) {\n        var crossOriginMessageEvent = message;\n        if (crossOriginMessageEvent.data.type !== \"rrweb\" || // To filter out the rrweb messages which are forwarded by some sites.\n        crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin) return;\n        var iframeSourceWindow = message.source;\n        if (!iframeSourceWindow) return;\n        var iframeEl = this.crossOriginIframeMap.get(message.source);\n        if (!iframeEl) return;\n        var transformedEvent = this.transformCrossOriginEvent(iframeEl, crossOriginMessageEvent.data.event);\n        if (transformedEvent) this.wrappedEmit(transformedEvent, crossOriginMessageEvent.data.isCheckout);\n    };\n    _proto.transformCrossOriginEvent = function transformCrossOriginEvent(iframeEl, e2) {\n        var _this = this;\n        var _a2;\n        switch(e2.type){\n            case EventType.FullSnapshot:\n                {\n                    this.crossOriginIframeMirror.reset(iframeEl);\n                    this.crossOriginIframeStyleMirror.reset(iframeEl);\n                    this.replaceIdOnNode(e2.data.node, iframeEl);\n                    var rootId = e2.data.node.id;\n                    this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\n                    this.patchRootIdOnNode(e2.data.node, rootId);\n                    return {\n                        timestamp: e2.timestamp,\n                        type: EventType.IncrementalSnapshot,\n                        data: {\n                            source: IncrementalSource.Mutation,\n                            adds: [\n                                {\n                                    parentId: this.mirror.getId(iframeEl),\n                                    nextId: null,\n                                    node: e2.data.node\n                                }\n                            ],\n                            removes: [],\n                            texts: [],\n                            attributes: [],\n                            isAttachIframe: true\n                        }\n                    };\n                }\n            case EventType.Meta:\n            case EventType.Load:\n            case EventType.DomContentLoaded:\n                {\n                    return false;\n                }\n            case EventType.Plugin:\n                {\n                    return e2;\n                }\n            case EventType.Custom:\n                {\n                    this.replaceIds(e2.data.payload, iframeEl, [\n                        \"id\",\n                        \"parentId\",\n                        \"previousId\",\n                        \"nextId\"\n                    ]);\n                    return e2;\n                }\n            case EventType.IncrementalSnapshot:\n                {\n                    switch(e2.data.source){\n                        case IncrementalSource.Mutation:\n                            {\n                                e2.data.adds.forEach(function(n2) {\n                                    _this.replaceIds(n2, iframeEl, [\n                                        \"parentId\",\n                                        \"nextId\",\n                                        \"previousId\"\n                                    ]);\n                                    _this.replaceIdOnNode(n2.node, iframeEl);\n                                    var rootId = _this.crossOriginIframeRootIdMap.get(iframeEl);\n                                    rootId && _this.patchRootIdOnNode(n2.node, rootId);\n                                });\n                                e2.data.removes.forEach(function(n2) {\n                                    _this.replaceIds(n2, iframeEl, [\n                                        \"parentId\",\n                                        \"id\"\n                                    ]);\n                                });\n                                e2.data.attributes.forEach(function(n2) {\n                                    _this.replaceIds(n2, iframeEl, [\n                                        \"id\"\n                                    ]);\n                                });\n                                e2.data.texts.forEach(function(n2) {\n                                    _this.replaceIds(n2, iframeEl, [\n                                        \"id\"\n                                    ]);\n                                });\n                                return e2;\n                            }\n                        case IncrementalSource.Drag:\n                        case IncrementalSource.TouchMove:\n                        case IncrementalSource.MouseMove:\n                            {\n                                e2.data.positions.forEach(function(p) {\n                                    _this.replaceIds(p, iframeEl, [\n                                        \"id\"\n                                    ]);\n                                });\n                                return e2;\n                            }\n                        case IncrementalSource.ViewportResize:\n                            {\n                                return false;\n                            }\n                        case IncrementalSource.MediaInteraction:\n                        case IncrementalSource.MouseInteraction:\n                        case IncrementalSource.Scroll:\n                        case IncrementalSource.CanvasMutation:\n                        case IncrementalSource.Input:\n                            {\n                                this.replaceIds(e2.data, iframeEl, [\n                                    \"id\"\n                                ]);\n                                return e2;\n                            }\n                        case IncrementalSource.StyleSheetRule:\n                        case IncrementalSource.StyleDeclaration:\n                            {\n                                this.replaceIds(e2.data, iframeEl, [\n                                    \"id\"\n                                ]);\n                                this.replaceStyleIds(e2.data, iframeEl, [\n                                    \"styleId\"\n                                ]);\n                                return e2;\n                            }\n                        case IncrementalSource.Font:\n                            {\n                                return e2;\n                            }\n                        case IncrementalSource.Selection:\n                            {\n                                e2.data.ranges.forEach(function(range) {\n                                    _this.replaceIds(range, iframeEl, [\n                                        \"start\",\n                                        \"end\"\n                                    ]);\n                                });\n                                return e2;\n                            }\n                        case IncrementalSource.AdoptedStyleSheet:\n                            {\n                                this.replaceIds(e2.data, iframeEl, [\n                                    \"id\"\n                                ]);\n                                this.replaceStyleIds(e2.data, iframeEl, [\n                                    \"styleIds\"\n                                ]);\n                                (_a2 = e2.data.styles) == null ? void 0 : _a2.forEach(function(style) {\n                                    _this.replaceStyleIds(style, iframeEl, [\n                                        \"styleId\"\n                                    ]);\n                                });\n                                return e2;\n                            }\n                    }\n                }\n        }\n        return false;\n    };\n    _proto.replace = function replace(iframeMirror, obj, iframeEl, keys) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(keys), _step; !(_step = _iterator()).done;){\n            var key = _step.value;\n            if (!Array.isArray(obj[key]) && typeof obj[key] !== \"number\") continue;\n            if (Array.isArray(obj[key])) {\n                obj[key] = iframeMirror.getIds(iframeEl, obj[key]);\n            } else {\n                obj[key] = iframeMirror.getId(iframeEl, obj[key]);\n            }\n        }\n        return obj;\n    };\n    _proto.replaceIds = function replaceIds(obj, iframeEl, keys) {\n        return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\n    };\n    _proto.replaceStyleIds = function replaceStyleIds(obj, iframeEl, keys) {\n        return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\n    };\n    _proto.replaceIdOnNode = function replaceIdOnNode(node2, iframeEl) {\n        var _this = this;\n        this.replaceIds(node2, iframeEl, [\n            \"id\",\n            \"rootId\"\n        ]);\n        if (\"childNodes\" in node2) {\n            node2.childNodes.forEach(function(child) {\n                _this.replaceIdOnNode(child, iframeEl);\n            });\n        }\n    };\n    _proto.patchRootIdOnNode = function patchRootIdOnNode(node2, rootId) {\n        var _this = this;\n        if (node2.type !== NodeType.Document && !node2.rootId) node2.rootId = rootId;\n        if (\"childNodes\" in node2) {\n            node2.childNodes.forEach(function(child) {\n                _this.patchRootIdOnNode(child, rootId);\n            });\n        }\n    };\n    return IframeManager;\n}();\nvar ShadowDomManager = /*#__PURE__*/ function() {\n    function ShadowDomManager(options) {\n        __publicField(this, \"shadowDoms\", /* @__PURE__ */ new WeakSet());\n        __publicField(this, \"mutationCb\");\n        __publicField(this, \"scrollCb\");\n        __publicField(this, \"bypassOptions\");\n        __publicField(this, \"mirror\");\n        __publicField(this, \"restoreHandlers\", []);\n        this.mutationCb = options.mutationCb;\n        this.scrollCb = options.scrollCb;\n        this.bypassOptions = options.bypassOptions;\n        this.mirror = options.mirror;\n        this.init();\n    }\n    var _proto = ShadowDomManager.prototype;\n    _proto.init = function init() {\n        this.reset();\n        this.patchAttachShadow(Element, document);\n    };\n    _proto.addShadowRoot = function addShadowRoot(shadowRoot2, doc) {\n        var _this = this;\n        if (!isNativeShadowDom(shadowRoot2)) return;\n        if (this.shadowDoms.has(shadowRoot2)) return;\n        this.shadowDoms.add(shadowRoot2);\n        var observer = initMutationObserver(_extends({}, this.bypassOptions, {\n            doc: doc,\n            mutationCb: this.mutationCb,\n            mirror: this.mirror,\n            shadowDomManager: this\n        }), shadowRoot2);\n        this.restoreHandlers.push(function() {\n            return observer.disconnect();\n        });\n        this.restoreHandlers.push(initScrollObserver(_extends({}, this.bypassOptions, {\n            scrollCb: this.scrollCb,\n            // https://gist.github.com/praveenpuglia/0832da687ed5a5d7a0907046c9ef1813\n            // scroll is not allowed to pass the boundary, so we need to listen the shadow document\n            doc: shadowRoot2,\n            mirror: this.mirror\n        })));\n        setTimeout(function() {\n            if (shadowRoot2.adoptedStyleSheets && shadowRoot2.adoptedStyleSheets.length > 0) _this.bypassOptions.stylesheetManager.adoptStyleSheets(shadowRoot2.adoptedStyleSheets, _this.mirror.getId(index.host(shadowRoot2)));\n            _this.restoreHandlers.push(initAdoptedStyleSheetObserver({\n                mirror: _this.mirror,\n                stylesheetManager: _this.bypassOptions.stylesheetManager\n            }, shadowRoot2));\n        }, 0);\n    };\n    /**\n   * Monkey patch 'attachShadow' of an IFrameElement to observe newly added shadow doms.\n   */ _proto.observeAttachShadow = function observeAttachShadow(iframeElement) {\n        if (!iframeElement.contentWindow || !iframeElement.contentDocument) return;\n        this.patchAttachShadow(iframeElement.contentWindow.Element, iframeElement.contentDocument);\n    };\n    /**\n   * Patch 'attachShadow' to observe newly added shadow doms.\n   */ _proto.patchAttachShadow = function patchAttachShadow(element, doc) {\n        var manager = this;\n        this.restoreHandlers.push(patch(element.prototype, \"attachShadow\", function(original) {\n            return function(option) {\n                var sRoot = original.call(this, option);\n                var shadowRootEl = index.shadowRoot(this);\n                if (shadowRootEl && inDom(this)) manager.addShadowRoot(shadowRootEl, doc);\n                return sRoot;\n            };\n        }));\n    };\n    _proto.reset = function reset() {\n        this.restoreHandlers.forEach(function(handler) {\n            try {\n                handler();\n            } catch (e2) {}\n        });\n        this.restoreHandlers = [];\n        this.shadowDoms = /* @__PURE__ */ new WeakSet();\n    };\n    return ShadowDomManager;\n}();\nvar chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar lookup = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\nfor(var i$1 = 0; i$1 < chars.length; i$1++){\n    lookup[chars.charCodeAt(i$1)] = i$1;\n}\nvar encode = function encode(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i2, len = bytes.length, base64 = \"\";\n    for(i2 = 0; i2 < len; i2 += 3){\n        base64 += chars[bytes[i2] >> 2];\n        base64 += chars[(bytes[i2] & 3) << 4 | bytes[i2 + 1] >> 4];\n        base64 += chars[(bytes[i2 + 1] & 15) << 2 | bytes[i2 + 2] >> 6];\n        base64 += chars[bytes[i2 + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n    return base64;\n};\nvar canvasVarMap = /* @__PURE__ */ new Map();\nfunction variableListFor$1(ctx, ctor) {\n    var contextMap = canvasVarMap.get(ctx);\n    if (!contextMap) {\n        contextMap = /* @__PURE__ */ new Map();\n        canvasVarMap.set(ctx, contextMap);\n    }\n    if (!contextMap.has(ctor)) {\n        contextMap.set(ctor, []);\n    }\n    return contextMap.get(ctor);\n}\nvar saveWebGLVar = function(value, win, ctx) {\n    if (!value || !(isInstanceOfWebGLObject(value, win) || (typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === \"object\")) return;\n    var name = value.constructor.name;\n    var list2 = variableListFor$1(ctx, name);\n    var index2 = list2.indexOf(value);\n    if (index2 === -1) {\n        index2 = list2.length;\n        list2.push(value);\n    }\n    return index2;\n};\nfunction serializeArg(value, win, ctx) {\n    if (_instanceof(value, Array)) {\n        return value.map(function(arg) {\n            return serializeArg(arg, win, ctx);\n        });\n    } else if (value === null) {\n        return value;\n    } else if (_instanceof(value, Float32Array) || _instanceof(value, Float64Array) || _instanceof(value, Int32Array) || _instanceof(value, Uint32Array) || _instanceof(value, Uint8Array) || _instanceof(value, Uint16Array) || _instanceof(value, Int16Array) || _instanceof(value, Int8Array) || _instanceof(value, Uint8ClampedArray)) {\n        var name = value.constructor.name;\n        return {\n            rr_type: name,\n            args: [\n                Object.values(value)\n            ]\n        };\n    } else if (// SharedArrayBuffer disabled on most browsers due to spectre.\n    // More info: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer/SharedArrayBuffer\n    // value instanceof SharedArrayBuffer ||\n    _instanceof(value, ArrayBuffer)) {\n        var name1 = value.constructor.name;\n        var base64 = encode(value);\n        return {\n            rr_type: name1,\n            base64: base64\n        };\n    } else if (_instanceof(value, DataView)) {\n        var name2 = value.constructor.name;\n        return {\n            rr_type: name2,\n            args: [\n                serializeArg(value.buffer, win, ctx),\n                value.byteOffset,\n                value.byteLength\n            ]\n        };\n    } else if (_instanceof(value, HTMLImageElement)) {\n        var name3 = value.constructor.name;\n        var src = value.src;\n        return {\n            rr_type: name3,\n            src: src\n        };\n    } else if (_instanceof(value, HTMLCanvasElement)) {\n        var name4 = \"HTMLImageElement\";\n        var src1 = value.toDataURL();\n        return {\n            rr_type: name4,\n            src: src1\n        };\n    } else if (_instanceof(value, ImageData)) {\n        var name5 = value.constructor.name;\n        return {\n            rr_type: name5,\n            args: [\n                serializeArg(value.data, win, ctx),\n                value.width,\n                value.height\n            ]\n        };\n    } else if (isInstanceOfWebGLObject(value, win) || (typeof value === \"undefined\" ? \"undefined\" : _type_of(value)) === \"object\") {\n        var name6 = value.constructor.name;\n        var index2 = saveWebGLVar(value, win, ctx);\n        return {\n            rr_type: name6,\n            index: index2\n        };\n    }\n    return value;\n}\nvar serializeArgs = function(args, win, ctx) {\n    return args.map(function(arg) {\n        return serializeArg(arg, win, ctx);\n    });\n};\nvar isInstanceOfWebGLObject = function(value, win) {\n    var webGLConstructorNames = [\n        \"WebGLActiveInfo\",\n        \"WebGLBuffer\",\n        \"WebGLFramebuffer\",\n        \"WebGLProgram\",\n        \"WebGLRenderbuffer\",\n        \"WebGLShader\",\n        \"WebGLShaderPrecisionFormat\",\n        \"WebGLTexture\",\n        \"WebGLUniformLocation\",\n        \"WebGLVertexArrayObject\",\n        // In old Chrome versions, value won't be an instanceof WebGLVertexArrayObject.\n        \"WebGLVertexArrayObjectOES\"\n    ];\n    var supportedWebGLConstructorNames = webGLConstructorNames.filter(function(name) {\n        return typeof win[name] === \"function\";\n    });\n    return Boolean(supportedWebGLConstructorNames.find(function(name) {\n        return _instanceof(value, win[name]);\n    }));\n};\nfunction initCanvas2DMutationObserver(cb, win, blockClass, blockSelector) {\n    var _loop = function() {\n        var prop = _step.value;\n        try {\n            if (typeof win.CanvasRenderingContext2D.prototype[prop] !== \"function\") {\n                return \"continue\";\n            }\n            var restoreHandler = patch(win.CanvasRenderingContext2D.prototype, prop, function(original) {\n                return function() {\n                    var _this = this;\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    if (!isBlocked(this.canvas, blockClass, blockSelector, true)) {\n                        setTimeout(function() {\n                            var recordArgs = serializeArgs(args, win, _this);\n                            cb(_this.canvas, {\n                                type: CanvasContext[\"2D\"],\n                                property: prop,\n                                args: recordArgs\n                            });\n                        }, 0);\n                    }\n                    return original.apply(this, args);\n                };\n            });\n            handlers.push(restoreHandler);\n        } catch (e) {\n            var hookHandler = hookSetter(win.CanvasRenderingContext2D.prototype, prop, {\n                set: function set(v2) {\n                    cb(this.canvas, {\n                        type: CanvasContext[\"2D\"],\n                        property: prop,\n                        args: [\n                            v2\n                        ],\n                        setter: true\n                    });\n                }\n            });\n            handlers.push(hookHandler);\n        }\n    };\n    var handlers = [];\n    var props2D = Object.getOwnPropertyNames(win.CanvasRenderingContext2D.prototype);\n    for(var _iterator = _create_for_of_iterator_helper_loose(props2D), _step; !(_step = _iterator()).done;)_loop();\n    return function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    };\n}\nfunction getNormalizedContextName(contextType) {\n    return contextType === \"experimental-webgl\" ? \"webgl\" : contextType;\n}\nfunction initCanvasContextObserver(win, blockClass, blockSelector, setPreserveDrawingBufferToTrue) {\n    var handlers = [];\n    try {\n        var restoreHandler = patch(win.HTMLCanvasElement.prototype, \"getContext\", function(original) {\n            return function(contextType) {\n                for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                    args[_key - 1] = arguments[_key];\n                }\n                if (!isBlocked(this, blockClass, blockSelector, true)) {\n                    var ctxName = getNormalizedContextName(contextType);\n                    if (!(\"__context\" in this)) this.__context = ctxName;\n                    if (setPreserveDrawingBufferToTrue && [\n                        \"webgl\",\n                        \"webgl2\"\n                    ].includes(ctxName)) {\n                        if (args[0] && _type_of(args[0]) === \"object\") {\n                            var contextAttributes = args[0];\n                            if (!contextAttributes.preserveDrawingBuffer) {\n                                contextAttributes.preserveDrawingBuffer = true;\n                            }\n                        } else {\n                            args.splice(0, 1, {\n                                preserveDrawingBuffer: true\n                            });\n                        }\n                    }\n                }\n                return original.apply(this, [].concat([\n                    contextType\n                ], args));\n            };\n        });\n        handlers.push(restoreHandler);\n    } catch (e) {\n        console.error(\"failed to patch HTMLCanvasElement.prototype.getContext\");\n    }\n    return function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    };\n}\nfunction patchGLPrototype(prototype, type, cb, blockClass, blockSelector, win) {\n    var _loop = function() {\n        var prop = _step.value;\n        if (//prop.startsWith('get') ||  // e.g. getProgramParameter, but too risky\n        [\n            \"isContextLost\",\n            \"canvas\",\n            \"drawingBufferWidth\",\n            \"drawingBufferHeight\"\n        ].includes(prop)) {\n            return \"continue\";\n        }\n        try {\n            if (typeof prototype[prop] !== \"function\") {\n                return \"continue\";\n            }\n            var restoreHandler = patch(prototype, prop, function(original) {\n                return function() {\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                        args[_key] = arguments[_key];\n                    }\n                    var result2 = original.apply(this, args);\n                    saveWebGLVar(result2, win, this);\n                    if (\"tagName\" in this.canvas && !isBlocked(this.canvas, blockClass, blockSelector, true)) {\n                        var recordArgs = serializeArgs(args, win, this);\n                        var mutation = {\n                            type: type,\n                            property: prop,\n                            args: recordArgs\n                        };\n                        cb(this.canvas, mutation);\n                    }\n                    return result2;\n                };\n            });\n            handlers.push(restoreHandler);\n        } catch (e) {\n            var hookHandler = hookSetter(prototype, prop, {\n                set: function set(v2) {\n                    cb(this.canvas, {\n                        type: type,\n                        property: prop,\n                        args: [\n                            v2\n                        ],\n                        setter: true\n                    });\n                }\n            });\n            handlers.push(hookHandler);\n        }\n    };\n    var handlers = [];\n    var props = Object.getOwnPropertyNames(prototype);\n    for(var _iterator = _create_for_of_iterator_helper_loose(props), _step; !(_step = _iterator()).done;)_loop();\n    return handlers;\n}\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass, blockSelector) {\n    var _handlers;\n    var handlers = [];\n    (_handlers = handlers).push.apply(_handlers, [].concat(patchGLPrototype(win.WebGLRenderingContext.prototype, CanvasContext.WebGL, cb, blockClass, blockSelector, win)));\n    if (typeof win.WebGL2RenderingContext !== \"undefined\") {\n        var _handlers1;\n        (_handlers1 = handlers).push.apply(_handlers1, [].concat(patchGLPrototype(win.WebGL2RenderingContext.prototype, CanvasContext.WebGL2, cb, blockClass, blockSelector, win)));\n    }\n    return function() {\n        handlers.forEach(function(h) {\n            return h();\n        });\n    };\n}\nvar encodedJs = \"KGZ1bmN0aW9uKCkgewogICJ1c2Ugc3RyaWN0IjsKICB2YXIgY2hhcnMgPSAiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyI7CiAgdmFyIGxvb2t1cCA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAidW5kZWZpbmVkIiA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTsKICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7CiAgICBsb29rdXBbY2hhcnMuY2hhckNvZGVBdChpKV0gPSBpOwogIH0KICB2YXIgZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHsKICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSwgaTIsIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gIiI7CiAgICBmb3IgKGkyID0gMDsgaTIgPCBsZW47IGkyICs9IDMpIHsKICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kyXSA+PiAyXTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMl0gJiAzKSA8PCA0IHwgYnl0ZXNbaTIgKyAxXSA+PiA0XTsKICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMiArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpMiArIDJdID4+IDZdOwogICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaTIgKyAyXSAmIDYzXTsKICAgIH0KICAgIGlmIChsZW4gJSAzID09PSAyKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgIj0iOwogICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7CiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgIj09IjsKICAgIH0KICAgIHJldHVybiBiYXNlNjQ7CiAgfTsKICBjb25zdCBsYXN0QmxvYk1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7CiAgY29uc3QgdHJhbnNwYXJlbnRCbG9iTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTsKICBhc3luYyBmdW5jdGlvbiBnZXRUcmFuc3BhcmVudEJsb2JGb3Iod2lkdGgsIGhlaWdodCwgZGF0YVVSTE9wdGlvbnMpIHsKICAgIGNvbnN0IGlkID0gYCR7d2lkdGh9LSR7aGVpZ2h0fWA7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBpZiAodHJhbnNwYXJlbnRCbG9iTWFwLmhhcyhpZCkpIHJldHVybiB0cmFuc3BhcmVudEJsb2JNYXAuZ2V0KGlkKTsKICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTsKICAgICAgb2Zmc2NyZWVuLmdldENvbnRleHQoIjJkIik7CiAgICAgIGNvbnN0IGJsb2IgPSBhd2FpdCBvZmZzY3JlZW4uY29udmVydFRvQmxvYihkYXRhVVJMT3B0aW9ucyk7CiAgICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpOwogICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUoYXJyYXlCdWZmZXIpOwogICAgICB0cmFuc3BhcmVudEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICByZXR1cm4gYmFzZTY0OwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuICIiOwogICAgfQogIH0KICBjb25zdCB3b3JrZXIgPSBzZWxmOwogIHdvcmtlci5vbm1lc3NhZ2UgPSBhc3luYyBmdW5jdGlvbihlKSB7CiAgICBpZiAoIk9mZnNjcmVlbkNhbnZhcyIgaW4gZ2xvYmFsVGhpcykgewogICAgICBjb25zdCB7IGlkLCBiaXRtYXAsIHdpZHRoLCBoZWlnaHQsIGRhdGFVUkxPcHRpb25zIH0gPSBlLmRhdGE7CiAgICAgIGNvbnN0IHRyYW5zcGFyZW50QmFzZTY0ID0gZ2V0VHJhbnNwYXJlbnRCbG9iRm9yKAogICAgICAgIHdpZHRoLAogICAgICAgIGhlaWdodCwKICAgICAgICBkYXRhVVJMT3B0aW9ucwogICAgICApOwogICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpOwogICAgICBjb25zdCBjdHggPSBvZmZzY3JlZW4uZ2V0Q29udGV4dCgiMmQiKTsKICAgICAgY3R4LmRyYXdJbWFnZShiaXRtYXAsIDAsIDApOwogICAgICBiaXRtYXAuY2xvc2UoKTsKICAgICAgY29uc3QgYmxvYiA9IGF3YWl0IG9mZnNjcmVlbi5jb252ZXJ0VG9CbG9iKGRhdGFVUkxPcHRpb25zKTsKICAgICAgY29uc3QgdHlwZSA9IGJsb2IudHlwZTsKICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBibG9iLmFycmF5QnVmZmVyKCk7CiAgICAgIGNvbnN0IGJhc2U2NCA9IGVuY29kZShhcnJheUJ1ZmZlcik7CiAgICAgIGlmICghbGFzdEJsb2JNYXAuaGFzKGlkKSAmJiBhd2FpdCB0cmFuc3BhcmVudEJhc2U2NCA9PT0gYmFzZTY0KSB7CiAgICAgICAgbGFzdEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpOwogICAgICAgIHJldHVybiB3b3JrZXIucG9zdE1lc3NhZ2UoeyBpZCB9KTsKICAgICAgfQogICAgICBpZiAobGFzdEJsb2JNYXAuZ2V0KGlkKSA9PT0gYmFzZTY0KSByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQgfSk7CiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7CiAgICAgICAgaWQsCiAgICAgICAgdHlwZSwKICAgICAgICBiYXNlNjQsCiAgICAgICAgd2lkdGgsCiAgICAgICAgaGVpZ2h0CiAgICAgIH0pOwogICAgICBsYXN0QmxvYk1hcC5zZXQoaWQsIGJhc2U2NCk7CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQ6IGUuZGF0YS5pZCB9KTsKICAgIH0KICB9Owp9KSgpOwovLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1iaXRtYXAtZGF0YS11cmwtd29ya2VyLUlKcEM3Z19iLmpzLm1hcAo=\";\nvar decodeBase64 = function(base64) {\n    return Uint8Array.from(atob(base64), function(c2) {\n        return c2.charCodeAt(0);\n    });\n};\nvar blob = typeof window !== \"undefined\" && window.Blob && new Blob([\n    decodeBase64(encodedJs)\n], {\n    type: \"text/javascript;charset=utf-8\"\n});\nfunction WorkerWrapper(options) {\n    var objURL;\n    try {\n        objURL = blob && (window.URL || window.webkitURL).createObjectURL(blob);\n        if (!objURL) throw \"\";\n        var worker = new Worker(objURL, {\n            name: options == null ? void 0 : options.name\n        });\n        worker.addEventListener(\"error\", function() {\n            (window.URL || window.webkitURL).revokeObjectURL(objURL);\n        });\n        return worker;\n    } catch (e2) {\n        return new Worker(\"data:text/javascript;base64,\" + encodedJs, {\n            name: options == null ? void 0 : options.name\n        });\n    } finally{\n        objURL && (window.URL || window.webkitURL).revokeObjectURL(objURL);\n    }\n}\nvar CanvasManager = /*#__PURE__*/ function() {\n    function CanvasManager(options) {\n        var _this = this;\n        __publicField(this, \"pendingCanvasMutations\", /* @__PURE__ */ new Map());\n        __publicField(this, \"rafStamps\", {\n            latestId: 0,\n            invokeId: null\n        });\n        __publicField(this, \"mirror\");\n        __publicField(this, \"mutationCb\");\n        __publicField(this, \"resetObservers\");\n        __publicField(this, \"frozen\", false);\n        __publicField(this, \"locked\", false);\n        __publicField(this, \"processMutation\", function(target, mutation) {\n            var newFrame = _this.rafStamps.invokeId && _this.rafStamps.latestId !== _this.rafStamps.invokeId;\n            if (newFrame || !_this.rafStamps.invokeId) _this.rafStamps.invokeId = _this.rafStamps.latestId;\n            if (!_this.pendingCanvasMutations.has(target)) {\n                _this.pendingCanvasMutations.set(target, []);\n            }\n            _this.pendingCanvasMutations.get(target).push(mutation);\n        });\n        var _options_sampling = options.sampling, sampling = _options_sampling === void 0 ? \"all\" : _options_sampling, win = options.win, blockClass = options.blockClass, blockSelector = options.blockSelector, recordCanvas = options.recordCanvas, dataURLOptions = options.dataURLOptions;\n        this.mutationCb = options.mutationCb;\n        this.mirror = options.mirror;\n        if (recordCanvas && sampling === \"all\") this.initCanvasMutationObserver(win, blockClass, blockSelector);\n        if (recordCanvas && typeof sampling === \"number\") this.initCanvasFPSObserver(sampling, win, blockClass, blockSelector, {\n            dataURLOptions: dataURLOptions\n        });\n    }\n    var _proto = CanvasManager.prototype;\n    _proto.reset = function reset() {\n        this.pendingCanvasMutations.clear();\n        this.resetObservers && this.resetObservers();\n    };\n    _proto.freeze = function freeze() {\n        this.frozen = true;\n    };\n    _proto.unfreeze = function unfreeze() {\n        this.frozen = false;\n    };\n    _proto.lock = function lock() {\n        this.locked = true;\n    };\n    _proto.unlock = function unlock() {\n        this.locked = false;\n    };\n    _proto.initCanvasFPSObserver = function initCanvasFPSObserver(fps, win, blockClass, blockSelector, options) {\n        var _this = this;\n        var canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, true);\n        var snapshotInProgressMap = /* @__PURE__ */ new Map();\n        var worker = new WorkerWrapper();\n        worker.onmessage = function(e2) {\n            var id = e2.data.id;\n            snapshotInProgressMap.set(id, false);\n            if (!(\"base64\" in e2.data)) return;\n            var _e2_data = e2.data, base64 = _e2_data.base64, type = _e2_data.type, width = _e2_data.width, height = _e2_data.height;\n            _this.mutationCb({\n                id: id,\n                type: CanvasContext[\"2D\"],\n                commands: [\n                    {\n                        property: \"clearRect\",\n                        // wipe canvas\n                        args: [\n                            0,\n                            0,\n                            width,\n                            height\n                        ]\n                    },\n                    {\n                        property: \"drawImage\",\n                        // draws (semi-transparent) image\n                        args: [\n                            {\n                                rr_type: \"ImageBitmap\",\n                                args: [\n                                    {\n                                        rr_type: \"Blob\",\n                                        data: [\n                                            {\n                                                rr_type: \"ArrayBuffer\",\n                                                base64: base64\n                                            }\n                                        ],\n                                        type: type\n                                    }\n                                ]\n                            },\n                            0,\n                            0\n                        ]\n                    }\n                ]\n            });\n        };\n        var timeBetweenSnapshots = 1e3 / fps;\n        var lastSnapshotTime = 0;\n        var rafId;\n        var getCanvas = function() {\n            var matchedCanvas = [];\n            win.document.querySelectorAll(\"canvas\").forEach(function(canvas) {\n                if (!isBlocked(canvas, blockClass, blockSelector, true)) {\n                    matchedCanvas.push(canvas);\n                }\n            });\n            return matchedCanvas;\n        };\n        var takeCanvasSnapshots = function(timestamp) {\n            if (lastSnapshotTime && timestamp - lastSnapshotTime < timeBetweenSnapshots) {\n                rafId = requestAnimationFrame(takeCanvasSnapshots);\n                return;\n            }\n            lastSnapshotTime = timestamp;\n            var _this1 = _this;\n            getCanvas().forEach(/*#__PURE__*/ _async_to_generator(function(canvas) {\n                var _a2, id, context, bitmap;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            id = _this1.mirror.getId(canvas);\n                            if (snapshotInProgressMap.get(id)) return [\n                                2\n                            ];\n                            if (canvas.width === 0 || canvas.height === 0) return [\n                                2\n                            ];\n                            snapshotInProgressMap.set(id, true);\n                            if ([\n                                \"webgl\",\n                                \"webgl2\"\n                            ].includes(canvas.__context)) {\n                                context = canvas.getContext(canvas.__context);\n                                if (((_a2 = context == null ? void 0 : context.getContextAttributes()) == null ? void 0 : _a2.preserveDrawingBuffer) === false) {\n                                    context.clear(context.COLOR_BUFFER_BIT);\n                                }\n                            }\n                            return [\n                                4,\n                                createImageBitmap(canvas)\n                            ];\n                        case 1:\n                            bitmap = _state.sent();\n                            worker.postMessage({\n                                id: id,\n                                bitmap: bitmap,\n                                width: canvas.width,\n                                height: canvas.height,\n                                dataURLOptions: options.dataURLOptions\n                            }, [\n                                bitmap\n                            ]);\n                            return [\n                                2\n                            ];\n                    }\n                });\n            }));\n            rafId = requestAnimationFrame(takeCanvasSnapshots);\n        };\n        rafId = requestAnimationFrame(takeCanvasSnapshots);\n        this.resetObservers = function() {\n            canvasContextReset();\n            cancelAnimationFrame(rafId);\n        };\n    };\n    _proto.initCanvasMutationObserver = function initCanvasMutationObserver(win, blockClass, blockSelector) {\n        this.startRAFTimestamping();\n        this.startPendingCanvasMutationFlusher();\n        var canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, false);\n        var canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector);\n        var canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector);\n        this.resetObservers = function() {\n            canvasContextReset();\n            canvas2DReset();\n            canvasWebGL1and2Reset();\n        };\n    };\n    _proto.startPendingCanvasMutationFlusher = function startPendingCanvasMutationFlusher() {\n        var _this = this;\n        requestAnimationFrame(function() {\n            return _this.flushPendingCanvasMutations();\n        });\n    };\n    _proto.startRAFTimestamping = function startRAFTimestamping() {\n        var _this = this;\n        var setLatestRAFTimestamp = function(timestamp) {\n            _this.rafStamps.latestId = timestamp;\n            requestAnimationFrame(setLatestRAFTimestamp);\n        };\n        requestAnimationFrame(setLatestRAFTimestamp);\n    };\n    _proto.flushPendingCanvasMutations = function flushPendingCanvasMutations() {\n        var _this = this;\n        this.pendingCanvasMutations.forEach(function(_values, canvas) {\n            var id = _this.mirror.getId(canvas);\n            _this.flushPendingCanvasMutationFor(canvas, id);\n        });\n        requestAnimationFrame(function() {\n            return _this.flushPendingCanvasMutations();\n        });\n    };\n    _proto.flushPendingCanvasMutationFor = function flushPendingCanvasMutationFor(canvas, id) {\n        if (this.frozen || this.locked) {\n            return;\n        }\n        var valuesWithType = this.pendingCanvasMutations.get(canvas);\n        if (!valuesWithType || id === -1) return;\n        var values = valuesWithType.map(function(value) {\n            value.type; var rest = _object_without_properties_loose(value, [\n                \"type\"\n            ]);\n            return rest;\n        });\n        var type = valuesWithType[0].type;\n        this.mutationCb({\n            id: id,\n            type: type,\n            commands: values\n        });\n        this.pendingCanvasMutations.delete(canvas);\n    };\n    return CanvasManager;\n}();\nvar StylesheetManager = /*#__PURE__*/ function() {\n    function StylesheetManager(options) {\n        __publicField(this, \"trackedLinkElements\", /* @__PURE__ */ new WeakSet());\n        __publicField(this, \"mutationCb\");\n        __publicField(this, \"adoptedStyleSheetCb\");\n        __publicField(this, \"styleMirror\", new StyleSheetMirror());\n        this.mutationCb = options.mutationCb;\n        this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\n    }\n    var _proto = StylesheetManager.prototype;\n    _proto.attachLinkElement = function attachLinkElement(linkEl, childSn) {\n        if (\"_cssText\" in childSn.attributes) this.mutationCb({\n            adds: [],\n            removes: [],\n            texts: [],\n            attributes: [\n                {\n                    id: childSn.id,\n                    attributes: childSn.attributes\n                }\n            ]\n        });\n        this.trackLinkElement(linkEl);\n    };\n    _proto.trackLinkElement = function trackLinkElement(linkEl) {\n        if (this.trackedLinkElements.has(linkEl)) return;\n        this.trackedLinkElements.add(linkEl);\n        this.trackStylesheetInLinkElement(linkEl);\n    };\n    _proto.adoptStyleSheets = function adoptStyleSheets(sheets, hostId) {\n        var _this, _loop = function() {\n            var sheet = _step.value;\n            var styleId = void 0;\n            if (!_this.styleMirror.has(sheet)) {\n                styleId = _this.styleMirror.add(sheet);\n                styles.push({\n                    styleId: styleId,\n                    rules: Array.from(sheet.rules || CSSRule, function(r2, index2) {\n                        return {\n                            rule: stringifyRule(r2, sheet.href),\n                            index: index2\n                        };\n                    })\n                });\n            } else styleId = _this.styleMirror.getId(sheet);\n            adoptedStyleSheetData.styleIds.push(styleId);\n        };\n        if (sheets.length === 0) return;\n        var adoptedStyleSheetData = {\n            id: hostId,\n            styleIds: []\n        };\n        var styles = [];\n        for(var _iterator = _create_for_of_iterator_helper_loose(sheets), _step; !(_step = _iterator()).done;)_this = this, _loop();\n        if (styles.length > 0) adoptedStyleSheetData.styles = styles;\n        this.adoptedStyleSheetCb(adoptedStyleSheetData);\n    };\n    _proto.reset = function reset() {\n        this.styleMirror.reset();\n        this.trackedLinkElements = /* @__PURE__ */ new WeakSet();\n    };\n    // TODO: take snapshot on stylesheet reload by applying event listener\n    _proto.trackStylesheetInLinkElement = function trackStylesheetInLinkElement(_linkEl) {};\n    return StylesheetManager;\n}();\nvar ProcessedNodeManager = /*#__PURE__*/ function() {\n    function ProcessedNodeManager() {\n        __publicField(this, \"nodeMap\", /* @__PURE__ */ new WeakMap());\n        __publicField(this, \"active\", false);\n    }\n    var _proto = ProcessedNodeManager.prototype;\n    _proto.inOtherBuffer = function inOtherBuffer(node2, thisBuffer) {\n        var buffers = this.nodeMap.get(node2);\n        return buffers && Array.from(buffers).some(function(buffer) {\n            return buffer !== thisBuffer;\n        });\n    };\n    _proto.add = function add(node2, buffer) {\n        var _this = this;\n        if (!this.active) {\n            this.active = true;\n            requestAnimationFrame(function() {\n                _this.nodeMap = /* @__PURE__ */ new WeakMap();\n                _this.active = false;\n            });\n        }\n        this.nodeMap.set(node2, (this.nodeMap.get(node2) || /* @__PURE__ */ new Set()).add(buffer));\n    };\n    _proto.destroy = function destroy() {};\n    return ProcessedNodeManager;\n}();\nvar wrappedEmit;\nvar takeFullSnapshot$1;\nvar canvasManager;\nvar recording = false;\ntry {\n    if (Array.from([\n        1\n    ], function(x2) {\n        return x2 * 2;\n    })[0] !== 2) {\n        var cleanFrame = document.createElement(\"iframe\");\n        document.body.appendChild(cleanFrame);\n        Array.from = ((_a = cleanFrame.contentWindow) == null ? void 0 : _a.Array.from) || Array.from;\n        document.body.removeChild(cleanFrame);\n    }\n} catch (err) {\n    console.debug(\"Unable to override Array.from\", err);\n}\nvar mirror = createMirror$2();\nfunction record(options) {\n    if (options === void 0) options = {};\n    var emit = options.emit, checkoutEveryNms = options.checkoutEveryNms, checkoutEveryNth = options.checkoutEveryNth, _options_blockClass = options.blockClass, blockClass = _options_blockClass === void 0 ? \"rr-block\" : _options_blockClass, _options_blockSelector = options.blockSelector, blockSelector = _options_blockSelector === void 0 ? null : _options_blockSelector, _options_ignoreClass = options.ignoreClass, ignoreClass = _options_ignoreClass === void 0 ? \"rr-ignore\" : _options_ignoreClass, _options_ignoreSelector = options.ignoreSelector, ignoreSelector = _options_ignoreSelector === void 0 ? null : _options_ignoreSelector, _options_maskTextClass = options.maskTextClass, maskTextClass = _options_maskTextClass === void 0 ? \"rr-mask\" : _options_maskTextClass, _options_maskTextSelector = options.maskTextSelector, maskTextSelector = _options_maskTextSelector === void 0 ? null : _options_maskTextSelector, _options_inlineStylesheet = options.inlineStylesheet, inlineStylesheet = _options_inlineStylesheet === void 0 ? true : _options_inlineStylesheet, maskAllInputs = options.maskAllInputs, _maskInputOptions = options.maskInputOptions, _slimDOMOptions = options.slimDOMOptions, maskInputFn = options.maskInputFn, maskTextFn = options.maskTextFn, hooks = options.hooks, packFn = options.packFn, _options_sampling = options.sampling, sampling = _options_sampling === void 0 ? {} : _options_sampling, _options_dataURLOptions = options.dataURLOptions, dataURLOptions = _options_dataURLOptions === void 0 ? {} : _options_dataURLOptions, mousemoveWait = options.mousemoveWait, _options_recordDOM = options.recordDOM, recordDOM = _options_recordDOM === void 0 ? true : _options_recordDOM, _options_recordCanvas = options.recordCanvas, recordCanvas = _options_recordCanvas === void 0 ? false : _options_recordCanvas, _options_recordCrossOriginIframes = options.recordCrossOriginIframes, recordCrossOriginIframes = _options_recordCrossOriginIframes === void 0 ? false : _options_recordCrossOriginIframes, _options_recordAfter = options.recordAfter, recordAfter = _options_recordAfter === void 0 ? options.recordAfter === \"DOMContentLoaded\" ? options.recordAfter : \"load\" : _options_recordAfter, _options_userTriggeredOnInput = options.userTriggeredOnInput, userTriggeredOnInput = _options_userTriggeredOnInput === void 0 ? false : _options_userTriggeredOnInput, _options_collectFonts = options.collectFonts, collectFonts = _options_collectFonts === void 0 ? false : _options_collectFonts, _options_inlineImages = options.inlineImages, inlineImages = _options_inlineImages === void 0 ? false : _options_inlineImages, plugins = options.plugins, _options_keepIframeSrcFn = options.keepIframeSrcFn, keepIframeSrcFn = _options_keepIframeSrcFn === void 0 ? function() {\n        return false;\n    } : _options_keepIframeSrcFn, _options_ignoreCSSAttributes = options.ignoreCSSAttributes, ignoreCSSAttributes = _options_ignoreCSSAttributes === void 0 ? /* @__PURE__ */ new Set([]) : _options_ignoreCSSAttributes, errorHandler2 = options.errorHandler;\n    registerErrorHandler(errorHandler2);\n    var inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;\n    var passEmitsToParent = false;\n    if (!inEmittingFrame) {\n        try {\n            if (window.parent.document) {\n                passEmitsToParent = false;\n            }\n        } catch (e2) {\n            passEmitsToParent = true;\n        }\n    }\n    if (inEmittingFrame && !emit) {\n        throw new Error(\"emit function is required\");\n    }\n    if (!inEmittingFrame && !passEmitsToParent) {\n        return function() {};\n    }\n    if (mousemoveWait !== void 0 && sampling.mousemove === void 0) {\n        sampling.mousemove = mousemoveWait;\n    }\n    mirror.reset();\n    var maskInputOptions = maskAllInputs === true ? {\n        color: true,\n        date: true,\n        \"datetime-local\": true,\n        email: true,\n        month: true,\n        number: true,\n        range: true,\n        search: true,\n        tel: true,\n        text: true,\n        time: true,\n        url: true,\n        week: true,\n        textarea: true,\n        select: true,\n        password: true\n    } : _maskInputOptions !== void 0 ? _maskInputOptions : {\n        password: true\n    };\n    var slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === \"all\" ? {\n        script: true,\n        comment: true,\n        headFavicon: true,\n        headWhitespace: true,\n        headMetaSocial: true,\n        headMetaRobots: true,\n        headMetaHttpEquiv: true,\n        headMetaVerification: true,\n        // the following are off for slimDOMOptions === true,\n        // as they destroy some (hidden) info:\n        headMetaAuthorship: _slimDOMOptions === \"all\",\n        headMetaDescKeywords: _slimDOMOptions === \"all\",\n        headTitleMutations: _slimDOMOptions === \"all\"\n    } : _slimDOMOptions ? _slimDOMOptions : {};\n    polyfill$1();\n    var lastFullSnapshotEvent;\n    var incrementalSnapshotCount = 0;\n    var eventProcessor = function(e2) {\n        for(var _iterator = _create_for_of_iterator_helper_loose(plugins || []), _step; !(_step = _iterator()).done;){\n            var plugin3 = _step.value;\n            if (plugin3.eventProcessor) {\n                e2 = plugin3.eventProcessor(e2);\n            }\n        }\n        if (packFn && // Disable packing events which will be emitted to parent frames.\n        !passEmitsToParent) {\n            e2 = packFn(e2);\n        }\n        return e2;\n    };\n    wrappedEmit = function(r2, isCheckout) {\n        var _a2;\n        var e2 = r2;\n        e2.timestamp = nowTimestamp();\n        if (((_a2 = mutationBuffers[0]) == null ? void 0 : _a2.isFrozen()) && e2.type !== EventType.FullSnapshot && !(e2.type === EventType.IncrementalSnapshot && e2.data.source === IncrementalSource.Mutation)) {\n            mutationBuffers.forEach(function(buf) {\n                return buf.unfreeze();\n            });\n        }\n        if (inEmittingFrame) {\n            emit == null ? void 0 : emit(eventProcessor(e2), isCheckout);\n        } else if (passEmitsToParent) {\n            var message = {\n                type: \"rrweb\",\n                event: eventProcessor(e2),\n                origin: window.location.origin,\n                isCheckout: isCheckout\n            };\n            window.parent.postMessage(message, \"*\");\n        }\n        if (e2.type === EventType.FullSnapshot) {\n            lastFullSnapshotEvent = e2;\n            incrementalSnapshotCount = 0;\n        } else if (e2.type === EventType.IncrementalSnapshot) {\n            if (e2.data.source === IncrementalSource.Mutation && e2.data.isAttachIframe) {\n                return;\n            }\n            incrementalSnapshotCount++;\n            var exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\n            var exceedTime = checkoutEveryNms && e2.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\n            if (exceedCount || exceedTime) {\n                takeFullSnapshot$1(true);\n            }\n        }\n    };\n    var wrappedMutationEmit = function(m) {\n        wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: _extends({\n                source: IncrementalSource.Mutation\n            }, m)\n        });\n    };\n    var wrappedScrollEmit = function(p) {\n        return wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: _extends({\n                source: IncrementalSource.Scroll\n            }, p)\n        });\n    };\n    var wrappedCanvasMutationEmit = function(p) {\n        return wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: _extends({\n                source: IncrementalSource.CanvasMutation\n            }, p)\n        });\n    };\n    var wrappedAdoptedStyleSheetEmit = function(a2) {\n        return wrappedEmit({\n            type: EventType.IncrementalSnapshot,\n            data: _extends({\n                source: IncrementalSource.AdoptedStyleSheet\n            }, a2)\n        });\n    };\n    var stylesheetManager = new StylesheetManager({\n        mutationCb: wrappedMutationEmit,\n        adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit\n    });\n    var iframeManager = new IframeManager({\n        mirror: mirror,\n        mutationCb: wrappedMutationEmit,\n        stylesheetManager: stylesheetManager,\n        recordCrossOriginIframes: recordCrossOriginIframes,\n        wrappedEmit: wrappedEmit\n    });\n    for(var _iterator = _create_for_of_iterator_helper_loose(plugins || []), _step; !(_step = _iterator()).done;){\n        var plugin3 = _step.value;\n        if (plugin3.getMirror) plugin3.getMirror({\n            nodeMirror: mirror,\n            crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\n            crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror\n        });\n    }\n    var processedNodeManager = new ProcessedNodeManager();\n    canvasManager = new CanvasManager({\n        recordCanvas: recordCanvas,\n        mutationCb: wrappedCanvasMutationEmit,\n        win: window,\n        blockClass: blockClass,\n        blockSelector: blockSelector,\n        mirror: mirror,\n        sampling: sampling.canvas,\n        dataURLOptions: dataURLOptions\n    });\n    var shadowDomManager = new ShadowDomManager({\n        mutationCb: wrappedMutationEmit,\n        scrollCb: wrappedScrollEmit,\n        bypassOptions: {\n            blockClass: blockClass,\n            blockSelector: blockSelector,\n            maskTextClass: maskTextClass,\n            maskTextSelector: maskTextSelector,\n            inlineStylesheet: inlineStylesheet,\n            maskInputOptions: maskInputOptions,\n            dataURLOptions: dataURLOptions,\n            maskTextFn: maskTextFn,\n            maskInputFn: maskInputFn,\n            recordCanvas: recordCanvas,\n            inlineImages: inlineImages,\n            sampling: sampling,\n            slimDOMOptions: slimDOMOptions,\n            iframeManager: iframeManager,\n            stylesheetManager: stylesheetManager,\n            canvasManager: canvasManager,\n            keepIframeSrcFn: keepIframeSrcFn,\n            processedNodeManager: processedNodeManager\n        },\n        mirror: mirror\n    });\n    takeFullSnapshot$1 = function(isCheckout) {\n        if (isCheckout === void 0) isCheckout = false;\n        if (!recordDOM) {\n            return;\n        }\n        wrappedEmit({\n            type: EventType.Meta,\n            data: {\n                href: window.location.href,\n                width: getWindowWidth(),\n                height: getWindowHeight()\n            }\n        }, isCheckout);\n        stylesheetManager.reset();\n        shadowDomManager.init();\n        mutationBuffers.forEach(function(buf) {\n            return buf.lock();\n        });\n        var node2 = snapshot(document, {\n            mirror: mirror,\n            blockClass: blockClass,\n            blockSelector: blockSelector,\n            maskTextClass: maskTextClass,\n            maskTextSelector: maskTextSelector,\n            inlineStylesheet: inlineStylesheet,\n            maskAllInputs: maskInputOptions,\n            maskTextFn: maskTextFn,\n            maskInputFn: maskInputFn,\n            slimDOM: slimDOMOptions,\n            dataURLOptions: dataURLOptions,\n            recordCanvas: recordCanvas,\n            inlineImages: inlineImages,\n            onSerialize: function(n2) {\n                if (isSerializedIframe(n2, mirror)) {\n                    iframeManager.addIframe(n2);\n                }\n                if (isSerializedStylesheet(n2, mirror)) {\n                    stylesheetManager.trackLinkElement(n2);\n                }\n                if (hasShadowRoot(n2)) {\n                    shadowDomManager.addShadowRoot(index.shadowRoot(n2), document);\n                }\n            },\n            onIframeLoad: function(iframe, childSn) {\n                iframeManager.attachIframe(iframe, childSn);\n                shadowDomManager.observeAttachShadow(iframe);\n            },\n            onStylesheetLoad: function(linkEl, childSn) {\n                stylesheetManager.attachLinkElement(linkEl, childSn);\n            },\n            keepIframeSrcFn: keepIframeSrcFn\n        });\n        if (!node2) {\n            return console.warn(\"Failed to snapshot the document\");\n        }\n        wrappedEmit({\n            type: EventType.FullSnapshot,\n            data: {\n                node: node2,\n                initialOffset: getWindowScroll(window)\n            }\n        }, isCheckout);\n        mutationBuffers.forEach(function(buf) {\n            return buf.unlock();\n        });\n        if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0) stylesheetManager.adoptStyleSheets(document.adoptedStyleSheets, mirror.getId(document));\n    };\n    try {\n        var handlers = [];\n        var observe = function(doc) {\n            var _a2;\n            return callbackWrapper(initObservers)({\n                mutationCb: wrappedMutationEmit,\n                mousemoveCb: function(positions, source) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: {\n                            source: source,\n                            positions: positions\n                        }\n                    });\n                },\n                mouseInteractionCb: function(d) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.MouseInteraction\n                        }, d)\n                    });\n                },\n                scrollCb: wrappedScrollEmit,\n                viewportResizeCb: function(d) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.ViewportResize\n                        }, d)\n                    });\n                },\n                inputCb: function(v2) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.Input\n                        }, v2)\n                    });\n                },\n                mediaInteractionCb: function(p) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.MediaInteraction\n                        }, p)\n                    });\n                },\n                styleSheetRuleCb: function(r2) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.StyleSheetRule\n                        }, r2)\n                    });\n                },\n                styleDeclarationCb: function(r2) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.StyleDeclaration\n                        }, r2)\n                    });\n                },\n                canvasMutationCb: wrappedCanvasMutationEmit,\n                fontCb: function(p) {\n                    return wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.Font\n                        }, p)\n                    });\n                },\n                selectionCb: function(p) {\n                    wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.Selection\n                        }, p)\n                    });\n                },\n                customElementCb: function(c2) {\n                    wrappedEmit({\n                        type: EventType.IncrementalSnapshot,\n                        data: _extends({\n                            source: IncrementalSource.CustomElement\n                        }, c2)\n                    });\n                },\n                blockClass: blockClass,\n                ignoreClass: ignoreClass,\n                ignoreSelector: ignoreSelector,\n                maskTextClass: maskTextClass,\n                maskTextSelector: maskTextSelector,\n                maskInputOptions: maskInputOptions,\n                inlineStylesheet: inlineStylesheet,\n                sampling: sampling,\n                recordDOM: recordDOM,\n                recordCanvas: recordCanvas,\n                inlineImages: inlineImages,\n                userTriggeredOnInput: userTriggeredOnInput,\n                collectFonts: collectFonts,\n                doc: doc,\n                maskInputFn: maskInputFn,\n                maskTextFn: maskTextFn,\n                keepIframeSrcFn: keepIframeSrcFn,\n                blockSelector: blockSelector,\n                slimDOMOptions: slimDOMOptions,\n                dataURLOptions: dataURLOptions,\n                mirror: mirror,\n                iframeManager: iframeManager,\n                stylesheetManager: stylesheetManager,\n                shadowDomManager: shadowDomManager,\n                processedNodeManager: processedNodeManager,\n                canvasManager: canvasManager,\n                ignoreCSSAttributes: ignoreCSSAttributes,\n                plugins: ((_a2 = plugins == null ? void 0 : plugins.filter(function(p) {\n                    return p.observer;\n                })) == null ? void 0 : _a2.map(function(p) {\n                    return {\n                        observer: p.observer,\n                        options: p.options,\n                        callback: function(payload) {\n                            return wrappedEmit({\n                                type: EventType.Plugin,\n                                data: {\n                                    plugin: p.name,\n                                    payload: payload\n                                }\n                            });\n                        }\n                    };\n                })) || []\n            }, hooks);\n        };\n        iframeManager.addLoadListener(function(iframeEl) {\n            try {\n                handlers.push(observe(iframeEl.contentDocument));\n            } catch (error) {\n                console.warn(error);\n            }\n        });\n        var init = function() {\n            takeFullSnapshot$1();\n            handlers.push(observe(document));\n            recording = true;\n        };\n        if (document.readyState === \"interactive\" || document.readyState === \"complete\") {\n            init();\n        } else {\n            handlers.push(on(\"DOMContentLoaded\", function() {\n                wrappedEmit({\n                    type: EventType.DomContentLoaded,\n                    data: {}\n                });\n                if (recordAfter === \"DOMContentLoaded\") init();\n            }));\n            handlers.push(on(\"load\", function() {\n                wrappedEmit({\n                    type: EventType.Load,\n                    data: {}\n                });\n                if (recordAfter === \"load\") init();\n            }, window));\n        }\n        return function() {\n            handlers.forEach(function(h) {\n                return h();\n            });\n            processedNodeManager.destroy();\n            recording = false;\n            unregisterErrorHandler();\n        };\n    } catch (error) {\n        console.warn(error);\n    }\n}\nrecord.addCustomEvent = function(tag, payload) {\n    if (!recording) {\n        throw new Error(\"please add custom event after start recording\");\n    }\n    wrappedEmit({\n        type: EventType.Custom,\n        data: {\n            tag: tag,\n            payload: payload\n        }\n    });\n};\nrecord.freezePage = function() {\n    mutationBuffers.forEach(function(buf) {\n        return buf.freeze();\n    });\n};\nrecord.takeFullSnapshot = function(isCheckout) {\n    if (!recording) {\n        throw new Error(\"please take full snapshot after start recording\");\n    }\n    takeFullSnapshot$1(isCheckout);\n};\nrecord.mirror = mirror;\nvar n;\n!function(t2) {\n    t2[t2.NotStarted = 0] = \"NotStarted\", t2[t2.Running = 1] = \"Running\", t2[t2.Stopped = 2] = \"Stopped\";\n}(n || (n = {}));\nrecord.addCustomEvent;\nrecord.freezePage;\nrecord.takeFullSnapshot;\n\nvar setImmediate = win['setImmediate'];\nvar builtInProp, cycle, schedulingQueue,\n    ToString = Object.prototype.toString,\n    timer = (typeof setImmediate !== 'undefined') ?\n        function timer(fn) { return setImmediate(fn); } :\n        setTimeout;\n\n// dammit, IE8.\ntry {\n    Object.defineProperty({},'x',{});\n    builtInProp = function builtInProp(obj,name,val,config) {\n        return Object.defineProperty(obj,name,{\n            value: val,\n            writable: true,\n            configurable: config !== false\n        });\n    };\n}\ncatch (err) {\n    builtInProp = function builtInProp(obj,name,val) {\n        obj[name] = val;\n        return obj;\n    };\n}\n\n// Note: using a queue instead of array for efficiency\nschedulingQueue = (function Queue() {\n    var first, last, item;\n\n    function Item(fn,self) {\n        this.fn = fn;\n        this.self = self;\n        this.next = void 0;\n    }\n\n    return {\n        add: function add(fn,self) {\n            item = new Item(fn,self);\n            if (last) {\n                last.next = item;\n            }\n            else {\n                first = item;\n            }\n            last = item;\n            item = void 0;\n        },\n        drain: function drain() {\n            var f = first;\n            first = last = cycle = void 0;\n\n            while (f) {\n                f.fn.call(f.self);\n                f = f.next;\n            }\n        }\n    };\n})();\n\nfunction schedule(fn,self) {\n    schedulingQueue.add(fn,self);\n    if (!cycle) {\n        cycle = timer(schedulingQueue.drain);\n    }\n}\n\n// promise duck typing\nfunction isThenable(o) {\n    var _then, oType = typeof o;\n\n    if (o !== null && (oType === 'object' || oType === 'function')) {\n        _then = o.then;\n    }\n    return typeof _then === 'function' ? _then : false;\n}\n\nfunction notify() {\n    for (var i=0; i<this.chain.length; i++) {\n        notifyIsolated(\n            this,\n            (this.state === 1) ? this.chain[i].success : this.chain[i].failure,\n            this.chain[i]\n        );\n    }\n    this.chain.length = 0;\n}\n\n// NOTE: This is a separate function to isolate\n// the `try..catch` so that other code can be\n// optimized better\nfunction notifyIsolated(self,cb,chain) {\n    var ret, _then;\n    try {\n        if (cb === false) {\n            chain.reject(self.msg);\n        }\n        else {\n            if (cb === true) {\n                ret = self.msg;\n            }\n            else {\n                ret = cb.call(void 0,self.msg);\n            }\n\n            if (ret === chain.promise) {\n                chain.reject(TypeError('Promise-chain cycle'));\n            }\n            // eslint-disable-next-line no-cond-assign\n            else if (_then = isThenable(ret)) {\n                _then.call(ret,chain.resolve,chain.reject);\n            }\n            else {\n                chain.resolve(ret);\n            }\n        }\n    }\n    catch (err) {\n        chain.reject(err);\n    }\n}\n\nfunction resolve(msg) {\n    var _then, self = this;\n\n    // already triggered?\n    if (self.triggered) { return; }\n\n    self.triggered = true;\n\n    // unwrap\n    if (self.def) {\n        self = self.def;\n    }\n\n    try {\n        // eslint-disable-next-line no-cond-assign\n        if (_then = isThenable(msg)) {\n            schedule(function(){\n                var defWrapper = new MakeDefWrapper(self);\n                try {\n                    _then.call(msg,\n                        function $resolve$(){ resolve.apply(defWrapper,arguments); },\n                        function $reject$(){ reject.apply(defWrapper,arguments); }\n                    );\n                }\n                catch (err) {\n                    reject.call(defWrapper,err);\n                }\n            });\n        }\n        else {\n            self.msg = msg;\n            self.state = 1;\n            if (self.chain.length > 0) {\n                schedule(notify,self);\n            }\n        }\n    }\n    catch (err) {\n        reject.call(new MakeDefWrapper(self),err);\n    }\n}\n\nfunction reject(msg) {\n    var self = this;\n\n    // already triggered?\n    if (self.triggered) { return; }\n\n    self.triggered = true;\n\n    // unwrap\n    if (self.def) {\n        self = self.def;\n    }\n\n    self.msg = msg;\n    self.state = 2;\n    if (self.chain.length > 0) {\n        schedule(notify,self);\n    }\n}\n\nfunction iteratePromises(Constructor,arr,resolver,rejecter) {\n    for (var idx=0; idx<arr.length; idx++) {\n        (function IIFE(idx){\n            Constructor.resolve(arr[idx])\n                .then(\n                    function $resolver$(msg){\n                        resolver(idx,msg);\n                    },\n                    rejecter\n                );\n        })(idx);\n    }\n}\n\nfunction MakeDefWrapper(self) {\n    this.def = self;\n    this.triggered = false;\n}\n\nfunction MakeDef(self) {\n    this.promise = self;\n    this.state = 0;\n    this.triggered = false;\n    this.chain = [];\n    this.msg = void 0;\n}\n\nfunction NpoPromise(executor) {\n    if (typeof executor !== 'function') {\n        throw TypeError('Not a function');\n    }\n\n    if (this['__NPO__'] !== 0) {\n        throw TypeError('Not a promise');\n    }\n\n    // instance shadowing the inherited \"brand\"\n    // to signal an already \"initialized\" promise\n    this['__NPO__'] = 1;\n\n    var def = new MakeDef(this);\n\n    this['then'] = function then(success,failure) {\n        var o = {\n            success: typeof success === 'function' ? success : true,\n            failure: typeof failure === 'function' ? failure : false\n        };\n            // Note: `then(..)` itself can be borrowed to be used against\n            // a different promise constructor for making the chained promise,\n            // by substituting a different `this` binding.\n        o.promise = new this.constructor(function extractChain(resolve,reject) {\n            if (typeof resolve !== 'function' || typeof reject !== 'function') {\n                throw TypeError('Not a function');\n            }\n\n            o.resolve = resolve;\n            o.reject = reject;\n        });\n        def.chain.push(o);\n\n        if (def.state !== 0) {\n            schedule(notify,def);\n        }\n\n        return o.promise;\n    };\n    this['catch'] = function $catch$(failure) {\n        return this.then(void 0,failure);\n    };\n\n    try {\n        executor.call(\n            void 0,\n            function publicResolve(msg){\n                resolve.call(def,msg);\n            },\n            function publicReject(msg) {\n                reject.call(def,msg);\n            }\n        );\n    }\n    catch (err) {\n        reject.call(def,err);\n    }\n}\n\nvar PromisePrototype = builtInProp({},'constructor',NpoPromise,\n    /*configurable=*/false\n);\n\n    // Note: Android 4 cannot use `Object.defineProperty(..)` here\nNpoPromise.prototype = PromisePrototype;\n\n// built-in \"brand\" to signal an \"uninitialized\" promise\nbuiltInProp(PromisePrototype,'__NPO__',0,\n    /*configurable=*/false\n);\n\nbuiltInProp(NpoPromise,'resolve',function Promise$resolve(msg) {\n    var Constructor = this;\n\n    // spec mandated checks\n    // note: best \"isPromise\" check that's practical for now\n    if (msg && typeof msg === 'object' && msg['__NPO__'] === 1) {\n        return msg;\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        resolve(msg);\n    });\n});\n\nbuiltInProp(NpoPromise,'reject',function Promise$reject(msg) {\n    return new this(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        reject(msg);\n    });\n});\n\nbuiltInProp(NpoPromise,'all',function Promise$all(arr) {\n    var Constructor = this;\n\n    // spec mandated checks\n    if (ToString.call(arr) !== '[object Array]') {\n        return Constructor.reject(TypeError('Not an array'));\n    }\n    if (arr.length === 0) {\n        return Constructor.resolve([]);\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        var len = arr.length, msgs = Array(len), count = 0;\n\n        iteratePromises(Constructor,arr,function resolver(idx,msg) {\n            msgs[idx] = msg;\n            if (++count === len) {\n                resolve(msgs);\n            }\n        },reject);\n    });\n});\n\nbuiltInProp(NpoPromise,'race',function Promise$race(arr) {\n    var Constructor = this;\n\n    // spec mandated checks\n    if (ToString.call(arr) !== '[object Array]') {\n        return Constructor.reject(TypeError('Not an array'));\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        iteratePromises(Constructor,arr,function resolver(idx,msg){\n            resolve(msg);\n        },reject);\n    });\n});\n\nvar PromisePolyfill;\nif (typeof Promise !== 'undefined' && Promise.toString().indexOf('[native code]') !== -1) {\n    PromisePolyfill = Promise;\n} else {\n    PromisePolyfill = NpoPromise;\n}\n\nvar Config = {\n    DEBUG: false,\n    LIB_VERSION: '2.65.0'\n};\n\n/* eslint camelcase: \"off\", eqeqeq: \"off\" */\n\n// Maximum allowed session recording length\nvar MAX_RECORDING_MS = 24 * 60 * 60 * 1000; // 24 hours\n// Maximum allowed value for minimum session recording length\nvar MAX_VALUE_FOR_MIN_RECORDING_MS = 8 * 1000; // 8 seconds\n\n/*\n * Saved references to long variable names, so that closure compiler can\n * minimize file size.\n */\n\nvar ArrayProto = Array.prototype,\n    FuncProto = Function.prototype,\n    ObjProto = Object.prototype,\n    slice = ArrayProto.slice,\n    toString = ObjProto.toString,\n    hasOwnProperty = ObjProto.hasOwnProperty,\n    windowConsole = win.console,\n    navigator = win.navigator,\n    document$1 = win.document,\n    windowOpera = win.opera,\n    screen = win.screen,\n    userAgent = navigator.userAgent;\n\nvar nativeBind = FuncProto.bind,\n    nativeForEach = ArrayProto.forEach,\n    nativeIndexOf = ArrayProto.indexOf,\n    nativeMap = ArrayProto.map,\n    nativeIsArray = Array.isArray,\n    breaker = {};\n\nvar _ = {\n    trim: function(str) {\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\n        return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n    }\n};\n\n// Console override\nvar console$1 = {\n    /** @type {function(...*)} */\n    log: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            try {\n                windowConsole.log.apply(windowConsole, arguments);\n            } catch (err) {\n                _.each(arguments, function(arg) {\n                    windowConsole.log(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    warn: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel warning:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.warn.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.warn(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    error: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel error:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.error.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.error(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    critical: function() {\n        if (!_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel error:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.error.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.error(arg);\n                });\n            }\n        }\n    }\n};\n\nvar log_func_with_prefix = function(func, prefix) {\n    return function() {\n        arguments[0] = '[' + prefix + '] ' + arguments[0];\n        return func.apply(console$1, arguments);\n    };\n};\nvar console_with_prefix = function(prefix) {\n    return {\n        log: log_func_with_prefix(console$1.log, prefix),\n        error: log_func_with_prefix(console$1.error, prefix),\n        critical: log_func_with_prefix(console$1.critical, prefix)\n    };\n};\n\n\nvar safewrap = function(f) {\n    return function() {\n        try {\n            return f.apply(this, arguments);\n        } catch (e) {\n            console$1.critical('Implementation error. Please turn on debug and contact support@mixpanel.com.');\n            if (Config.DEBUG){\n                console$1.critical(e);\n            }\n        }\n    };\n};\n\nvar safewrapClass = function(klass) {\n    var proto = klass.prototype;\n    for (var func in proto) {\n        if (typeof(proto[func]) === 'function') {\n            proto[func] = safewrap(proto[func]);\n        }\n    }\n};\n\n\n// UNDERSCORE\n// Embed part of the Underscore Library\n_.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) {\n        return nativeBind.apply(func, slice.call(arguments, 1));\n    }\n    if (!_.isFunction(func)) {\n        throw new TypeError();\n    }\n    args = slice.call(arguments, 2);\n    bound = function() {\n        if (!(this instanceof bound)) {\n            return func.apply(context, args.concat(slice.call(arguments)));\n        }\n        var ctor = {};\n        ctor.prototype = func.prototype;\n        var self = new ctor();\n        ctor.prototype = null;\n        var result = func.apply(self, args.concat(slice.call(arguments)));\n        if (Object(result) === result) {\n            return result;\n        }\n        return self;\n    };\n    return bound;\n};\n\n/**\n * @param {*=} obj\n * @param {function(...*)=} iterator\n * @param {Object=} context\n */\n_.each = function(obj, iterator, context) {\n    if (obj === null || obj === undefined) {\n        return;\n    }\n    if (nativeForEach && obj.forEach === nativeForEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n        for (var i = 0, l = obj.length; i < l; i++) {\n            if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {\n                return;\n            }\n        }\n    } else {\n        for (var key in obj) {\n            if (hasOwnProperty.call(obj, key)) {\n                if (iterator.call(context, obj[key], key, obj) === breaker) {\n                    return;\n                }\n            }\n        }\n    }\n};\n\n_.extend = function(obj) {\n    _.each(slice.call(arguments, 1), function(source) {\n        for (var prop in source) {\n            if (source[prop] !== void 0) {\n                obj[prop] = source[prop];\n            }\n        }\n    });\n    return obj;\n};\n\n_.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n};\n\n// from a comment on http://dbj.org/dbj/?p=286\n// fails on only one very rare and deliberate custom object:\n// var bomb = { toString : undefined, valueOf: function(o) { return \"function BOMBA!\"; }};\n_.isFunction = function(f) {\n    try {\n        return /^\\s*\\bfunction\\b/.test(f);\n    } catch (x) {\n        return false;\n    }\n};\n\n_.isArguments = function(obj) {\n    return !!(obj && hasOwnProperty.call(obj, 'callee'));\n};\n\n_.toArray = function(iterable) {\n    if (!iterable) {\n        return [];\n    }\n    if (iterable.toArray) {\n        return iterable.toArray();\n    }\n    if (_.isArray(iterable)) {\n        return slice.call(iterable);\n    }\n    if (_.isArguments(iterable)) {\n        return slice.call(iterable);\n    }\n    return _.values(iterable);\n};\n\n_.map = function(arr, callback, context) {\n    if (nativeMap && arr.map === nativeMap) {\n        return arr.map(callback, context);\n    } else {\n        var results = [];\n        _.each(arr, function(item) {\n            results.push(callback.call(context, item));\n        });\n        return results;\n    }\n};\n\n_.keys = function(obj) {\n    var results = [];\n    if (obj === null) {\n        return results;\n    }\n    _.each(obj, function(value, key) {\n        results[results.length] = key;\n    });\n    return results;\n};\n\n_.values = function(obj) {\n    var results = [];\n    if (obj === null) {\n        return results;\n    }\n    _.each(obj, function(value) {\n        results[results.length] = value;\n    });\n    return results;\n};\n\n_.include = function(obj, target) {\n    var found = false;\n    if (obj === null) {\n        return found;\n    }\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) {\n        return obj.indexOf(target) != -1;\n    }\n    _.each(obj, function(value) {\n        if (found || (found = (value === target))) {\n            return breaker;\n        }\n    });\n    return found;\n};\n\n_.includes = function(str, needle) {\n    return str.indexOf(needle) !== -1;\n};\n\n// Underscore Addons\n_.inherit = function(subclass, superclass) {\n    subclass.prototype = new superclass();\n    subclass.prototype.constructor = subclass;\n    subclass.superclass = superclass.prototype;\n    return subclass;\n};\n\n_.isObject = function(obj) {\n    return (obj === Object(obj) && !_.isArray(obj));\n};\n\n_.isEmptyObject = function(obj) {\n    if (_.isObject(obj)) {\n        for (var key in obj) {\n            if (hasOwnProperty.call(obj, key)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n_.isUndefined = function(obj) {\n    return obj === void 0;\n};\n\n_.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n};\n\n_.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n};\n\n_.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n};\n\n_.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n};\n\n_.encodeDates = function(obj) {\n    _.each(obj, function(v, k) {\n        if (_.isDate(v)) {\n            obj[k] = _.formatDate(v);\n        } else if (_.isObject(v)) {\n            obj[k] = _.encodeDates(v); // recurse\n        }\n    });\n    return obj;\n};\n\n_.timestamp = function() {\n    Date.now = Date.now || function() {\n        return +new Date;\n    };\n    return Date.now();\n};\n\n_.formatDate = function(d) {\n    // YYYY-MM-DDTHH:MM:SS in UTC\n    function pad(n) {\n        return n < 10 ? '0' + n : n;\n    }\n    return d.getUTCFullYear() + '-' +\n        pad(d.getUTCMonth() + 1) + '-' +\n        pad(d.getUTCDate()) + 'T' +\n        pad(d.getUTCHours()) + ':' +\n        pad(d.getUTCMinutes()) + ':' +\n        pad(d.getUTCSeconds());\n};\n\n_.strip_empty_properties = function(p) {\n    var ret = {};\n    _.each(p, function(v, k) {\n        if (_.isString(v) && v.length > 0) {\n            ret[k] = v;\n        }\n    });\n    return ret;\n};\n\n/*\n * this function returns a copy of object after truncating it.  If\n * passed an Array or Object it will iterate through obj and\n * truncate all the values recursively.\n */\n_.truncate = function(obj, length) {\n    var ret;\n\n    if (typeof(obj) === 'string') {\n        ret = obj.slice(0, length);\n    } else if (_.isArray(obj)) {\n        ret = [];\n        _.each(obj, function(val) {\n            ret.push(_.truncate(val, length));\n        });\n    } else if (_.isObject(obj)) {\n        ret = {};\n        _.each(obj, function(val, key) {\n            ret[key] = _.truncate(val, length);\n        });\n    } else {\n        ret = obj;\n    }\n\n    return ret;\n};\n\n_.JSONEncode = (function() {\n    return function(mixed_val) {\n        var value = mixed_val;\n        var quote = function(string) {\n            var escapable = /[\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g; // eslint-disable-line no-control-regex\n            var meta = { // table of character substitutions\n                '\\b': '\\\\b',\n                '\\t': '\\\\t',\n                '\\n': '\\\\n',\n                '\\f': '\\\\f',\n                '\\r': '\\\\r',\n                '\"': '\\\\\"',\n                '\\\\': '\\\\\\\\'\n            };\n\n            escapable.lastIndex = 0;\n            return escapable.test(string) ?\n                '\"' + string.replace(escapable, function(a) {\n                    var c = meta[a];\n                    return typeof c === 'string' ? c :\n                        '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n                }) + '\"' :\n                '\"' + string + '\"';\n        };\n\n        var str = function(key, holder) {\n            var gap = '';\n            var indent = '    ';\n            var i = 0; // The loop counter.\n            var k = ''; // The member key.\n            var v = ''; // The member value.\n            var length = 0;\n            var mind = gap;\n            var partial = [];\n            var value = holder[key];\n\n            // If the value has a toJSON method, call it to obtain a replacement value.\n            if (value && typeof value === 'object' &&\n                typeof value.toJSON === 'function') {\n                value = value.toJSON(key);\n            }\n\n            // What happens next depends on the value's type.\n            switch (typeof value) {\n                case 'string':\n                    return quote(value);\n\n                case 'number':\n                    // JSON numbers must be finite. Encode non-finite numbers as null.\n                    return isFinite(value) ? String(value) : 'null';\n\n                case 'boolean':\n                case 'null':\n                    // If the value is a boolean or null, convert it to a string. Note:\n                    // typeof null does not produce 'null'. The case is included here in\n                    // the remote chance that this gets fixed someday.\n\n                    return String(value);\n\n                case 'object':\n                    // If the type is 'object', we might be dealing with an object or an array or\n                    // null.\n                    // Due to a specification blunder in ECMAScript, typeof null is 'object',\n                    // so watch out for that case.\n                    if (!value) {\n                        return 'null';\n                    }\n\n                    // Make an array to hold the partial results of stringifying this object value.\n                    gap += indent;\n                    partial = [];\n\n                    // Is the value an array?\n                    if (toString.apply(value) === '[object Array]') {\n                        // The value is an array. Stringify every element. Use null as a placeholder\n                        // for non-JSON values.\n\n                        length = value.length;\n                        for (i = 0; i < length; i += 1) {\n                            partial[i] = str(i, value) || 'null';\n                        }\n\n                        // Join all of the elements together, separated with commas, and wrap them in\n                        // brackets.\n                        v = partial.length === 0 ? '[]' :\n                            gap ? '[\\n' + gap +\n                            partial.join(',\\n' + gap) + '\\n' +\n                            mind + ']' :\n                                '[' + partial.join(',') + ']';\n                        gap = mind;\n                        return v;\n                    }\n\n                    // Iterate through all of the keys in the object.\n                    for (k in value) {\n                        if (hasOwnProperty.call(value, k)) {\n                            v = str(k, value);\n                            if (v) {\n                                partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                            }\n                        }\n                    }\n\n                    // Join all of the member texts together, separated with commas,\n                    // and wrap them in braces.\n                    v = partial.length === 0 ? '{}' :\n                        gap ? '{' + partial.join(',') + '' +\n                        mind + '}' : '{' + partial.join(',') + '}';\n                    gap = mind;\n                    return v;\n            }\n        };\n\n        // Make a fake root object containing our value under the key of ''.\n        // Return the result of stringifying the value.\n        return str('', {\n            '': value\n        });\n    };\n})();\n\n/**\n * From https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\n * Slightly modified to throw a real Error rather than a POJO\n */\n_.JSONDecode = (function() {\n    var at, // The index of the current character\n        ch, // The current character\n        escapee = {\n            '\"': '\"',\n            '\\\\': '\\\\',\n            '/': '/',\n            'b': '\\b',\n            'f': '\\f',\n            'n': '\\n',\n            'r': '\\r',\n            't': '\\t'\n        },\n        text,\n        error = function(m) {\n            var e = new SyntaxError(m);\n            e.at = at;\n            e.text = text;\n            throw e;\n        },\n        next = function(c) {\n            // If a c parameter is provided, verify that it matches the current character.\n            if (c && c !== ch) {\n                error('Expected \\'' + c + '\\' instead of \\'' + ch + '\\'');\n            }\n            // Get the next character. When there are no more characters,\n            // return the empty string.\n            ch = text.charAt(at);\n            at += 1;\n            return ch;\n        },\n        number = function() {\n            // Parse a number value.\n            var number,\n                string = '';\n\n            if (ch === '-') {\n                string = '-';\n                next('-');\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n            if (ch === '.') {\n                string += '.';\n                while (next() && ch >= '0' && ch <= '9') {\n                    string += ch;\n                }\n            }\n            if (ch === 'e' || ch === 'E') {\n                string += ch;\n                next();\n                if (ch === '-' || ch === '+') {\n                    string += ch;\n                    next();\n                }\n                while (ch >= '0' && ch <= '9') {\n                    string += ch;\n                    next();\n                }\n            }\n            number = +string;\n            if (!isFinite(number)) {\n                error('Bad number');\n            } else {\n                return number;\n            }\n        },\n\n        string = function() {\n            // Parse a string value.\n            var hex,\n                i,\n                string = '',\n                uffff;\n            // When parsing for string values, we must look for \" and \\ characters.\n            if (ch === '\"') {\n                while (next()) {\n                    if (ch === '\"') {\n                        next();\n                        return string;\n                    }\n                    if (ch === '\\\\') {\n                        next();\n                        if (ch === 'u') {\n                            uffff = 0;\n                            for (i = 0; i < 4; i += 1) {\n                                hex = parseInt(next(), 16);\n                                if (!isFinite(hex)) {\n                                    break;\n                                }\n                                uffff = uffff * 16 + hex;\n                            }\n                            string += String.fromCharCode(uffff);\n                        } else if (typeof escapee[ch] === 'string') {\n                            string += escapee[ch];\n                        } else {\n                            break;\n                        }\n                    } else {\n                        string += ch;\n                    }\n                }\n            }\n            error('Bad string');\n        },\n        white = function() {\n            // Skip whitespace.\n            while (ch && ch <= ' ') {\n                next();\n            }\n        },\n        word = function() {\n            // true, false, or null.\n            switch (ch) {\n                case 't':\n                    next('t');\n                    next('r');\n                    next('u');\n                    next('e');\n                    return true;\n                case 'f':\n                    next('f');\n                    next('a');\n                    next('l');\n                    next('s');\n                    next('e');\n                    return false;\n                case 'n':\n                    next('n');\n                    next('u');\n                    next('l');\n                    next('l');\n                    return null;\n            }\n            error('Unexpected \"' + ch + '\"');\n        },\n        value, // Placeholder for the value function.\n        array = function() {\n            // Parse an array value.\n            var array = [];\n\n            if (ch === '[') {\n                next('[');\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array; // empty array\n                }\n                while (ch) {\n                    array.push(value());\n                    white();\n                    if (ch === ']') {\n                        next(']');\n                        return array;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error('Bad array');\n        },\n        object = function() {\n            // Parse an object value.\n            var key,\n                object = {};\n\n            if (ch === '{') {\n                next('{');\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object; // empty object\n                }\n                while (ch) {\n                    key = string();\n                    white();\n                    next(':');\n                    if (Object.hasOwnProperty.call(object, key)) {\n                        error('Duplicate key \"' + key + '\"');\n                    }\n                    object[key] = value();\n                    white();\n                    if (ch === '}') {\n                        next('}');\n                        return object;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error('Bad object');\n        };\n\n    value = function() {\n        // Parse a JSON value. It could be an object, an array, a string,\n        // a number, or a word.\n        white();\n        switch (ch) {\n            case '{':\n                return object();\n            case '[':\n                return array();\n            case '\"':\n                return string();\n            case '-':\n                return number();\n            default:\n                return ch >= '0' && ch <= '9' ? number() : word();\n        }\n    };\n\n    // Return the json_parse function. It will have access to all of the\n    // above functions and variables.\n    return function(source) {\n        var result;\n\n        text = source;\n        at = 0;\n        ch = ' ';\n        result = value();\n        white();\n        if (ch) {\n            error('Syntax error');\n        }\n\n        return result;\n    };\n})();\n\n_.base64Encode = function(data) {\n    var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\n        ac = 0,\n        enc = '',\n        tmp_arr = [];\n\n    if (!data) {\n        return data;\n    }\n\n    data = _.utf8Encode(data);\n\n    do { // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n\n        bits = o1 << 16 | o2 << 8 | o3;\n\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n    } while (i < data.length);\n\n    enc = tmp_arr.join('');\n\n    switch (data.length % 3) {\n        case 1:\n            enc = enc.slice(0, -2) + '==';\n            break;\n        case 2:\n            enc = enc.slice(0, -1) + '=';\n            break;\n    }\n\n    return enc;\n};\n\n_.utf8Encode = function(string) {\n    string = (string + '').replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n\n    var utftext = '',\n        start,\n        end;\n    var stringl = 0,\n        n;\n\n    start = end = 0;\n    stringl = string.length;\n\n    for (n = 0; n < stringl; n++) {\n        var c1 = string.charCodeAt(n);\n        var enc = null;\n\n        if (c1 < 128) {\n            end++;\n        } else if ((c1 > 127) && (c1 < 2048)) {\n            enc = String.fromCharCode((c1 >> 6) | 192, (c1 & 63) | 128);\n        } else {\n            enc = String.fromCharCode((c1 >> 12) | 224, ((c1 >> 6) & 63) | 128, (c1 & 63) | 128);\n        }\n        if (enc !== null) {\n            if (end > start) {\n                utftext += string.substring(start, end);\n            }\n            utftext += enc;\n            start = end = n + 1;\n        }\n    }\n\n    if (end > start) {\n        utftext += string.substring(start, string.length);\n    }\n\n    return utftext;\n};\n\n_.UUID = function() {\n    try {\n        // use native Crypto API when available\n        return win['crypto']['randomUUID']();\n    } catch (err) {\n        // fall back to generating our own UUID\n        // based on https://gist.github.com/scwood/3bff42cc005cc20ab7ec98f0d8e1d59d\n        var uuid = new Array(36);\n        for (var i = 0; i < 36; i++) {\n            uuid[i] = Math.floor(Math.random() * 16);\n        }\n        uuid[14] = 4; // set bits 12-15 of time-high-and-version to 0100\n        uuid[19] = uuid[19] &= -5; // set bit 6 of clock-seq-and-reserved to zero\n        uuid[19] = uuid[19] |= (1 << 3); // set bit 7 of clock-seq-and-reserved to one\n        uuid[8] = uuid[13] = uuid[18] = uuid[23] = '-';\n\n        return _.map(uuid, function(x) {\n            return x.toString(16);\n        }).join('');\n    }\n};\n\n// _.isBlockedUA()\n// This is to block various web spiders from executing our JS and\n// sending false tracking data\nvar BLOCKED_UA_STRS = [\n    'ahrefsbot',\n    'ahrefssiteaudit',\n    'amazonbot',\n    'baiduspider',\n    'bingbot',\n    'bingpreview',\n    'chrome-lighthouse',\n    'facebookexternal',\n    'petalbot',\n    'pinterest',\n    'screaming frog',\n    'yahoo! slurp',\n    'yandex',\n\n    // a whole bunch of goog-specific crawlers\n    // https://developers.google.com/search/docs/advanced/crawling/overview-google-crawlers\n    'adsbot-google',\n    'apis-google',\n    'duplexweb-google',\n    'feedfetcher-google',\n    'google favicon',\n    'google web preview',\n    'google-read-aloud',\n    'googlebot',\n    'googleweblight',\n    'mediapartners-google',\n    'storebot-google'\n];\n_.isBlockedUA = function(ua) {\n    var i;\n    ua = ua.toLowerCase();\n    for (i = 0; i < BLOCKED_UA_STRS.length; i++) {\n        if (ua.indexOf(BLOCKED_UA_STRS[i]) !== -1) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * @param {Object=} formdata\n * @param {string=} arg_separator\n */\n_.HTTPBuildQuery = function(formdata, arg_separator) {\n    var use_val, use_key, tmp_arr = [];\n\n    if (_.isUndefined(arg_separator)) {\n        arg_separator = '&';\n    }\n\n    _.each(formdata, function(val, key) {\n        use_val = encodeURIComponent(val.toString());\n        use_key = encodeURIComponent(key);\n        tmp_arr[tmp_arr.length] = use_key + '=' + use_val;\n    });\n\n    return tmp_arr.join(arg_separator);\n};\n\n_.getQueryParam = function(url, param) {\n    // Expects a raw URL\n\n    param = param.replace(/[[]/g, '\\\\[').replace(/[\\]]/g, '\\\\]');\n    var regexS = '[\\\\?&]' + param + '=([^&#]*)',\n        regex = new RegExp(regexS),\n        results = regex.exec(url);\n    if (results === null || (results && typeof(results[1]) !== 'string' && results[1].length)) {\n        return '';\n    } else {\n        var result = results[1];\n        try {\n            result = decodeURIComponent(result);\n        } catch(err) {\n            console$1.error('Skipping decoding for malformed query param: ' + result);\n        }\n        return result.replace(/\\+/g, ' ');\n    }\n};\n\n\n// _.cookie\n// Methods partially borrowed from quirksmode.org/js/cookies.html\n_.cookie = {\n    get: function(name) {\n        var nameEQ = name + '=';\n        var ca = document$1.cookie.split(';');\n        for (var i = 0; i < ca.length; i++) {\n            var c = ca[i];\n            while (c.charAt(0) == ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return decodeURIComponent(c.substring(nameEQ.length, c.length));\n            }\n        }\n        return null;\n    },\n\n    parse: function(name) {\n        var cookie;\n        try {\n            cookie = _.JSONDecode(_.cookie.get(name)) || {};\n        } catch (err) {\n            // noop\n        }\n        return cookie;\n    },\n\n    set_seconds: function(name, value, seconds, is_cross_subdomain, is_secure, is_cross_site, domain_override) {\n        var cdomain = '',\n            expires = '',\n            secure = '';\n\n        if (domain_override) {\n            cdomain = '; domain=' + domain_override;\n        } else if (is_cross_subdomain) {\n            var domain = extract_domain(document$1.location.hostname);\n            cdomain = domain ? '; domain=.' + domain : '';\n        }\n\n        if (seconds) {\n            var date = new Date();\n            date.setTime(date.getTime() + (seconds * 1000));\n            expires = '; expires=' + date.toGMTString();\n        }\n\n        if (is_cross_site) {\n            is_secure = true;\n            secure = '; SameSite=None';\n        }\n        if (is_secure) {\n            secure += '; secure';\n        }\n\n        document$1.cookie = name + '=' + encodeURIComponent(value) + expires + '; path=/' + cdomain + secure;\n    },\n\n    set: function(name, value, days, is_cross_subdomain, is_secure, is_cross_site, domain_override) {\n        var cdomain = '', expires = '', secure = '';\n\n        if (domain_override) {\n            cdomain = '; domain=' + domain_override;\n        } else if (is_cross_subdomain) {\n            var domain = extract_domain(document$1.location.hostname);\n            cdomain = domain ? '; domain=.' + domain : '';\n        }\n\n        if (days) {\n            var date = new Date();\n            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n            expires = '; expires=' + date.toGMTString();\n        }\n\n        if (is_cross_site) {\n            is_secure = true;\n            secure = '; SameSite=None';\n        }\n        if (is_secure) {\n            secure += '; secure';\n        }\n\n        var new_cookie_val = name + '=' + encodeURIComponent(value) + expires + '; path=/' + cdomain + secure;\n        document$1.cookie = new_cookie_val;\n        return new_cookie_val;\n    },\n\n    remove: function(name, is_cross_subdomain, domain_override) {\n        _.cookie.set(name, '', -1, is_cross_subdomain, false, false, domain_override);\n    }\n};\n\nvar _testStorageSupported = function (storage) {\n    var supported = true;\n    try {\n        var key = '__mplss_' + cheap_guid(8),\n            val = 'xyz';\n        storage.setItem(key, val);\n        if (storage.getItem(key) !== val) {\n            supported = false;\n        }\n        storage.removeItem(key);\n    } catch (err) {\n        supported = false;\n    }\n    return supported;\n};\n\nvar _localStorageSupported = null;\nvar localStorageSupported = function(storage, forceCheck) {\n    if (_localStorageSupported !== null && !forceCheck) {\n        return _localStorageSupported;\n    }\n    return _localStorageSupported = _testStorageSupported(storage || win.localStorage);\n};\n\nvar _sessionStorageSupported = null;\nvar sessionStorageSupported = function(storage, forceCheck) {\n    if (_sessionStorageSupported !== null && !forceCheck) {\n        return _sessionStorageSupported;\n    }\n    return _sessionStorageSupported = _testStorageSupported(storage || win.sessionStorage);\n};\n\nfunction _storageWrapper(storage, name, is_supported_fn) {\n    var log_error = function(msg) {\n        console$1.error(name + ' error: ' + msg);\n    };\n\n    return {\n        is_supported: function(forceCheck) {\n            var supported = is_supported_fn(storage, forceCheck);\n            if (!supported) {\n                console$1.error(name + ' unsupported');\n            }\n            return supported;\n        },\n        error: log_error,\n        get: function(key) {\n            try {\n                return storage.getItem(key);\n            } catch (err) {\n                log_error(err);\n            }\n            return null;\n        },\n        parse: function(key) {\n            try {\n                return _.JSONDecode(storage.getItem(key)) || {};\n            } catch (err) {\n                // noop\n            }\n            return null;\n        },\n        set: function(key, value) {\n            try {\n                storage.setItem(key, value);\n            } catch (err) {\n                log_error(err);\n            }\n        },\n        remove: function(key) {\n            try {\n                storage.removeItem(key);\n            } catch (err) {\n                log_error(err);\n            }\n        }\n    };\n}\n\n_.localStorage = _storageWrapper(win.localStorage, 'localStorage', localStorageSupported);\n_.sessionStorage = _storageWrapper(win.sessionStorage, 'sessionStorage', sessionStorageSupported);\n\n_.register_event = (function() {\n    // written by Dean Edwards, 2005\n    // with input from Tino Zijdel - crisp@xs4all.nl\n    // with input from Carl Sverre - mail@carlsverre.com\n    // with input from Mixpanel\n    // http://dean.edwards.name/weblog/2005/10/add-event/\n    // https://gist.github.com/1930440\n\n    /**\n     * @param {Object} element\n     * @param {string} type\n     * @param {function(...*)} handler\n     * @param {boolean=} oldSchool\n     * @param {boolean=} useCapture\n     */\n    var register_event = function(element, type, handler, oldSchool, useCapture) {\n        if (!element) {\n            console$1.error('No valid element provided to register_event');\n            return;\n        }\n\n        if (element.addEventListener && !oldSchool) {\n            element.addEventListener(type, handler, !!useCapture);\n        } else {\n            var ontype = 'on' + type;\n            var old_handler = element[ontype]; // can be undefined\n            element[ontype] = makeHandler(element, handler, old_handler);\n        }\n    };\n\n    function makeHandler(element, new_handler, old_handlers) {\n        var handler = function(event) {\n            event = event || fixEvent(win.event);\n\n            // this basically happens in firefox whenever another script\n            // overwrites the onload callback and doesn't pass the event\n            // object to previously defined callbacks.  All the browsers\n            // that don't define window.event implement addEventListener\n            // so the dom_loaded handler will still be fired as usual.\n            if (!event) {\n                return undefined;\n            }\n\n            var ret = true;\n            var old_result, new_result;\n\n            if (_.isFunction(old_handlers)) {\n                old_result = old_handlers(event);\n            }\n            new_result = new_handler.call(element, event);\n\n            if ((false === old_result) || (false === new_result)) {\n                ret = false;\n            }\n\n            return ret;\n        };\n\n        return handler;\n    }\n\n    function fixEvent(event) {\n        if (event) {\n            event.preventDefault = fixEvent.preventDefault;\n            event.stopPropagation = fixEvent.stopPropagation;\n        }\n        return event;\n    }\n    fixEvent.preventDefault = function() {\n        this.returnValue = false;\n    };\n    fixEvent.stopPropagation = function() {\n        this.cancelBubble = true;\n    };\n\n    return register_event;\n})();\n\n\nvar TOKEN_MATCH_REGEX = new RegExp('^(\\\\w*)\\\\[(\\\\w+)([=~\\\\|\\\\^\\\\$\\\\*]?)=?\"?([^\\\\]\"]*)\"?\\\\]$');\n\n_.dom_query = (function() {\n    /* document.getElementsBySelector(selector)\n    - returns an array of element objects from the current document\n    matching the CSS selector. Selectors can contain element names,\n    class names and ids and can be nested. For example:\n\n    elements = document.getElementsBySelector('div#main p a.external')\n\n    Will return an array of all 'a' elements with 'external' in their\n    class attribute that are contained inside 'p' elements that are\n    contained inside the 'div' element which has id=\"main\"\n\n    New in version 0.4: Support for CSS2 and CSS3 attribute selectors:\n    See http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\n    Version 0.4 - Simon Willison, March 25th 2003\n    -- Works in Phoenix 0.5, Mozilla 1.3, Opera 7, Internet Explorer 6, Internet Explorer 5 on Windows\n    -- Opera 7 fails\n\n    Version 0.5 - Carl Sverre, Jan 7th 2013\n    -- Now uses jQuery-esque `hasClass` for testing class name\n    equality.  This fixes a bug related to '-' characters being\n    considered not part of a 'word' in regex.\n    */\n\n    function getAllChildren(e) {\n        // Returns all children of element. Workaround required for IE5/Windows. Ugh.\n        return e.all ? e.all : e.getElementsByTagName('*');\n    }\n\n    var bad_whitespace = /[\\t\\r\\n]/g;\n\n    function hasClass(elem, selector) {\n        var className = ' ' + selector + ' ';\n        return ((' ' + elem.className + ' ').replace(bad_whitespace, ' ').indexOf(className) >= 0);\n    }\n\n    function getElementsBySelector(selector) {\n        // Attempt to fail gracefully in lesser browsers\n        if (!document$1.getElementsByTagName) {\n            return [];\n        }\n        // Split selector in to tokens\n        var tokens = selector.split(' ');\n        var token, bits, tagName, found, foundCount, i, j, k, elements, currentContextIndex;\n        var currentContext = [document$1];\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i].replace(/^\\s+/, '').replace(/\\s+$/, '');\n            if (token.indexOf('#') > -1) {\n                // Token is an ID selector\n                bits = token.split('#');\n                tagName = bits[0];\n                var id = bits[1];\n                var element = document$1.getElementById(id);\n                if (!element || (tagName && element.nodeName.toLowerCase() != tagName)) {\n                    // element not found or tag with that ID not found, return false\n                    return [];\n                }\n                // Set currentContext to contain just this element\n                currentContext = [element];\n                continue; // Skip to next token\n            }\n            if (token.indexOf('.') > -1) {\n                // Token contains a class selector\n                bits = token.split('.');\n                tagName = bits[0];\n                var className = bits[1];\n                if (!tagName) {\n                    tagName = '*';\n                }\n                // Get elements matching tag, filter them for class selector\n                found = [];\n                foundCount = 0;\n                for (j = 0; j < currentContext.length; j++) {\n                    if (tagName == '*') {\n                        elements = getAllChildren(currentContext[j]);\n                    } else {\n                        elements = currentContext[j].getElementsByTagName(tagName);\n                    }\n                    for (k = 0; k < elements.length; k++) {\n                        found[foundCount++] = elements[k];\n                    }\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                for (j = 0; j < found.length; j++) {\n                    if (found[j].className &&\n                        _.isString(found[j].className) && // some SVG elements have classNames which are not strings\n                        hasClass(found[j], className)\n                    ) {\n                        currentContext[currentContextIndex++] = found[j];\n                    }\n                }\n                continue; // Skip to next token\n            }\n            // Code to deal with attribute selectors\n            var token_match = token.match(TOKEN_MATCH_REGEX);\n            if (token_match) {\n                tagName = token_match[1];\n                var attrName = token_match[2];\n                var attrOperator = token_match[3];\n                var attrValue = token_match[4];\n                if (!tagName) {\n                    tagName = '*';\n                }\n                // Grab all of the tagName elements within current context\n                found = [];\n                foundCount = 0;\n                for (j = 0; j < currentContext.length; j++) {\n                    if (tagName == '*') {\n                        elements = getAllChildren(currentContext[j]);\n                    } else {\n                        elements = currentContext[j].getElementsByTagName(tagName);\n                    }\n                    for (k = 0; k < elements.length; k++) {\n                        found[foundCount++] = elements[k];\n                    }\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                var checkFunction; // This function will be used to filter the elements\n                switch (attrOperator) {\n                    case '=': // Equality\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName) == attrValue);\n                        };\n                        break;\n                    case '~': // Match one of space seperated words\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).match(new RegExp('\\\\b' + attrValue + '\\\\b')));\n                        };\n                        break;\n                    case '|': // Match start with value followed by optional hyphen\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).match(new RegExp('^' + attrValue + '-?')));\n                        };\n                        break;\n                    case '^': // Match starts with value\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).indexOf(attrValue) === 0);\n                        };\n                        break;\n                    case '$': // Match ends with value - fails with \"Warning\" in Opera 7\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).lastIndexOf(attrValue) == e.getAttribute(attrName).length - attrValue.length);\n                        };\n                        break;\n                    case '*': // Match ends with value\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).indexOf(attrValue) > -1);\n                        };\n                        break;\n                    default:\n                        // Just test for existence of attribute\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName);\n                        };\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                for (j = 0; j < found.length; j++) {\n                    if (checkFunction(found[j])) {\n                        currentContext[currentContextIndex++] = found[j];\n                    }\n                }\n                // alert('Attribute Selector: '+tagName+' '+attrName+' '+attrOperator+' '+attrValue);\n                continue; // Skip to next token\n            }\n            // If we get here, token is JUST an element (not a class or ID selector)\n            tagName = token;\n            found = [];\n            foundCount = 0;\n            for (j = 0; j < currentContext.length; j++) {\n                elements = currentContext[j].getElementsByTagName(tagName);\n                for (k = 0; k < elements.length; k++) {\n                    found[foundCount++] = elements[k];\n                }\n            }\n            currentContext = found;\n        }\n        return currentContext;\n    }\n\n    return function(query) {\n        if (_.isElement(query)) {\n            return [query];\n        } else if (_.isObject(query) && !_.isUndefined(query.length)) {\n            return query;\n        } else {\n            return getElementsBySelector.call(this, query);\n        }\n    };\n})();\n\nvar CAMPAIGN_KEYWORDS = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_content', 'utm_term', 'utm_id', 'utm_source_platform','utm_campaign_id', 'utm_creative_format', 'utm_marketing_tactic'];\nvar CLICK_IDS = ['dclid', 'fbclid', 'gclid', 'ko_click_id', 'li_fat_id', 'msclkid', 'sccid', 'ttclid', 'twclid', 'wbraid'];\n\n_.info = {\n    campaignParams: function(default_value) {\n        var kw = '',\n            params = {};\n        _.each(CAMPAIGN_KEYWORDS, function(kwkey) {\n            kw = _.getQueryParam(document$1.URL, kwkey);\n            if (kw.length) {\n                params[kwkey] = kw;\n            } else if (default_value !== undefined) {\n                params[kwkey] = default_value;\n            }\n        });\n\n        return params;\n    },\n\n    clickParams: function() {\n        var id = '',\n            params = {};\n        _.each(CLICK_IDS, function(idkey) {\n            id = _.getQueryParam(document$1.URL, idkey);\n            if (id.length) {\n                params[idkey] = id;\n            }\n        });\n\n        return params;\n    },\n\n    marketingParams: function() {\n        return _.extend(_.info.campaignParams(), _.info.clickParams());\n    },\n\n    searchEngine: function(referrer) {\n        if (referrer.search('https?://(.*)google.([^/?]*)') === 0) {\n            return 'google';\n        } else if (referrer.search('https?://(.*)bing.com') === 0) {\n            return 'bing';\n        } else if (referrer.search('https?://(.*)yahoo.com') === 0) {\n            return 'yahoo';\n        } else if (referrer.search('https?://(.*)duckduckgo.com') === 0) {\n            return 'duckduckgo';\n        } else {\n            return null;\n        }\n    },\n\n    searchInfo: function(referrer) {\n        var search = _.info.searchEngine(referrer),\n            param = (search != 'yahoo') ? 'q' : 'p',\n            ret = {};\n\n        if (search !== null) {\n            ret['$search_engine'] = search;\n\n            var keyword = _.getQueryParam(referrer, param);\n            if (keyword.length) {\n                ret['mp_keyword'] = keyword;\n            }\n        }\n\n        return ret;\n    },\n\n    /**\n     * This function detects which browser is running this script.\n     * The order of the checks are important since many user agents\n     * include key words used in later checks.\n     */\n    browser: function(user_agent, vendor, opera) {\n        vendor = vendor || ''; // vendor is undefined for at least IE9\n        if (opera || _.includes(user_agent, ' OPR/')) {\n            if (_.includes(user_agent, 'Mini')) {\n                return 'Opera Mini';\n            }\n            return 'Opera';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {\n            return 'BlackBerry';\n        } else if (_.includes(user_agent, 'IEMobile') || _.includes(user_agent, 'WPDesktop')) {\n            return 'Internet Explorer Mobile';\n        } else if (_.includes(user_agent, 'SamsungBrowser/')) {\n            // https://developer.samsung.com/internet/user-agent-string-format\n            return 'Samsung Internet';\n        } else if (_.includes(user_agent, 'Edge') || _.includes(user_agent, 'Edg/')) {\n            return 'Microsoft Edge';\n        } else if (_.includes(user_agent, 'FBIOS')) {\n            return 'Facebook Mobile';\n        } else if (_.includes(user_agent, 'Whale/')) {\n            // https://user-agents.net/browsers/whale-browser\n            return 'Whale Browser';\n        } else if (_.includes(user_agent, 'Chrome')) {\n            return 'Chrome';\n        } else if (_.includes(user_agent, 'CriOS')) {\n            return 'Chrome iOS';\n        } else if (_.includes(user_agent, 'UCWEB') || _.includes(user_agent, 'UCBrowser')) {\n            return 'UC Browser';\n        } else if (_.includes(user_agent, 'FxiOS')) {\n            return 'Firefox iOS';\n        } else if (_.includes(vendor, 'Apple')) {\n            if (_.includes(user_agent, 'Mobile')) {\n                return 'Mobile Safari';\n            }\n            return 'Safari';\n        } else if (_.includes(user_agent, 'Android')) {\n            return 'Android Mobile';\n        } else if (_.includes(user_agent, 'Konqueror')) {\n            return 'Konqueror';\n        } else if (_.includes(user_agent, 'Firefox')) {\n            return 'Firefox';\n        } else if (_.includes(user_agent, 'MSIE') || _.includes(user_agent, 'Trident/')) {\n            return 'Internet Explorer';\n        } else if (_.includes(user_agent, 'Gecko')) {\n            return 'Mozilla';\n        } else {\n            return '';\n        }\n    },\n\n    /**\n     * This function detects which browser version is running this script,\n     * parsing major and minor version (e.g., 42.1). User agent strings from:\n     * http://www.useragentstring.com/pages/useragentstring.php\n     */\n    browserVersion: function(userAgent, vendor, opera) {\n        var browser = _.info.browser(userAgent, vendor, opera);\n        var versionRegexs = {\n            'Internet Explorer Mobile': /rv:(\\d+(\\.\\d+)?)/,\n            'Microsoft Edge': /Edge?\\/(\\d+(\\.\\d+)?)/,\n            'Chrome': /Chrome\\/(\\d+(\\.\\d+)?)/,\n            'Chrome iOS': /CriOS\\/(\\d+(\\.\\d+)?)/,\n            'UC Browser' : /(UCBrowser|UCWEB)\\/(\\d+(\\.\\d+)?)/,\n            'Safari': /Version\\/(\\d+(\\.\\d+)?)/,\n            'Mobile Safari': /Version\\/(\\d+(\\.\\d+)?)/,\n            'Opera': /(Opera|OPR)\\/(\\d+(\\.\\d+)?)/,\n            'Firefox': /Firefox\\/(\\d+(\\.\\d+)?)/,\n            'Firefox iOS': /FxiOS\\/(\\d+(\\.\\d+)?)/,\n            'Konqueror': /Konqueror:(\\d+(\\.\\d+)?)/,\n            'BlackBerry': /BlackBerry (\\d+(\\.\\d+)?)/,\n            'Android Mobile': /android\\s(\\d+(\\.\\d+)?)/,\n            'Samsung Internet': /SamsungBrowser\\/(\\d+(\\.\\d+)?)/,\n            'Internet Explorer': /(rv:|MSIE )(\\d+(\\.\\d+)?)/,\n            'Mozilla': /rv:(\\d+(\\.\\d+)?)/,\n            'Whale Browser': /Whale\\/(\\d+(\\.\\d+)?)/\n        };\n        var regex = versionRegexs[browser];\n        if (regex === undefined) {\n            return null;\n        }\n        var matches = userAgent.match(regex);\n        if (!matches) {\n            return null;\n        }\n        return parseFloat(matches[matches.length - 2]);\n    },\n\n    os: function() {\n        var a = userAgent;\n        if (/Windows/i.test(a)) {\n            if (/Phone/.test(a) || /WPDesktop/.test(a)) {\n                return 'Windows Phone';\n            }\n            return 'Windows';\n        } else if (/(iPhone|iPad|iPod)/.test(a)) {\n            return 'iOS';\n        } else if (/Android/.test(a)) {\n            return 'Android';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(a)) {\n            return 'BlackBerry';\n        } else if (/Mac/i.test(a)) {\n            return 'Mac OS X';\n        } else if (/Linux/.test(a)) {\n            return 'Linux';\n        } else if (/CrOS/.test(a)) {\n            return 'Chrome OS';\n        } else {\n            return '';\n        }\n    },\n\n    device: function(user_agent) {\n        if (/Windows Phone/i.test(user_agent) || /WPDesktop/.test(user_agent)) {\n            return 'Windows Phone';\n        } else if (/iPad/.test(user_agent)) {\n            return 'iPad';\n        } else if (/iPod/.test(user_agent)) {\n            return 'iPod Touch';\n        } else if (/iPhone/.test(user_agent)) {\n            return 'iPhone';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {\n            return 'BlackBerry';\n        } else if (/Android/.test(user_agent)) {\n            return 'Android';\n        } else {\n            return '';\n        }\n    },\n\n    referringDomain: function(referrer) {\n        var split = referrer.split('/');\n        if (split.length >= 3) {\n            return split[2];\n        }\n        return '';\n    },\n\n    currentUrl: function() {\n        return win.location.href;\n    },\n\n    properties: function(extra_props) {\n        if (typeof extra_props !== 'object') {\n            extra_props = {};\n        }\n        return _.extend(_.strip_empty_properties({\n            '$os': _.info.os(),\n            '$browser': _.info.browser(userAgent, navigator.vendor, windowOpera),\n            '$referrer': document$1.referrer,\n            '$referring_domain': _.info.referringDomain(document$1.referrer),\n            '$device': _.info.device(userAgent)\n        }), {\n            '$current_url': _.info.currentUrl(),\n            '$browser_version': _.info.browserVersion(userAgent, navigator.vendor, windowOpera),\n            '$screen_height': screen.height,\n            '$screen_width': screen.width,\n            'mp_lib': 'web',\n            '$lib_version': Config.LIB_VERSION,\n            '$insert_id': cheap_guid(),\n            'time': _.timestamp() / 1000 // epoch time in seconds\n        }, _.strip_empty_properties(extra_props));\n    },\n\n    people_properties: function() {\n        return _.extend(_.strip_empty_properties({\n            '$os': _.info.os(),\n            '$browser': _.info.browser(userAgent, navigator.vendor, windowOpera)\n        }), {\n            '$browser_version': _.info.browserVersion(userAgent, navigator.vendor, windowOpera)\n        });\n    },\n\n    mpPageViewProperties: function() {\n        return _.strip_empty_properties({\n            'current_page_title': document$1.title,\n            'current_domain': win.location.hostname,\n            'current_url_path': win.location.pathname,\n            'current_url_protocol': win.location.protocol,\n            'current_url_search': win.location.search\n        });\n    }\n};\n\n/**\n * Returns a throttled function that will only run at most every `waitMs` and returns a promise that resolves with the next invocation.\n * Throttled calls will build up a batch of args and invoke the callback with all args since the last invocation.\n */\nvar batchedThrottle = function (fn, waitMs) {\n    var timeoutPromise = null;\n    var throttledItems = [];\n    return function (item) {\n        var self = this;\n        throttledItems.push(item);\n\n        if (!timeoutPromise) {\n            timeoutPromise = new PromisePolyfill(function (resolve) {\n                setTimeout(function () {\n                    var returnValue = fn.apply(self, [throttledItems]);\n                    timeoutPromise = null;\n                    throttledItems = [];\n                    resolve(returnValue);\n                }, waitMs);\n            });\n        }\n        return timeoutPromise;\n    };\n};\n\nvar cheap_guid = function(maxlen) {\n    var guid = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);\n    return maxlen ? guid.substring(0, maxlen) : guid;\n};\n\n// naive way to extract domain name (example.com) from full hostname (my.sub.example.com)\nvar SIMPLE_DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]*\\.[a-z]+$/i;\n// this next one attempts to account for some ccSLDs, e.g. extracting oxford.ac.uk from www.oxford.ac.uk\nvar DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]+\\.[a-z.]{2,6}$/i;\n/**\n * Attempts to extract main domain name from full hostname, using a few blunt heuristics. For\n * common TLDs like .com/.org that always have a simple SLD.TLD structure (example.com), we\n * simply extract the last two .-separated parts of the hostname (SIMPLE_DOMAIN_MATCH_REGEX).\n * For others, we attempt to account for short ccSLD+TLD combos (.ac.uk) with the legacy\n * DOMAIN_MATCH_REGEX (kept to maintain backwards compatibility with existing Mixpanel\n * integrations). The only _reliable_ way to extract domain from hostname is with an up-to-date\n * list like at https://publicsuffix.org/ so for cases that this helper fails at, the SDK\n * offers the 'cookie_domain' config option to set it explicitly.\n * @example\n * extract_domain('my.sub.example.com')\n * // 'example.com'\n */\nvar extract_domain = function(hostname) {\n    var domain_regex = DOMAIN_MATCH_REGEX;\n    var parts = hostname.split('.');\n    var tld = parts[parts.length - 1];\n    if (tld.length > 4 || tld === 'com' || tld === 'org') {\n        domain_regex = SIMPLE_DOMAIN_MATCH_REGEX;\n    }\n    var matches = hostname.match(domain_regex);\n    return matches ? matches[0] : '';\n};\n\n/**\n * Check whether we have network connection. default to true for browsers that don't support navigator.onLine (IE)\n * @returns {boolean}\n */\nvar isOnline = function() {\n    var onLine = win.navigator['onLine'];\n    return _.isUndefined(onLine) || onLine;\n};\n\nvar NOOP_FUNC = function () {};\n\nvar JSONStringify = null, JSONParse = null;\nif (typeof JSON !== 'undefined') {\n    JSONStringify = JSON.stringify;\n    JSONParse = JSON.parse;\n}\nJSONStringify = JSONStringify || _.JSONEncode;\nJSONParse = JSONParse || _.JSONDecode;\n\n// UNMINIFIED EXPORTS (for closure compiler)\n_['info']                   = _.info;\n_['info']['browser']        = _.info.browser;\n_['info']['browserVersion'] = _.info.browserVersion;\n_['info']['device']         = _.info.device;\n_['info']['properties']     = _.info.properties;\n_['isBlockedUA']            = _.isBlockedUA;\n_['isEmptyObject']          = _.isEmptyObject;\n_['isObject']               = _.isObject;\n_['JSONDecode']             = _.JSONDecode;\n_['JSONEncode']             = _.JSONEncode;\n_['toArray']                = _.toArray;\n_['NPO']                    = NpoPromise;\n\nvar MIXPANEL_DB_NAME = 'mixpanelBrowserDb';\n\nvar RECORDING_EVENTS_STORE_NAME = 'mixpanelRecordingEvents';\nvar RECORDING_REGISTRY_STORE_NAME = 'mixpanelRecordingRegistry';\n\n// note: increment the version number when adding new object stores\nvar DB_VERSION = 1;\nvar OBJECT_STORES = [RECORDING_EVENTS_STORE_NAME, RECORDING_REGISTRY_STORE_NAME];\n\n/**\n * @type {import('./wrapper').StorageWrapper}\n */\nvar IDBStorageWrapper = function (storeName) {\n    /**\n     * @type {Promise<IDBDatabase>|null}\n     */\n    this.dbPromise = null;\n    this.storeName = storeName;\n};\n\nIDBStorageWrapper.prototype._openDb = function () {\n    return new PromisePolyfill(function (resolve, reject) {\n        var openRequest = win.indexedDB.open(MIXPANEL_DB_NAME, DB_VERSION);\n        openRequest['onerror'] = function () {\n            reject(openRequest.error);\n        };\n\n        openRequest['onsuccess'] = function () {\n            resolve(openRequest.result);\n        };\n\n        openRequest['onupgradeneeded'] = function (ev) {\n            var db = ev.target.result;\n\n            OBJECT_STORES.forEach(function (storeName) {\n                db.createObjectStore(storeName);\n            });\n        };\n    });\n};\n\nIDBStorageWrapper.prototype.init = function () {\n    if (!win.indexedDB) {\n        return PromisePolyfill.reject('indexedDB is not supported in this browser');\n    }\n\n    if (!this.dbPromise) {\n        this.dbPromise = this._openDb();\n    }\n\n    return this.dbPromise\n        .then(function (dbOrError) {\n            if (dbOrError instanceof win['IDBDatabase']) {\n                return PromisePolyfill.resolve();\n            } else {\n                return PromisePolyfill.reject(dbOrError);\n            }\n        });\n};\n\n/**\n * @param {IDBTransactionMode} mode\n * @param {function(IDBObjectStore): void} storeCb\n */\nIDBStorageWrapper.prototype.makeTransaction = function (mode, storeCb) {\n    var storeName = this.storeName;\n    var doTransaction = function (db) {\n        return new PromisePolyfill(function (resolve, reject) {\n            var transaction = db.transaction(storeName, mode);\n            transaction.oncomplete = function () {\n                resolve(transaction);\n            };\n            transaction.onabort = transaction.onerror = function () {\n                reject(transaction.error);\n            };\n\n            storeCb(transaction.objectStore(storeName));\n        });\n    };\n\n    return this.dbPromise\n        .then(doTransaction)\n        .catch(function (err) {\n            if (err && err['name'] === 'InvalidStateError') {\n                // try reopening the DB if the connection is closed\n                this.dbPromise = this._openDb();\n                return this.dbPromise.then(doTransaction);\n            } else {\n                return PromisePolyfill.reject(err);\n            }\n        }.bind(this));\n};\n\nIDBStorageWrapper.prototype.setItem = function (key, value) {\n    return this.makeTransaction('readwrite', function (objectStore) {\n        objectStore.put(value, key);\n    });\n};\n\nIDBStorageWrapper.prototype.getItem = function (key) {\n    var req;\n    return this.makeTransaction('readonly', function (objectStore) {\n        req = objectStore.get(key);\n    }).then(function () {\n        return req.result;\n    });\n};\n\nIDBStorageWrapper.prototype.removeItem = function (key) {\n    return this.makeTransaction('readwrite', function (objectStore) {\n        objectStore.delete(key);\n    });\n};\n\nIDBStorageWrapper.prototype.getAll = function () {\n    var req;\n    return this.makeTransaction('readonly', function (objectStore) {\n        req = objectStore.getAll();\n    }).then(function () {\n        return req.result;\n    });\n};\n\n/**\n * GDPR utils\n *\n * The General Data Protection Regulation (GDPR) is a regulation in EU law on data protection\n * and privacy for all individuals within the European Union. It addresses the export of personal\n * data outside the EU. The GDPR aims primarily to give control back to citizens and residents\n * over their personal data and to simplify the regulatory environment for international business\n * by unifying the regulation within the EU.\n *\n * This set of utilities is intended to enable opt in/out functionality in the Mixpanel JS SDK.\n * These functions are used internally by the SDK and are not intended to be publicly exposed.\n */\n\n\n/**\n * A function used to track a Mixpanel event (e.g. MixpanelLib.track)\n * @callback trackFunction\n * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.\n * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.\n * @param {Function} [callback] If provided, the callback function will be called after tracking the event.\n */\n\n/** Public **/\n\nvar GDPR_DEFAULT_PERSISTENCE_PREFIX = '__mp_opt_in_out_';\n\n/**\n * Opt the user in to data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action\n * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action\n * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction optIn(token, options) {\n    _optInOut(true, token, options);\n}\n\n/**\n * Opt the user out of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-out cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-out cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-out cookie is set as secure or not\n */\nfunction optOut(token, options) {\n    _optInOut(false, token, options);\n}\n\n/**\n * Check whether the user has opted in to data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} whether the user has opted in to the given opt type\n */\nfunction hasOptedIn(token, options) {\n    return _getStorageValue(token, options) === '1';\n}\n\n/**\n * Check whether the user has opted out of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false\n * @returns {boolean} whether the user has opted out of the given opt type\n */\nfunction hasOptedOut(token, options) {\n    if (_hasDoNotTrackFlagOn(options)) {\n        console$1.warn('This browser has \"Do Not Track\" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the \"Do Not Track\" browser setting, initialize the Mixpanel instance with the config \"ignore_dnt: true\"');\n        return true;\n    }\n    var optedOut = _getStorageValue(token, options) === '0';\n    if (optedOut) {\n        console$1.warn('You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data.');\n    }\n    return optedOut;\n}\n\n/**\n * Wrap a MixpanelLib method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelLib(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this.get_config(name);\n    });\n}\n\n/**\n * Wrap a MixpanelPeople method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelPeople(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this._get_config(name);\n    });\n}\n\n/**\n * Wrap a MixpanelGroup method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelGroup(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this._get_config(name);\n    });\n}\n\n/**\n * Clear the user's opt in/out status of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction clearOptInOut(token, options) {\n    options = options || {};\n    _getStorage(options).remove(\n        _getStorageKey(token, options), !!options.crossSubdomainCookie, options.cookieDomain\n    );\n}\n\n/** Private **/\n\n/**\n * Get storage util\n * @param {Object} [options]\n * @param {string} [options.persistenceType]\n * @returns {object} either _.cookie or _.localstorage\n */\nfunction _getStorage(options) {\n    options = options || {};\n    return options.persistenceType === 'localStorage' ? _.localStorage : _.cookie;\n}\n\n/**\n * Get the name of the cookie that is used for the given opt type (tracking, cookie, etc.)\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {string} the name of the cookie for the given opt type\n */\nfunction _getStorageKey(token, options) {\n    options = options || {};\n    return (options.persistencePrefix || GDPR_DEFAULT_PERSISTENCE_PREFIX) + token;\n}\n\n/**\n * Get the value of the cookie that is used for the given opt type (tracking, cookie, etc.)\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {string} the value of the cookie for the given opt type\n */\nfunction _getStorageValue(token, options) {\n    return _getStorage(options).get(_getStorageKey(token, options));\n}\n\n/**\n * Check whether the user has set the DNT/doNotTrack setting to true in their browser\n * @param {Object} [options]\n * @param {string} [options.window] - alternate window object to check; used to force various DNT settings in browser tests\n * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false\n * @returns {boolean} whether the DNT setting is true\n */\nfunction _hasDoNotTrackFlagOn(options) {\n    if (options && options.ignoreDnt) {\n        return false;\n    }\n    var win$1 = (options && options.window) || win;\n    var nav = win$1['navigator'] || {};\n    var hasDntOn = false;\n\n    _.each([\n        nav['doNotTrack'], // standard\n        nav['msDoNotTrack'],\n        win$1['doNotTrack']\n    ], function(dntValue) {\n        if (_.includes([true, 1, '1', 'yes'], dntValue)) {\n            hasDntOn = true;\n        }\n    });\n\n    return hasDntOn;\n}\n\n/**\n * Set cookie/localstorage for the user indicating that they are opted in or out for the given opt type\n * @param {boolean} optValue - whether to opt the user in or out for the given opt type\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action\n * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action\n * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction _optInOut(optValue, token, options) {\n    if (!_.isString(token) || !token.length) {\n        console$1.error('gdpr.' + (optValue ? 'optIn' : 'optOut') + ' called with an invalid token');\n        return;\n    }\n\n    options = options || {};\n\n    _getStorage(options).set(\n        _getStorageKey(token, options),\n        optValue ? 1 : 0,\n        _.isNumber(options.cookieExpiration) ? options.cookieExpiration : null,\n        !!options.crossSubdomainCookie,\n        !!options.secureCookie,\n        !!options.crossSiteCookie,\n        options.cookieDomain\n    );\n\n    if (options.track && optValue) { // only track event if opting in (optValue=true)\n        options.track(options.trackEventName || '$opt_in', options.trackProperties, {\n            'send_immediately': true\n        });\n    }\n}\n\n/**\n * Wrap a method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @param {function} getConfigValue - getter function for the Mixpanel API token and other options to be used with opt-out check\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction _addOptOutCheck(method, getConfigValue) {\n    return function() {\n        var optedOut = false;\n\n        try {\n            var token = getConfigValue.call(this, 'token');\n            var ignoreDnt = getConfigValue.call(this, 'ignore_dnt');\n            var persistenceType = getConfigValue.call(this, 'opt_out_tracking_persistence_type');\n            var persistencePrefix = getConfigValue.call(this, 'opt_out_tracking_cookie_prefix');\n            var win = getConfigValue.call(this, 'window'); // used to override window during browser tests\n\n            if (token) { // if there was an issue getting the token, continue method execution as normal\n                optedOut = hasOptedOut(token, {\n                    ignoreDnt: ignoreDnt,\n                    persistenceType: persistenceType,\n                    persistencePrefix: persistencePrefix,\n                    window: win\n                });\n            }\n        } catch(err) {\n            console$1.error('Unexpected error when checking tracking opt-out status: ' + err);\n        }\n\n        if (!optedOut) {\n            return method.apply(this, arguments);\n        }\n\n        var callback = arguments[arguments.length - 1];\n        if (typeof(callback) === 'function') {\n            callback(0);\n        }\n\n        return;\n    };\n}\n\nvar logger$6 = console_with_prefix('lock');\n\n/**\n * SharedLock: a mutex built on HTML5 localStorage, to ensure that only one browser\n * window/tab at a time will be able to access shared resources.\n *\n * Based on the Alur and Taubenfeld fast lock\n * (http://www.cs.rochester.edu/research/synchronization/pseudocode/fastlock.html)\n * with an added timeout to ensure there will be eventual progress in the event\n * that a window is closed in the middle of the callback.\n *\n * Implementation based on the original version by David Wolever (https://github.com/wolever)\n * at https://gist.github.com/wolever/5fd7573d1ef6166e8f8c4af286a69432.\n *\n * @example\n * const myLock = new SharedLock('some-key');\n * myLock.withLock(function() {\n *   console.log('I hold the mutex!');\n * });\n *\n * @constructor\n */\nvar SharedLock = function(key, options) {\n    options = options || {};\n\n    this.storageKey = key;\n    this.storage = options.storage || win.localStorage;\n    this.pollIntervalMS = options.pollIntervalMS || 100;\n    this.timeoutMS = options.timeoutMS || 2000;\n\n    // dependency-inject promise implementation for testing purposes\n    this.promiseImpl = options.promiseImpl || PromisePolyfill;\n};\n\n// pass in a specific pid to test contention scenarios; otherwise\n// it is chosen randomly for each acquisition attempt\nSharedLock.prototype.withLock = function(lockedCB, pid) {\n    var Promise = this.promiseImpl;\n    return new Promise(_.bind(function (resolve, reject) {\n        var i = pid || (new Date().getTime() + '|' + Math.random());\n        var startTime = new Date().getTime();\n        var key = this.storageKey;\n        var pollIntervalMS = this.pollIntervalMS;\n        var timeoutMS = this.timeoutMS;\n        var storage = this.storage;\n\n        var keyX = key + ':X';\n        var keyY = key + ':Y';\n        var keyZ = key + ':Z';\n\n        var delay = function(cb) {\n            if (new Date().getTime() - startTime > timeoutMS) {\n                logger$6.error('Timeout waiting for mutex on ' + key + '; clearing lock. [' + i + ']');\n                storage.removeItem(keyZ);\n                storage.removeItem(keyY);\n                loop();\n                return;\n            }\n            setTimeout(function() {\n                try {\n                    cb();\n                } catch(err) {\n                    reject(err);\n                }\n            }, pollIntervalMS * (Math.random() + 0.1));\n        };\n\n        var waitFor = function(predicate, cb) {\n            if (predicate()) {\n                cb();\n            } else {\n                delay(function() {\n                    waitFor(predicate, cb);\n                });\n            }\n        };\n\n        var getSetY = function() {\n            var valY = storage.getItem(keyY);\n            if (valY && valY !== i) { // if Y == i then this process already has the lock (useful for test cases)\n                return false;\n            } else {\n                storage.setItem(keyY, i);\n                if (storage.getItem(keyY) === i) {\n                    return true;\n                } else {\n                    if (!localStorageSupported(storage, true)) {\n                        reject(new Error('localStorage support dropped while acquiring lock'));\n                    }\n                    return false;\n                }\n            }\n        };\n\n        var loop = function() {\n            storage.setItem(keyX, i);\n\n            waitFor(getSetY, function() {\n                if (storage.getItem(keyX) === i) {\n                    criticalSection();\n                    return;\n                }\n\n                delay(function() {\n                    if (storage.getItem(keyY) !== i) {\n                        loop();\n                        return;\n                    }\n                    waitFor(function() {\n                        return !storage.getItem(keyZ);\n                    }, criticalSection);\n                });\n            });\n        };\n\n        var criticalSection = function() {\n            storage.setItem(keyZ, '1');\n            var removeLock = function () {\n                storage.removeItem(keyZ);\n                if (storage.getItem(keyY) === i) {\n                    storage.removeItem(keyY);\n                }\n                if (storage.getItem(keyX) === i) {\n                    storage.removeItem(keyX);\n                }\n            };\n\n            lockedCB()\n                .then(function (ret) {\n                    removeLock();\n                    resolve(ret);\n                })\n                .catch(function (err) {\n                    removeLock();\n                    reject(err);\n                });\n        };\n\n        try {\n            if (localStorageSupported(storage, true)) {\n                loop();\n            } else {\n                throw new Error('localStorage support check failed');\n            }\n        } catch(err) {\n            reject(err);\n        }\n    }, this));\n};\n\n/**\n * @type {import('./wrapper').StorageWrapper}\n */\nvar LocalStorageWrapper = function (storageOverride) {\n    this.storage = storageOverride || win.localStorage;\n};\n\nLocalStorageWrapper.prototype.init = function () {\n    return PromisePolyfill.resolve();\n};\n\nLocalStorageWrapper.prototype.setItem = function (key, value) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        try {\n            this.storage.setItem(key, JSONStringify(value));\n        } catch (e) {\n            reject(e);\n        }\n        resolve();\n    }, this));\n};\n\nLocalStorageWrapper.prototype.getItem = function (key) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        var item;\n        try {\n            item = JSONParse(this.storage.getItem(key));\n        } catch (e) {\n            reject(e);\n        }\n        resolve(item);\n    }, this));\n};\n\nLocalStorageWrapper.prototype.removeItem = function (key) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        try {\n            this.storage.removeItem(key);\n        } catch (e) {\n            reject(e);\n        }\n        resolve();\n    }, this));\n};\n\nvar logger$5 = console_with_prefix('batch');\n\n/**\n * RequestQueue: queue for batching API requests with localStorage backup for retries.\n * Maintains an in-memory queue which represents the source of truth for the current\n * page, but also writes all items out to a copy in the browser's localStorage, which\n * can be read on subsequent pageloads and retried. For batchability, all the request\n * items in the queue should be of the same type (events, people updates, group updates)\n * so they can be sent in a single request to the same API endpoint.\n *\n * LocalStorage keying and locking: In order for reloads and subsequent pageloads of\n * the same site to access the same persisted data, they must share the same localStorage\n * key (for instance based on project token and queue type). Therefore access to the\n * localStorage entry is guarded by an asynchronous mutex (SharedLock) to prevent\n * simultaneously open windows/tabs from overwriting each other's data (which would lead\n * to data loss in some situations).\n * @constructor\n */\nvar RequestQueue = function (storageKey, options) {\n    options = options || {};\n    this.storageKey = storageKey;\n    this.usePersistence = options.usePersistence;\n    if (this.usePersistence) {\n        this.queueStorage = options.queueStorage || new LocalStorageWrapper();\n        this.lock = new SharedLock(storageKey, {\n            storage: options.sharedLockStorage || win.localStorage,\n            timeoutMS: options.sharedLockTimeoutMS,\n        });\n    }\n    this.reportError = options.errorReporter || _.bind(logger$5.error, logger$5);\n\n    this.pid = options.pid || null; // pass pid to test out storage lock contention scenarios\n\n    this.memQueue = [];\n    this.initialized = false;\n\n    if (options.enqueueThrottleMs) {\n        this.enqueuePersisted = batchedThrottle(_.bind(this._enqueuePersisted, this), options.enqueueThrottleMs);\n    } else {\n        this.enqueuePersisted = _.bind(function (queueEntry) {\n            return this._enqueuePersisted([queueEntry]);\n        }, this);\n    }\n};\n\nRequestQueue.prototype.ensureInit = function () {\n    if (this.initialized) {\n        return PromisePolyfill.resolve();\n    }\n\n    return this.queueStorage\n        .init()\n        .then(_.bind(function () {\n            this.initialized = true;\n        }, this))\n        .catch(_.bind(function (err) {\n            this.reportError('Error initializing queue persistence. Disabling persistence', err);\n            this.initialized = true;\n            this.usePersistence = false;\n        }, this));\n};\n\n/**\n * Add one item to queues (memory and localStorage). The queued entry includes\n * the given item along with an auto-generated ID and a \"flush-after\" timestamp.\n * It is expected that the item will be sent over the network and dequeued\n * before the flush-after time; if this doesn't happen it is considered orphaned\n * (e.g., the original tab where it was enqueued got closed before it could be\n * sent) and the item can be sent by any tab that finds it in localStorage.\n *\n * The final callback param is called with a param indicating success or\n * failure of the enqueue operation; it is asynchronous because the localStorage\n * lock is asynchronous.\n */\nRequestQueue.prototype.enqueue = function (item, flushInterval) {\n    var queueEntry = {\n        'id': cheap_guid(),\n        'flushAfter': new Date().getTime() + flushInterval * 2,\n        'payload': item\n    };\n\n    if (!this.usePersistence) {\n        this.memQueue.push(queueEntry);\n        return PromisePolyfill.resolve(true);\n    } else {\n        return this.enqueuePersisted(queueEntry);\n    }\n};\n\nRequestQueue.prototype._enqueuePersisted = function (queueEntries) {\n    var enqueueItem = _.bind(function () {\n        return this.ensureInit()\n            .then(_.bind(function () {\n                return this.readFromStorage();\n            }, this))\n            .then(_.bind(function (storedQueue) {\n                return this.saveToStorage(storedQueue.concat(queueEntries));\n            }, this))\n            .then(_.bind(function (succeeded) {\n                // only add to in-memory queue when storage succeeds\n                if (succeeded) {\n                    this.memQueue = this.memQueue.concat(queueEntries);\n                }\n\n                return succeeded;\n            }, this))\n            .catch(_.bind(function (err) {\n                this.reportError('Error enqueueing items', err, queueEntries);\n                return false;\n            }, this));\n    }, this);\n\n    return this.lock\n        .withLock(enqueueItem, this.pid)\n        .catch(_.bind(function (err) {\n            this.reportError('Error acquiring storage lock', err);\n            return false;\n        }, this));\n};\n\n/**\n * Read out the given number of queue entries. If this.memQueue\n * has fewer than batchSize items, then look for \"orphaned\" items\n * in the persisted queue (items where the 'flushAfter' time has\n * already passed).\n */\nRequestQueue.prototype.fillBatch = function (batchSize) {\n    var batch = this.memQueue.slice(0, batchSize);\n    if (this.usePersistence && batch.length < batchSize) {\n        // don't need lock just to read events; localStorage is thread-safe\n        // and the worst that could happen is a duplicate send of some\n        // orphaned events, which will be deduplicated on the server side\n        return this.ensureInit()\n            .then(_.bind(function () {\n                return this.readFromStorage();\n            }, this))\n            .then(_.bind(function (storedQueue) {\n                if (storedQueue.length) {\n                    // item IDs already in batch; don't duplicate out of storage\n                    var idsInBatch = {}; // poor man's Set\n                    _.each(batch, function (item) {\n                        idsInBatch[item['id']] = true;\n                    });\n\n                    for (var i = 0; i < storedQueue.length; i++) {\n                        var item = storedQueue[i];\n                        if (new Date().getTime() > item['flushAfter'] && !idsInBatch[item['id']]) {\n                            item.orphaned = true;\n                            batch.push(item);\n                            if (batch.length >= batchSize) {\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                return batch;\n            }, this));\n    } else {\n        return PromisePolyfill.resolve(batch);\n    }\n};\n\n/**\n * Remove items with matching 'id' from array (immutably)\n * also remove any item without a valid id (e.g., malformed\n * storage entries).\n */\nvar filterOutIDsAndInvalid = function (items, idSet) {\n    var filteredItems = [];\n    _.each(items, function (item) {\n        if (item['id'] && !idSet[item['id']]) {\n            filteredItems.push(item);\n        }\n    });\n    return filteredItems;\n};\n\n/**\n * Remove items with matching IDs from both in-memory queue\n * and persisted queue\n */\nRequestQueue.prototype.removeItemsByID = function (ids) {\n    var idSet = {}; // poor man's Set\n    _.each(ids, function (id) {\n        idSet[id] = true;\n    });\n\n    this.memQueue = filterOutIDsAndInvalid(this.memQueue, idSet);\n    if (!this.usePersistence) {\n        return PromisePolyfill.resolve(true);\n    } else {\n        var removeFromStorage = _.bind(function () {\n            return this.ensureInit()\n                .then(_.bind(function () {\n                    return this.readFromStorage();\n                }, this))\n                .then(_.bind(function (storedQueue) {\n                    storedQueue = filterOutIDsAndInvalid(storedQueue, idSet);\n                    return this.saveToStorage(storedQueue);\n                }, this))\n                .then(_.bind(function () {\n                    return this.readFromStorage();\n                }, this))\n                .then(_.bind(function (storedQueue) {\n                    // an extra check: did storage report success but somehow\n                    // the items are still there?\n                    for (var i = 0; i < storedQueue.length; i++) {\n                        var item = storedQueue[i];\n                        if (item['id'] && !!idSet[item['id']]) {\n                            throw new Error('Item not removed from storage');\n                        }\n                    }\n                    return true;\n                }, this))\n                .catch(_.bind(function (err) {\n                    this.reportError('Error removing items', err, ids);\n                    return false;\n                }, this));\n        }, this);\n\n        return this.lock\n            .withLock(removeFromStorage, this.pid)\n            .catch(_.bind(function (err) {\n                this.reportError('Error acquiring storage lock', err);\n                if (!localStorageSupported(this.lock.storage, true)) {\n                    // Looks like localStorage writes have stopped working sometime after\n                    // initialization (probably full), and so nobody can acquire locks\n                    // anymore. Consider it temporarily safe to remove items without the\n                    // lock, since nobody's writing successfully anyway.\n                    return removeFromStorage()\n                        .then(_.bind(function (success) {\n                            if (!success) {\n                                // OK, we couldn't even write out the smaller queue. Try clearing it\n                                // entirely.\n                                return this.queueStorage.removeItem(this.storageKey).then(function () {\n                                    return success;\n                                });\n                            }\n                            return success;\n                        }, this))\n                        .catch(_.bind(function (err) {\n                            this.reportError('Error clearing queue', err);\n                            return false;\n                        }, this));\n                } else {\n                    return false;\n                }\n            }, this));\n    }\n};\n\n// internal helper for RequestQueue.updatePayloads\nvar updatePayloads = function (existingItems, itemsToUpdate) {\n    var newItems = [];\n    _.each(existingItems, function (item) {\n        var id = item['id'];\n        if (id in itemsToUpdate) {\n            var newPayload = itemsToUpdate[id];\n            if (newPayload !== null) {\n                item['payload'] = newPayload;\n                newItems.push(item);\n            }\n        } else {\n            // no update\n            newItems.push(item);\n        }\n    });\n    return newItems;\n};\n\n/**\n * Update payloads of given items in both in-memory queue and\n * persisted queue. Items set to null are removed from queues.\n */\nRequestQueue.prototype.updatePayloads = function (itemsToUpdate) {\n    this.memQueue = updatePayloads(this.memQueue, itemsToUpdate);\n    if (!this.usePersistence) {\n        return PromisePolyfill.resolve(true);\n    } else {\n        return this.lock\n            .withLock(_.bind(function lockAcquired() {\n                return this.ensureInit()\n                    .then(_.bind(function () {\n                        return this.readFromStorage();\n                    }, this))\n                    .then(_.bind(function (storedQueue) {\n                        storedQueue = updatePayloads(storedQueue, itemsToUpdate);\n                        return this.saveToStorage(storedQueue);\n                    }, this))\n                    .catch(_.bind(function (err) {\n                        this.reportError('Error updating items', itemsToUpdate, err);\n                        return false;\n                    }, this));\n            }, this), this.pid)\n            .catch(_.bind(function (err) {\n                this.reportError('Error acquiring storage lock', err);\n                return false;\n            }, this));\n    }\n};\n\n/**\n * Read and parse items array from localStorage entry, handling\n * malformed/missing data if necessary.\n */\nRequestQueue.prototype.readFromStorage = function () {\n    return this.ensureInit()\n        .then(_.bind(function () {\n            return this.queueStorage.getItem(this.storageKey);\n        }, this))\n        .then(_.bind(function (storageEntry) {\n            if (storageEntry) {\n                if (!_.isArray(storageEntry)) {\n                    this.reportError('Invalid storage entry:', storageEntry);\n                    storageEntry = null;\n                }\n            }\n            return storageEntry || [];\n        }, this))\n        .catch(_.bind(function (err) {\n            this.reportError('Error retrieving queue', err);\n            return [];\n        }, this));\n};\n\n/**\n * Serialize the given items array to localStorage.\n */\nRequestQueue.prototype.saveToStorage = function (queue) {\n    return this.ensureInit()\n        .then(_.bind(function () {\n            return this.queueStorage.setItem(this.storageKey, queue);\n        }, this))\n        .then(function () {\n            return true;\n        })\n        .catch(_.bind(function (err) {\n            this.reportError('Error saving queue', err);\n            return false;\n        }, this));\n};\n\n/**\n * Clear out queues (memory and localStorage).\n */\nRequestQueue.prototype.clear = function () {\n    this.memQueue = [];\n\n    if (this.usePersistence) {\n        return this.ensureInit()\n            .then(_.bind(function () {\n                return this.queueStorage.removeItem(this.storageKey);\n            }, this));\n    } else {\n        return PromisePolyfill.resolve();\n    }\n};\n\n// maximum interval between request retries after exponential backoff\nvar MAX_RETRY_INTERVAL_MS = 10 * 60 * 1000; // 10 minutes\n\nvar logger$4 = console_with_prefix('batch');\n\n/**\n * RequestBatcher: manages the queueing, flushing, retry etc of requests of one\n * type (events, people, groups).\n * Uses RequestQueue to manage the backing store.\n * @constructor\n */\nvar RequestBatcher = function(storageKey, options) {\n    this.errorReporter = options.errorReporter;\n    this.queue = new RequestQueue(storageKey, {\n        errorReporter: _.bind(this.reportError, this),\n        queueStorage: options.queueStorage,\n        sharedLockStorage: options.sharedLockStorage,\n        sharedLockTimeoutMS: options.sharedLockTimeoutMS,\n        usePersistence: options.usePersistence,\n        enqueueThrottleMs: options.enqueueThrottleMs\n    });\n\n    this.libConfig = options.libConfig;\n    this.sendRequest = options.sendRequestFunc;\n    this.beforeSendHook = options.beforeSendHook;\n    this.stopAllBatching = options.stopAllBatchingFunc;\n\n    // seed variable batch size + flush interval with configured values\n    this.batchSize = this.libConfig['batch_size'];\n    this.flushInterval = this.libConfig['batch_flush_interval_ms'];\n\n    this.stopped = !this.libConfig['batch_autostart'];\n    this.consecutiveRemovalFailures = 0;\n\n    // extra client-side dedupe\n    this.itemIdsSentSuccessfully = {};\n\n    // Make the flush occur at the interval specified by flushIntervalMs, default behavior will attempt consecutive flushes\n    // as long as the queue is not empty. This is useful for high-frequency events like Session Replay where we might end up\n    // in a request loop and get ratelimited by the server.\n    this.flushOnlyOnInterval = options.flushOnlyOnInterval || false;\n\n    this._flushPromise = null;\n};\n\n/**\n * Add one item to queue.\n */\nRequestBatcher.prototype.enqueue = function(item) {\n    return this.queue.enqueue(item, this.flushInterval);\n};\n\n/**\n * Start flushing batches at the configured time interval. Must call\n * this method upon SDK init in order to send anything over the network.\n */\nRequestBatcher.prototype.start = function() {\n    this.stopped = false;\n    this.consecutiveRemovalFailures = 0;\n    return this.flush();\n};\n\n/**\n * Stop flushing batches. Can be restarted by calling start().\n */\nRequestBatcher.prototype.stop = function() {\n    this.stopped = true;\n    if (this.timeoutID) {\n        clearTimeout(this.timeoutID);\n        this.timeoutID = null;\n    }\n};\n\n/**\n * Clear out queue.\n */\nRequestBatcher.prototype.clear = function() {\n    return this.queue.clear();\n};\n\n/**\n * Restore batch size configuration to whatever is set in the main SDK.\n */\nRequestBatcher.prototype.resetBatchSize = function() {\n    this.batchSize = this.libConfig['batch_size'];\n};\n\n/**\n * Restore flush interval time configuration to whatever is set in the main SDK.\n */\nRequestBatcher.prototype.resetFlush = function() {\n    this.scheduleFlush(this.libConfig['batch_flush_interval_ms']);\n};\n\n/**\n * Schedule the next flush in the given number of milliseconds.\n */\nRequestBatcher.prototype.scheduleFlush = function(flushMS) {\n    this.flushInterval = flushMS;\n    if (!this.stopped) { // don't schedule anymore if batching has been stopped\n        this.timeoutID = setTimeout(_.bind(function() {\n            if (!this.stopped) {\n                this._flushPromise = this.flush();\n            }\n        }, this), this.flushInterval);\n    }\n};\n\n/**\n * Send a request using the sendRequest callback, but promisified.\n * TODO: sendRequest should be promisified in the first place.\n */\nRequestBatcher.prototype.sendRequestPromise = function(data, options) {\n    return new PromisePolyfill(_.bind(function(resolve) {\n        this.sendRequest(data, options, resolve);\n    }, this));\n};\n\n\n/**\n * Flush one batch to network. Depending on success/failure modes, it will either\n * remove the batch from the queue or leave it in for retry, and schedule the next\n * flush. In cases of most network or API failures, it will back off exponentially\n * when retrying.\n * @param {Object} [options]\n * @param {boolean} [options.sendBeacon] - whether to send batch with\n * navigator.sendBeacon (only useful for sending batches before page unloads, as\n * sendBeacon offers no callbacks or status indications)\n */\nRequestBatcher.prototype.flush = function(options) {\n    if (this.requestInProgress) {\n        logger$4.log('Flush: Request already in progress');\n        return PromisePolyfill.resolve();\n    }\n\n    this.requestInProgress = true;\n\n    options = options || {};\n    var timeoutMS = this.libConfig['batch_request_timeout_ms'];\n    var startTime = new Date().getTime();\n    var currentBatchSize = this.batchSize;\n\n    return this.queue.fillBatch(currentBatchSize)\n        .then(_.bind(function(batch) {\n\n            // if there's more items in the queue than the batch size, attempt\n            // to flush again after the current batch is done.\n            var attemptSecondaryFlush = batch.length === currentBatchSize;\n            var dataForRequest = [];\n            var transformedItems = {};\n            _.each(batch, function(item) {\n                var payload = item['payload'];\n                if (this.beforeSendHook && !item.orphaned) {\n                    payload = this.beforeSendHook(payload);\n                }\n                if (payload) {\n                    // mp_sent_by_lib_version prop captures which lib version actually\n                    // sends each event (regardless of which version originally queued\n                    // it for sending)\n                    if (payload['event'] && payload['properties']) {\n                        payload['properties'] = _.extend(\n                            {},\n                            payload['properties'],\n                            {'mp_sent_by_lib_version': Config.LIB_VERSION}\n                        );\n                    }\n                    var addPayload = true;\n                    var itemId = item['id'];\n                    if (itemId) {\n                        if ((this.itemIdsSentSuccessfully[itemId] || 0) > 5) {\n                            this.reportError('[dupe] item ID sent too many times, not sending', {\n                                item: item,\n                                batchSize: batch.length,\n                                timesSent: this.itemIdsSentSuccessfully[itemId]\n                            });\n                            addPayload = false;\n                        }\n                    } else {\n                        this.reportError('[dupe] found item with no ID', {item: item});\n                    }\n\n                    if (addPayload) {\n                        dataForRequest.push(payload);\n                    }\n                }\n                transformedItems[item['id']] = payload;\n            }, this);\n\n            if (dataForRequest.length < 1) {\n                this.requestInProgress = false;\n                this.resetFlush();\n                return PromisePolyfill.resolve(); // nothing to do\n            }\n\n            var removeItemsFromQueue = _.bind(function () {\n                return this.queue\n                    .removeItemsByID(\n                        _.map(batch, function (item) {\n                            return item['id'];\n                        })\n                    )\n                    .then(_.bind(function (succeeded) {\n                        // client-side dedupe\n                        _.each(batch, _.bind(function(item) {\n                            var itemId = item['id'];\n                            if (itemId) {\n                                this.itemIdsSentSuccessfully[itemId] = this.itemIdsSentSuccessfully[itemId] || 0;\n                                this.itemIdsSentSuccessfully[itemId]++;\n                                if (this.itemIdsSentSuccessfully[itemId] > 5) {\n                                    this.reportError('[dupe] item ID sent too many times', {\n                                        item: item,\n                                        batchSize: batch.length,\n                                        timesSent: this.itemIdsSentSuccessfully[itemId]\n                                    });\n                                }\n                            } else {\n                                this.reportError('[dupe] found item with no ID while removing', {item: item});\n                            }\n                        }, this));\n\n                        if (succeeded) {\n                            this.consecutiveRemovalFailures = 0;\n                            if (this.flushOnlyOnInterval && !attemptSecondaryFlush) {\n                                this.resetFlush(); // schedule next batch with a delay\n                                return PromisePolyfill.resolve();\n                            } else {\n                                return this.flush(); // handle next batch if the queue isn't empty\n                            }\n                        } else {\n                            if (++this.consecutiveRemovalFailures > 5) {\n                                this.reportError('Too many queue failures; disabling batching system.');\n                                this.stopAllBatching();\n                            } else {\n                                this.resetFlush();\n                            }\n                            return PromisePolyfill.resolve();\n                        }\n                    }, this));\n            }, this);\n\n            var batchSendCallback = _.bind(function(res) {\n                this.requestInProgress = false;\n\n                try {\n\n                    // handle API response in a try-catch to make sure we can reset the\n                    // flush operation if something goes wrong\n\n                    if (options.unloading) {\n                        // update persisted data to include hook transformations\n                        return this.queue.updatePayloads(transformedItems);\n                    } else if (\n                        _.isObject(res) &&\n                            res.error === 'timeout' &&\n                            new Date().getTime() - startTime >= timeoutMS\n                    ) {\n                        this.reportError('Network timeout; retrying');\n                        return this.flush();\n                    } else if (\n                        _.isObject(res) &&\n                            (\n                                res.httpStatusCode >= 500\n                                || res.httpStatusCode === 429\n                                || (res.httpStatusCode <= 0 && !isOnline())\n                                || res.error === 'timeout'\n                            )\n                    ) {\n                        // network or API error, or 429 Too Many Requests, retry\n                        var retryMS = this.flushInterval * 2;\n                        if (res.retryAfter) {\n                            retryMS = (parseInt(res.retryAfter, 10) * 1000) || retryMS;\n                        }\n                        retryMS = Math.min(MAX_RETRY_INTERVAL_MS, retryMS);\n                        this.reportError('Error; retry in ' + retryMS + ' ms');\n                        this.scheduleFlush(retryMS);\n                        return PromisePolyfill.resolve();\n                    } else if (_.isObject(res) && res.httpStatusCode === 413) {\n                        // 413 Payload Too Large\n                        if (batch.length > 1) {\n                            var halvedBatchSize = Math.max(1, Math.floor(currentBatchSize / 2));\n                            this.batchSize = Math.min(this.batchSize, halvedBatchSize, batch.length - 1);\n                            this.reportError('413 response; reducing batch size to ' + this.batchSize);\n                            this.resetFlush();\n                            return PromisePolyfill.resolve();\n                        } else {\n                            this.reportError('Single-event request too large; dropping', batch);\n                            this.resetBatchSize();\n                            return removeItemsFromQueue();\n                        }\n                    } else {\n                        // successful network request+response; remove each item in batch from queue\n                        // (even if it was e.g. a 400, in which case retrying won't help)\n                        return removeItemsFromQueue();\n                    }\n                } catch(err) {\n                    this.reportError('Error handling API response', err);\n                    this.resetFlush();\n                }\n            }, this);\n            var requestOptions = {\n                method: 'POST',\n                verbose: true,\n                ignore_json_errors: true, // eslint-disable-line camelcase\n                timeout_ms: timeoutMS // eslint-disable-line camelcase\n            };\n            if (options.unloading) {\n                requestOptions.transport = 'sendBeacon';\n            }\n            logger$4.log('MIXPANEL REQUEST:', dataForRequest);\n            return this.sendRequestPromise(dataForRequest, requestOptions).then(batchSendCallback);\n        }, this))\n        .catch(_.bind(function(err) {\n            this.reportError('Error flushing request queue', err);\n            this.resetFlush();\n        }, this));\n};\n\n/**\n * Log error to global logger and optional user-defined logger.\n */\nRequestBatcher.prototype.reportError = function(msg, err) {\n    logger$4.error.apply(logger$4.error, arguments);\n    if (this.errorReporter) {\n        try {\n            if (!(err instanceof Error)) {\n                err = new Error(msg);\n            }\n            this.errorReporter(msg, err);\n        } catch(err) {\n            logger$4.error(err);\n        }\n    }\n};\n\n/**\n * @param {import('./session-recording').SerializedRecording} serializedRecording\n * @returns {boolean}\n */\nvar isRecordingExpired = function(serializedRecording) {\n    var now = Date.now();\n    return !serializedRecording || now > serializedRecording['maxExpires'] || now > serializedRecording['idleExpires'];\n};\n\nvar RECORD_ENQUEUE_THROTTLE_MS = 250;\n\nvar logger$3 = console_with_prefix('recorder');\nvar CompressionStream = win['CompressionStream'];\n\nvar RECORDER_BATCHER_LIB_CONFIG = {\n    'batch_size': 1000,\n    'batch_flush_interval_ms': 10 * 1000,\n    'batch_request_timeout_ms': 90 * 1000,\n    'batch_autostart': true\n};\n\nvar ACTIVE_SOURCES = new Set([\n    IncrementalSource.MouseMove,\n    IncrementalSource.MouseInteraction,\n    IncrementalSource.Scroll,\n    IncrementalSource.ViewportResize,\n    IncrementalSource.Input,\n    IncrementalSource.TouchMove,\n    IncrementalSource.MediaInteraction,\n    IncrementalSource.Drag,\n    IncrementalSource.Selection,\n]);\n\nfunction isUserEvent(ev) {\n    return ev.type === EventType.IncrementalSnapshot && ACTIVE_SOURCES.has(ev.data.source);\n}\n\n/**\n * @typedef {Object} SerializedRecording\n * @property {number} idleExpires\n * @property {number} maxExpires\n * @property {number} replayStartTime\n * @property {number} seqNo\n * @property {string} batchStartUrl\n * @property {string} replayId\n * @property {string} tabId\n * @property {string} replayStartUrl\n */\n\n/**\n * @typedef {Object} SessionRecordingOptions\n * @property {Object} [options.mixpanelInstance] - reference to the core MixpanelLib\n * @property {String} [options.replayId] - unique uuid for a single replay\n * @property {Function} [options.onIdleTimeout] - callback when a recording reaches idle timeout\n * @property {Function} [options.onMaxLengthReached] - callback when a recording reaches its maximum length\n * @property {Function} [options.rrwebRecord] - rrweb's `record` function\n * @property {Function} [options.onBatchSent] - callback when a batch of events is sent to the server\n * @property {Storage} [options.sharedLockStorage] - optional storage for shared lock, used for test dependency injection\n * optional properties for deserialization:\n * @property {number} idleExpires\n * @property {number} maxExpires\n * @property {number} replayStartTime\n * @property {number} seqNo\n * @property {string} batchStartUrl\n * @property {string} replayStartUrl\n */\n\n\n/**\n * This class encapsulates a single session recording and its lifecycle.\n * @param {SessionRecordingOptions} options\n */\nvar SessionRecording = function(options) {\n    this._mixpanel = options.mixpanelInstance;\n    this._onIdleTimeout = options.onIdleTimeout || NOOP_FUNC;\n    this._onMaxLengthReached = options.onMaxLengthReached || NOOP_FUNC;\n    this._onBatchSent = options.onBatchSent || NOOP_FUNC;\n    this._rrwebRecord = options.rrwebRecord || null;\n\n    // internal rrweb stopRecording function\n    this._stopRecording = null;\n    this.replayId = options.replayId;\n\n    this.batchStartUrl = options.batchStartUrl || null;\n    this.replayStartUrl = options.replayStartUrl || null;\n    this.idleExpires = options.idleExpires || null;\n    this.maxExpires = options.maxExpires || null;\n    this.replayStartTime = options.replayStartTime || null;\n    this.seqNo = options.seqNo || 0;\n\n    this.idleTimeoutId = null;\n    this.maxTimeoutId = null;\n\n    this.recordMaxMs = MAX_RECORDING_MS;\n    this.recordMinMs = 0;\n\n    // disable persistence if localStorage is not supported\n    // request-queue will automatically disable persistence if indexedDB fails to initialize\n    var usePersistence = localStorageSupported(options.sharedLockStorage, true);\n\n    // each replay has its own batcher key to avoid conflicts between rrweb events of different recordings\n    // this will be important when persistence is introduced\n    this.batcherKey = '__mprec_' + this.getConfig('name') + '_' + this.getConfig('token') + '_' + this.replayId;\n    this.queueStorage = new IDBStorageWrapper(RECORDING_EVENTS_STORE_NAME);\n    this.batcher = new RequestBatcher(this.batcherKey, {\n        errorReporter: this.reportError.bind(this),\n        flushOnlyOnInterval: true,\n        libConfig: RECORDER_BATCHER_LIB_CONFIG,\n        sendRequestFunc: this.flushEventsWithOptOut.bind(this),\n        queueStorage: this.queueStorage,\n        sharedLockStorage: options.sharedLockStorage,\n        usePersistence: usePersistence,\n        stopAllBatchingFunc: this.stopRecording.bind(this),\n\n        // increased throttle and shared lock timeout because recording events are very high frequency.\n        // this will minimize the amount of lock contention between enqueued events.\n        // for session recordings there is a lock for each tab anyway, so there's no risk of deadlock between tabs.\n        enqueueThrottleMs: RECORD_ENQUEUE_THROTTLE_MS,\n        sharedLockTimeoutMS: 10 * 1000,\n    });\n};\n\nSessionRecording.prototype.unloadPersistedData = function () {\n    this.batcher.stop();\n    return this.batcher.flush()\n        .then(function () {\n            return this.queueStorage.removeItem(this.batcherKey);\n        }.bind(this));\n};\n\nSessionRecording.prototype.getConfig = function(configVar) {\n    return this._mixpanel.get_config(configVar);\n};\n\n// Alias for getConfig, used by the common addOptOutCheckMixpanelLib function which\n// reaches into this class instance and expects the snake case version of the function.\n// eslint-disable-next-line camelcase\nSessionRecording.prototype.get_config = function(configVar) {\n    return this.getConfig(configVar);\n};\n\nSessionRecording.prototype.startRecording = function (shouldStopBatcher) {\n    if (this._rrwebRecord === null) {\n        this.reportError('rrweb record function not provided. ');\n        return;\n    }\n\n    if (this._stopRecording !== null) {\n        logger$3.log('Recording already in progress, skipping startRecording.');\n        return;\n    }\n\n    this.recordMaxMs = this.getConfig('record_max_ms');\n    if (this.recordMaxMs > MAX_RECORDING_MS) {\n        this.recordMaxMs = MAX_RECORDING_MS;\n        logger$3.critical('record_max_ms cannot be greater than ' + MAX_RECORDING_MS + 'ms. Capping value.');\n    }\n\n    if (!this.maxExpires) {\n        this.maxExpires = new Date().getTime() + this.recordMaxMs;\n    }\n\n    this.recordMinMs = this.getConfig('record_min_ms');\n    if (this.recordMinMs > MAX_VALUE_FOR_MIN_RECORDING_MS) {\n        this.recordMinMs = MAX_VALUE_FOR_MIN_RECORDING_MS;\n        logger$3.critical('record_min_ms cannot be greater than ' + MAX_VALUE_FOR_MIN_RECORDING_MS + 'ms. Capping value.');\n    }\n\n    if (!this.replayStartTime) {\n        this.replayStartTime = new Date().getTime();\n        this.batchStartUrl = _.info.currentUrl();\n        this.replayStartUrl = _.info.currentUrl();\n    }\n\n    if (shouldStopBatcher || this.recordMinMs > 0) {\n        // the primary case for shouldStopBatcher is when we're starting recording after a reset\n        // and don't want to send anything over the network until there's\n        // actual user activity\n        // this also applies if the minimum recording length has not been hit yet\n        // so that we don't send data until we know the recording will be long enough\n        this.batcher.stop();\n    } else {\n        this.batcher.start();\n    }\n\n    var resetIdleTimeout = function () {\n        clearTimeout(this.idleTimeoutId);\n        var idleTimeoutMs = this.getConfig('record_idle_timeout_ms');\n        this.idleTimeoutId = setTimeout(this._onIdleTimeout, idleTimeoutMs);\n        this.idleExpires = new Date().getTime() + idleTimeoutMs;\n    }.bind(this);\n    resetIdleTimeout();\n\n    var blockSelector = this.getConfig('record_block_selector');\n    if (blockSelector === '' || blockSelector === null) {\n        blockSelector = undefined;\n    }\n\n    try {\n        this._stopRecording = this._rrwebRecord({\n            'emit': function (ev) {\n                if (this.idleExpires && this.idleExpires < ev.timestamp) {\n                    this._onIdleTimeout();\n                    return;\n                }\n                if (isUserEvent(ev)) {\n                    if (this.batcher.stopped && new Date().getTime() - this.replayStartTime >= this.recordMinMs) {\n                        // start flushing again after user activity\n                        this.batcher.start();\n                    }\n                    resetIdleTimeout();\n                }\n                // promise only used to await during tests\n                this.__enqueuePromise = this.batcher.enqueue(ev);\n            }.bind(this),\n            'blockClass': this.getConfig('record_block_class'),\n            'blockSelector': blockSelector,\n            'collectFonts': this.getConfig('record_collect_fonts'),\n            'dataURLOptions': { // canvas image options (https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL)\n                'type': 'image/webp',\n                'quality': 0.6\n            },\n            'maskAllInputs': true,\n            'maskTextClass': this.getConfig('record_mask_text_class'),\n            'maskTextSelector': this.getConfig('record_mask_text_selector'),\n            'recordCanvas': this.getConfig('record_canvas'),\n            'sampling': {\n                'canvas': 15\n            }\n        });\n    } catch (err) {\n        this.reportError('Unexpected error when starting rrweb recording.', err);\n    }\n\n    if (typeof this._stopRecording !== 'function') {\n        this.reportError('rrweb failed to start, skipping this recording.');\n        this._stopRecording = null;\n        this.stopRecording(); // stop batcher looping and any timeouts\n        return;\n    }\n\n    var maxTimeoutMs = this.maxExpires - new Date().getTime();\n    this.maxTimeoutId = setTimeout(this._onMaxLengthReached.bind(this), maxTimeoutMs);\n};\n\nSessionRecording.prototype.stopRecording = function (skipFlush) {\n    if (!this.isRrwebStopped()) {\n        try {\n            this._stopRecording();\n        } catch (err) {\n            this.reportError('Error with rrweb stopRecording', err);\n        }\n        this._stopRecording = null;\n    }\n\n    var flushPromise;\n    if (this.batcher.stopped) {\n        // never got user activity to flush after reset, so just clear the batcher\n        flushPromise = this.batcher.clear();\n    } else if (!skipFlush) {\n        // flush any remaining events from running batcher\n        flushPromise = this.batcher.flush();\n    }\n    this.batcher.stop();\n\n    clearTimeout(this.idleTimeoutId);\n    clearTimeout(this.maxTimeoutId);\n    return flushPromise;\n};\n\nSessionRecording.prototype.isRrwebStopped = function () {\n    return this._stopRecording === null;\n};\n\n\n/**\n * Flushes the current batch of events to the server, but passes an opt-out callback to make sure\n * we stop recording and dump any queued events if the user has opted out.\n */\nSessionRecording.prototype.flushEventsWithOptOut = function (data, options, cb) {\n    var onOptOut = function (code) {\n        // addOptOutCheckMixpanelLib invokes this function with code=0 when the user has opted out\n        if (code === 0) {\n            this.stopRecording();\n            cb({error: 'Tracking has been opted out, stopping recording.'});\n        }\n    }.bind(this);\n\n    this._flushEvents(data, options, cb, onOptOut);\n};\n\n/**\n * @returns {SerializedRecording}\n */\nSessionRecording.prototype.serialize = function () {\n    // don't break if mixpanel instance was destroyed at some point\n    var tabId;\n    try {\n        tabId = this._mixpanel.get_tab_id();\n    } catch (e) {\n        this.reportError('Error getting tab ID for serialization ', e);\n        tabId = null;\n    }\n\n    return {\n        'replayId': this.replayId,\n        'seqNo': this.seqNo,\n        'replayStartTime': this.replayStartTime,\n        'batchStartUrl': this.batchStartUrl,\n        'replayStartUrl': this.replayStartUrl,\n        'idleExpires': this.idleExpires,\n        'maxExpires': this.maxExpires,\n        'tabId': tabId,\n    };\n};\n\n\n/**\n * @static\n * @param {SerializedRecording} serializedRecording\n * @param {SessionRecordingOptions} options\n * @returns {SessionRecording}\n */\nSessionRecording.deserialize = function (serializedRecording, options) {\n    var recording = new SessionRecording(_.extend({}, options, {\n        replayId: serializedRecording['replayId'],\n        batchStartUrl: serializedRecording['batchStartUrl'],\n        replayStartUrl: serializedRecording['replayStartUrl'],\n        idleExpires: serializedRecording['idleExpires'],\n        maxExpires: serializedRecording['maxExpires'],\n        replayStartTime: serializedRecording['replayStartTime'],\n        seqNo: serializedRecording['seqNo'],\n        sharedLockStorage: options.sharedLockStorage,\n    }));\n\n    return recording;\n};\n\nSessionRecording.prototype._sendRequest = function(currentReplayId, reqParams, reqBody, callback) {\n    var onSuccess = function (response, responseBody) {\n        // Update batch specific props only if the request was successful to guarantee ordering.\n        // RequestBatcher will always flush the next batch after the previous one succeeds.\n        // extra check to see if the replay ID has changed so that we don't increment the seqNo on the wrong replay\n        if (response.status === 200 && this.replayId === currentReplayId) {\n            this.seqNo++;\n            this.batchStartUrl = _.info.currentUrl();\n        }\n\n        this._onBatchSent();\n        callback({\n            status: 0,\n            httpStatusCode: response.status,\n            responseBody: responseBody,\n            retryAfter: response.headers.get('Retry-After')\n        });\n    }.bind(this);\n\n    win['fetch'](this.getConfig('api_host') + '/' + this.getConfig('api_routes')['record'] + '?' + new URLSearchParams(reqParams), {\n        'method': 'POST',\n        'headers': {\n            'Authorization': 'Basic ' + btoa(this.getConfig('token') + ':'),\n            'Content-Type': 'application/octet-stream'\n        },\n        'body': reqBody,\n    }).then(function (response) {\n        response.json().then(function (responseBody) {\n            onSuccess(response, responseBody);\n        }).catch(function (error) {\n            callback({error: error});\n        });\n    }).catch(function (error) {\n        callback({error: error, httpStatusCode: 0});\n    });\n};\n\nSessionRecording.prototype._flushEvents = addOptOutCheckMixpanelLib(function (data, options, callback) {\n    var numEvents = data.length;\n\n    if (numEvents > 0) {\n        var replayId = this.replayId;\n\n        // each rrweb event has a timestamp - leverage those to get time properties\n        var batchStartTime = Infinity;\n        var batchEndTime = -Infinity;\n        var hasFullSnapshot = false;\n        for (var i = 0; i < numEvents; i++) {\n            batchStartTime = Math.min(batchStartTime, data[i].timestamp);\n            batchEndTime = Math.max(batchEndTime, data[i].timestamp);\n            if (data[i].type === EventType.FullSnapshot) {\n                hasFullSnapshot = true;\n            }\n        }\n\n        if (this.seqNo === 0) {\n            if (!hasFullSnapshot) {\n                callback({error: 'First batch does not contain a full snapshot. Aborting recording.'});\n                this.stopRecording(true);\n                return;\n            }\n            this.replayStartTime = batchStartTime;\n        } else if (!this.replayStartTime) {\n            this.reportError('Replay start time not set but seqNo is not 0. Using current batch start time as a fallback.');\n            this.replayStartTime = batchStartTime;\n        }\n\n        var replayLengthMs = batchEndTime - this.replayStartTime;\n\n        var reqParams = {\n            '$current_url': this.batchStartUrl,\n            '$lib_version': Config.LIB_VERSION,\n            'batch_start_time': batchStartTime / 1000,\n            'distinct_id': String(this._mixpanel.get_distinct_id()),\n            'mp_lib': 'web',\n            'replay_id': replayId,\n            'replay_length_ms': replayLengthMs,\n            'replay_start_time': this.replayStartTime / 1000,\n            'replay_start_url': this.replayStartUrl,\n            'seq': this.seqNo\n        };\n        var eventsJson = JSON.stringify(data);\n\n        // send ID management props if they exist\n        var deviceId = this._mixpanel.get_property('$device_id');\n        if (deviceId) {\n            reqParams['$device_id'] = deviceId;\n        }\n        var userId = this._mixpanel.get_property('$user_id');\n        if (userId) {\n            reqParams['$user_id'] = userId;\n        }\n\n        if (CompressionStream) {\n            var jsonStream = new Blob([eventsJson], {type: 'application/json'}).stream();\n            var gzipStream = jsonStream.pipeThrough(new CompressionStream('gzip'));\n            new Response(gzipStream)\n                .blob()\n                .then(function(compressedBlob) {\n                    reqParams['format'] = 'gzip';\n                    this._sendRequest(replayId, reqParams, compressedBlob, callback);\n                }.bind(this));\n        } else {\n            reqParams['format'] = 'body';\n            this._sendRequest(replayId, reqParams, eventsJson, callback);\n        }\n    }\n});\n\n\nSessionRecording.prototype.reportError = function(msg, err) {\n    logger$3.error.apply(logger$3.error, arguments);\n    try {\n        if (!err && !(msg instanceof Error)) {\n            msg = new Error(msg);\n        }\n        this.getConfig('error_reporter')(msg, err);\n    } catch(err) {\n        logger$3.error(err);\n    }\n};\n\n/**\n * Module for handling the storage and retrieval of recording metadata as well as any active recordings.\n * Makes sure that only one tab can be recording at a time.\n */\nvar RecordingRegistry = function (options) {\n    this.idb = new IDBStorageWrapper(RECORDING_REGISTRY_STORE_NAME);\n    this.errorReporter = options.errorReporter;\n    this.mixpanelInstance = options.mixpanelInstance;\n    this.sharedLockStorage = options.sharedLockStorage;\n};\n\nRecordingRegistry.prototype.handleError = function (err) {\n    this.errorReporter('IndexedDB error: ', err);\n};\n\n/**\n * @param {import('./session-recording').SerializedRecording} serializedRecording\n */\nRecordingRegistry.prototype.setActiveRecording = function (serializedRecording) {\n    var tabId = serializedRecording['tabId'];\n    if (!tabId) {\n        console.warn('No tab ID is set, cannot persist recording metadata.');\n        return PromisePolyfill.resolve();\n    }\n\n    return this.idb.init()\n        .then(function () {\n            return this.idb.setItem(tabId, serializedRecording);\n        }.bind(this))\n        .catch(this.handleError.bind(this));\n};\n\n/**\n * @returns {Promise<import('./session-recording').SerializedRecording>}\n */\nRecordingRegistry.prototype.getActiveRecording = function () {\n    return this.idb.init()\n        .then(function () {\n            return this.idb.getItem(this.mixpanelInstance.get_tab_id());\n        }.bind(this))\n        .then(function (serializedRecording) {\n            return isRecordingExpired(serializedRecording) ? null : serializedRecording;\n        }.bind(this))\n        .catch(this.handleError.bind(this));\n};\n\nRecordingRegistry.prototype.clearActiveRecording = function () {\n    // mark recording as expired instead of deleting it in case the page unloads mid-flush and doesn't make it to ingestion.\n    // this will ensure the next pageload will flush the remaining events, but not try to continue the recording.\n    return this.getActiveRecording()\n        .then(function (serializedRecording) {\n            if (serializedRecording) {\n                serializedRecording['maxExpires'] = 0;\n                return this.setActiveRecording(serializedRecording);\n            }\n        }.bind(this))\n        .catch(this.handleError.bind(this));\n};\n\n/**\n * Flush any inactive recordings from the registry to minimize data loss.\n * The main idea here is that we can flush remaining rrweb events on the next page load if a tab is closed mid-batch.\n */\nRecordingRegistry.prototype.flushInactiveRecordings = function () {\n    return this.idb.init()\n        .then(function() {\n            return this.idb.getAll();\n        }.bind(this))\n        .then(function (serializedRecordings) {\n            // clean up any expired recordings from the registry, non-expired ones may be active in other tabs\n            var unloadPromises = serializedRecordings\n                .filter(function (serializedRecording) {\n                    return isRecordingExpired(serializedRecording);\n                })\n                .map(function (serializedRecording) {\n                    var sessionRecording = SessionRecording.deserialize(serializedRecording, {\n                        mixpanelInstance: this.mixpanelInstance,\n                        sharedLockStorage: this.sharedLockStorage\n                    });\n                    return sessionRecording.unloadPersistedData()\n                        .then(function () {\n                            // expired recording was successfully flushed, we can clean it up from the registry\n                            return this.idb.removeItem(serializedRecording['tabId']);\n                        }.bind(this))\n                        .catch(this.handleError.bind(this));\n                }.bind(this));\n\n            return PromisePolyfill.all(unloadPromises);\n        }.bind(this))\n        .catch(this.handleError.bind(this));\n};\n\nvar logger$2 = console_with_prefix('recorder');\n\n/**\n * Recorder API: bundles rrweb and and exposes methods to start and stop recordings.\n * @param {Object} [options.mixpanelInstance] - reference to the core MixpanelLib\n*/\nvar MixpanelRecorder = function(mixpanelInstance, rrwebRecord, sharedLockStorage) {\n    this.mixpanelInstance = mixpanelInstance;\n    this.rrwebRecord = rrwebRecord || record;\n    this.sharedLockStorage = sharedLockStorage;\n\n    /**\n     * @member {import('./registry').RecordingRegistry}\n     */\n    this.recordingRegistry = new RecordingRegistry({\n        mixpanelInstance: this.mixpanelInstance,\n        errorReporter: logger$2.error,\n        sharedLockStorage: sharedLockStorage\n    });\n    this._flushInactivePromise = this.recordingRegistry.flushInactiveRecordings();\n\n    this.activeRecording = null;\n};\n\nMixpanelRecorder.prototype.startRecording = function(options) {\n    options = options || {};\n    if (this.activeRecording && !this.activeRecording.isRrwebStopped()) {\n        logger$2.log('Recording already in progress, skipping startRecording.');\n        return;\n    }\n\n    var onIdleTimeout = function () {\n        logger$2.log('Idle timeout reached, restarting recording.');\n        this.resetRecording();\n    }.bind(this);\n\n    var onMaxLengthReached = function () {\n        logger$2.log('Max recording length reached, stopping recording.');\n        this.resetRecording();\n    }.bind(this);\n\n    var onBatchSent = function () {\n        this.recordingRegistry.setActiveRecording(this.activeRecording.serialize());\n        this['__flushPromise'] = this.activeRecording.batcher._flushPromise;\n    }.bind(this);\n\n    /**\n     * @type {import('./session-recording').SessionRecordingOptions}\n     */\n    var sessionRecordingOptions = {\n        mixpanelInstance: this.mixpanelInstance,\n        onBatchSent: onBatchSent,\n        onIdleTimeout: onIdleTimeout,\n        onMaxLengthReached: onMaxLengthReached,\n        replayId: _.UUID(),\n        rrwebRecord: this.rrwebRecord,\n        sharedLockStorage: this.sharedLockStorage\n    };\n\n    if (options.activeSerializedRecording) {\n        this.activeRecording = SessionRecording.deserialize(options.activeSerializedRecording, sessionRecordingOptions);\n    } else {\n        this.activeRecording = new SessionRecording(sessionRecordingOptions);\n    }\n\n    this.activeRecording.startRecording(options.shouldStopBatcher);\n    return this.recordingRegistry.setActiveRecording(this.activeRecording.serialize());\n};\n\nMixpanelRecorder.prototype.stopRecording = function() {\n    var stopPromise = this._stopCurrentRecording(false);\n    this.recordingRegistry.clearActiveRecording();\n    this.activeRecording = null;\n    return stopPromise;\n};\n\nMixpanelRecorder.prototype.pauseRecording = function() {\n    return this._stopCurrentRecording(false);\n};\n\nMixpanelRecorder.prototype._stopCurrentRecording = function(skipFlush) {\n    if (this.activeRecording) {\n        return this.activeRecording.stopRecording(skipFlush);\n    }\n    return PromisePolyfill.resolve();\n};\n\nMixpanelRecorder.prototype.resumeRecording = function (startNewIfInactive) {\n    if (this.activeRecording && this.activeRecording.isRrwebStopped()) {\n        this.activeRecording.startRecording(false);\n        return PromisePolyfill.resolve(null);\n    }\n\n    return this.recordingRegistry.getActiveRecording()\n        .then(function (activeSerializedRecording) {\n            if (activeSerializedRecording) {\n                return this.startRecording({activeSerializedRecording: activeSerializedRecording});\n            } else if (startNewIfInactive) {\n                return this.startRecording({shouldStopBatcher: false});\n            } else {\n                logger$2.log('No resumable recording found.');\n                return null;\n            }\n        }.bind(this));\n};\n\n\nMixpanelRecorder.prototype.resetRecording = function () {\n    this.stopRecording();\n    this.startRecording({shouldStopBatcher: true});\n};\n\nMixpanelRecorder.prototype.getActiveReplayId = function () {\n    if (this.activeRecording && !this.activeRecording.isRrwebStopped()) {\n        return this.activeRecording.replayId;\n    } else {\n        return null;\n    }\n};\n\n// getter so that older mixpanel-core versions can still retrieve the replay ID\n// when pulling the latest recorder bundle from the CDN\nObject.defineProperty(MixpanelRecorder.prototype, 'replayId', {\n    get: function () {\n        return this.getActiveReplayId();\n    }\n});\n\nwin['__mp_recorder'] = MixpanelRecorder;\n\n// stateless utils\n// mostly from https://github.com/mixpanel/mixpanel-js/blob/989ada50f518edab47b9c4fd9535f9fbd5ec5fc0/src/autotrack-utils.js\n\n\nvar EV_CHANGE = 'change';\nvar EV_CLICK = 'click';\nvar EV_HASHCHANGE = 'hashchange';\nvar EV_MP_LOCATION_CHANGE = 'mp_locationchange';\nvar EV_POPSTATE = 'popstate';\n// TODO scrollend isn't available in Safari: document or polyfill?\nvar EV_SCROLLEND = 'scrollend';\nvar EV_SUBMIT = 'submit';\n\nvar CLICK_EVENT_PROPS = [\n    'clientX', 'clientY',\n    'offsetX', 'offsetY',\n    'pageX', 'pageY',\n    'screenX', 'screenY',\n    'x', 'y'\n];\nvar OPT_IN_CLASSES = ['mp-include'];\nvar OPT_OUT_CLASSES = ['mp-no-track'];\nvar SENSITIVE_DATA_CLASSES = OPT_OUT_CLASSES.concat(['mp-sensitive']);\nvar TRACKED_ATTRS = [\n    'aria-label', 'aria-labelledby', 'aria-describedby',\n    'href', 'name', 'role', 'title', 'type'\n];\n\nvar logger$1 = console_with_prefix('autocapture');\n\n\nfunction getClasses(el) {\n    var classes = {};\n    var classList = getClassName(el).split(' ');\n    for (var i = 0; i < classList.length; i++) {\n        var cls = classList[i];\n        if (cls) {\n            classes[cls] = true;\n        }\n    }\n    return classes;\n}\n\n/*\n * Get the className of an element, accounting for edge cases where element.className is an object\n * @param {Element} el - element to get the className of\n * @returns {string} the element's class\n */\nfunction getClassName(el) {\n    switch(typeof el.className) {\n        case 'string':\n            return el.className;\n        case 'object': // handle cases where className might be SVGAnimatedString or some other type\n            return el.className.baseVal || el.getAttribute('class') || '';\n        default: // future proof\n            return '';\n    }\n}\n\nfunction getPreviousElementSibling(el) {\n    if (el.previousElementSibling) {\n        return el.previousElementSibling;\n    } else {\n        do {\n            el = el.previousSibling;\n        } while (el && !isElementNode(el));\n        return el;\n    }\n}\n\nfunction getPropertiesFromElement(el, ev, blockAttrsSet, extraAttrs, allowElementCallback, allowSelectors) {\n    var props = {\n        '$classes': getClassName(el).split(' '),\n        '$tag_name': el.tagName.toLowerCase()\n    };\n    var elId = el.id;\n    if (elId) {\n        props['$id'] = elId;\n    }\n\n    if (shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors)) {\n        _.each(TRACKED_ATTRS.concat(extraAttrs), function(attr) {\n            if (el.hasAttribute(attr) && !blockAttrsSet[attr]) {\n                var attrVal = el.getAttribute(attr);\n                if (shouldTrackValue(attrVal)) {\n                    props['$attr-' + attr] = attrVal;\n                }\n            }\n        });\n    }\n\n    var nthChild = 1;\n    var nthOfType = 1;\n    var currentElem = el;\n    while (currentElem = getPreviousElementSibling(currentElem)) { // eslint-disable-line no-cond-assign\n        nthChild++;\n        if (currentElem.tagName === el.tagName) {\n            nthOfType++;\n        }\n    }\n    props['$nth_child'] = nthChild;\n    props['$nth_of_type'] = nthOfType;\n\n    return props;\n}\n\nfunction getPropsForDOMEvent(ev, config) {\n    var allowElementCallback = config.allowElementCallback;\n    var allowSelectors = config.allowSelectors || [];\n    var blockAttrs = config.blockAttrs || [];\n    var blockElementCallback = config.blockElementCallback;\n    var blockSelectors = config.blockSelectors || [];\n    var captureTextContent = config.captureTextContent || false;\n    var captureExtraAttrs = config.captureExtraAttrs || [];\n    var capturedForHeatMap = config.capturedForHeatMap || false;\n\n    // convert array to set every time, as the config may have changed\n    var blockAttrsSet = {};\n    _.each(blockAttrs, function(attr) {\n        blockAttrsSet[attr] = true;\n    });\n\n    var props = null;\n\n    var target = typeof ev.target === 'undefined' ? ev.srcElement : ev.target;\n    if (isTextNode(target)) { // defeat Safari bug (see: http://www.quirksmode.org/js/events_properties.html)\n        target = target.parentNode;\n    }\n\n    if (\n        shouldTrackDomEvent(target, ev) &&\n        isElementAllowed(target, ev, allowElementCallback, allowSelectors) &&\n        !isElementBlocked(target, ev, blockElementCallback, blockSelectors)\n    ) {\n        var targetElementList = [target];\n        var curEl = target;\n        while (curEl.parentNode && !isTag(curEl, 'body')) {\n            targetElementList.push(curEl.parentNode);\n            curEl = curEl.parentNode;\n        }\n\n        var elementsJson = [];\n        var href, explicitNoTrack = false;\n        _.each(targetElementList, function(el) {\n            var shouldTrackDetails = shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors);\n\n            // if the element or a parent element is an anchor tag\n            // include the href as a property\n            if (!blockAttrsSet['href'] && el.tagName.toLowerCase() === 'a') {\n                href = el.getAttribute('href');\n                href = shouldTrackDetails && shouldTrackValue(href) && href;\n            }\n\n            if (isElementBlocked(el, ev, blockElementCallback, blockSelectors)) {\n                explicitNoTrack = true;\n            }\n\n            elementsJson.push(getPropertiesFromElement(el, ev, blockAttrsSet, captureExtraAttrs, allowElementCallback, allowSelectors));\n        }, this);\n\n        if (!explicitNoTrack) {\n            var docElement = document$1['documentElement'];\n            props = {\n                '$event_type': ev.type,\n                '$host': win.location.host,\n                '$pathname': win.location.pathname,\n                '$elements':  elementsJson,\n                '$el_attr__href': href,\n                '$viewportHeight': Math.max(docElement['clientHeight'], win['innerHeight'] || 0),\n                '$viewportWidth': Math.max(docElement['clientWidth'], win['innerWidth'] || 0),\n                '$pageHeight': document$1['body']['offsetHeight'] || 0,\n                '$pageWidth': document$1['body']['offsetWidth'] || 0,\n            };\n            _.each(captureExtraAttrs, function(attr) {\n                if (!blockAttrsSet[attr] && target.hasAttribute(attr)) {\n                    var attrVal = target.getAttribute(attr);\n                    if (shouldTrackValue(attrVal)) {\n                        props['$el_attr__' + attr] = attrVal;\n                    }\n                }\n            });\n\n            if (captureTextContent) {\n                elementText = getSafeText(target, ev, allowElementCallback, allowSelectors);\n                if (elementText && elementText.length) {\n                    props['$el_text'] = elementText;\n                }\n            }\n\n            if (ev.type === EV_CLICK) {\n                _.each(CLICK_EVENT_PROPS, function(prop) {\n                    if (prop in ev) {\n                        props['$' + prop] = ev[prop];\n                    }\n                });\n                if (capturedForHeatMap) {\n                    props['$captured_for_heatmap'] = true;\n                }\n                target = guessRealClickTarget(ev);\n            }\n            // prioritize text content from \"real\" click target if different from original target\n            if (captureTextContent) {\n                var elementText = getSafeText(target, ev, allowElementCallback, allowSelectors);\n                if (elementText && elementText.length) {\n                    props['$el_text'] = elementText;\n                }\n            }\n\n            if (target) {\n                // target may have been recalculated; check allowlists and blocklists again\n                if (\n                    !isElementAllowed(target, ev, allowElementCallback, allowSelectors) ||\n                    isElementBlocked(target, ev, blockElementCallback, blockSelectors)\n                ) {\n                    return null;\n                }\n\n                var targetProps = getPropertiesFromElement(target, ev, blockAttrsSet, captureExtraAttrs, allowElementCallback, allowSelectors);\n                props['$target'] = targetProps;\n                // pull up more props onto main event props\n                props['$el_classes'] = targetProps['$classes'];\n                _.extend(props, _.strip_empty_properties({\n                    '$el_id': targetProps['$id'],\n                    '$el_tag_name': targetProps['$tag_name']\n                }));\n            }\n        }\n    }\n\n    return props;\n}\n\n\n/**\n * Get the direct text content of an element, protecting against sensitive data collection.\n * Concats textContent of each of the element's text node children; this avoids potential\n * collection of sensitive data that could happen if we used element.textContent and the\n * element had sensitive child elements, since element.textContent includes child content.\n * Scrubs values that look like they could be sensitive (i.e. cc or ssn number).\n * @param {Element} el - element to get the text of\n * @param {Array<string>} allowSelectors - CSS selectors for elements that should be included\n * @returns {string} the element's direct text content\n */\nfunction getSafeText(el, ev, allowElementCallback, allowSelectors) {\n    var elText = '';\n\n    if (shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors) && el.childNodes && el.childNodes.length) {\n        _.each(el.childNodes, function(child) {\n            if (isTextNode(child) && child.textContent) {\n                elText += _.trim(child.textContent)\n                    // scrub potentially sensitive values\n                    .split(/(\\s+)/).filter(shouldTrackValue).join('')\n                    // normalize whitespace\n                    .replace(/[\\r\\n]/g, ' ').replace(/[ ]+/g, ' ')\n                    // truncate\n                    .substring(0, 255);\n            }\n        });\n    }\n\n    return _.trim(elText);\n}\n\nfunction guessRealClickTarget(ev) {\n    var target = ev.target;\n    var composedPath = ev['composedPath']();\n    for (var i = 0; i < composedPath.length; i++) {\n        var node = composedPath[i];\n        if (\n            isTag(node, 'a') ||\n            isTag(node, 'button') ||\n            isTag(node, 'input') ||\n            isTag(node, 'select') ||\n            (node.getAttribute && node.getAttribute('role') === 'button')\n        ) {\n            target = node;\n            break;\n        }\n        if (node === target) {\n            break;\n        }\n    }\n    return target;\n}\n\nfunction isElementAllowed(el, ev, allowElementCallback, allowSelectors) {\n    if (allowElementCallback) {\n        try {\n            if (!allowElementCallback(el, ev)) {\n                return false;\n            }\n        } catch (err) {\n            logger$1.critical('Error while checking element in allowElementCallback', err);\n            return false;\n        }\n    }\n\n    if (!allowSelectors.length) {\n        // no allowlist; all elements are fair game\n        return true;\n    }\n\n    for (var i = 0; i < allowSelectors.length; i++) {\n        var sel = allowSelectors[i];\n        try {\n            if (el['matches'](sel)) {\n                return true;\n            }\n        } catch (err) {\n            logger$1.critical('Error while checking selector: ' + sel, err);\n        }\n    }\n    return false;\n}\n\nfunction isElementBlocked(el, ev, blockElementCallback, blockSelectors) {\n    var i;\n\n    if (blockElementCallback) {\n        try {\n            if (blockElementCallback(el, ev)) {\n                return true;\n            }\n        } catch (err) {\n            logger$1.critical('Error while checking element in blockElementCallback', err);\n            return true;\n        }\n    }\n\n    if (blockSelectors && blockSelectors.length) {\n        // programmatically prevent tracking of elements that match CSS selectors\n        for (i = 0; i < blockSelectors.length; i++) {\n            var sel = blockSelectors[i];\n            try {\n                if (el['matches'](sel)) {\n                    return true;\n                }\n            } catch (err) {\n                logger$1.critical('Error while checking selector: ' + sel, err);\n            }\n        }\n    }\n\n    // allow users to programmatically prevent tracking of elements by adding default classes such as 'mp-no-track'\n    var classes = getClasses(el);\n    for (i = 0; i < OPT_OUT_CLASSES.length; i++) {\n        if (classes[OPT_OUT_CLASSES[i]]) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/*\n * Check whether a DOM node has nodeType Node.ELEMENT_NODE\n * @param {Node} node - node to check\n * @returns {boolean} whether node is of the correct nodeType\n */\nfunction isElementNode(node) {\n    return node && node.nodeType === 1; // Node.ELEMENT_NODE - use integer constant for browser portability\n}\n\n/*\n * Check whether an element is of a given tag type.\n * Due to potential reference discrepancies (such as the webcomponents.js polyfill),\n * we want to match tagNames instead of specific references because something like\n * element === document.body won't always work because element might not be a native\n * element.\n * @param {Element} el - element to check\n * @param {string} tag - tag name (e.g., \"div\")\n * @returns {boolean} whether el is of the given tag type\n */\nfunction isTag(el, tag) {\n    return el && el.tagName && el.tagName.toLowerCase() === tag.toLowerCase();\n}\n\n/*\n * Check whether a DOM node is a TEXT_NODE\n * @param {Node} node - node to check\n * @returns {boolean} whether node is of type Node.TEXT_NODE\n */\nfunction isTextNode(node) {\n    return node && node.nodeType === 3; // Node.TEXT_NODE - use integer constant for browser portability\n}\n\nfunction minDOMApisSupported() {\n    try {\n        var testEl = document$1.createElement('div');\n        return !!testEl['matches'];\n    } catch (err) {\n        return false;\n    }\n}\n\n/*\n * Check whether a DOM event should be \"tracked\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {Element} el - element to check\n * @param {Event} ev - event to check\n * @returns {boolean} whether the event should be tracked\n */\nfunction shouldTrackDomEvent(el, ev) {\n    if (!el || isTag(el, 'html') || !isElementNode(el)) {\n        return false;\n    }\n    var tag = el.tagName.toLowerCase();\n    switch (tag) {\n        case 'form':\n            return ev.type === EV_SUBMIT;\n        case 'input':\n            if (['button', 'submit'].indexOf(el.getAttribute('type')) === -1) {\n                return ev.type === EV_CHANGE;\n            } else {\n                return ev.type === EV_CLICK;\n            }\n        case 'select':\n        case 'textarea':\n            return ev.type === EV_CHANGE;\n        default:\n            return ev.type === EV_CLICK;\n    }\n}\n\n/*\n * Check whether a DOM element should be \"tracked\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {Element} el - element to check\n * @param {Array<string>} allowSelectors - CSS selectors for elements that should be included\n * @returns {boolean} whether the element should be tracked\n */\nfunction shouldTrackElementDetails(el, ev, allowElementCallback, allowSelectors) {\n    var i;\n\n    if (!isElementAllowed(el, ev, allowElementCallback, allowSelectors)) {\n        return false;\n    }\n\n    for (var curEl = el; curEl.parentNode && !isTag(curEl, 'body'); curEl = curEl.parentNode) {\n        var classes = getClasses(curEl);\n        for (i = 0; i < SENSITIVE_DATA_CLASSES.length; i++) {\n            if (classes[SENSITIVE_DATA_CLASSES[i]]) {\n                return false;\n            }\n        }\n    }\n\n    var elClasses = getClasses(el);\n    for (i = 0; i < OPT_IN_CLASSES.length; i++) {\n        if (elClasses[OPT_IN_CLASSES[i]]) {\n            return true;\n        }\n    }\n\n    // don't send data from inputs or similar elements since there will always be\n    // a risk of clientside javascript placing sensitive data in attributes\n    if (\n        isTag(el, 'input') ||\n        isTag(el, 'select') ||\n        isTag(el, 'textarea') ||\n        el.getAttribute('contenteditable') === 'true'\n    ) {\n        return false;\n    }\n\n    // don't include hidden or password fields\n    var type = el.type || '';\n    if (typeof type === 'string') { // it's possible for el.type to be a DOM element if el is a form with a child input[name=\"type\"]\n        switch(type.toLowerCase()) {\n            case 'hidden':\n                return false;\n            case 'password':\n                return false;\n        }\n    }\n\n    // filter out data from fields that look like sensitive fields\n    var name = el.name || el.id || '';\n    if (typeof name === 'string') { // it's possible for el.name or el.id to be a DOM element if el is a form with a child input[name=\"name\"]\n        var sensitiveNameRegex = /^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i;\n        if (sensitiveNameRegex.test(name.replace(/[^a-zA-Z0-9]/g, ''))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\n/*\n * Check whether a string value should be \"tracked\" or if it may contain sensitive data\n * using a variety of heuristics.\n * @param {string} value - string value to check\n * @returns {boolean} whether the element should be tracked\n */\nfunction shouldTrackValue(value) {\n    if (value === null || _.isUndefined(value)) {\n        return false;\n    }\n\n    if (typeof value === 'string') {\n        value = _.trim(value);\n\n        // check to see if input value looks like a credit card number\n        // see: https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9781449327453/ch04s20.html\n        var ccRegex = /^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/;\n        if (ccRegex.test((value || '').replace(/[- ]/g, ''))) {\n            return false;\n        }\n\n        // check to see if input value looks like a social security number\n        var ssnRegex = /(^\\d{3}-?\\d{2}-?\\d{4}$)/;\n        if (ssnRegex.test(value)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nvar AUTOCAPTURE_CONFIG_KEY = 'autocapture';\nvar LEGACY_PAGEVIEW_CONFIG_KEY = 'track_pageview';\n\nvar PAGEVIEW_OPTION_FULL_URL = 'full-url';\nvar PAGEVIEW_OPTION_URL_WITH_PATH_AND_QUERY_STRING = 'url-with-path-and-query-string';\nvar PAGEVIEW_OPTION_URL_WITH_PATH = 'url-with-path';\n\nvar CONFIG_ALLOW_ELEMENT_CALLBACK = 'allow_element_callback';\nvar CONFIG_ALLOW_SELECTORS = 'allow_selectors';\nvar CONFIG_ALLOW_URL_REGEXES = 'allow_url_regexes';\nvar CONFIG_BLOCK_ATTRS = 'block_attrs';\nvar CONFIG_BLOCK_ELEMENT_CALLBACK = 'block_element_callback';\nvar CONFIG_BLOCK_SELECTORS = 'block_selectors';\nvar CONFIG_BLOCK_URL_REGEXES = 'block_url_regexes';\nvar CONFIG_CAPTURE_EXTRA_ATTRS = 'capture_extra_attrs';\nvar CONFIG_CAPTURE_TEXT_CONTENT = 'capture_text_content';\nvar CONFIG_SCROLL_CAPTURE_ALL = 'scroll_capture_all';\nvar CONFIG_SCROLL_CHECKPOINTS = 'scroll_depth_percent_checkpoints';\nvar CONFIG_TRACK_CLICK = 'click';\nvar CONFIG_TRACK_INPUT = 'input';\nvar CONFIG_TRACK_PAGEVIEW = 'pageview';\nvar CONFIG_TRACK_SCROLL = 'scroll';\nvar CONFIG_TRACK_SUBMIT = 'submit';\n\nvar CONFIG_DEFAULTS$1 = {};\nCONFIG_DEFAULTS$1[CONFIG_ALLOW_SELECTORS] = [];\nCONFIG_DEFAULTS$1[CONFIG_ALLOW_URL_REGEXES] = [];\nCONFIG_DEFAULTS$1[CONFIG_BLOCK_ATTRS] = [];\nCONFIG_DEFAULTS$1[CONFIG_BLOCK_ELEMENT_CALLBACK] = null;\nCONFIG_DEFAULTS$1[CONFIG_BLOCK_SELECTORS] = [];\nCONFIG_DEFAULTS$1[CONFIG_BLOCK_URL_REGEXES] = [];\nCONFIG_DEFAULTS$1[CONFIG_CAPTURE_EXTRA_ATTRS] = [];\nCONFIG_DEFAULTS$1[CONFIG_CAPTURE_TEXT_CONTENT] = false;\nCONFIG_DEFAULTS$1[CONFIG_SCROLL_CAPTURE_ALL] = false;\nCONFIG_DEFAULTS$1[CONFIG_SCROLL_CHECKPOINTS] = [25, 50, 75, 100];\nCONFIG_DEFAULTS$1[CONFIG_TRACK_CLICK] = true;\nCONFIG_DEFAULTS$1[CONFIG_TRACK_INPUT] = true;\nCONFIG_DEFAULTS$1[CONFIG_TRACK_PAGEVIEW] = PAGEVIEW_OPTION_FULL_URL;\nCONFIG_DEFAULTS$1[CONFIG_TRACK_SCROLL] = true;\nCONFIG_DEFAULTS$1[CONFIG_TRACK_SUBMIT] = true;\n\nvar DEFAULT_PROPS = {\n    '$mp_autocapture': true\n};\n\nvar MP_EV_CLICK = '$mp_click';\nvar MP_EV_INPUT = '$mp_input_change';\nvar MP_EV_SCROLL = '$mp_scroll';\nvar MP_EV_SUBMIT = '$mp_submit';\n\n/**\n * Autocapture: manages automatic event tracking\n * @constructor\n */\nvar Autocapture = function(mp) {\n    this.mp = mp;\n};\n\nAutocapture.prototype.init = function() {\n    if (!minDOMApisSupported()) {\n        logger$1.critical('Autocapture unavailable: missing required DOM APIs');\n        return;\n    }\n\n    this.initPageviewTracking();\n    this.initClickTracking();\n    this.initInputTracking();\n    this.initScrollTracking();\n    this.initSubmitTracking();\n};\n\nAutocapture.prototype.getFullConfig = function() {\n    var autocaptureConfig = this.mp.get_config(AUTOCAPTURE_CONFIG_KEY);\n    if (!autocaptureConfig) {\n        // Autocapture is completely off\n        return {};\n    } else if (_.isObject(autocaptureConfig)) {\n        return _.extend({}, CONFIG_DEFAULTS$1, autocaptureConfig);\n    } else {\n        // Autocapture config is non-object truthy value, return default\n        return CONFIG_DEFAULTS$1;\n    }\n};\n\nAutocapture.prototype.getConfig = function(key) {\n    return this.getFullConfig()[key];\n};\n\nAutocapture.prototype.currentUrlBlocked = function() {\n    var i;\n    var currentUrl = _.info.currentUrl();\n\n    var allowUrlRegexes = this.getConfig(CONFIG_ALLOW_URL_REGEXES) || [];\n    if (allowUrlRegexes.length) {\n        // we're using an allowlist, only track if current URL matches\n        var allowed = false;\n        for (i = 0; i < allowUrlRegexes.length; i++) {\n            var allowRegex = allowUrlRegexes[i];\n            try {\n                if (currentUrl.match(allowRegex)) {\n                    allowed = true;\n                    break;\n                }\n            } catch (err) {\n                logger$1.critical('Error while checking block URL regex: ' + allowRegex, err);\n                return true;\n            }\n        }\n        if (!allowed) {\n            // wasn't allowed by any regex\n            return true;\n        }\n    }\n\n    var blockUrlRegexes = this.getConfig(CONFIG_BLOCK_URL_REGEXES) || [];\n    if (!blockUrlRegexes || !blockUrlRegexes.length) {\n        return false;\n    }\n\n    for (i = 0; i < blockUrlRegexes.length; i++) {\n        try {\n            if (currentUrl.match(blockUrlRegexes[i])) {\n                return true;\n            }\n        } catch (err) {\n            logger$1.critical('Error while checking block URL regex: ' + blockUrlRegexes[i], err);\n            return true;\n        }\n    }\n    return false;\n};\n\nAutocapture.prototype.pageviewTrackingConfig = function() {\n    // supports both autocapture config and old track_pageview config\n    if (this.mp.get_config(AUTOCAPTURE_CONFIG_KEY)) {\n        return this.getConfig(CONFIG_TRACK_PAGEVIEW);\n    } else {\n        return this.mp.get_config(LEGACY_PAGEVIEW_CONFIG_KEY);\n    }\n};\n\n// helper for event handlers\nAutocapture.prototype.trackDomEvent = function(ev, mpEventName) {\n    if (this.currentUrlBlocked()) {\n        return;\n    }\n\n    var props = getPropsForDOMEvent(ev, {\n        allowElementCallback: this.getConfig(CONFIG_ALLOW_ELEMENT_CALLBACK),\n        allowSelectors: this.getConfig(CONFIG_ALLOW_SELECTORS),\n        blockAttrs: this.getConfig(CONFIG_BLOCK_ATTRS),\n        blockElementCallback: this.getConfig(CONFIG_BLOCK_ELEMENT_CALLBACK),\n        blockSelectors: this.getConfig(CONFIG_BLOCK_SELECTORS),\n        captureExtraAttrs: this.getConfig(CONFIG_CAPTURE_EXTRA_ATTRS),\n        captureTextContent: this.getConfig(CONFIG_CAPTURE_TEXT_CONTENT),\n        capturedForHeatMap: mpEventName === MP_EV_CLICK && !this.getConfig(CONFIG_TRACK_CLICK) && this.mp.is_recording_heatmap_data(),\n    });\n    if (props) {\n        _.extend(props, DEFAULT_PROPS);\n        this.mp.track(mpEventName, props);\n    }\n};\n\nAutocapture.prototype.initClickTracking = function() {\n    win.removeEventListener(EV_CLICK, this.listenerClick);\n\n    if (!this.getConfig(CONFIG_TRACK_CLICK) && !this.mp.get_config('record_heatmap_data')) {\n        return;\n    }\n    logger$1.log('Initializing click tracking');\n\n    this.listenerClick = win.addEventListener(EV_CLICK, function(ev) {\n        if (!this.getConfig(CONFIG_TRACK_CLICK) && !this.mp.is_recording_heatmap_data()) {\n            return;\n        }\n        this.trackDomEvent(ev, MP_EV_CLICK);\n    }.bind(this));\n};\n\nAutocapture.prototype.initInputTracking = function() {\n    win.removeEventListener(EV_CHANGE, this.listenerChange);\n\n    if (!this.getConfig(CONFIG_TRACK_INPUT)) {\n        return;\n    }\n    logger$1.log('Initializing input tracking');\n\n    this.listenerChange = win.addEventListener(EV_CHANGE, function(ev) {\n        if (!this.getConfig(CONFIG_TRACK_INPUT)) {\n            return;\n        }\n        this.trackDomEvent(ev, MP_EV_INPUT);\n    }.bind(this));\n};\n\nAutocapture.prototype.initPageviewTracking = function() {\n    win.removeEventListener(EV_POPSTATE, this.listenerPopstate);\n    win.removeEventListener(EV_HASHCHANGE, this.listenerHashchange);\n    win.removeEventListener(EV_MP_LOCATION_CHANGE, this.listenerLocationchange);\n\n    if (!this.pageviewTrackingConfig()) {\n        return;\n    }\n    logger$1.log('Initializing pageview tracking');\n\n    var previousTrackedUrl = '';\n    var tracked = false;\n    if (!this.currentUrlBlocked()) {\n        tracked = this.mp.track_pageview(DEFAULT_PROPS);\n    }\n    if (tracked) {\n        previousTrackedUrl = _.info.currentUrl();\n    }\n\n    this.listenerPopstate = win.addEventListener(EV_POPSTATE, function() {\n        win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n    });\n    this.listenerHashchange = win.addEventListener(EV_HASHCHANGE, function() {\n        win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n    });\n    var nativePushState = win.history.pushState;\n    if (typeof nativePushState === 'function') {\n        win.history.pushState = function(state, unused, url) {\n            nativePushState.call(win.history, state, unused, url);\n            win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n        };\n    }\n    var nativeReplaceState = win.history.replaceState;\n    if (typeof nativeReplaceState === 'function') {\n        win.history.replaceState = function(state, unused, url) {\n            nativeReplaceState.call(win.history, state, unused, url);\n            win.dispatchEvent(new Event(EV_MP_LOCATION_CHANGE));\n        };\n    }\n    this.listenerLocationchange = win.addEventListener(EV_MP_LOCATION_CHANGE, safewrap(function() {\n        if (this.currentUrlBlocked()) {\n            return;\n        }\n\n        var currentUrl = _.info.currentUrl();\n        var shouldTrack = false;\n        var didPathChange = currentUrl.split('#')[0].split('?')[0] !== previousTrackedUrl.split('#')[0].split('?')[0];\n        var trackPageviewOption = this.pageviewTrackingConfig();\n        if (trackPageviewOption === PAGEVIEW_OPTION_FULL_URL) {\n            shouldTrack = currentUrl !== previousTrackedUrl;\n        } else if (trackPageviewOption === PAGEVIEW_OPTION_URL_WITH_PATH_AND_QUERY_STRING) {\n            shouldTrack = currentUrl.split('#')[0] !== previousTrackedUrl.split('#')[0];\n        } else if (trackPageviewOption === PAGEVIEW_OPTION_URL_WITH_PATH) {\n            shouldTrack = didPathChange;\n        }\n\n        if (shouldTrack) {\n            var tracked = this.mp.track_pageview(DEFAULT_PROPS);\n            if (tracked) {\n                previousTrackedUrl = currentUrl;\n            }\n            if (didPathChange) {\n                this.lastScrollCheckpoint = 0;\n                logger$1.log('Path change: re-initializing scroll depth checkpoints');\n            }\n        }\n    }.bind(this)));\n};\n\nAutocapture.prototype.initScrollTracking = function() {\n    win.removeEventListener(EV_SCROLLEND, this.listenerScroll);\n\n    if (!this.getConfig(CONFIG_TRACK_SCROLL)) {\n        return;\n    }\n    logger$1.log('Initializing scroll tracking');\n    this.lastScrollCheckpoint = 0;\n\n    this.listenerScroll = win.addEventListener(EV_SCROLLEND, safewrap(function() {\n        if (!this.getConfig(CONFIG_TRACK_SCROLL)) {\n            return;\n        }\n        if (this.currentUrlBlocked()) {\n            return;\n        }\n\n        var shouldTrack = this.getConfig(CONFIG_SCROLL_CAPTURE_ALL);\n        var scrollCheckpoints = (this.getConfig(CONFIG_SCROLL_CHECKPOINTS) || [])\n            .slice()\n            .sort(function(a, b) { return a - b; });\n\n        var scrollTop = win.scrollY;\n        var props = _.extend({'$scroll_top': scrollTop}, DEFAULT_PROPS);\n        try {\n            var scrollHeight = document$1.body.scrollHeight;\n            var scrollPercentage = Math.round((scrollTop / (scrollHeight - win.innerHeight)) * 100);\n            props['$scroll_height'] = scrollHeight;\n            props['$scroll_percentage'] = scrollPercentage;\n            if (scrollPercentage > this.lastScrollCheckpoint) {\n                for (var i = 0; i < scrollCheckpoints.length; i++) {\n                    var checkpoint = scrollCheckpoints[i];\n                    if (\n                        scrollPercentage >= checkpoint &&\n                        this.lastScrollCheckpoint < checkpoint\n                    ) {\n                        props['$scroll_checkpoint'] = checkpoint;\n                        this.lastScrollCheckpoint = checkpoint;\n                        shouldTrack = true;\n                    }\n                }\n            }\n        } catch (err) {\n            logger$1.critical('Error while calculating scroll percentage', err);\n        }\n        if (shouldTrack) {\n            this.mp.track(MP_EV_SCROLL, props);\n        }\n    }.bind(this)));\n};\n\nAutocapture.prototype.initSubmitTracking = function() {\n    win.removeEventListener(EV_SUBMIT, this.listenerSubmit);\n\n    if (!this.getConfig(CONFIG_TRACK_SUBMIT)) {\n        return;\n    }\n    logger$1.log('Initializing submit tracking');\n\n    this.listenerSubmit = win.addEventListener(EV_SUBMIT, function(ev) {\n        if (!this.getConfig(CONFIG_TRACK_SUBMIT)) {\n            return;\n        }\n        this.trackDomEvent(ev, MP_EV_SUBMIT);\n    }.bind(this));\n};\n\n// TODO integrate error_reporter from mixpanel instance\nsafewrapClass(Autocapture);\n\nvar fetch = win['fetch'];\nvar logger = console_with_prefix('flags');\n\nvar FLAGS_CONFIG_KEY = 'flags';\n\nvar CONFIG_CONTEXT = 'context';\nvar CONFIG_DEFAULTS = {};\nCONFIG_DEFAULTS[CONFIG_CONTEXT] = {};\n\n/**\n * FeatureFlagManager: support for Mixpanel's feature flagging product\n * @constructor\n */\nvar FeatureFlagManager = function(initOptions) {\n    this.getMpConfig = initOptions.getConfigFunc;\n    this.getDistinctId = initOptions.getDistinctIdFunc;\n    this.track = initOptions.trackingFunc;\n};\n\nFeatureFlagManager.prototype.init = function() {\n    if (!minApisSupported()) {\n        logger.critical('Feature Flags unavailable: missing minimum required APIs');\n        return;\n    }\n\n    this.flags = null;\n    this.fetchFlags();\n\n    this.trackedFeatures = new Set();\n};\n\nFeatureFlagManager.prototype.getFullConfig = function() {\n    var ffConfig = this.getMpConfig(FLAGS_CONFIG_KEY);\n    if (!ffConfig) {\n        // flags are completely off\n        return {};\n    } else if (_.isObject(ffConfig)) {\n        return _.extend({}, CONFIG_DEFAULTS, ffConfig);\n    } else {\n        // config is non-object truthy value, return default\n        return CONFIG_DEFAULTS;\n    }\n};\n\nFeatureFlagManager.prototype.getConfig = function(key) {\n    return this.getFullConfig()[key];\n};\n\nFeatureFlagManager.prototype.isSystemEnabled = function() {\n    return !!this.getMpConfig(FLAGS_CONFIG_KEY);\n};\n\nFeatureFlagManager.prototype.areFlagsReady = function() {\n    if (!this.isSystemEnabled()) {\n        logger.error('Feature Flags not enabled');\n    }\n    return !!this.flags;\n};\n\nFeatureFlagManager.prototype.fetchFlags = function() {\n    if (!this.isSystemEnabled()) {\n        return;\n    }\n\n    var distinctId = this.getDistinctId();\n    logger.log('Fetching flags for distinct ID: ' + distinctId);\n    var reqParams = {\n        'context': _.extend({'distinct_id': distinctId}, this.getConfig(CONFIG_CONTEXT))\n    };\n    this.fetchPromise = win['fetch'](this.getMpConfig('api_host') + '/' + this.getMpConfig('api_routes')['flags'], {\n        'method': 'POST',\n        'headers': {\n            'Authorization': 'Basic ' + btoa(this.getMpConfig('token') + ':'),\n            'Content-Type': 'application/octet-stream'\n        },\n        'body': JSON.stringify(reqParams)\n    }).then(function(response) {\n        return response.json().then(function(responseBody) {\n            var responseFlags = responseBody['flags'];\n            if (!responseFlags) {\n                throw new Error('No flags in API response');\n            }\n            var flags = new Map();\n            _.each(responseFlags, function(data, key) {\n                flags.set(key, {\n                    'key': data['variant_key'],\n                    'value': data['variant_value']\n                });\n            });\n            this.flags = flags;\n        }.bind(this)).catch(function(error) {\n            logger.error(error);\n        });\n    }.bind(this)).catch(function() {});\n};\n\nFeatureFlagManager.prototype.getVariant = function(featureName, fallback) {\n    if (!this.fetchPromise) {\n        return new Promise(function(resolve) {\n            logger.critical('Feature Flags not initialized');\n            resolve(fallback);\n        });\n    }\n\n    return this.fetchPromise.then(function() {\n        return this.getVariantSync(featureName, fallback);\n    }.bind(this)).catch(function(error) {\n        logger.error(error);\n        return fallback;\n    });\n};\n\nFeatureFlagManager.prototype.getVariantSync = function(featureName, fallback) {\n    if (!this.areFlagsReady()) {\n        logger.log('Flags not loaded yet');\n        return fallback;\n    }\n    var feature = this.flags.get(featureName);\n    if (!feature) {\n        logger.log('No flag found: \"' + featureName + '\"');\n        return fallback;\n    }\n    this.trackFeatureCheck(featureName, feature);\n    return feature;\n};\n\nFeatureFlagManager.prototype.getVariantValue = function(featureName, fallbackValue) {\n    return this.getVariant(featureName, {'value': fallbackValue}).then(function(feature) {\n        return feature['value'];\n    }).catch(function(error) {\n        logger.error(error);\n        return fallbackValue;\n    });\n};\n\n// TODO remove deprecated method\nFeatureFlagManager.prototype.getFeatureData = function(featureName, fallbackValue) {\n    logger.critical('mixpanel.flags.get_feature_data() is deprecated and will be removed in a future release. Use mixpanel.flags.get_variant_value() instead.');\n    return this.getVariantValue(featureName, fallbackValue);\n};\n\nFeatureFlagManager.prototype.getVariantValueSync = function(featureName, fallbackValue) {\n    return this.getVariantSync(featureName, {'value': fallbackValue})['value'];\n};\n\nFeatureFlagManager.prototype.isEnabled = function(featureName, fallbackValue) {\n    return this.getVariantValue(featureName).then(function() {\n        return this.isEnabledSync(featureName, fallbackValue);\n    }.bind(this)).catch(function(error) {\n        logger.error(error);\n        return fallbackValue;\n    });\n};\n\nFeatureFlagManager.prototype.isEnabledSync = function(featureName, fallbackValue) {\n    fallbackValue = fallbackValue || false;\n    var val = this.getVariantValueSync(featureName, fallbackValue);\n    if (val !== true && val !== false) {\n        logger.error('Feature flag \"' + featureName + '\" value: ' + val + ' is not a boolean; returning fallback value: ' + fallbackValue);\n        val = fallbackValue;\n    }\n    return val;\n};\n\nFeatureFlagManager.prototype.trackFeatureCheck = function(featureName, feature) {\n    if (this.trackedFeatures.has(featureName)) {\n        return;\n    }\n    this.trackedFeatures.add(featureName);\n    this.track('$experiment_started', {\n        'Experiment name': featureName,\n        'Variant name': feature['key'],\n        '$experiment_type': 'feature_flag'\n    });\n};\n\nfunction minApisSupported() {\n    return !!fetch &&\n      typeof Promise !== 'undefined' &&\n      typeof Map !== 'undefined' &&\n      typeof Set !== 'undefined';\n}\n\nsafewrapClass(FeatureFlagManager);\n\nFeatureFlagManager.prototype['are_flags_ready'] = FeatureFlagManager.prototype.areFlagsReady;\nFeatureFlagManager.prototype['get_variant'] = FeatureFlagManager.prototype.getVariant;\nFeatureFlagManager.prototype['get_variant_sync'] = FeatureFlagManager.prototype.getVariantSync;\nFeatureFlagManager.prototype['get_variant_value'] = FeatureFlagManager.prototype.getVariantValue;\nFeatureFlagManager.prototype['get_variant_value_sync'] = FeatureFlagManager.prototype.getVariantValueSync;\nFeatureFlagManager.prototype['is_enabled'] = FeatureFlagManager.prototype.isEnabled;\nFeatureFlagManager.prototype['is_enabled_sync'] = FeatureFlagManager.prototype.isEnabledSync;\n\n// Deprecated method\nFeatureFlagManager.prototype['get_feature_data'] = FeatureFlagManager.prototype.getFeatureData;\n\n/* eslint camelcase: \"off\" */\n\n\n/**\n * DomTracker Object\n * @constructor\n */\nvar DomTracker = function() {};\n\n\n// interface\nDomTracker.prototype.create_properties = function() {};\nDomTracker.prototype.event_handler = function() {};\nDomTracker.prototype.after_track_handler = function() {};\n\nDomTracker.prototype.init = function(mixpanel_instance) {\n    this.mp = mixpanel_instance;\n    return this;\n};\n\n/**\n * @param {Object|string} query\n * @param {string} event_name\n * @param {Object=} properties\n * @param {function=} user_callback\n */\nDomTracker.prototype.track = function(query, event_name, properties, user_callback) {\n    var that = this;\n    var elements = _.dom_query(query);\n\n    if (elements.length === 0) {\n        console$1.error('The DOM query (' + query + ') returned 0 elements');\n        return;\n    }\n\n    _.each(elements, function(element) {\n        _.register_event(element, this.override_event, function(e) {\n            var options = {};\n            var props = that.create_properties(properties, this);\n            var timeout = that.mp.get_config('track_links_timeout');\n\n            that.event_handler(e, this, options);\n\n            // in case the mixpanel servers don't get back to us in time\n            window.setTimeout(that.track_callback(user_callback, props, options, true), timeout);\n\n            // fire the tracking event\n            that.mp.track(event_name, props, that.track_callback(user_callback, props, options));\n        });\n    }, this);\n\n    return true;\n};\n\n/**\n * @param {function} user_callback\n * @param {Object} props\n * @param {boolean=} timeout_occured\n */\nDomTracker.prototype.track_callback = function(user_callback, props, options, timeout_occured) {\n    timeout_occured = timeout_occured || false;\n    var that = this;\n\n    return function() {\n        // options is referenced from both callbacks, so we can have\n        // a 'lock' of sorts to ensure only one fires\n        if (options.callback_fired) { return; }\n        options.callback_fired = true;\n\n        if (user_callback && user_callback(timeout_occured, props) === false) {\n            // user can prevent the default functionality by\n            // returning false from their callback\n            return;\n        }\n\n        that.after_track_handler(props, options, timeout_occured);\n    };\n};\n\nDomTracker.prototype.create_properties = function(properties, element) {\n    var props;\n\n    if (typeof(properties) === 'function') {\n        props = properties(element);\n    } else {\n        props = _.extend({}, properties);\n    }\n\n    return props;\n};\n\n/**\n * LinkTracker Object\n * @constructor\n * @extends DomTracker\n */\nvar LinkTracker = function() {\n    this.override_event = 'click';\n};\n_.inherit(LinkTracker, DomTracker);\n\nLinkTracker.prototype.create_properties = function(properties, element) {\n    var props = LinkTracker.superclass.create_properties.apply(this, arguments);\n\n    if (element.href) { props['url'] = element.href; }\n\n    return props;\n};\n\nLinkTracker.prototype.event_handler = function(evt, element, options) {\n    options.new_tab = (\n        evt.which === 2 ||\n        evt.metaKey ||\n        evt.ctrlKey ||\n        element.target === '_blank'\n    );\n    options.href = element.href;\n\n    if (!options.new_tab) {\n        evt.preventDefault();\n    }\n};\n\nLinkTracker.prototype.after_track_handler = function(props, options) {\n    if (options.new_tab) { return; }\n\n    setTimeout(function() {\n        window.location = options.href;\n    }, 0);\n};\n\n/**\n * FormTracker Object\n * @constructor\n * @extends DomTracker\n */\nvar FormTracker = function() {\n    this.override_event = 'submit';\n};\n_.inherit(FormTracker, DomTracker);\n\nFormTracker.prototype.event_handler = function(evt, element, options) {\n    options.element = element;\n    evt.preventDefault();\n};\n\nFormTracker.prototype.after_track_handler = function(props, options) {\n    setTimeout(function() {\n        options.element.submit();\n    }, 0);\n};\n\n/* eslint camelcase: \"off\" */\n\n\n/** @const */ var SET_ACTION      = '$set';\n/** @const */ var SET_ONCE_ACTION = '$set_once';\n/** @const */ var UNSET_ACTION    = '$unset';\n/** @const */ var ADD_ACTION      = '$add';\n/** @const */ var APPEND_ACTION   = '$append';\n/** @const */ var UNION_ACTION    = '$union';\n/** @const */ var REMOVE_ACTION   = '$remove';\n/** @const */ var DELETE_ACTION   = '$delete';\n\n// Common internal methods for mixpanel.people and mixpanel.group APIs.\n// These methods shouldn't involve network I/O.\nvar apiActions = {\n    set_action: function(prop, to) {\n        var data = {};\n        var $set = {};\n        if (_.isObject(prop)) {\n            _.each(prop, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $set[k] = v;\n                }\n            }, this);\n        } else {\n            $set[prop] = to;\n        }\n\n        data[SET_ACTION] = $set;\n        return data;\n    },\n\n    unset_action: function(prop) {\n        var data = {};\n        var $unset = [];\n        if (!_.isArray(prop)) {\n            prop = [prop];\n        }\n\n        _.each(prop, function(k) {\n            if (!this._is_reserved_property(k)) {\n                $unset.push(k);\n            }\n        }, this);\n\n        data[UNSET_ACTION] = $unset;\n        return data;\n    },\n\n    set_once_action: function(prop, to) {\n        var data = {};\n        var $set_once = {};\n        if (_.isObject(prop)) {\n            _.each(prop, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $set_once[k] = v;\n                }\n            }, this);\n        } else {\n            $set_once[prop] = to;\n        }\n        data[SET_ONCE_ACTION] = $set_once;\n        return data;\n    },\n\n    union_action: function(list_name, values) {\n        var data = {};\n        var $union = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $union[k] = _.isArray(v) ? v : [v];\n                }\n            }, this);\n        } else {\n            $union[list_name] = _.isArray(values) ? values : [values];\n        }\n        data[UNION_ACTION] = $union;\n        return data;\n    },\n\n    append_action: function(list_name, value) {\n        var data = {};\n        var $append = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $append[k] = v;\n                }\n            }, this);\n        } else {\n            $append[list_name] = value;\n        }\n        data[APPEND_ACTION] = $append;\n        return data;\n    },\n\n    remove_action: function(list_name, value) {\n        var data = {};\n        var $remove = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $remove[k] = v;\n                }\n            }, this);\n        } else {\n            $remove[list_name] = value;\n        }\n        data[REMOVE_ACTION] = $remove;\n        return data;\n    },\n\n    delete_action: function() {\n        var data = {};\n        data[DELETE_ACTION] = '';\n        return data;\n    }\n};\n\n/* eslint camelcase: \"off\" */\n\n/**\n * Mixpanel Group Object\n * @constructor\n */\nvar MixpanelGroup = function() {};\n\n_.extend(MixpanelGroup.prototype, apiActions);\n\nMixpanelGroup.prototype._init = function(mixpanel_instance, group_key, group_id) {\n    this._mixpanel = mixpanel_instance;\n    this._group_key = group_key;\n    this._group_id = group_id;\n};\n\n/**\n * Set properties on a group.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').set('Location', '405 Howard');\n *\n *     // or set multiple properties at once\n *     mixpanel.get_group('company', 'mixpanel').set({\n *          'Location': '405 Howard',\n *          'Founded' : 2009,\n *     });\n *     // properties can be strings, integers, dates, or lists\n *\n * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n * @param {*} [to] A value to set on the given property name\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.set = addOptOutCheckMixpanelGroup(function(prop, to, callback) {\n    var data = this.set_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/**\n * Set properties on a group, only if they do not yet exist.\n * This will not overwrite previous group property values, unlike\n * group.set().\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').set_once('Location', '405 Howard');\n *\n *     // or set multiple properties at once\n *     mixpanel.get_group('company', 'mixpanel').set_once({\n *          'Location': '405 Howard',\n *          'Founded' : 2009,\n *     });\n *     // properties can be strings, integers, lists or dates\n *\n * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n * @param {*} [to] A value to set on the given property name\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.set_once = addOptOutCheckMixpanelGroup(function(prop, to, callback) {\n    var data = this.set_once_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/**\n * Unset properties on a group permanently.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').unset('Founded');\n *\n * @param {String} prop The name of the property.\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.unset = addOptOutCheckMixpanelGroup(function(prop, callback) {\n    var data = this.unset_action(prop);\n    return this._send_request(data, callback);\n});\n\n/**\n * Merge a given list with a list-valued group property, excluding duplicate values.\n *\n * ### Usage:\n *\n *     // merge a value to a list, creating it if needed\n *     mixpanel.get_group('company', 'mixpanel').union('Location', ['San Francisco', 'London']);\n *\n * @param {String} list_name Name of the property.\n * @param {Array} values Values to merge with the given property\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.union = addOptOutCheckMixpanelGroup(function(list_name, values, callback) {\n    if (_.isObject(list_name)) {\n        callback = values;\n    }\n    var data = this.union_action(list_name, values);\n    return this._send_request(data, callback);\n});\n\n/**\n * Permanently delete a group.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').delete();\n *\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype['delete'] = addOptOutCheckMixpanelGroup(function(callback) {\n    // bracket notation above prevents a minification error related to reserved words\n    var data = this.delete_action();\n    return this._send_request(data, callback);\n});\n\n/**\n * Remove a property from a group. The value will be ignored if doesn't exist.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').remove('Location', 'London');\n *\n * @param {String} list_name Name of the property.\n * @param {Object} value Value to remove from the given group property\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.remove = addOptOutCheckMixpanelGroup(function(list_name, value, callback) {\n    var data = this.remove_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\nMixpanelGroup.prototype._send_request = function(data, callback) {\n    data['$group_key'] = this._group_key;\n    data['$group_id'] = this._group_id;\n    data['$token'] = this._get_config('token');\n\n    var date_encoded_data = _.encodeDates(data);\n    return this._mixpanel._track_or_batch({\n        type: 'groups',\n        data: date_encoded_data,\n        endpoint: this._get_config('api_host') + '/' +  this._get_config('api_routes')['groups'],\n        batcher: this._mixpanel.request_batchers.groups\n    }, callback);\n};\n\nMixpanelGroup.prototype._is_reserved_property = function(prop) {\n    return prop === '$group_key' || prop === '$group_id';\n};\n\nMixpanelGroup.prototype._get_config = function(conf) {\n    return this._mixpanel.get_config(conf);\n};\n\nMixpanelGroup.prototype.toString = function() {\n    return this._mixpanel.toString() + '.group.' + this._group_key + '.' + this._group_id;\n};\n\n// MixpanelGroup Exports\nMixpanelGroup.prototype['remove']   = MixpanelGroup.prototype.remove;\nMixpanelGroup.prototype['set']      = MixpanelGroup.prototype.set;\nMixpanelGroup.prototype['set_once'] = MixpanelGroup.prototype.set_once;\nMixpanelGroup.prototype['union']    = MixpanelGroup.prototype.union;\nMixpanelGroup.prototype['unset']    = MixpanelGroup.prototype.unset;\nMixpanelGroup.prototype['toString'] = MixpanelGroup.prototype.toString;\n\n/* eslint camelcase: \"off\" */\n\n/**\n * Mixpanel People Object\n * @constructor\n */\nvar MixpanelPeople = function() {};\n\n_.extend(MixpanelPeople.prototype, apiActions);\n\nMixpanelPeople.prototype._init = function(mixpanel_instance) {\n    this._mixpanel = mixpanel_instance;\n};\n\n/*\n* Set properties on a user record.\n*\n* ### Usage:\n*\n*     mixpanel.people.set('gender', 'm');\n*\n*     // or set multiple properties at once\n*     mixpanel.people.set({\n*         'Company': 'Acme',\n*         'Plan': 'Premium',\n*         'Upgrade date': new Date()\n*     });\n*     // properties can be strings, integers, dates, or lists\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [to] A value to set on the given property name\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.set = addOptOutCheckMixpanelPeople(function(prop, to, callback) {\n    var data = this.set_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    // make sure that the referrer info has been updated and saved\n    if (this._get_config('save_referrer')) {\n        this._mixpanel['persistence'].update_referrer_info(document.referrer);\n    }\n\n    // update $set object with default people properties\n    data[SET_ACTION] = _.extend(\n        {},\n        _.info.people_properties(),\n        data[SET_ACTION]\n    );\n    return this._send_request(data, callback);\n});\n\n/*\n* Set properties on a user record, only if they do not yet exist.\n* This will not overwrite previous people property values, unlike\n* people.set().\n*\n* ### Usage:\n*\n*     mixpanel.people.set_once('First Login Date', new Date());\n*\n*     // or set multiple properties at once\n*     mixpanel.people.set_once({\n*         'First Login Date': new Date(),\n*         'Starting Plan': 'Premium'\n*     });\n*\n*     // properties can be strings, integers or dates\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [to] A value to set on the given property name\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.set_once = addOptOutCheckMixpanelPeople(function(prop, to, callback) {\n    var data = this.set_once_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/*\n* Unset properties on a user record (permanently removes the properties and their values from a profile).\n*\n* ### Usage:\n*\n*     mixpanel.people.unset('gender');\n*\n*     // or unset multiple properties at once\n*     mixpanel.people.unset(['gender', 'Company']);\n*\n* @param {Array|String} prop If a string, this is the name of the property. If an array, this is a list of property names.\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.unset = addOptOutCheckMixpanelPeople(function(prop, callback) {\n    var data = this.unset_action(prop);\n    return this._send_request(data, callback);\n});\n\n/*\n* Increment/decrement numeric people analytics properties.\n*\n* ### Usage:\n*\n*     mixpanel.people.increment('page_views', 1);\n*\n*     // or, for convenience, if you're just incrementing a counter by\n*     // 1, you can simply do\n*     mixpanel.people.increment('page_views');\n*\n*     // to decrement a counter, pass a negative number\n*     mixpanel.people.increment('credits_left', -1);\n*\n*     // like mixpanel.people.set(), you can increment multiple\n*     // properties at once:\n*     mixpanel.people.increment({\n*         counter1: 1,\n*         counter2: 6\n*     });\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and numeric values.\n* @param {Number} [by] An amount to increment the given property\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.increment = addOptOutCheckMixpanelPeople(function(prop, by, callback) {\n    var data = {};\n    var $add = {};\n    if (_.isObject(prop)) {\n        _.each(prop, function(v, k) {\n            if (!this._is_reserved_property(k)) {\n                if (isNaN(parseFloat(v))) {\n                    console$1.error('Invalid increment value passed to mixpanel.people.increment - must be a number');\n                    return;\n                } else {\n                    $add[k] = v;\n                }\n            }\n        }, this);\n        callback = by;\n    } else {\n        // convenience: mixpanel.people.increment('property'); will\n        // increment 'property' by 1\n        if (_.isUndefined(by)) {\n            by = 1;\n        }\n        $add[prop] = by;\n    }\n    data[ADD_ACTION] = $add;\n\n    return this._send_request(data, callback);\n});\n\n/*\n* Append a value to a list-valued people analytics property.\n*\n* ### Usage:\n*\n*     // append a value to a list, creating it if needed\n*     mixpanel.people.append('pages_visited', 'homepage');\n*\n*     // like mixpanel.people.set(), you can append multiple\n*     // properties at once:\n*     mixpanel.people.append({\n*         list1: 'bob',\n*         list2: 123\n*     });\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] value An item to append to the list\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.append = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {\n    if (_.isObject(list_name)) {\n        callback = value;\n    }\n    var data = this.append_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\n/*\n* Remove a value from a list-valued people analytics property.\n*\n* ### Usage:\n*\n*     mixpanel.people.remove('School', 'UCB');\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] value Item to remove from the list\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.remove = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {\n    if (_.isObject(list_name)) {\n        callback = value;\n    }\n    var data = this.remove_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\n/*\n* Merge a given list with a list-valued people analytics property,\n* excluding duplicate values.\n*\n* ### Usage:\n*\n*     // merge a value to a list, creating it if needed\n*     mixpanel.people.union('pages_visited', 'homepage');\n*\n*     // like mixpanel.people.set(), you can append multiple\n*     // properties at once:\n*     mixpanel.people.union({\n*         list1: 'bob',\n*         list2: 123\n*     });\n*\n*     // like mixpanel.people.append(), you can append multiple\n*     // values to the same list:\n*     mixpanel.people.union({\n*         list1: ['bob', 'billy']\n*     });\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] Value / values to merge with the given property\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.union = addOptOutCheckMixpanelPeople(function(list_name, values, callback) {\n    if (_.isObject(list_name)) {\n        callback = values;\n    }\n    var data = this.union_action(list_name, values);\n    return this._send_request(data, callback);\n});\n\n/*\n * Record that you have charged the current user a certain amount\n * of money. Charges recorded with track_charge() will appear in the\n * Mixpanel revenue report.\n *\n * ### Usage:\n *\n *     // charge a user $50\n *     mixpanel.people.track_charge(50);\n *\n *     // charge a user $30.50 on the 2nd of january\n *     mixpanel.people.track_charge(30.50, {\n *         '$time': new Date('jan 1 2012')\n *     });\n *\n * @param {Number} amount The amount of money charged to the current user\n * @param {Object} [properties] An associative array of properties associated with the charge\n * @param {Function} [callback] If provided, the callback will be called when the server responds\n * @deprecated\n */\nMixpanelPeople.prototype.track_charge = addOptOutCheckMixpanelPeople(function() {\n    console$1.error('mixpanel.people.track_charge() is deprecated and no longer has any effect.');\n});\n\n/*\n * Permanently clear all revenue report transactions from the\n * current user's people analytics profile.\n *\n * ### Usage:\n *\n *     mixpanel.people.clear_charges();\n *\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n * @deprecated\n */\nMixpanelPeople.prototype.clear_charges = function(callback) {\n    return this.set('$transactions', [], callback);\n};\n\n/*\n* Permanently deletes the current people analytics profile from\n* Mixpanel (using the current distinct_id).\n*\n* ### Usage:\n*\n*     // remove the all data you have stored about the current user\n*     mixpanel.people.delete_user();\n*\n*/\nMixpanelPeople.prototype.delete_user = function() {\n    if (!this._identify_called()) {\n        console$1.error('mixpanel.people.delete_user() requires you to call identify() first');\n        return;\n    }\n    var data = {'$delete': this._mixpanel.get_distinct_id()};\n    return this._send_request(data);\n};\n\nMixpanelPeople.prototype.toString = function() {\n    return this._mixpanel.toString() + '.people';\n};\n\nMixpanelPeople.prototype._send_request = function(data, callback) {\n    data['$token'] = this._get_config('token');\n    data['$distinct_id'] = this._mixpanel.get_distinct_id();\n    var device_id = this._mixpanel.get_property('$device_id');\n    var user_id = this._mixpanel.get_property('$user_id');\n    var had_persisted_distinct_id = this._mixpanel.get_property('$had_persisted_distinct_id');\n    if (device_id) {\n        data['$device_id'] = device_id;\n    }\n    if (user_id) {\n        data['$user_id'] = user_id;\n    }\n    if (had_persisted_distinct_id) {\n        data['$had_persisted_distinct_id'] = had_persisted_distinct_id;\n    }\n\n    var date_encoded_data = _.encodeDates(data);\n\n    if (!this._identify_called()) {\n        this._enqueue(data);\n        if (!_.isUndefined(callback)) {\n            if (this._get_config('verbose')) {\n                callback({status: -1, error: null});\n            } else {\n                callback(-1);\n            }\n        }\n        return _.truncate(date_encoded_data, 255);\n    }\n\n    return this._mixpanel._track_or_batch({\n        type: 'people',\n        data: date_encoded_data,\n        endpoint: this._get_config('api_host') + '/' +  this._get_config('api_routes')['engage'],\n        batcher: this._mixpanel.request_batchers.people\n    }, callback);\n};\n\nMixpanelPeople.prototype._get_config = function(conf_var) {\n    return this._mixpanel.get_config(conf_var);\n};\n\nMixpanelPeople.prototype._identify_called = function() {\n    return this._mixpanel._flags.identify_called === true;\n};\n\n// Queue up engage operations if identify hasn't been called yet.\nMixpanelPeople.prototype._enqueue = function(data) {\n    if (SET_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(SET_ACTION, data);\n    } else if (SET_ONCE_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(SET_ONCE_ACTION, data);\n    } else if (UNSET_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(UNSET_ACTION, data);\n    } else if (ADD_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(ADD_ACTION, data);\n    } else if (APPEND_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(APPEND_ACTION, data);\n    } else if (REMOVE_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(REMOVE_ACTION, data);\n    } else if (UNION_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(UNION_ACTION, data);\n    } else {\n        console$1.error('Invalid call to _enqueue():', data);\n    }\n};\n\nMixpanelPeople.prototype._flush_one_queue = function(action, action_method, callback, queue_to_params_fn) {\n    var _this = this;\n    var queued_data = _.extend({}, this._mixpanel['persistence'].load_queue(action));\n    var action_params = queued_data;\n\n    if (!_.isUndefined(queued_data) && _.isObject(queued_data) && !_.isEmptyObject(queued_data)) {\n        _this._mixpanel['persistence']._pop_from_people_queue(action, queued_data);\n        _this._mixpanel['persistence'].save();\n        if (queue_to_params_fn) {\n            action_params = queue_to_params_fn(queued_data);\n        }\n        action_method.call(_this, action_params, function(response, data) {\n            // on bad response, we want to add it back to the queue\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(action, queued_data);\n            }\n            if (!_.isUndefined(callback)) {\n                callback(response, data);\n            }\n        });\n    }\n};\n\n// Flush queued engage operations - order does not matter,\n// and there are network level race conditions anyway\nMixpanelPeople.prototype._flush = function(\n    _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback\n) {\n    var _this = this;\n\n    this._flush_one_queue(SET_ACTION, this.set, _set_callback);\n    this._flush_one_queue(SET_ONCE_ACTION, this.set_once, _set_once_callback);\n    this._flush_one_queue(UNSET_ACTION, this.unset, _unset_callback, function(queue) { return _.keys(queue); });\n    this._flush_one_queue(ADD_ACTION, this.increment, _add_callback);\n    this._flush_one_queue(UNION_ACTION, this.union, _union_callback);\n\n    // we have to fire off each $append individually since there is\n    // no concat method server side\n    var $append_queue = this._mixpanel['persistence'].load_queue(APPEND_ACTION);\n    if (!_.isUndefined($append_queue) && _.isArray($append_queue) && $append_queue.length) {\n        var $append_item;\n        var append_callback = function(response, data) {\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(APPEND_ACTION, $append_item);\n            }\n            if (!_.isUndefined(_append_callback)) {\n                _append_callback(response, data);\n            }\n        };\n        for (var i = $append_queue.length - 1; i >= 0; i--) {\n            $append_queue = this._mixpanel['persistence'].load_queue(APPEND_ACTION);\n            $append_item = $append_queue.pop();\n            _this._mixpanel['persistence'].save();\n            if (!_.isEmptyObject($append_item)) {\n                _this.append($append_item, append_callback);\n            }\n        }\n    }\n\n    // same for $remove\n    var $remove_queue = this._mixpanel['persistence'].load_queue(REMOVE_ACTION);\n    if (!_.isUndefined($remove_queue) && _.isArray($remove_queue) && $remove_queue.length) {\n        var $remove_item;\n        var remove_callback = function(response, data) {\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(REMOVE_ACTION, $remove_item);\n            }\n            if (!_.isUndefined(_remove_callback)) {\n                _remove_callback(response, data);\n            }\n        };\n        for (var j = $remove_queue.length - 1; j >= 0; j--) {\n            $remove_queue = this._mixpanel['persistence'].load_queue(REMOVE_ACTION);\n            $remove_item = $remove_queue.pop();\n            _this._mixpanel['persistence'].save();\n            if (!_.isEmptyObject($remove_item)) {\n                _this.remove($remove_item, remove_callback);\n            }\n        }\n    }\n};\n\nMixpanelPeople.prototype._is_reserved_property = function(prop) {\n    return prop === '$distinct_id' || prop === '$token' || prop === '$device_id' || prop === '$user_id' || prop === '$had_persisted_distinct_id';\n};\n\n// MixpanelPeople Exports\nMixpanelPeople.prototype['set']           = MixpanelPeople.prototype.set;\nMixpanelPeople.prototype['set_once']      = MixpanelPeople.prototype.set_once;\nMixpanelPeople.prototype['unset']         = MixpanelPeople.prototype.unset;\nMixpanelPeople.prototype['increment']     = MixpanelPeople.prototype.increment;\nMixpanelPeople.prototype['append']        = MixpanelPeople.prototype.append;\nMixpanelPeople.prototype['remove']        = MixpanelPeople.prototype.remove;\nMixpanelPeople.prototype['union']         = MixpanelPeople.prototype.union;\nMixpanelPeople.prototype['track_charge']  = MixpanelPeople.prototype.track_charge;\nMixpanelPeople.prototype['clear_charges'] = MixpanelPeople.prototype.clear_charges;\nMixpanelPeople.prototype['delete_user']   = MixpanelPeople.prototype.delete_user;\nMixpanelPeople.prototype['toString']      = MixpanelPeople.prototype.toString;\n\n/* eslint camelcase: \"off\" */\n\n\n/*\n * Constants\n */\n/** @const */ var SET_QUEUE_KEY          = '__mps';\n/** @const */ var SET_ONCE_QUEUE_KEY     = '__mpso';\n/** @const */ var UNSET_QUEUE_KEY        = '__mpus';\n/** @const */ var ADD_QUEUE_KEY          = '__mpa';\n/** @const */ var APPEND_QUEUE_KEY       = '__mpap';\n/** @const */ var REMOVE_QUEUE_KEY       = '__mpr';\n/** @const */ var UNION_QUEUE_KEY        = '__mpu';\n// This key is deprecated, but we want to check for it to see whether aliasing is allowed.\n/** @const */ var PEOPLE_DISTINCT_ID_KEY = '$people_distinct_id';\n/** @const */ var ALIAS_ID_KEY           = '__alias';\n/** @const */ var EVENT_TIMERS_KEY       = '__timers';\n/** @const */ var RESERVED_PROPERTIES = [\n    SET_QUEUE_KEY,\n    SET_ONCE_QUEUE_KEY,\n    UNSET_QUEUE_KEY,\n    ADD_QUEUE_KEY,\n    APPEND_QUEUE_KEY,\n    REMOVE_QUEUE_KEY,\n    UNION_QUEUE_KEY,\n    PEOPLE_DISTINCT_ID_KEY,\n    ALIAS_ID_KEY,\n    EVENT_TIMERS_KEY\n];\n\n/**\n * Mixpanel Persistence Object\n * @constructor\n */\nvar MixpanelPersistence = function(config) {\n    this['props'] = {};\n    this.campaign_params_saved = false;\n\n    if (config['persistence_name']) {\n        this.name = 'mp_' + config['persistence_name'];\n    } else {\n        this.name = 'mp_' + config['token'] + '_mixpanel';\n    }\n\n    var storage_type = config['persistence'];\n    if (storage_type !== 'cookie' && storage_type !== 'localStorage') {\n        console$1.critical('Unknown persistence type ' + storage_type + '; falling back to cookie');\n        storage_type = config['persistence'] = 'cookie';\n    }\n\n    if (storage_type === 'localStorage' && _.localStorage.is_supported()) {\n        this.storage = _.localStorage;\n    } else {\n        this.storage = _.cookie;\n    }\n\n    this.load();\n    this.update_config(config);\n    this.upgrade();\n    this.save();\n};\n\nMixpanelPersistence.prototype.properties = function() {\n    var p = {};\n\n    this.load();\n\n    // Filter out reserved properties\n    _.each(this['props'], function(v, k) {\n        if (!_.include(RESERVED_PROPERTIES, k)) {\n            p[k] = v;\n        }\n    });\n    return p;\n};\n\nMixpanelPersistence.prototype.load = function() {\n    if (this.disabled) { return; }\n\n    var entry = this.storage.parse(this.name);\n\n    if (entry) {\n        this['props'] = _.extend({}, entry);\n    }\n};\n\nMixpanelPersistence.prototype.upgrade = function() {\n    var old_cookie,\n        old_localstorage;\n\n    // if transferring from cookie to localStorage or vice-versa, copy existing\n    // super properties over to new storage mode\n    if (this.storage === _.localStorage) {\n        old_cookie = _.cookie.parse(this.name);\n\n        _.cookie.remove(this.name);\n        _.cookie.remove(this.name, true);\n\n        if (old_cookie) {\n            this.register_once(old_cookie);\n        }\n    } else if (this.storage === _.cookie) {\n        old_localstorage = _.localStorage.parse(this.name);\n\n        _.localStorage.remove(this.name);\n\n        if (old_localstorage) {\n            this.register_once(old_localstorage);\n        }\n    }\n};\n\nMixpanelPersistence.prototype.save = function() {\n    if (this.disabled) { return; }\n\n    this.storage.set(\n        this.name,\n        JSONStringify(this['props']),\n        this.expire_days,\n        this.cross_subdomain,\n        this.secure,\n        this.cross_site,\n        this.cookie_domain\n    );\n};\n\nMixpanelPersistence.prototype.load_prop = function(key) {\n    this.load();\n    return this['props'][key];\n};\n\nMixpanelPersistence.prototype.remove = function() {\n    // remove both domain and subdomain cookies\n    this.storage.remove(this.name, false, this.cookie_domain);\n    this.storage.remove(this.name, true, this.cookie_domain);\n};\n\n// removes the storage entry and deletes all loaded data\n// forced name for tests\nMixpanelPersistence.prototype.clear = function() {\n    this.remove();\n    this['props'] = {};\n};\n\n/**\n* @param {Object} props\n* @param {*=} default_value\n* @param {number=} days\n*/\nMixpanelPersistence.prototype.register_once = function(props, default_value, days) {\n    if (_.isObject(props)) {\n        if (typeof(default_value) === 'undefined') { default_value = 'None'; }\n        this.expire_days = (typeof(days) === 'undefined') ? this.default_expiry : days;\n\n        this.load();\n\n        _.each(props, function(val, prop) {\n            if (!this['props'].hasOwnProperty(prop) || this['props'][prop] === default_value) {\n                this['props'][prop] = val;\n            }\n        }, this);\n\n        this.save();\n\n        return true;\n    }\n    return false;\n};\n\n/**\n* @param {Object} props\n* @param {number=} days\n*/\nMixpanelPersistence.prototype.register = function(props, days) {\n    if (_.isObject(props)) {\n        this.expire_days = (typeof(days) === 'undefined') ? this.default_expiry : days;\n\n        this.load();\n        _.extend(this['props'], props);\n        this.save();\n\n        return true;\n    }\n    return false;\n};\n\nMixpanelPersistence.prototype.unregister = function(prop) {\n    this.load();\n    if (prop in this['props']) {\n        delete this['props'][prop];\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.update_search_keyword = function(referrer) {\n    this.register(_.info.searchInfo(referrer));\n};\n\n// EXPORTED METHOD, we test this directly.\nMixpanelPersistence.prototype.update_referrer_info = function(referrer) {\n    // If referrer doesn't exist, we want to note the fact that it was type-in traffic.\n    this.register_once({\n        '$initial_referrer': referrer || '$direct',\n        '$initial_referring_domain': _.info.referringDomain(referrer) || '$direct'\n    }, '');\n};\n\nMixpanelPersistence.prototype.get_referrer_info = function() {\n    return _.strip_empty_properties({\n        '$initial_referrer': this['props']['$initial_referrer'],\n        '$initial_referring_domain': this['props']['$initial_referring_domain']\n    });\n};\n\nMixpanelPersistence.prototype.update_config = function(config) {\n    this.default_expiry = this.expire_days = config['cookie_expiration'];\n    this.set_disabled(config['disable_persistence']);\n    this.set_cookie_domain(config['cookie_domain']);\n    this.set_cross_site(config['cross_site_cookie']);\n    this.set_cross_subdomain(config['cross_subdomain_cookie']);\n    this.set_secure(config['secure_cookie']);\n};\n\nMixpanelPersistence.prototype.set_disabled = function(disabled) {\n    this.disabled = disabled;\n    if (this.disabled) {\n        this.remove();\n    } else {\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cookie_domain = function(cookie_domain) {\n    if (cookie_domain !== this.cookie_domain) {\n        this.remove();\n        this.cookie_domain = cookie_domain;\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cross_site = function(cross_site) {\n    if (cross_site !== this.cross_site) {\n        this.cross_site = cross_site;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cross_subdomain = function(cross_subdomain) {\n    if (cross_subdomain !== this.cross_subdomain) {\n        this.cross_subdomain = cross_subdomain;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.get_cross_subdomain = function() {\n    return this.cross_subdomain;\n};\n\nMixpanelPersistence.prototype.set_secure = function(secure) {\n    if (secure !== this.secure) {\n        this.secure = secure ? true : false;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype._add_to_people_queue = function(queue, data) {\n    var q_key = this._get_queue_key(queue),\n        q_data = data[queue],\n        set_q = this._get_or_create_queue(SET_ACTION),\n        set_once_q = this._get_or_create_queue(SET_ONCE_ACTION),\n        unset_q = this._get_or_create_queue(UNSET_ACTION),\n        add_q = this._get_or_create_queue(ADD_ACTION),\n        union_q = this._get_or_create_queue(UNION_ACTION),\n        remove_q = this._get_or_create_queue(REMOVE_ACTION, []),\n        append_q = this._get_or_create_queue(APPEND_ACTION, []);\n\n    if (q_key === SET_QUEUE_KEY) {\n        // Update the set queue - we can override any existing values\n        _.extend(set_q, q_data);\n        // if there was a pending increment, override it\n        // with the set.\n        this._pop_from_people_queue(ADD_ACTION, q_data);\n        // if there was a pending union, override it\n        // with the set.\n        this._pop_from_people_queue(UNION_ACTION, q_data);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === SET_ONCE_QUEUE_KEY) {\n        // only queue the data if there is not already a set_once call for it.\n        _.each(q_data, function(v, k) {\n            if (!(k in set_once_q)) {\n                set_once_q[k] = v;\n            }\n        });\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === UNSET_QUEUE_KEY) {\n        _.each(q_data, function(prop) {\n\n            // undo previously-queued actions on this key\n            _.each([set_q, set_once_q, add_q, union_q], function(enqueued_obj) {\n                if (prop in enqueued_obj) {\n                    delete enqueued_obj[prop];\n                }\n            });\n            _.each(append_q, function(append_obj) {\n                if (prop in append_obj) {\n                    delete append_obj[prop];\n                }\n            });\n\n            unset_q[prop] = true;\n\n        });\n    } else if (q_key === ADD_QUEUE_KEY) {\n        _.each(q_data, function(v, k) {\n            // If it exists in the set queue, increment\n            // the value\n            if (k in set_q) {\n                set_q[k] += v;\n            } else {\n                // If it doesn't exist, update the add\n                // queue\n                if (!(k in add_q)) {\n                    add_q[k] = 0;\n                }\n                add_q[k] += v;\n            }\n        }, this);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === UNION_QUEUE_KEY) {\n        _.each(q_data, function(v, k) {\n            if (_.isArray(v)) {\n                if (!(k in union_q)) {\n                    union_q[k] = [];\n                }\n                // Prevent duplicate values\n                _.each(v, function(item) {\n                    if (!_.include(union_q[k], item)) {\n                        union_q[k].push(item);\n                    }\n                });\n            }\n        });\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === REMOVE_QUEUE_KEY) {\n        remove_q.push(q_data);\n        this._pop_from_people_queue(APPEND_ACTION, q_data);\n    } else if (q_key === APPEND_QUEUE_KEY) {\n        append_q.push(q_data);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    }\n\n    console$1.log('MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):');\n    console$1.log(data);\n\n    this.save();\n};\n\nMixpanelPersistence.prototype._pop_from_people_queue = function(queue, data) {\n    var q = this['props'][this._get_queue_key(queue)];\n    if (!_.isUndefined(q)) {\n        _.each(data, function(v, k) {\n            if (queue === APPEND_ACTION || queue === REMOVE_ACTION) {\n                // list actions: only remove if both k+v match\n                // e.g. remove should not override append in a case like\n                // append({foo: 'bar'}); remove({foo: 'qux'})\n                _.each(q, function(queued_action) {\n                    if (queued_action[k] === v) {\n                        delete queued_action[k];\n                    }\n                });\n            } else {\n                delete q[k];\n            }\n        }, this);\n    }\n};\n\nMixpanelPersistence.prototype.load_queue = function(queue) {\n    return this.load_prop(this._get_queue_key(queue));\n};\n\nMixpanelPersistence.prototype._get_queue_key = function(queue) {\n    if (queue === SET_ACTION) {\n        return SET_QUEUE_KEY;\n    } else if (queue === SET_ONCE_ACTION) {\n        return SET_ONCE_QUEUE_KEY;\n    } else if (queue === UNSET_ACTION) {\n        return UNSET_QUEUE_KEY;\n    } else if (queue === ADD_ACTION) {\n        return ADD_QUEUE_KEY;\n    } else if (queue === APPEND_ACTION) {\n        return APPEND_QUEUE_KEY;\n    } else if (queue === REMOVE_ACTION) {\n        return REMOVE_QUEUE_KEY;\n    } else if (queue === UNION_ACTION) {\n        return UNION_QUEUE_KEY;\n    } else {\n        console$1.error('Invalid queue:', queue);\n    }\n};\n\nMixpanelPersistence.prototype._get_or_create_queue = function(queue, default_val) {\n    var key = this._get_queue_key(queue);\n    default_val = _.isUndefined(default_val) ? {} : default_val;\n    return this['props'][key] || (this['props'][key] = default_val);\n};\n\nMixpanelPersistence.prototype.set_event_timer = function(event_name, timestamp) {\n    var timers = this.load_prop(EVENT_TIMERS_KEY) || {};\n    timers[event_name] = timestamp;\n    this['props'][EVENT_TIMERS_KEY] = timers;\n    this.save();\n};\n\nMixpanelPersistence.prototype.remove_event_timer = function(event_name) {\n    var timers = this.load_prop(EVENT_TIMERS_KEY) || {};\n    var timestamp = timers[event_name];\n    if (!_.isUndefined(timestamp)) {\n        delete this['props'][EVENT_TIMERS_KEY][event_name];\n        this.save();\n    }\n    return timestamp;\n};\n\n/* eslint camelcase: \"off\" */\n\n/*\n * Mixpanel JS Library\n *\n * Copyright 2012, Mixpanel, Inc. All Rights Reserved\n * http://mixpanel.com/\n *\n * Includes portions of Underscore.js\n * http://documentcloud.github.com/underscore/\n * (c) 2011 Jeremy Ashkenas, DocumentCloud Inc.\n * Released under the MIT License.\n */\n\n/*\nSIMPLE STYLE GUIDE:\n\nthis.x === public function\nthis._x === internal - only use within this file\nthis.__x === private - only use within the class\n\nGlobals should be all caps\n*/\n\nvar init_type;       // MODULE or SNIPPET loader\n// allow bundlers to specify how extra code (recorder bundle) should be loaded\n// eslint-disable-next-line no-unused-vars\nvar load_extra_bundle = function(src, _onload) {\n    throw new Error(src + ' not available in this build.');\n};\n\nvar mixpanel_master; // main mixpanel instance / object\nvar INIT_MODULE  = 0;\nvar INIT_SNIPPET = 1;\n\nvar IDENTITY_FUNC = function(x) {return x;};\n\n/** @const */ var PRIMARY_INSTANCE_NAME = 'mixpanel';\n/** @const */ var PAYLOAD_TYPE_BASE64   = 'base64';\n/** @const */ var PAYLOAD_TYPE_JSON     = 'json';\n/** @const */ var DEVICE_ID_PREFIX      = '$device:';\n\n\n/*\n * Dynamic... constants? Is that an oxymoron?\n */\n// http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\n// https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#withCredentials\nvar USE_XHR = (win.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest());\n\n// IE<10 does not support cross-origin XHR's but script tags\n// with defer won't block window.onload; ENQUEUE_REQUESTS\n// should only be true for Opera<12\nvar ENQUEUE_REQUESTS = !USE_XHR && (userAgent.indexOf('MSIE') === -1) && (userAgent.indexOf('Mozilla') === -1);\n\n// save reference to navigator.sendBeacon so it can be minified\nvar sendBeacon = null;\nif (navigator['sendBeacon']) {\n    sendBeacon = function() {\n        // late reference to navigator.sendBeacon to allow patching/spying\n        return navigator['sendBeacon'].apply(navigator, arguments);\n    };\n}\n\nvar DEFAULT_API_ROUTES = {\n    'track':  'track/',\n    'engage': 'engage/',\n    'groups': 'groups/',\n    'record': 'record/',\n    'flags':  'flags/'\n};\n\n/*\n * Module-level globals\n */\nvar DEFAULT_CONFIG = {\n    'api_host':                          'https://api-js.mixpanel.com',\n    'api_routes':                        DEFAULT_API_ROUTES,\n    'api_extra_query_params':            {},\n    'api_method':                        'POST',\n    'api_transport':                     'XHR',\n    'api_payload_format':                PAYLOAD_TYPE_BASE64,\n    'app_host':                          'https://mixpanel.com',\n    'autocapture':                       false,\n    'cdn':                               'https://cdn.mxpnl.com',\n    'cross_site_cookie':                 false,\n    'cross_subdomain_cookie':            true,\n    'error_reporter':                    NOOP_FUNC,\n    'flags':                             false,\n    'persistence':                       'cookie',\n    'persistence_name':                  '',\n    'cookie_domain':                     '',\n    'cookie_name':                       '',\n    'loaded':                            NOOP_FUNC,\n    'mp_loader':                         null,\n    'track_marketing':                   true,\n    'track_pageview':                    false,\n    'skip_first_touch_marketing':        false,\n    'store_google':                      true,\n    'stop_utm_persistence':              false,\n    'save_referrer':                     true,\n    'test':                              false,\n    'verbose':                           false,\n    'img':                               false,\n    'debug':                             false,\n    'track_links_timeout':               300,\n    'cookie_expiration':                 365,\n    'upgrade':                           false,\n    'disable_persistence':               false,\n    'disable_cookie':                    false,\n    'secure_cookie':                     false,\n    'ip':                                true,\n    'opt_out_tracking_by_default':       false,\n    'opt_out_persistence_by_default':    false,\n    'opt_out_tracking_persistence_type': 'localStorage',\n    'opt_out_tracking_cookie_prefix':    null,\n    'property_blacklist':                [],\n    'xhr_headers':                       {}, // { header: value, header2: value }\n    'ignore_dnt':                        false,\n    'batch_requests':                    true,\n    'batch_size':                        50,\n    'batch_flush_interval_ms':           5000,\n    'batch_request_timeout_ms':          90000,\n    'batch_autostart':                   true,\n    'hooks':                             {},\n    'record_block_class':                new RegExp('^(mp-block|fs-exclude|amp-block|rr-block|ph-no-capture)$'),\n    'record_block_selector':             'img, video',\n    'record_canvas':                     false,\n    'record_collect_fonts':              false,\n    'record_heatmap_data':               false,\n    'record_idle_timeout_ms':            30 * 60 * 1000, // 30 minutes\n    'record_mask_text_class':            new RegExp('^(mp-mask|fs-mask|amp-mask|rr-mask|ph-mask)$'),\n    'record_mask_text_selector':         '*',\n    'record_max_ms':                     MAX_RECORDING_MS,\n    'record_min_ms':                     0,\n    'record_sessions_percent':           0,\n    'recorder_src':                      'https://cdn.mxpnl.com/libs/mixpanel-recorder.min.js'\n};\n\nvar DOM_LOADED = false;\n\n/**\n * Mixpanel Library Object\n * @constructor\n */\nvar MixpanelLib = function() {};\n\n\n/**\n * create_mplib(token:string, config:object, name:string)\n *\n * This function is used by the init method of MixpanelLib objects\n * as well as the main initializer at the end of the JSLib (that\n * initializes document.mixpanel as well as any additional instances\n * declared before this file has loaded).\n */\nvar create_mplib = function(token, config, name) {\n    var instance,\n        target = (name === PRIMARY_INSTANCE_NAME) ? mixpanel_master : mixpanel_master[name];\n\n    if (target && init_type === INIT_MODULE) {\n        instance = target;\n    } else {\n        if (target && !_.isArray(target)) {\n            console$1.error('You have already initialized ' + name);\n            return;\n        }\n        instance = new MixpanelLib();\n    }\n\n    instance._cached_groups = {}; // cache groups in a pool\n\n    instance._init(token, config, name);\n\n    instance['people'] = new MixpanelPeople();\n    instance['people']._init(instance);\n\n    if (!instance.get_config('skip_first_touch_marketing')) {\n        // We need null UTM params in the object because\n        // UTM parameters act as a tuple. If any UTM param\n        // is present, then we set all UTM params including\n        // empty ones together\n        var utm_params = _.info.campaignParams(null);\n        var initial_utm_params = {};\n        var has_utm = false;\n        _.each(utm_params, function(utm_value, utm_key) {\n            initial_utm_params['initial_' + utm_key] = utm_value;\n            if (utm_value) {\n                has_utm = true;\n            }\n        });\n        if (has_utm) {\n            instance['people'].set_once(initial_utm_params);\n        }\n    }\n\n    // if any instance on the page has debug = true, we set the\n    // global debug to be true\n    Config.DEBUG = Config.DEBUG || instance.get_config('debug');\n\n    // if target is not defined, we called init after the lib already\n    // loaded, so there won't be an array of things to execute\n    if (!_.isUndefined(target) && _.isArray(target)) {\n        // Crunch through the people queue first - we queue this data up &\n        // flush on identify, so it's better to do all these operations first\n        instance._execute_array.call(instance['people'], target['people']);\n        instance._execute_array(target);\n    }\n\n    return instance;\n};\n\n// Initialization methods\n\n/**\n * This function initializes a new instance of the Mixpanel tracking object.\n * All new instances are added to the main mixpanel object as sub properties (such as\n * mixpanel.library_name) and also returned by this function. To define a\n * second instance on the page, you would call:\n *\n *     mixpanel.init('new token', { your: 'config' }, 'library_name');\n *\n * and use it like so:\n *\n *     mixpanel.library_name.track(...);\n *\n * @param {String} token   Your Mixpanel API token\n * @param {Object} [config]  A dictionary of config options to override. <a href=\"https://github.com/mixpanel/mixpanel-js/blob/v2.46.0/src/mixpanel-core.js#L88-L127\">See a list of default config options</a>.\n * @param {String} [name]    The name for the new mixpanel instance that you want created\n */\nMixpanelLib.prototype.init = function (token, config, name) {\n    if (_.isUndefined(name)) {\n        this.report_error('You must name your new library: init(token, config, name)');\n        return;\n    }\n    if (name === PRIMARY_INSTANCE_NAME) {\n        this.report_error('You must initialize the main mixpanel object right after you include the Mixpanel js snippet');\n        return;\n    }\n\n    var instance = create_mplib(token, config, name);\n    mixpanel_master[name] = instance;\n    instance._loaded();\n\n    return instance;\n};\n\n// mixpanel._init(token:string, config:object, name:string)\n//\n// This function sets up the current instance of the mixpanel\n// library.  The difference between this method and the init(...)\n// method is this one initializes the actual instance, whereas the\n// init(...) method sets up a new library and calls _init on it.\n//\nMixpanelLib.prototype._init = function(token, config, name) {\n    config = config || {};\n\n    this['__loaded'] = true;\n    this['config'] = {};\n\n    var variable_features = {};\n\n    // default to JSON payload for standard mixpanel.com API hosts\n    if (!('api_payload_format' in config)) {\n        var api_host = config['api_host'] || DEFAULT_CONFIG['api_host'];\n        if (api_host.match(/\\.mixpanel\\.com/)) {\n            variable_features['api_payload_format'] = PAYLOAD_TYPE_JSON;\n        }\n    }\n\n    this.set_config(_.extend({}, DEFAULT_CONFIG, variable_features, config, {\n        'name': name,\n        'token': token,\n        'callback_fn': ((name === PRIMARY_INSTANCE_NAME) ? name : PRIMARY_INSTANCE_NAME + '.' + name) + '._jsc'\n    }));\n\n    this['_jsc'] = NOOP_FUNC;\n\n    this.__dom_loaded_queue = [];\n    this.__request_queue = [];\n    this.__disabled_events = [];\n    this._flags = {\n        'disable_all_events': false,\n        'identify_called': false\n    };\n\n    // set up request queueing/batching\n    this.request_batchers = {};\n    this._batch_requests = this.get_config('batch_requests');\n    if (this._batch_requests) {\n        if (!_.localStorage.is_supported(true) || !USE_XHR) {\n            this._batch_requests = false;\n            console$1.log('Turning off Mixpanel request-queueing; needs XHR and localStorage support');\n            _.each(this.get_batcher_configs(), function(batcher_config) {\n                console$1.log('Clearing batch queue ' + batcher_config.queue_key);\n                _.localStorage.remove(batcher_config.queue_key);\n            });\n        } else {\n            this.init_batchers();\n            if (sendBeacon && win.addEventListener) {\n                // Before page closes or hides (user tabs away etc), attempt to flush any events\n                // queued up via navigator.sendBeacon. Since sendBeacon doesn't report success/failure,\n                // events will not be removed from the persistent store; if the site is loaded again,\n                // the events will be flushed again on startup and deduplicated on the Mixpanel server\n                // side.\n                // There is no reliable way to capture only page close events, so we lean on the\n                // visibilitychange and pagehide events as recommended at\n                // https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event#usage_notes.\n                // These events fire when the user clicks away from the current page/tab, so will occur\n                // more frequently than page unload, but are the only mechanism currently for capturing\n                // this scenario somewhat reliably.\n                var flush_on_unload = _.bind(function() {\n                    if (!this.request_batchers.events.stopped) {\n                        this.request_batchers.events.flush({unloading: true});\n                    }\n                }, this);\n                win.addEventListener('pagehide', function(ev) {\n                    if (ev['persisted']) {\n                        flush_on_unload();\n                    }\n                });\n                win.addEventListener('visibilitychange', function() {\n                    if (document$1['visibilityState'] === 'hidden') {\n                        flush_on_unload();\n                    }\n                });\n            }\n        }\n    }\n\n    this['persistence'] = this['cookie'] = new MixpanelPersistence(this['config']);\n    this.unpersisted_superprops = {};\n    this._gdpr_init();\n\n    var uuid = _.UUID();\n    if (!this.get_distinct_id()) {\n        // There is no need to set the distinct id\n        // or the device id if something was already stored\n        // in the persitence\n        this.register_once({\n            'distinct_id': DEVICE_ID_PREFIX + uuid,\n            '$device_id': uuid\n        }, '');\n    }\n\n    this.flags = new FeatureFlagManager({\n        getConfigFunc: _.bind(this.get_config, this),\n        getDistinctIdFunc: _.bind(this.get_distinct_id, this),\n        trackingFunc: _.bind(this.track, this)\n    });\n    this.flags.init();\n    this['flags'] = this.flags;\n\n    this.autocapture = new Autocapture(this);\n    this.autocapture.init();\n\n    this._init_tab_id();\n    this._check_and_start_session_recording();\n};\n\n/**\n * Assigns a unique UUID to this tab / window by leveraging sessionStorage.\n * This is primarily used for session recording, where data must be isolated to the current tab.\n */\nMixpanelLib.prototype._init_tab_id = function() {\n    if (_.sessionStorage.is_supported()) {\n        try {\n            var key_suffix = this.get_config('name') + '_' + this.get_config('token');\n            var tab_id_key = 'mp_tab_id_' + key_suffix;\n\n            // A flag is used to determine if sessionStorage is copied over and we need to generate a new tab ID.\n            // This enforces a unique ID in the cases like duplicated tab, window.open(...)\n            var should_generate_new_tab_id_key = 'mp_gen_new_tab_id_' + key_suffix;\n            if (_.sessionStorage.get(should_generate_new_tab_id_key) || !_.sessionStorage.get(tab_id_key)) {\n                _.sessionStorage.set(tab_id_key, '$tab-' + _.UUID());\n            }\n\n            _.sessionStorage.set(should_generate_new_tab_id_key, '1');\n            this.tab_id = _.sessionStorage.get(tab_id_key);\n\n            // Remove the flag when the tab is unloaded to indicate the stored tab ID can be reused. This event is not reliable to detect all page unloads,\n            // but reliable in cases where the user remains in the tab e.g. a refresh or href navigation.\n            // If the flag is absent, this indicates to the next SDK instance that we can reuse the stored tab_id.\n            win.addEventListener('beforeunload', function () {\n                _.sessionStorage.remove(should_generate_new_tab_id_key);\n            });\n        } catch(err) {\n            this.report_error('Error initializing tab id', err);\n        }\n    } else {\n        this.report_error('Session storage is not supported, cannot keep track of unique tab ID.');\n    }\n};\n\nMixpanelLib.prototype.get_tab_id = function () {\n    return this.tab_id || null;\n};\n\nMixpanelLib.prototype._should_load_recorder = function () {\n    var recording_registry_idb = new IDBStorageWrapper(RECORDING_REGISTRY_STORE_NAME);\n    var tab_id = this.get_tab_id();\n    return recording_registry_idb.init()\n        .then(function () {\n            return recording_registry_idb.getAll();\n        })\n        .then(function (recordings) {\n            for (var i = 0; i < recordings.length; i++) {\n                // if there are expired recordings in the registry, we should load the recorder to flush them\n                // if there's a recording for this tab id, we should load the recorder to continue the recording\n                if (isRecordingExpired(recordings[i]) || recordings[i]['tabId'] === tab_id) {\n                    return true;\n                }\n            }\n            return false;\n        })\n        .catch(_.bind(function (err) {\n            this.report_error('Error checking recording registry', err);\n        }, this));\n};\n\nMixpanelLib.prototype._check_and_start_session_recording = addOptOutCheckMixpanelLib(function(force_start) {\n    if (!win['MutationObserver']) {\n        console$1.critical('Browser does not support MutationObserver; skipping session recording');\n        return;\n    }\n\n    var loadRecorder = _.bind(function(startNewIfInactive) {\n        var handleLoadedRecorder = _.bind(function() {\n            this._recorder = this._recorder || new win['__mp_recorder'](this);\n            this._recorder['resumeRecording'](startNewIfInactive);\n        }, this);\n\n        if (_.isUndefined(win['__mp_recorder'])) {\n            load_extra_bundle(this.get_config('recorder_src'), handleLoadedRecorder);\n        } else {\n            handleLoadedRecorder();\n        }\n    }, this);\n\n    /**\n     * If the user is sampled or start_session_recording is called, we always load the recorder since it's guaranteed a recording should start.\n     * Otherwise, if the recording registry has any records then it's likely there's a recording in progress or orphaned data that needs to be flushed.\n     */\n    var is_sampled = this.get_config('record_sessions_percent') > 0 && Math.random() * 100 <= this.get_config('record_sessions_percent');\n    if (force_start || is_sampled) {\n        loadRecorder(true);\n    } else {\n        this._should_load_recorder()\n            .then(function (shouldLoad) {\n                if (shouldLoad) {\n                    loadRecorder(false);\n                }\n            });\n    }\n});\n\nMixpanelLib.prototype.start_session_recording = function () {\n    this._check_and_start_session_recording(true);\n};\n\nMixpanelLib.prototype.stop_session_recording = function () {\n    if (this._recorder) {\n        this._recorder['stopRecording']();\n    }\n};\n\nMixpanelLib.prototype.pause_session_recording = function () {\n    if (this._recorder) {\n        this._recorder['pauseRecording']();\n    }\n};\n\nMixpanelLib.prototype.resume_session_recording = function () {\n    if (this._recorder) {\n        this._recorder['resumeRecording']();\n    }\n};\n\nMixpanelLib.prototype.is_recording_heatmap_data = function () {\n    return this._get_session_replay_id() && this.get_config('record_heatmap_data');\n};\n\nMixpanelLib.prototype.get_session_recording_properties = function () {\n    var props = {};\n    var replay_id = this._get_session_replay_id();\n    if (replay_id) {\n        props['$mp_replay_id'] = replay_id;\n    }\n    return props;\n};\n\nMixpanelLib.prototype.get_session_replay_url = function () {\n    var replay_url = null;\n    var replay_id = this._get_session_replay_id();\n    if (replay_id) {\n        var query_params = _.HTTPBuildQuery({\n            'replay_id': replay_id,\n            'distinct_id': this.get_distinct_id(),\n            'token': this.get_config('token')\n        });\n        replay_url = 'https://mixpanel.com/projects/replay-redirect?' + query_params;\n    }\n    return replay_url;\n};\n\nMixpanelLib.prototype._get_session_replay_id = function () {\n    var replay_id = null;\n    if (this._recorder) {\n        replay_id = this._recorder['replayId'];\n    }\n    return replay_id || null;\n};\n\n// \"private\" public method to reach into the recorder in test cases\nMixpanelLib.prototype.__get_recorder = function () {\n    return this._recorder;\n};\n\n// Private methods\n\nMixpanelLib.prototype._loaded = function() {\n    this.get_config('loaded')(this);\n    this._set_default_superprops();\n    this['people'].set_once(this['persistence'].get_referrer_info());\n\n    // `store_google` is now deprecated and previously stored UTM parameters are cleared\n    // from persistence by default.\n    if (this.get_config('store_google') && this.get_config('stop_utm_persistence')) {\n        var utm_params = _.info.campaignParams(null);\n        _.each(utm_params, function(_utm_value, utm_key) {\n            // We need to unregister persisted UTM parameters so old values\n            // are not mixed with the new UTM parameters\n            this.unregister(utm_key);\n        }.bind(this));\n    }\n};\n\n// update persistence with info on referrer, UTM params, etc\nMixpanelLib.prototype._set_default_superprops = function() {\n    this['persistence'].update_search_keyword(document$1.referrer);\n    // Registering super properties for UTM persistence by 'store_google' is deprecated.\n    if (this.get_config('store_google') && !this.get_config('stop_utm_persistence')) {\n        this.register(_.info.campaignParams());\n    }\n    if (this.get_config('save_referrer')) {\n        this['persistence'].update_referrer_info(document$1.referrer);\n    }\n};\n\nMixpanelLib.prototype._dom_loaded = function() {\n    _.each(this.__dom_loaded_queue, function(item) {\n        this._track_dom.apply(this, item);\n    }, this);\n\n    if (!this.has_opted_out_tracking()) {\n        _.each(this.__request_queue, function(item) {\n            this._send_request.apply(this, item);\n        }, this);\n    }\n\n    delete this.__dom_loaded_queue;\n    delete this.__request_queue;\n};\n\nMixpanelLib.prototype._track_dom = function(DomClass, args) {\n    if (this.get_config('img')) {\n        this.report_error('You can\\'t use DOM tracking functions with img = true.');\n        return false;\n    }\n\n    if (!DOM_LOADED) {\n        this.__dom_loaded_queue.push([DomClass, args]);\n        return false;\n    }\n\n    var dt = new DomClass().init(this);\n    return dt.track.apply(dt, args);\n};\n\n/**\n * _prepare_callback() should be called by callers of _send_request for use\n * as the callback argument.\n *\n * If there is no callback, this returns null.\n * If we are going to make XHR/XDR requests, this returns a function.\n * If we are going to use script tags, this returns a string to use as the\n * callback GET param.\n */\nMixpanelLib.prototype._prepare_callback = function(callback, data) {\n    if (_.isUndefined(callback)) {\n        return null;\n    }\n\n    if (USE_XHR) {\n        var callback_function = function(response) {\n            callback(response, data);\n        };\n        return callback_function;\n    } else {\n        // if the user gives us a callback, we store as a random\n        // property on this instances jsc function and update our\n        // callback string to reflect that.\n        var jsc = this['_jsc'];\n        var randomized_cb = '' + Math.floor(Math.random() * 100000000);\n        var callback_string = this.get_config('callback_fn') + '[' + randomized_cb + ']';\n        jsc[randomized_cb] = function(response) {\n            delete jsc[randomized_cb];\n            callback(response, data);\n        };\n        return callback_string;\n    }\n};\n\nMixpanelLib.prototype._send_request = function(url, data, options, callback) {\n    var succeeded = true;\n\n    if (ENQUEUE_REQUESTS) {\n        this.__request_queue.push(arguments);\n        return succeeded;\n    }\n\n    var DEFAULT_OPTIONS = {\n        method: this.get_config('api_method'),\n        transport: this.get_config('api_transport'),\n        verbose: this.get_config('verbose')\n    };\n    var body_data = null;\n\n    if (!callback && (_.isFunction(options) || typeof options === 'string')) {\n        callback = options;\n        options = null;\n    }\n    options = _.extend(DEFAULT_OPTIONS, options || {});\n    if (!USE_XHR) {\n        options.method = 'GET';\n    }\n    var use_post = options.method === 'POST';\n    var use_sendBeacon = sendBeacon && use_post && options.transport.toLowerCase() === 'sendbeacon';\n\n    // needed to correctly format responses\n    var verbose_mode = options.verbose;\n    if (data['verbose']) { verbose_mode = true; }\n\n    if (this.get_config('test')) { data['test'] = 1; }\n    if (verbose_mode) { data['verbose'] = 1; }\n    if (this.get_config('img')) { data['img'] = 1; }\n    if (!USE_XHR) {\n        if (callback) {\n            data['callback'] = callback;\n        } else if (verbose_mode || this.get_config('test')) {\n            // Verbose output (from verbose mode, or an error in test mode) is a json blob,\n            // which by itself is not valid javascript. Without a callback, this verbose output will\n            // cause an error when returned via jsonp, so we force a no-op callback param.\n            // See the ECMA script spec: http://www.ecma-international.org/ecma-262/5.1/#sec-12.4\n            data['callback'] = '(function(){})';\n        }\n    }\n\n    data['ip'] = this.get_config('ip')?1:0;\n    data['_'] = new Date().getTime().toString();\n\n    if (use_post) {\n        body_data = 'data=' + encodeURIComponent(data['data']);\n        delete data['data'];\n    }\n\n    _.extend(data, this.get_config('api_extra_query_params'));\n\n    url += '?' + _.HTTPBuildQuery(data);\n\n    var lib = this;\n    if ('img' in data) {\n        var img = document$1.createElement('img');\n        img.src = url;\n        document$1.body.appendChild(img);\n    } else if (use_sendBeacon) {\n        try {\n            succeeded = sendBeacon(url, body_data);\n        } catch (e) {\n            lib.report_error(e);\n            succeeded = false;\n        }\n        try {\n            if (callback) {\n                callback(succeeded ? 1 : 0);\n            }\n        } catch (e) {\n            lib.report_error(e);\n        }\n    } else if (USE_XHR) {\n        try {\n            var req = new XMLHttpRequest();\n            req.open(options.method, url, true);\n\n            var headers = this.get_config('xhr_headers');\n            if (use_post) {\n                headers['Content-Type'] = 'application/x-www-form-urlencoded';\n            }\n            _.each(headers, function(headerValue, headerName) {\n                req.setRequestHeader(headerName, headerValue);\n            });\n\n            if (options.timeout_ms && typeof req.timeout !== 'undefined') {\n                req.timeout = options.timeout_ms;\n                var start_time = new Date().getTime();\n            }\n\n            // send the mp_optout cookie\n            // withCredentials cannot be modified until after calling .open on Android and Mobile Safari\n            req.withCredentials = true;\n            req.onreadystatechange = function () {\n                if (req.readyState === 4) { // XMLHttpRequest.DONE == 4, except in safari 4\n                    if (req.status === 200) {\n                        if (callback) {\n                            if (verbose_mode) {\n                                var response;\n                                try {\n                                    response = _.JSONDecode(req.responseText);\n                                } catch (e) {\n                                    lib.report_error(e);\n                                    if (options.ignore_json_errors) {\n                                        response = req.responseText;\n                                    } else {\n                                        return;\n                                    }\n                                }\n                                callback(response);\n                            } else {\n                                callback(Number(req.responseText));\n                            }\n                        }\n                    } else {\n                        var error;\n                        if (\n                            req.timeout &&\n                            !req.status &&\n                            new Date().getTime() - start_time >= req.timeout\n                        ) {\n                            error = 'timeout';\n                        } else {\n                            error = 'Bad HTTP status: ' + req.status + ' ' + req.statusText;\n                        }\n                        lib.report_error(error);\n                        if (callback) {\n                            if (verbose_mode) {\n                                var response_headers = req['responseHeaders'] || {};\n                                callback({status: 0, httpStatusCode: req['status'], error: error, retryAfter: response_headers['Retry-After']});\n                            } else {\n                                callback(0);\n                            }\n                        }\n                    }\n                }\n            };\n            req.send(body_data);\n        } catch (e) {\n            lib.report_error(e);\n            succeeded = false;\n        }\n    } else {\n        var script = document$1.createElement('script');\n        script.type = 'text/javascript';\n        script.async = true;\n        script.defer = true;\n        script.src = url;\n        var s = document$1.getElementsByTagName('script')[0];\n        s.parentNode.insertBefore(script, s);\n    }\n\n    return succeeded;\n};\n\n/**\n * _execute_array() deals with processing any mixpanel function\n * calls that were called before the Mixpanel library were loaded\n * (and are thus stored in an array so they can be called later)\n *\n * Note: we fire off all the mixpanel function calls && user defined\n * functions BEFORE we fire off mixpanel tracking calls. This is so\n * identify/register/set_config calls can properly modify early\n * tracking calls.\n *\n * @param {Array} array\n */\nMixpanelLib.prototype._execute_array = function(array) {\n    var fn_name, alias_calls = [], other_calls = [], tracking_calls = [];\n    _.each(array, function(item) {\n        if (item) {\n            fn_name = item[0];\n            if (_.isArray(fn_name)) {\n                tracking_calls.push(item); // chained call e.g. mixpanel.get_group().set()\n            } else if (typeof(item) === 'function') {\n                item.call(this);\n            } else if (_.isArray(item) && fn_name === 'alias') {\n                alias_calls.push(item);\n            } else if (_.isArray(item) && fn_name.indexOf('track') !== -1 && typeof(this[fn_name]) === 'function') {\n                tracking_calls.push(item);\n            } else {\n                other_calls.push(item);\n            }\n        }\n    }, this);\n\n    var execute = function(calls, context) {\n        _.each(calls, function(item) {\n            if (_.isArray(item[0])) {\n                // chained call\n                var caller = context;\n                _.each(item, function(call) {\n                    caller = caller[call[0]].apply(caller, call.slice(1));\n                });\n            } else {\n                this[item[0]].apply(this, item.slice(1));\n            }\n        }, context);\n    };\n\n    execute(alias_calls, this);\n    execute(other_calls, this);\n    execute(tracking_calls, this);\n};\n\n// request queueing utils\n\nMixpanelLib.prototype.are_batchers_initialized = function() {\n    return !!this.request_batchers.events;\n};\n\nMixpanelLib.prototype.get_batcher_configs = function() {\n    var queue_prefix = '__mpq_' + this.get_config('token');\n    var api_routes = this.get_config('api_routes');\n    this._batcher_configs = this._batcher_configs || {\n        events: {type: 'events', endpoint: '/' + api_routes['track'], queue_key: queue_prefix + '_ev'},\n        people: {type: 'people', endpoint: '/' + api_routes['engage'], queue_key: queue_prefix + '_pp'},\n        groups: {type: 'groups', endpoint: '/' + api_routes['groups'], queue_key: queue_prefix + '_gr'}\n    };\n    return this._batcher_configs;\n};\n\nMixpanelLib.prototype.init_batchers = function() {\n    if (!this.are_batchers_initialized()) {\n        var batcher_for = _.bind(function(attrs) {\n            return new RequestBatcher(\n                attrs.queue_key,\n                {\n                    libConfig: this['config'],\n                    errorReporter: this.get_config('error_reporter'),\n                    sendRequestFunc: _.bind(function(data, options, cb) {\n                        this._send_request(\n                            this.get_config('api_host') + attrs.endpoint,\n                            this._encode_data_for_request(data),\n                            options,\n                            this._prepare_callback(cb, data)\n                        );\n                    }, this),\n                    beforeSendHook: _.bind(function(item) {\n                        return this._run_hook('before_send_' + attrs.type, item);\n                    }, this),\n                    stopAllBatchingFunc: _.bind(this.stop_batch_senders, this),\n                    usePersistence: true,\n                }\n            );\n        }, this);\n        var batcher_configs = this.get_batcher_configs();\n        this.request_batchers = {\n            events: batcher_for(batcher_configs.events),\n            people: batcher_for(batcher_configs.people),\n            groups: batcher_for(batcher_configs.groups)\n        };\n    }\n    if (this.get_config('batch_autostart')) {\n        this.start_batch_senders();\n    }\n};\n\nMixpanelLib.prototype.start_batch_senders = function() {\n    this._batchers_were_started = true;\n    if (this.are_batchers_initialized()) {\n        this._batch_requests = true;\n        _.each(this.request_batchers, function(batcher) {\n            batcher.start();\n        });\n    }\n};\n\nMixpanelLib.prototype.stop_batch_senders = function() {\n    this._batch_requests = false;\n    _.each(this.request_batchers, function(batcher) {\n        batcher.stop();\n        batcher.clear();\n    });\n};\n\n/**\n * push() keeps the standard async-array-push\n * behavior around after the lib is loaded.\n * This is only useful for external integrations that\n * do not wish to rely on our convenience methods\n * (created in the snippet).\n *\n * ### Usage:\n *     mixpanel.push(['register', { a: 'b' }]);\n *\n * @param {Array} item A [function_name, args...] array to be executed\n */\nMixpanelLib.prototype.push = function(item) {\n    this._execute_array([item]);\n};\n\n/**\n * Disable events on the Mixpanel object. If passed no arguments,\n * this function disables tracking of any event. If passed an\n * array of event names, those events will be disabled, but other\n * events will continue to be tracked.\n *\n * Note: this function does not stop other mixpanel functions from\n * firing, such as register() or people.set().\n *\n * @param {Array} [events] An array of event names to disable\n */\nMixpanelLib.prototype.disable = function(events) {\n    if (typeof(events) === 'undefined') {\n        this._flags.disable_all_events = true;\n    } else {\n        this.__disabled_events = this.__disabled_events.concat(events);\n    }\n};\n\nMixpanelLib.prototype._encode_data_for_request = function(data) {\n    var encoded_data = JSONStringify(data);\n    if (this.get_config('api_payload_format') === PAYLOAD_TYPE_BASE64) {\n        encoded_data = _.base64Encode(encoded_data);\n    }\n    return {'data': encoded_data};\n};\n\n// internal method for handling track vs batch-enqueue logic\nMixpanelLib.prototype._track_or_batch = function(options, callback) {\n    var truncated_data = _.truncate(options.data, 255);\n    var endpoint = options.endpoint;\n    var batcher = options.batcher;\n    var should_send_immediately = options.should_send_immediately;\n    var send_request_options = options.send_request_options || {};\n    callback = callback || NOOP_FUNC;\n\n    var request_enqueued_or_initiated = true;\n    var send_request_immediately = _.bind(function() {\n        if (!send_request_options.skip_hooks) {\n            truncated_data = this._run_hook('before_send_' + options.type, truncated_data);\n        }\n        if (truncated_data) {\n            console$1.log('MIXPANEL REQUEST:');\n            console$1.log(truncated_data);\n            return this._send_request(\n                endpoint,\n                this._encode_data_for_request(truncated_data),\n                send_request_options,\n                this._prepare_callback(callback, truncated_data)\n            );\n        } else {\n            return null;\n        }\n    }, this);\n\n    if (this._batch_requests && !should_send_immediately) {\n        batcher.enqueue(truncated_data).then(function(succeeded) {\n            if (succeeded) {\n                callback(1, truncated_data);\n            } else {\n                send_request_immediately();\n            }\n        });\n    } else {\n        request_enqueued_or_initiated = send_request_immediately();\n    }\n\n    return request_enqueued_or_initiated && truncated_data;\n};\n\n/**\n * Track an event. This is the most important and\n * frequently used Mixpanel function.\n *\n * ### Usage:\n *\n *     // track an event named 'Registered'\n *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});\n *\n *     // track an event using navigator.sendBeacon\n *     mixpanel.track('Left page', {'duration_seconds': 35}, {transport: 'sendBeacon'});\n *\n * To track link clicks or form submissions, see track_links() or track_forms().\n *\n * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.\n * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.\n * @param {Object} [options] Optional configuration for this track request.\n * @param {String} [options.transport] Transport method for network request ('xhr' or 'sendBeacon').\n * @param {Boolean} [options.send_immediately] Whether to bypass batching/queueing and send track request immediately.\n * @param {Function} [callback] If provided, the callback function will be called after tracking the event.\n * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object\n * with the tracking payload sent to the API server is returned; otherwise false.\n */\nMixpanelLib.prototype.track = addOptOutCheckMixpanelLib(function(event_name, properties, options, callback) {\n    if (!callback && typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n    options = options || {};\n    var transport = options['transport']; // external API, don't minify 'transport' prop\n    if (transport) {\n        options.transport = transport; // 'transport' prop name can be minified internally\n    }\n    var should_send_immediately = options['send_immediately'];\n    if (typeof callback !== 'function') {\n        callback = NOOP_FUNC;\n    }\n\n    if (_.isUndefined(event_name)) {\n        this.report_error('No event name provided to mixpanel.track');\n        return;\n    }\n\n    if (this._event_is_disabled(event_name)) {\n        callback(0);\n        return;\n    }\n\n    // set defaults\n    properties = _.extend({}, properties);\n    properties['token'] = this.get_config('token');\n\n    // set $duration if time_event was previously called for this event\n    var start_timestamp = this['persistence'].remove_event_timer(event_name);\n    if (!_.isUndefined(start_timestamp)) {\n        var duration_in_ms = new Date().getTime() - start_timestamp;\n        properties['$duration'] = parseFloat((duration_in_ms / 1000).toFixed(3));\n    }\n\n    this._set_default_superprops();\n\n    var marketing_properties = this.get_config('track_marketing')\n        ? _.info.marketingParams()\n        : {};\n\n    // note: extend writes to the first object, so lets make sure we\n    // don't write to the persistence properties object and info\n    // properties object by passing in a new object\n\n    // update properties with pageview info and super-properties\n    properties = _.extend(\n        {},\n        _.info.properties({'mp_loader': this.get_config('mp_loader')}),\n        marketing_properties,\n        this['persistence'].properties(),\n        this.unpersisted_superprops,\n        this.get_session_recording_properties(),\n        properties\n    );\n\n    var property_blacklist = this.get_config('property_blacklist');\n    if (_.isArray(property_blacklist)) {\n        _.each(property_blacklist, function(blacklisted_prop) {\n            delete properties[blacklisted_prop];\n        });\n    } else {\n        this.report_error('Invalid value for property_blacklist config: ' + property_blacklist);\n    }\n\n    var data = {\n        'event': event_name,\n        'properties': properties\n    };\n    var ret = this._track_or_batch({\n        type: 'events',\n        data: data,\n        endpoint: this.get_config('api_host') + '/' + this.get_config('api_routes')['track'],\n        batcher: this.request_batchers.events,\n        should_send_immediately: should_send_immediately,\n        send_request_options: options\n    }, callback);\n\n    return ret;\n});\n\n/**\n * Register the current user into one/many groups.\n *\n * ### Usage:\n *\n *      mixpanel.set_group('company', ['mixpanel', 'google']) // an array of IDs\n *      mixpanel.set_group('company', 'mixpanel')\n *      mixpanel.set_group('company', 128746312)\n *\n * @param {String} group_key Group key\n * @param {Array|String|Number} group_ids An array of group IDs, or a singular group ID\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n *\n */\nMixpanelLib.prototype.set_group = addOptOutCheckMixpanelLib(function(group_key, group_ids, callback) {\n    if (!_.isArray(group_ids)) {\n        group_ids = [group_ids];\n    }\n    var prop = {};\n    prop[group_key] = group_ids;\n    this.register(prop);\n    return this['people'].set(group_key, group_ids, callback);\n});\n\n/**\n * Add a new group for this user.\n *\n * ### Usage:\n *\n *      mixpanel.add_group('company', 'mixpanel')\n *\n * @param {String} group_key Group key\n * @param {*} group_id A valid Mixpanel property type\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.add_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {\n    var old_values = this.get_property(group_key);\n    var prop = {};\n    if (old_values === undefined) {\n        prop[group_key] = [group_id];\n        this.register(prop);\n    } else {\n        if (old_values.indexOf(group_id) === -1) {\n            old_values.push(group_id);\n            prop[group_key] = old_values;\n            this.register(prop);\n        }\n    }\n    return this['people'].union(group_key, group_id, callback);\n});\n\n/**\n * Remove a group from this user.\n *\n * ### Usage:\n *\n *      mixpanel.remove_group('company', 'mixpanel')\n *\n * @param {String} group_key Group key\n * @param {*} group_id A valid Mixpanel property type\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.remove_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {\n    var old_value = this.get_property(group_key);\n    // if the value doesn't exist, the persistent store is unchanged\n    if (old_value !== undefined) {\n        var idx = old_value.indexOf(group_id);\n        if (idx > -1) {\n            old_value.splice(idx, 1);\n            this.register({group_key: old_value});\n        }\n        if (old_value.length === 0) {\n            this.unregister(group_key);\n        }\n    }\n    return this['people'].remove(group_key, group_id, callback);\n});\n\n/**\n * Track an event with specific groups.\n *\n * ### Usage:\n *\n *      mixpanel.track_with_groups('purchase', {'product': 'iphone'}, {'University': ['UCB', 'UCLA']})\n *\n * @param {String} event_name The name of the event (see `mixpanel.track()`)\n * @param {Object=} properties A set of properties to include with the event you're sending (see `mixpanel.track()`)\n * @param {Object=} groups An object mapping group name keys to one or more values\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.track_with_groups = addOptOutCheckMixpanelLib(function(event_name, properties, groups, callback) {\n    var tracking_props = _.extend({}, properties || {});\n    _.each(groups, function(v, k) {\n        if (v !== null && v !== undefined) {\n            tracking_props[k] = v;\n        }\n    });\n    return this.track(event_name, tracking_props, callback);\n});\n\nMixpanelLib.prototype._create_map_key = function (group_key, group_id) {\n    return group_key + '_' + JSON.stringify(group_id);\n};\n\nMixpanelLib.prototype._remove_group_from_cache = function (group_key, group_id) {\n    delete this._cached_groups[this._create_map_key(group_key, group_id)];\n};\n\n/**\n * Look up reference to a Mixpanel group\n *\n * ### Usage:\n *\n *       mixpanel.get_group(group_key, group_id)\n *\n * @param {String} group_key Group key\n * @param {Object} group_id A valid Mixpanel property type\n * @returns {Object} A MixpanelGroup identifier\n */\nMixpanelLib.prototype.get_group = function (group_key, group_id) {\n    var map_key = this._create_map_key(group_key, group_id);\n    var group = this._cached_groups[map_key];\n    if (group === undefined || group._group_key !== group_key || group._group_id !== group_id) {\n        group = new MixpanelGroup();\n        group._init(this, group_key, group_id);\n        this._cached_groups[map_key] = group;\n    }\n    return group;\n};\n\n/**\n * Track a default Mixpanel page view event, which includes extra default event properties to\n * improve page view data.\n *\n * ### Usage:\n *\n *     // track a default $mp_web_page_view event\n *     mixpanel.track_pageview();\n *\n *     // track a page view event with additional event properties\n *     mixpanel.track_pageview({'ab_test_variant': 'card-layout-b'});\n *\n *     // example approach to track page views on different page types as event properties\n *     mixpanel.track_pageview({'page': 'pricing'});\n *     mixpanel.track_pageview({'page': 'homepage'});\n *\n *     // UNCOMMON: Tracking a page view event with a custom event_name option. NOT expected to be used for\n *     // individual pages on the same site or product. Use cases for custom event_name may be page\n *     // views on different products or internal applications that are considered completely separate\n *     mixpanel.track_pageview({'page': 'customer-search'}, {'event_name': '[internal] Admin Page View'});\n *\n * ### Notes:\n *\n * The `config.track_pageview` option for <a href=\"#mixpanelinit\">mixpanel.init()</a>\n * may be turned on for tracking page loads automatically.\n *\n *     // track only page loads\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: true});\n *\n *     // track when the URL changes in any manner\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'full-url'});\n *\n *     // track when the URL changes, ignoring any changes in the hash part\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'url-with-path-and-query-string'});\n *\n *     // track when the path changes, ignoring any query parameter or hash changes\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'url-with-path'});\n *\n * @param {Object} [properties] An optional set of additional properties to send with the page view event\n * @param {Object} [options] Page view tracking options\n * @param {String} [options.event_name] - Alternate name for the tracking event\n * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object\n * with the tracking payload sent to the API server is returned; otherwise false.\n */\nMixpanelLib.prototype.track_pageview = addOptOutCheckMixpanelLib(function(properties, options) {\n    if (typeof properties !== 'object') {\n        properties = {};\n    }\n    options = options || {};\n    var event_name = options['event_name'] || '$mp_web_page_view';\n\n    var default_page_properties = _.extend(\n        _.info.mpPageViewProperties(),\n        _.info.campaignParams(),\n        _.info.clickParams()\n    );\n\n    var event_properties = _.extend(\n        {},\n        default_page_properties,\n        properties\n    );\n\n    return this.track(event_name, event_properties);\n});\n\n/**\n * Track clicks on a set of document elements. Selector must be a\n * valid query. Elements must exist on the page at the time track_links is called.\n *\n * ### Usage:\n *\n *     // track click for link id #nav\n *     mixpanel.track_links('#nav', 'Clicked Nav Link');\n *\n * ### Notes:\n *\n * This function will wait up to 300 ms for the Mixpanel\n * servers to respond. If they have not responded by that time\n * it will head to the link without ensuring that your event\n * has been tracked.  To configure this timeout please see the\n * set_config() documentation below.\n *\n * If you pass a function in as the properties argument, the\n * function will receive the DOMElement that triggered the\n * event as an argument.  You are expected to return an object\n * from the function; any properties defined on this object\n * will be sent to mixpanel as event properties.\n *\n * @type {Function}\n * @param {Object|String} query A valid DOM query, element or jQuery-esque list\n * @param {String} event_name The name of the event to track\n * @param {Object|Function} [properties] A properties object or function that returns a dictionary of properties when passed a DOMElement\n */\nMixpanelLib.prototype.track_links = function() {\n    return this._track_dom.call(this, LinkTracker, arguments);\n};\n\n/**\n * Track form submissions. Selector must be a valid query.\n *\n * ### Usage:\n *\n *     // track submission for form id 'register'\n *     mixpanel.track_forms('#register', 'Created Account');\n *\n * ### Notes:\n *\n * This function will wait up to 300 ms for the mixpanel\n * servers to respond, if they have not responded by that time\n * it will head to the link without ensuring that your event\n * has been tracked.  To configure this timeout please see the\n * set_config() documentation below.\n *\n * If you pass a function in as the properties argument, the\n * function will receive the DOMElement that triggered the\n * event as an argument.  You are expected to return an object\n * from the function; any properties defined on this object\n * will be sent to mixpanel as event properties.\n *\n * @type {Function}\n * @param {Object|String} query A valid DOM query, element or jQuery-esque list\n * @param {String} event_name The name of the event to track\n * @param {Object|Function} [properties] This can be a set of properties, or a function that returns a set of properties after being passed a DOMElement\n */\nMixpanelLib.prototype.track_forms = function() {\n    return this._track_dom.call(this, FormTracker, arguments);\n};\n\n/**\n * Time an event by including the time between this call and a\n * later 'track' call for the same event in the properties sent\n * with the event.\n *\n * ### Usage:\n *\n *     // time an event named 'Registered'\n *     mixpanel.time_event('Registered');\n *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});\n *\n * When called for a particular event name, the next track call for that event\n * name will include the elapsed time between the 'time_event' and 'track'\n * calls. This value is stored as seconds in the '$duration' property.\n *\n * @param {String} event_name The name of the event.\n */\nMixpanelLib.prototype.time_event = function(event_name) {\n    if (_.isUndefined(event_name)) {\n        this.report_error('No event name provided to mixpanel.time_event');\n        return;\n    }\n\n    if (this._event_is_disabled(event_name)) {\n        return;\n    }\n\n    this['persistence'].set_event_timer(event_name,  new Date().getTime());\n};\n\nvar REGISTER_DEFAULTS = {\n    'persistent': true\n};\n/**\n * Helper to parse options param for register methods, maintaining\n * legacy support for plain \"days\" param instead of options object\n * @param {Number|Object} [days_or_options] 'days' option (Number), or Options object for register methods\n * @returns {Object} options object\n */\nvar options_for_register = function(days_or_options) {\n    var options;\n    if (_.isObject(days_or_options)) {\n        options = days_or_options;\n    } else if (!_.isUndefined(days_or_options)) {\n        options = {'days': days_or_options};\n    } else {\n        options = {};\n    }\n    return _.extend({}, REGISTER_DEFAULTS, options);\n};\n\n/**\n * Register a set of super properties, which are included with all\n * events. This will overwrite previous super property values.\n *\n * ### Usage:\n *\n *     // register 'Gender' as a super property\n *     mixpanel.register({'Gender': 'Female'});\n *\n *     // register several super properties when a user signs up\n *     mixpanel.register({\n *         'Email': 'jdoe@example.com',\n *         'Account Type': 'Free'\n *     });\n *\n *     // register only for the current pageload\n *     mixpanel.register({'Name': 'Pat'}, {persistent: false});\n *\n * @param {Object} properties An associative array of properties to store about the user\n * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.register = function(props, days_or_options) {\n    var options = options_for_register(days_or_options);\n    if (options['persistent']) {\n        this['persistence'].register(props, options['days']);\n    } else {\n        _.extend(this.unpersisted_superprops, props);\n    }\n};\n\n/**\n * Register a set of super properties only once. This will not\n * overwrite previous super property values, unlike register().\n *\n * ### Usage:\n *\n *     // register a super property for the first time only\n *     mixpanel.register_once({\n *         'First Login Date': new Date().toISOString()\n *     });\n *\n *     // register once, only for the current pageload\n *     mixpanel.register_once({\n *         'First interaction time': new Date().toISOString()\n *     }, 'None', {persistent: false});\n *\n * ### Notes:\n *\n * If default_value is specified, current super properties\n * with that value will be overwritten.\n *\n * @param {Object} properties An associative array of properties to store about the user\n * @param {*} [default_value] Value to override if already set in super properties (ex: 'False') Default: 'None'\n * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.register_once = function(props, default_value, days_or_options) {\n    var options = options_for_register(days_or_options);\n    if (options['persistent']) {\n        this['persistence'].register_once(props, default_value, options['days']);\n    } else {\n        if (typeof(default_value) === 'undefined') {\n            default_value = 'None';\n        }\n        _.each(props, function(val, prop) {\n            if (!this.unpersisted_superprops.hasOwnProperty(prop) || this.unpersisted_superprops[prop] === default_value) {\n                this.unpersisted_superprops[prop] = val;\n            }\n        }, this);\n    }\n};\n\n/**\n * Delete a super property stored with the current user.\n *\n * @param {String} property The name of the super property to remove\n * @param {Object} [options]\n * @param {boolean} [options.persistent=true] - whether to look in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.unregister = function(property, options) {\n    options = options_for_register(options);\n    if (options['persistent']) {\n        this['persistence'].unregister(property);\n    } else {\n        delete this.unpersisted_superprops[property];\n    }\n};\n\nMixpanelLib.prototype._register_single = function(prop, value) {\n    var props = {};\n    props[prop] = value;\n    this.register(props);\n};\n\n/**\n * Identify a user with a unique ID to track user activity across\n * devices, tie a user to their events, and create a user profile.\n * If you never call this method, unique visitors are tracked using\n * a UUID generated the first time they visit the site.\n *\n * Call identify when you know the identity of the current user,\n * typically after login or signup. We recommend against using\n * identify for anonymous visitors to your site.\n *\n * ### Notes:\n * If your project has\n * <a href=\"https://help.mixpanel.com/hc/en-us/articles/360039133851\">ID Merge</a>\n * enabled, the identify method will connect pre- and\n * post-authentication events when appropriate.\n *\n * If your project does not have ID Merge enabled, identify will\n * change the user's local distinct_id to the unique ID you pass.\n * Events tracked prior to authentication will not be connected\n * to the same user identity. If ID Merge is disabled, alias can\n * be used to connect pre- and post-registration events.\n *\n * @param {String} [unique_id] A string that uniquely identifies a user. If not provided, the distinct_id currently in the persistent store (cookie or localStorage) will be used.\n */\nMixpanelLib.prototype.identify = function(\n    new_distinct_id, _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback\n) {\n    // Optional Parameters\n    //  _set_callback:function  A callback to be run if and when the People set queue is flushed\n    //  _add_callback:function  A callback to be run if and when the People add queue is flushed\n    //  _append_callback:function  A callback to be run if and when the People append queue is flushed\n    //  _set_once_callback:function  A callback to be run if and when the People set_once queue is flushed\n    //  _union_callback:function  A callback to be run if and when the People union queue is flushed\n    //  _unset_callback:function  A callback to be run if and when the People unset queue is flushed\n\n    var previous_distinct_id = this.get_distinct_id();\n    if (new_distinct_id && previous_distinct_id !== new_distinct_id) {\n        // we allow the following condition if previous distinct_id is same as new_distinct_id\n        // so that you can force flush people updates for anonymous profiles.\n        if (typeof new_distinct_id === 'string' && new_distinct_id.indexOf(DEVICE_ID_PREFIX) === 0) {\n            this.report_error('distinct_id cannot have $device: prefix');\n            return -1;\n        }\n        this.register({'$user_id': new_distinct_id});\n    }\n\n    if (!this.get_property('$device_id')) {\n        // The persisted distinct id might not actually be a device id at all\n        // it might be a distinct id of the user from before\n        var device_id = previous_distinct_id;\n        this.register_once({\n            '$had_persisted_distinct_id': true,\n            '$device_id': device_id\n        }, '');\n    }\n\n    // identify only changes the distinct id if it doesn't match either the existing or the alias;\n    // if it's new, blow away the alias as well.\n    if (new_distinct_id !== previous_distinct_id && new_distinct_id !== this.get_property(ALIAS_ID_KEY)) {\n        this.unregister(ALIAS_ID_KEY);\n        this.register({'distinct_id': new_distinct_id});\n    }\n    this._flags.identify_called = true;\n    // Flush any queued up people requests\n    this['people']._flush(_set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback);\n\n    // send an $identify event any time the distinct_id is changing - logic on the server\n    // will determine whether or not to do anything with it.\n    if (new_distinct_id !== previous_distinct_id) {\n        this.track('$identify', {\n            'distinct_id': new_distinct_id,\n            '$anon_distinct_id': previous_distinct_id\n        }, {skip_hooks: true});\n    }\n\n    // check feature flags again if distinct id has changed\n    if (new_distinct_id !== previous_distinct_id) {\n        this.flags.fetchFlags();\n    }\n};\n\n/**\n * Clears super properties and generates a new random distinct_id for this instance.\n * Useful for clearing data when a user logs out.\n */\nMixpanelLib.prototype.reset = function() {\n    this['persistence'].clear();\n    this._flags.identify_called = false;\n    var uuid = _.UUID();\n    this.register_once({\n        'distinct_id': DEVICE_ID_PREFIX + uuid,\n        '$device_id': uuid\n    }, '');\n    this.stop_session_recording();\n    this._check_and_start_session_recording();\n};\n\n/**\n * Returns the current distinct id of the user. This is either the id automatically\n * generated by the library or the id that has been passed by a call to identify().\n *\n * ### Notes:\n *\n * get_distinct_id() can only be called after the Mixpanel library has finished loading.\n * init() has a loaded function available to handle this automatically. For example:\n *\n *     // set distinct_id after the mixpanel library has loaded\n *     mixpanel.init('YOUR PROJECT TOKEN', {\n *         loaded: function(mixpanel) {\n *             distinct_id = mixpanel.get_distinct_id();\n *         }\n *     });\n */\nMixpanelLib.prototype.get_distinct_id = function() {\n    return this.get_property('distinct_id');\n};\n\n/**\n * The alias method creates an alias which Mixpanel will use to\n * remap one id to another. Multiple aliases can point to the\n * same identifier.\n *\n * The following is a valid use of alias:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // You can add multiple id aliases to the existing ID\n *     mixpanel.alias('newer_id', 'existing_id');\n *\n * Aliases can also be chained - the following is a valid example:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // chain newer_id - new_id - existing_id\n *     mixpanel.alias('newer_id', 'new_id');\n *\n * Aliases cannot point to multiple identifiers - the following\n * example will not work:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // this is invalid as 'new_id' already points to 'existing_id'\n *     mixpanel.alias('new_id', 'newer_id');\n *\n * ### Notes:\n *\n * If your project does not have\n * <a href=\"https://help.mixpanel.com/hc/en-us/articles/360039133851\">ID Merge</a>\n * enabled, the best practice is to call alias once when a unique\n * ID is first created for a user (e.g., when a user first registers\n * for an account). Do not use alias multiple times for a single\n * user without ID Merge enabled.\n *\n * @param {String} alias A unique identifier that you want to use for this user in the future.\n * @param {String} [original] The current identifier being used for this user.\n */\nMixpanelLib.prototype.alias = function(alias, original) {\n    // If the $people_distinct_id key exists in persistence, there has been a previous\n    // mixpanel.people.identify() call made for this user. It is VERY BAD to make an alias with\n    // this ID, as it will duplicate users.\n    if (alias === this.get_property(PEOPLE_DISTINCT_ID_KEY)) {\n        this.report_error('Attempting to create alias for existing People user - aborting.');\n        return -2;\n    }\n\n    var _this = this;\n    if (_.isUndefined(original)) {\n        original = this.get_distinct_id();\n    }\n    if (alias !== original) {\n        this._register_single(ALIAS_ID_KEY, alias);\n        return this.track('$create_alias', {\n            'alias': alias,\n            'distinct_id': original\n        }, {\n            skip_hooks: true\n        }, function() {\n            // Flush the people queue\n            _this.identify(alias);\n        });\n    } else {\n        this.report_error('alias matches current distinct_id - skipping api call.');\n        this.identify(alias);\n        return -1;\n    }\n};\n\n/**\n * Provide a string to recognize the user by. The string passed to\n * this method will appear in the Mixpanel Streams product rather\n * than an automatically generated name. Name tags do not have to\n * be unique.\n *\n * This value will only be included in Streams data.\n *\n * @param {String} name_tag A human readable name for the user\n * @deprecated\n */\nMixpanelLib.prototype.name_tag = function(name_tag) {\n    this._register_single('mp_name_tag', name_tag);\n};\n\n/**\n * Update the configuration of a mixpanel library instance.\n *\n * The default config is:\n *\n *     {\n *       // host for requests (customizable for e.g. a local proxy)\n *       api_host: 'https://api-js.mixpanel.com',\n *\n *       // endpoints for different types of requests\n *       api_routes: {\n *         track: 'track/',\n *         engage: 'engage/',\n *         groups: 'groups/',\n *       }\n *\n *       // HTTP method for tracking requests\n *       api_method: 'POST'\n *\n *       // transport for sending requests ('XHR' or 'sendBeacon')\n *       // NB: sendBeacon should only be used for scenarios such as\n *       // page unload where a \"best-effort\" attempt to send is\n *       // acceptable; the sendBeacon API does not support callbacks\n *       // or any way to know the result of the request. Mixpanel\n *       // tracking via sendBeacon will not support any event-\n *       // batching or retry mechanisms.\n *       api_transport: 'XHR'\n *\n *       // request-batching/queueing/retry\n *       batch_requests: true,\n *\n *       // maximum number of events/updates to send in a single\n *       // network request\n *       batch_size: 50,\n *\n *       // milliseconds to wait between sending batch requests\n *       batch_flush_interval_ms: 5000,\n *\n *       // milliseconds to wait for network responses to batch requests\n *       // before they are considered timed-out and retried\n *       batch_request_timeout_ms: 90000,\n *\n *       // override value for cookie domain, only useful for ensuring\n *       // correct cross-subdomain cookies on unusual domains like\n *       // subdomain.mainsite.avocat.fr; NB this cannot be used to\n *       // set cookies on a different domain than the current origin\n *       cookie_domain: ''\n *\n *       // super properties cookie expiration (in days)\n *       cookie_expiration: 365\n *\n *       // if true, cookie will be set with SameSite=None; Secure\n *       // this is only useful in special situations, like embedded\n *       // 3rd-party iframes that set up a Mixpanel instance\n *       cross_site_cookie: false\n *\n *       // super properties span subdomains\n *       cross_subdomain_cookie: true\n *\n *       // debug mode\n *       debug: false\n *\n *       // if this is true, the mixpanel cookie or localStorage entry\n *       // will be deleted, and no user persistence will take place\n *       disable_persistence: false\n *\n *       // if this is true, Mixpanel will automatically determine\n *       // City, Region and Country data using the IP address of\n *       //the client\n *       ip: true\n *\n *       // opt users out of tracking by this Mixpanel instance by default\n *       opt_out_tracking_by_default: false\n *\n *       // opt users out of browser data storage by this Mixpanel instance by default\n *       opt_out_persistence_by_default: false\n *\n *       // persistence mechanism used by opt-in/opt-out methods - cookie\n *       // or localStorage - falls back to cookie if localStorage is unavailable\n *       opt_out_tracking_persistence_type: 'localStorage'\n *\n *       // customize the name of cookie/localStorage set by opt-in/opt-out methods\n *       opt_out_tracking_cookie_prefix: null\n *\n *       // type of persistent store for super properties (cookie/\n *       // localStorage) if set to 'localStorage', any existing\n *       // mixpanel cookie value with the same persistence_name\n *       // will be transferred to localStorage and deleted\n *       persistence: 'cookie'\n *\n *       // name for super properties persistent store\n *       persistence_name: ''\n *\n *       // names of properties/superproperties which should never\n *       // be sent with track() calls\n *       property_blacklist: []\n *\n *       // if this is true, mixpanel cookies will be marked as\n *       // secure, meaning they will only be transmitted over https\n *       secure_cookie: false\n *\n *       // disables enriching user profiles with first touch marketing data\n *       skip_first_touch_marketing: false\n *\n *       // the amount of time track_links will\n *       // wait for Mixpanel's servers to respond\n *       track_links_timeout: 300\n *\n *       // adds any UTM parameters and click IDs present on the page to any events fired\n *       track_marketing: true\n *\n *       // enables automatic page view tracking using default page view events through\n *       // the track_pageview() method\n *       track_pageview: false\n *\n *       // if you set upgrade to be true, the library will check for\n *       // a cookie from our old js library and import super\n *       // properties from it, then the old cookie is deleted\n *       // The upgrade config option only works in the initialization,\n *       // so make sure you set it when you create the library.\n *       upgrade: false\n *\n *       // extra HTTP request headers to set for each API request, in\n *       // the format {'Header-Name': value}\n *       xhr_headers: {}\n *\n *       // whether to ignore or respect the web browser's Do Not Track setting\n *       ignore_dnt: false\n *     }\n *\n *\n * @param {Object} config A dictionary of new configuration values to update\n */\nMixpanelLib.prototype.set_config = function(config) {\n    if (_.isObject(config)) {\n        _.extend(this['config'], config);\n\n        var new_batch_size = config['batch_size'];\n        if (new_batch_size) {\n            _.each(this.request_batchers, function(batcher) {\n                batcher.resetBatchSize();\n            });\n        }\n\n        if (!this.get_config('persistence_name')) {\n            this['config']['persistence_name'] = this['config']['cookie_name'];\n        }\n        if (!this.get_config('disable_persistence')) {\n            this['config']['disable_persistence'] = this['config']['disable_cookie'];\n        }\n\n        if (this['persistence']) {\n            this['persistence'].update_config(this['config']);\n        }\n        Config.DEBUG = Config.DEBUG || this.get_config('debug');\n\n        if (('autocapture' in config || 'record_heatmap_data' in config) && this.autocapture) {\n            this.autocapture.init();\n        }\n    }\n};\n\n/**\n * returns the current config object for the library.\n */\nMixpanelLib.prototype.get_config = function(prop_name) {\n    return this['config'][prop_name];\n};\n\n/**\n * Fetch a hook function from config, with safe default, and run it\n * against the given arguments\n * @param {string} hook_name which hook to retrieve\n * @returns {any|null} return value of user-provided hook, or null if nothing was returned\n */\nMixpanelLib.prototype._run_hook = function(hook_name) {\n    var ret = (this['config']['hooks'][hook_name] || IDENTITY_FUNC).apply(this, slice.call(arguments, 1));\n    if (typeof ret === 'undefined') {\n        this.report_error(hook_name + ' hook did not return a value');\n        ret = null;\n    }\n    return ret;\n};\n\n/**\n * Returns the value of the super property named property_name. If no such\n * property is set, get_property() will return the undefined value.\n *\n * ### Notes:\n *\n * get_property() can only be called after the Mixpanel library has finished loading.\n * init() has a loaded function available to handle this automatically. For example:\n *\n *     // grab value for 'user_id' after the mixpanel library has loaded\n *     mixpanel.init('YOUR PROJECT TOKEN', {\n *         loaded: function(mixpanel) {\n *             user_id = mixpanel.get_property('user_id');\n *         }\n *     });\n *\n * @param {String} property_name The name of the super property you want to retrieve\n */\nMixpanelLib.prototype.get_property = function(property_name) {\n    return this['persistence'].load_prop([property_name]);\n};\n\nMixpanelLib.prototype.toString = function() {\n    var name = this.get_config('name');\n    if (name !== PRIMARY_INSTANCE_NAME) {\n        name = PRIMARY_INSTANCE_NAME + '.' + name;\n    }\n    return name;\n};\n\nMixpanelLib.prototype._event_is_disabled = function(event_name) {\n    return _.isBlockedUA(userAgent) ||\n        this._flags.disable_all_events ||\n        _.include(this.__disabled_events, event_name);\n};\n\n// perform some housekeeping around GDPR opt-in/out state\nMixpanelLib.prototype._gdpr_init = function() {\n    var is_localStorage_requested = this.get_config('opt_out_tracking_persistence_type') === 'localStorage';\n\n    // try to convert opt-in/out cookies to localStorage if possible\n    if (is_localStorage_requested && _.localStorage.is_supported()) {\n        if (!this.has_opted_in_tracking() && this.has_opted_in_tracking({'persistence_type': 'cookie'})) {\n            this.opt_in_tracking({'enable_persistence': false});\n        }\n        if (!this.has_opted_out_tracking() && this.has_opted_out_tracking({'persistence_type': 'cookie'})) {\n            this.opt_out_tracking({'clear_persistence': false});\n        }\n        this.clear_opt_in_out_tracking({\n            'persistence_type': 'cookie',\n            'enable_persistence': false\n        });\n    }\n\n    // check whether the user has already opted out - if so, clear & disable persistence\n    if (this.has_opted_out_tracking()) {\n        this._gdpr_update_persistence({'clear_persistence': true});\n\n    // check whether we should opt out by default\n    // note: we don't clear persistence here by default since opt-out default state is often\n    //       used as an initial state while GDPR information is being collected\n    } else if (!this.has_opted_in_tracking() && (\n        this.get_config('opt_out_tracking_by_default') || _.cookie.get('mp_optout')\n    )) {\n        _.cookie.remove('mp_optout');\n        this.opt_out_tracking({\n            'clear_persistence': this.get_config('opt_out_persistence_by_default')\n        });\n    }\n};\n\n/**\n * Enable or disable persistence based on options\n * only enable/disable if persistence is not already in this state\n * @param {boolean} [options.clear_persistence] If true, will delete all data stored by the sdk in persistence and disable it\n * @param {boolean} [options.enable_persistence] If true, will re-enable sdk persistence\n */\nMixpanelLib.prototype._gdpr_update_persistence = function(options) {\n    var disabled;\n    if (options && options['clear_persistence']) {\n        disabled = true;\n    } else if (options && options['enable_persistence']) {\n        disabled = false;\n    } else {\n        return;\n    }\n\n    if (!this.get_config('disable_persistence') && this['persistence'].disabled !== disabled) {\n        this['persistence'].set_disabled(disabled);\n    }\n\n    if (disabled) {\n        this.stop_batch_senders();\n        this.stop_session_recording();\n    } else {\n        // only start batchers after opt-in if they have previously been started\n        // in order to avoid unintentionally starting up batching for the first time\n        if (this._batchers_were_started) {\n            this.start_batch_senders();\n        }\n    }\n};\n\n// call a base gdpr function after constructing the appropriate token and options args\nMixpanelLib.prototype._gdpr_call_func = function(func, options) {\n    options = _.extend({\n        'track': _.bind(this.track, this),\n        'persistence_type': this.get_config('opt_out_tracking_persistence_type'),\n        'cookie_prefix': this.get_config('opt_out_tracking_cookie_prefix'),\n        'cookie_expiration': this.get_config('cookie_expiration'),\n        'cross_site_cookie': this.get_config('cross_site_cookie'),\n        'cross_subdomain_cookie': this.get_config('cross_subdomain_cookie'),\n        'cookie_domain': this.get_config('cookie_domain'),\n        'secure_cookie': this.get_config('secure_cookie'),\n        'ignore_dnt': this.get_config('ignore_dnt')\n    }, options);\n\n    // check if localStorage can be used for recording opt out status, fall back to cookie if not\n    if (!_.localStorage.is_supported()) {\n        options['persistence_type'] = 'cookie';\n    }\n\n    return func(this.get_config('token'), {\n        track: options['track'],\n        trackEventName: options['track_event_name'],\n        trackProperties: options['track_properties'],\n        persistenceType: options['persistence_type'],\n        persistencePrefix: options['cookie_prefix'],\n        cookieDomain: options['cookie_domain'],\n        cookieExpiration: options['cookie_expiration'],\n        crossSiteCookie: options['cross_site_cookie'],\n        crossSubdomainCookie: options['cross_subdomain_cookie'],\n        secureCookie: options['secure_cookie'],\n        ignoreDnt: options['ignore_dnt']\n    });\n};\n\n/**\n * Opt the user in to data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // opt user in\n *     mixpanel.opt_in_tracking();\n *\n *     // opt user in with specific event name, properties, cookie configuration\n *     mixpanel.opt_in_tracking({\n *         track_event_name: 'User opted in',\n *         track_event_properties: {\n *             'Email': 'jdoe@example.com'\n *         },\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {function} [options.track] Function used for tracking a Mixpanel event to record the opt-in action (default is this Mixpanel instance's track method)\n * @param {string} [options.track_event_name=$opt_in] Event name to be used for tracking the opt-in action\n * @param {Object} [options.track_properties] Set of properties to be tracked along with the opt-in action\n * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.opt_in_tracking = function(options) {\n    options = _.extend({\n        'enable_persistence': true\n    }, options);\n\n    this._gdpr_call_func(optIn, options);\n    this._gdpr_update_persistence(options);\n};\n\n/**\n * Opt the user out of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // opt user out\n *     mixpanel.opt_out_tracking();\n *\n *     // opt user out with different cookie configuration from Mixpanel instance\n *     mixpanel.opt_out_tracking({\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {boolean} [options.delete_user=true] If true, will delete the currently identified user's profile and clear all charges after opting the user out\n * @param {boolean} [options.clear_persistence=true] If true, will delete all data stored by the sdk in persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.opt_out_tracking = function(options) {\n    options = _.extend({\n        'clear_persistence': true,\n        'delete_user': true\n    }, options);\n\n    // delete user and clear charges since these methods may be disabled by opt-out\n    if (options['delete_user'] && this['people'] && this['people']._identify_called()) {\n        this['people'].delete_user();\n        this['people'].clear_charges();\n    }\n\n    this._gdpr_call_func(optOut, options);\n    this._gdpr_update_persistence(options);\n};\n\n/**\n * Check whether the user has opted in to data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     var has_opted_in = mixpanel.has_opted_in_tracking();\n *     // use has_opted_in value\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} current opt-in status\n */\nMixpanelLib.prototype.has_opted_in_tracking = function(options) {\n    return this._gdpr_call_func(hasOptedIn, options);\n};\n\n/**\n * Check whether the user has opted out of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     var has_opted_out = mixpanel.has_opted_out_tracking();\n *     // use has_opted_out value\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} current opt-out status\n */\nMixpanelLib.prototype.has_opted_out_tracking = function(options) {\n    return this._gdpr_call_func(hasOptedOut, options);\n};\n\n/**\n * Clear the user's opt in/out status of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // clear user's opt-in/out status\n *     mixpanel.clear_opt_in_out_tracking();\n *\n *     // clear user's opt-in/out status with specific cookie configuration - should match\n *     // configuration used when opt_in_tracking/opt_out_tracking methods were called.\n *     mixpanel.clear_opt_in_out_tracking({\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.clear_opt_in_out_tracking = function(options) {\n    options = _.extend({\n        'enable_persistence': true\n    }, options);\n\n    this._gdpr_call_func(clearOptInOut, options);\n    this._gdpr_update_persistence(options);\n};\n\nMixpanelLib.prototype.report_error = function(msg, err) {\n    console$1.error.apply(console$1.error, arguments);\n    try {\n        if (!err && !(msg instanceof Error)) {\n            msg = new Error(msg);\n        }\n        this.get_config('error_reporter')(msg, err);\n    } catch(err) {\n        console$1.error(err);\n    }\n};\n\n// EXPORTS (for closure compiler)\n\n// MixpanelLib Exports\nMixpanelLib.prototype['init']                               = MixpanelLib.prototype.init;\nMixpanelLib.prototype['reset']                              = MixpanelLib.prototype.reset;\nMixpanelLib.prototype['disable']                            = MixpanelLib.prototype.disable;\nMixpanelLib.prototype['time_event']                         = MixpanelLib.prototype.time_event;\nMixpanelLib.prototype['track']                              = MixpanelLib.prototype.track;\nMixpanelLib.prototype['track_links']                        = MixpanelLib.prototype.track_links;\nMixpanelLib.prototype['track_forms']                        = MixpanelLib.prototype.track_forms;\nMixpanelLib.prototype['track_pageview']                     = MixpanelLib.prototype.track_pageview;\nMixpanelLib.prototype['register']                           = MixpanelLib.prototype.register;\nMixpanelLib.prototype['register_once']                      = MixpanelLib.prototype.register_once;\nMixpanelLib.prototype['unregister']                         = MixpanelLib.prototype.unregister;\nMixpanelLib.prototype['identify']                           = MixpanelLib.prototype.identify;\nMixpanelLib.prototype['alias']                              = MixpanelLib.prototype.alias;\nMixpanelLib.prototype['name_tag']                           = MixpanelLib.prototype.name_tag;\nMixpanelLib.prototype['set_config']                         = MixpanelLib.prototype.set_config;\nMixpanelLib.prototype['get_config']                         = MixpanelLib.prototype.get_config;\nMixpanelLib.prototype['get_property']                       = MixpanelLib.prototype.get_property;\nMixpanelLib.prototype['get_distinct_id']                    = MixpanelLib.prototype.get_distinct_id;\nMixpanelLib.prototype['toString']                           = MixpanelLib.prototype.toString;\nMixpanelLib.prototype['opt_out_tracking']                   = MixpanelLib.prototype.opt_out_tracking;\nMixpanelLib.prototype['opt_in_tracking']                    = MixpanelLib.prototype.opt_in_tracking;\nMixpanelLib.prototype['has_opted_out_tracking']             = MixpanelLib.prototype.has_opted_out_tracking;\nMixpanelLib.prototype['has_opted_in_tracking']              = MixpanelLib.prototype.has_opted_in_tracking;\nMixpanelLib.prototype['clear_opt_in_out_tracking']          = MixpanelLib.prototype.clear_opt_in_out_tracking;\nMixpanelLib.prototype['get_group']                          = MixpanelLib.prototype.get_group;\nMixpanelLib.prototype['set_group']                          = MixpanelLib.prototype.set_group;\nMixpanelLib.prototype['add_group']                          = MixpanelLib.prototype.add_group;\nMixpanelLib.prototype['remove_group']                       = MixpanelLib.prototype.remove_group;\nMixpanelLib.prototype['track_with_groups']                  = MixpanelLib.prototype.track_with_groups;\nMixpanelLib.prototype['start_batch_senders']                = MixpanelLib.prototype.start_batch_senders;\nMixpanelLib.prototype['stop_batch_senders']                 = MixpanelLib.prototype.stop_batch_senders;\nMixpanelLib.prototype['start_session_recording']            = MixpanelLib.prototype.start_session_recording;\nMixpanelLib.prototype['stop_session_recording']             = MixpanelLib.prototype.stop_session_recording;\nMixpanelLib.prototype['pause_session_recording']            = MixpanelLib.prototype.pause_session_recording;\nMixpanelLib.prototype['resume_session_recording']           = MixpanelLib.prototype.resume_session_recording;\nMixpanelLib.prototype['get_session_recording_properties']   = MixpanelLib.prototype.get_session_recording_properties;\nMixpanelLib.prototype['get_session_replay_url']             = MixpanelLib.prototype.get_session_replay_url;\nMixpanelLib.prototype['get_tab_id']                         = MixpanelLib.prototype.get_tab_id;\nMixpanelLib.prototype['DEFAULT_API_ROUTES']                 = DEFAULT_API_ROUTES;\n\n// Exports intended only for testing\nMixpanelLib.prototype['__get_recorder']                     = MixpanelLib.prototype.__get_recorder;\n\n// MixpanelPersistence Exports\nMixpanelPersistence.prototype['properties']            = MixpanelPersistence.prototype.properties;\nMixpanelPersistence.prototype['update_search_keyword'] = MixpanelPersistence.prototype.update_search_keyword;\nMixpanelPersistence.prototype['update_referrer_info']  = MixpanelPersistence.prototype.update_referrer_info;\nMixpanelPersistence.prototype['get_cross_subdomain']   = MixpanelPersistence.prototype.get_cross_subdomain;\nMixpanelPersistence.prototype['clear']                 = MixpanelPersistence.prototype.clear;\n\n\nvar instances = {};\nvar extend_mp = function() {\n    // add all the sub mixpanel instances\n    _.each(instances, function(instance, name) {\n        if (name !== PRIMARY_INSTANCE_NAME) { mixpanel_master[name] = instance; }\n    });\n\n    // add private functions as _\n    mixpanel_master['_'] = _;\n};\n\nvar override_mp_init_func = function() {\n    // we override the snippets init function to handle the case where a\n    // user initializes the mixpanel library after the script loads & runs\n    mixpanel_master['init'] = function(token, config, name) {\n        if (name) {\n            // initialize a sub library\n            if (!mixpanel_master[name]) {\n                mixpanel_master[name] = instances[name] = create_mplib(token, config, name);\n                mixpanel_master[name]._loaded();\n            }\n            return mixpanel_master[name];\n        } else {\n            var instance = mixpanel_master;\n\n            if (instances[PRIMARY_INSTANCE_NAME]) {\n                // main mixpanel lib already initialized\n                instance = instances[PRIMARY_INSTANCE_NAME];\n            } else if (token) {\n                // intialize the main mixpanel lib\n                instance = create_mplib(token, config, PRIMARY_INSTANCE_NAME);\n                instance._loaded();\n                instances[PRIMARY_INSTANCE_NAME] = instance;\n            }\n\n            mixpanel_master = instance;\n            if (init_type === INIT_SNIPPET) {\n                win[PRIMARY_INSTANCE_NAME] = mixpanel_master;\n            }\n            extend_mp();\n        }\n    };\n};\n\nvar add_dom_loaded_handler = function() {\n    // Cross browser DOM Loaded support\n    function dom_loaded_handler() {\n        // function flag since we only want to execute this once\n        if (dom_loaded_handler.done) { return; }\n        dom_loaded_handler.done = true;\n\n        DOM_LOADED = true;\n        ENQUEUE_REQUESTS = false;\n\n        _.each(instances, function(inst) {\n            inst._dom_loaded();\n        });\n    }\n\n    function do_scroll_check() {\n        try {\n            document$1.documentElement.doScroll('left');\n        } catch(e) {\n            setTimeout(do_scroll_check, 1);\n            return;\n        }\n\n        dom_loaded_handler();\n    }\n\n    if (document$1.addEventListener) {\n        if (document$1.readyState === 'complete') {\n            // safari 4 can fire the DOMContentLoaded event before loading all\n            // external JS (including this file). you will see some copypasta\n            // on the internet that checks for 'complete' and 'loaded', but\n            // 'loaded' is an IE thing\n            dom_loaded_handler();\n        } else {\n            document$1.addEventListener('DOMContentLoaded', dom_loaded_handler, false);\n        }\n    } else if (document$1.attachEvent) {\n        // IE\n        document$1.attachEvent('onreadystatechange', dom_loaded_handler);\n\n        // check to make sure we arn't in a frame\n        var toplevel = false;\n        try {\n            toplevel = win.frameElement === null;\n        } catch(e) {\n            // noop\n        }\n\n        if (document$1.documentElement.doScroll && toplevel) {\n            do_scroll_check();\n        }\n    }\n\n    // fallback handler, always will work\n    _.register_event(win, 'load', dom_loaded_handler, true);\n};\n\nfunction init_as_module(bundle_loader) {\n    load_extra_bundle = bundle_loader;\n    init_type = INIT_MODULE;\n    mixpanel_master = new MixpanelLib();\n\n    override_mp_init_func();\n    mixpanel_master['init']();\n    add_dom_loaded_handler();\n\n    return mixpanel_master;\n}\n\n// For loading separate bundles asynchronously via script tag\n// so that we don't load them until they are needed at runtime.\n\n// For builds that have everything in one bundle, no extra work.\nfunction loadNoop (_src, onload) {\n    onload();\n}\n\n/* eslint camelcase: \"off\" */\n\nvar mixpanel = init_as_module(loadNoop);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWl4cGFuZWwtYnJvd3Nlci9kaXN0L21peHBhbmVsLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCLDZCQUE2QjtBQUN0RSxxQkFBcUIsNkJBQTZCO0FBQ2xEO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBLFNBQVM7QUFDVCxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVCQUF1QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakcsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUJBQWlCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHdEQUF3RDtBQUN6Ryw2REFBNkQscUNBQXFDLHNCQUFzQjtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2Qyx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLDRCQUE0QjtBQUM1RztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQSwrQkFBK0IsNEJBQTRCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxvQkFBb0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsdURBQXVELFNBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNFRBQTRULDRNQUE0TTtBQUN4Z0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbVFBQW1RLDJLQUEySztBQUM5YTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxza0JBQXNrQixxUEFBcVA7QUFDM3pCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUhBQWlILDRCQUE0QjtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SEFBOEgsOEJBQThCO0FBQzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0seUJBQXlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLDRCQUE0QjtBQUM3SDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQSxvREFBb0QsRUFBRTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGFBQWE7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRiw0QkFBNEI7QUFDaEg7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZUFBZTtBQUNyRSwrQ0FBK0M7QUFDL0Msa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsNEJBQTRCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4Riw0QkFBNEI7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGFBQWE7QUFDNUY7QUFDQTtBQUNBLG1GQUFtRiw0QkFBNEI7QUFDL0c7QUFDQTtBQUNBLHNGQUFzRiw4QkFBOEI7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsNEJBQTRCO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsMkZBQTJGLGFBQWE7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxtSEFBbUgsYUFBYTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGLDRCQUE0QjtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsNEJBQTRCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxvRkFBb0YsNEJBQTRCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHNGQUFzRiw4QkFBOEI7QUFDcEg7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsYUFBYTtBQUM1RjtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsNEJBQTRCO0FBQy9HO0FBQ0E7QUFDQSxzRkFBc0YsOEJBQThCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLDRCQUE0QjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0MsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxhQUFhO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxhQUFhO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZCx3RkFBd0YsNEJBQTRCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLDRCQUE0QjtBQUM3RztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDLGdDQUFnQztBQUNoQyxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsNEJBQTRCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0NBQStDO0FBQzdEO0FBQ0EsZ0NBQWdDO0FBQ2hDLGNBQWM7QUFDZCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQkFBb0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0EsMkZBQTJGO0FBQzNGLGtCQUFrQjtBQUNsQiwyRkFBMkY7QUFDM0Ysa0JBQWtCO0FBQ2xCLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxvQkFBb0IsSUFBcUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1Riw0QkFBNEI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1Riw0QkFBNEI7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLDhCQUE4QjtBQUNsSTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLDRCQUE0QjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsNEJBQTRCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFxQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLDRCQUE0QjtBQUM5RztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Qsb0JBQW9CLElBQXFDO0FBQ3pEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRiw0QkFBNEI7QUFDaEg7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxhQUFhO0FBQ2I7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxhQUFhO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGFBQWE7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsNEJBQTRCO0FBQzdIO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBLG9EQUFvRCxFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsYUFBYTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLDRCQUE0QjtBQUNoSDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxlQUFlO0FBQ3JFLCtDQUErQztBQUMvQyxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRiw0QkFBNEI7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLDRCQUE0QjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsYUFBYTtBQUM1RjtBQUNBO0FBQ0EsbUZBQW1GLDRCQUE0QjtBQUMvRztBQUNBO0FBQ0Esc0ZBQXNGLDhCQUE4QjtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlGQUF5Riw0QkFBNEI7QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSwyRkFBMkYsYUFBYTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLG1IQUFtSCxhQUFhO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsNEJBQTRCO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRiw0QkFBNEI7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLG9GQUFvRiw0QkFBNEI7QUFDaEg7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esc0ZBQXNGLDhCQUE4QjtBQUNwSDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxhQUFhO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRiw0QkFBNEI7QUFDL0c7QUFDQTtBQUNBLHNGQUFzRiw4QkFBOEI7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsNEJBQTRCO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QyxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGFBQWE7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGFBQWE7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsY0FBYztBQUNkLHdGQUF3Riw0QkFBNEI7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsNEJBQTRCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEMsZ0NBQWdDO0FBQ2hDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJGQUEyRiw0QkFBNEI7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQ0FBK0M7QUFDN0Q7QUFDQSxnQ0FBZ0M7QUFDaEMsY0FBYztBQUNkLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQSwyRkFBMkY7QUFDM0Ysa0JBQWtCO0FBQ2xCLDJGQUEyRjtBQUMzRixrQkFBa0I7QUFDbEIsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG9CQUFvQixJQUFxQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLDRCQUE0QjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLDRCQUE0QjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0csOEJBQThCO0FBQ2xJO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksSUFBcUM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsNEJBQTRCO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRiw0QkFBNEI7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLElBQXFDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsNEJBQTRCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZCxvQkFBb0IsSUFBcUM7QUFDekQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLDRCQUE0QjtBQUNoSDtBQUNBLDJDQUEyQztBQUMzQztBQUNBLGFBQWE7QUFDYjtBQUNBLCtDQUErQztBQUMvQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGFBQWE7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsYUFBYTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxhQUFhO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGFBQWE7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxHQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3QkFBd0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsbUJBQW1CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGVBQWU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLDRCQUE0QjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0YsOEJBQThCO0FBQzdIO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwySEFBMkgsNEJBQTRCO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSCw4QkFBOEI7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGFBQWE7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFtQyxvQkFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsNEJBQTRCO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLDRCQUE0QjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGFBQWE7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNEJBQTRCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxhQUFhO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsYUFBYTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsNEJBQTRCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTixnREFBZ0Q7QUFDaEQ7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLDRCQUE0QjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDgyQ0FBODJDLGdJQUFnSTtBQUM5K0M7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0YsNEJBQTRCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9GQUFvRiw0QkFBNEI7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGFBQWE7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkJBQTJCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0NBQXNDO0FBQ3BGLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDZDQUE2QztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKO0FBQ3ZKLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELGdDQUFnQztBQUNoQyxpQ0FBaUMsTUFBTSwwQkFBMEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCO0FBQ0EsNkJBQTZCO0FBQzdCLDJCQUEyQjtBQUMzQixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixtQ0FBbUM7QUFDbkMseUNBQXlDO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQyx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekIsVUFBVTtBQUNWO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUEsa0ZBQWtGO0FBQ2xGLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QixVQUFVO0FBQ1Y7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQSxtRkFBbUY7QUFDbkY7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxnQkFBZ0I7QUFDL0IsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwyQkFBMkI7QUFDdkQ7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFELElBQUk7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0IsV0FBVyxnQ0FBZ0M7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsYUFBYSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVEscURBQXFEO0FBQ3hFLFdBQVcsU0FBUztBQUNwQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckIsb0NBQW9DLHdCQUF3QjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYixNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msd0JBQXdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsMEVBQTBFLFdBQVc7QUFDckY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSw4QkFBOEI7QUFDOUIsaUdBQWlHLFdBQVc7QUFDNUc7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLDhCQUE4QjtBQUM5QixxREFBcUQ7QUFDckQ7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsYUFBYTs7QUFFYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsbURBQW1EO0FBQzlELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFVBQVU7QUFDeEIsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsVUFBVTtBQUN4QixjQUFjLFVBQVU7QUFDeEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7OztBQUdBO0FBQ0E7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwREFBMEQ7QUFDMUU7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyx5QkFBeUI7QUFDcEMsYUFBYTtBQUNiO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsU0FBUztBQUNULHNCQUFzQixhQUFhO0FBQ25DLFNBQVM7QUFDVCxLQUFLO0FBQ0wsa0JBQWtCLGdDQUFnQztBQUNsRCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsMkVBQTJFO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQseUJBQXlCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxtREFBbUQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMscURBQXFEO0FBQ2pHLGNBQWM7QUFDZCw0Q0FBNEMseUJBQXlCO0FBQ3JFLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7OztBQUdBO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCO0FBQ2pEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLHdDQUF3QztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5QiwyQ0FBMkM7QUFDcEU7QUFDQSxvQkFBb0IsbUNBQW1DO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsMkJBQTJCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQ0FBbUMsR0FBRyxTQUFTLEVBQUUsaUJBQWlCLEdBQUcsa0JBQWtCLEVBQUUsT0FBTyxHQUFHLGNBQWMsR0FBRyw4QkFBOEIsR0FBRyx3QkFBd0IsRUFBRSxPQUFPLEdBQUc7QUFDekw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDBCQUEwQjtBQUMxQixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7O0FBRWxEO0FBQ0EsOEJBQThCLHlCQUF5QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOEJBQThCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwwQkFBMEI7QUFDMUIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwwQkFBMEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxLQUFLLGdDQUFnQztBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5Qyx1QkFBdUI7QUFDaEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkNBQTZDLHVCQUF1QjtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsR0FBRztBQUNkLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekIsVUFBVSxHQUFHO0FBQ2IsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZUFBZTtBQUN6QixVQUFVLEdBQUc7QUFDYixVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxVQUFVLGVBQWU7QUFDekIsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ04sK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLFVBQVUsZUFBZTtBQUN6QixVQUFVLEdBQUc7QUFDYixVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsR0FBRztBQUNiLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCLFVBQVUsR0FBRztBQUNiLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1RkFBdUYsdUJBQXVCO0FBQzlHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7O0FBRXpCOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsSUFBSTtBQUNkLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVcsR0FBRyxRQUFRLFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUEsaUNBQWlDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGdCQUFnQjtBQUM1RTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCOztBQUUzQixtQ0FBbUM7QUFDbkMsd0JBQXdCO0FBQ3hCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxvR0FBb0c7QUFDOUksOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFGQUFxRjtBQUN0RyxpQkFBaUIsc0ZBQXNGO0FBQ3ZHLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0QkFBNEI7QUFDakU7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUIsR0FBRyx3QkFBd0I7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFVBQVU7QUFDckIsYUFBYSxnQkFBZ0I7QUFDN0IsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDViwyQkFBMkIsMENBQTBDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLEdBQUc7QUFDZCxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG9CQUFvQixHQUFHLDhCQUE4QjtBQUNyRztBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0Esb0NBQW9DLGtCQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUNBQW1DO0FBQ25FO0FBQ0E7QUFDQSxnQ0FBZ0Msa0JBQWtCO0FBQ2xELGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEJBQTBCLEdBQUcsMkNBQTJDO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0EscUNBQXFDLDJCQUEyQjtBQUNoRTtBQUNBO0FBQ0EscUNBQXFDLGlEQUFpRDtBQUN0RjtBQUNBO0FBQ0EscUNBQXFDLGdDQUFnQztBQUNyRTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsZ0JBQWdCO0FBQzdCLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsVUFBVTtBQUNWLFdBQVcsZUFBZTtBQUMxQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLFVBQVU7QUFDVixXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw0QkFBNEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQjtBQUNuQixNQUFNO0FBQ047QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsMEJBQTBCLGNBQWMsR0FBRyxrQkFBa0I7QUFDN0Q7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxlQUFlO0FBQzFCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHLGlCQUFpQjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUVBQXlFLDZCQUE2QjtBQUN0RyxrQ0FBa0MsNEJBQTRCO0FBQzlEO0FBQ0EsMkVBQTJFLDZCQUE2QjtBQUN4RyxtQ0FBbUMsMkJBQTJCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsMEJBQTBCOztBQUVqRTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFK0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9rcmlzdGFhbml2b3J5L0RvY3VtZW50cy9Tb2NpYWwgU2FnZSBBcHAvc29jaWFsc2FnZS9ub2RlX21vZHVsZXMvbWl4cGFuZWwtYnJvd3Nlci9kaXN0L21peHBhbmVsLm1vZHVsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaW5jZSBlczYgaW1wb3J0cyBhcmUgc3RhdGljIGFuZCB3ZSBydW4gdW5pdCB0ZXN0cyBmcm9tIHRoZSBjb25zb2xlLCB3aW5kb3cgd29uJ3QgYmUgZGVmaW5lZCB3aGVuIGltcG9ydGluZyB0aGlzIGZpbGVcbnZhciB3aW47XG5pZiAodHlwZW9mKHdpbmRvdykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIGxvYyA9IHtcbiAgICAgICAgaG9zdG5hbWU6ICcnXG4gICAgfTtcbiAgICB3aW4gPSB7XG4gICAgICAgIGNyeXB0bzoge3JhbmRvbVVVSUQ6IGZ1bmN0aW9uKCkge3Rocm93IEVycm9yKCd1bnN1cHBvcnRlZCcpO319LFxuICAgICAgICBuYXZpZ2F0b3I6IHsgdXNlckFnZW50OiAnJywgb25MaW5lOiB0cnVlIH0sXG4gICAgICAgIGRvY3VtZW50OiB7XG4gICAgICAgICAgICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9LFxuICAgICAgICAgICAgbG9jYXRpb246IGxvYyxcbiAgICAgICAgICAgIHJlZmVycmVyOiAnJ1xuICAgICAgICB9LFxuICAgICAgICBzY3JlZW46IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9LFxuICAgICAgICBsb2NhdGlvbjogbG9jLFxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbigpIHt9XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgd2luID0gd2luZG93O1xufVxuXG5mdW5jdGlvbiBfYXJyYXlfbGlrZV90b19hcnJheShhcnIsIGxlbikge1xuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIGZvcih2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKWFycjJbaV0gPSBhcnJbaV07XG4gICAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgICAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgICByZXNvbHZlKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gICAgfVxufVxuZnVuY3Rpb24gX2FzeW5jX3RvX2dlbmVyYXRvcihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICBpZiAoX2lzX25hdGl2ZV9yZWZsZWN0X2NvbnN0cnVjdCgpKSB7XG4gICAgICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfY29uc3RydWN0ID0gZnVuY3Rpb24gY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgICAgICAgICAgIHZhciBhID0gW1xuICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgICAgICAgIGlmIChDbGFzcykgX3NldF9wcm90b3R5cGVfb2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlX2NsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICAgIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gc291cmNlKXtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG4gICAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfZ2V0X3Byb3RvdHlwZV9vZihvKSB7XG4gICAgX2dldF9wcm90b3R5cGVfb2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBnZXRQcm90b3R5cGVPZihvKSB7XG4gICAgICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gICAgfTtcbiAgICByZXR1cm4gX2dldF9wcm90b3R5cGVfb2Yobyk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRfcHJvdG90eXBlX29mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cbmZ1bmN0aW9uIF9pbnN0YW5jZW9mKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKHJpZ2h0ICE9IG51bGwgJiYgdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiByaWdodFtTeW1ib2wuaGFzSW5zdGFuY2VdKSB7XG4gICAgICAgIHJldHVybiAhIXJpZ2h0W1N5bWJvbC5oYXNJbnN0YW5jZV0obGVmdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGxlZnQgaW5zdGFuY2VvZiByaWdodDtcbiAgICB9XG59XG5mdW5jdGlvbiBfaXNfbmF0aXZlX2Z1bmN0aW9uKGZuKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn1cbmZ1bmN0aW9uIF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG4gICAgZm9yKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfc2V0X3Byb3RvdHlwZV9vZihvLCBwKSB7XG4gICAgX3NldF9wcm90b3R5cGVfb2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgICAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgICAgIHJldHVybiBvO1xuICAgIH07XG4gICAgcmV0dXJuIF9zZXRfcHJvdG90eXBlX29mKG8sIHApO1xufVxuZnVuY3Rpb24gX3R5cGVfb2Yob2JqKSB7XG4gICAgXCJAc3djL2hlbHBlcnMgLSB0eXBlb2ZcIjtcbiAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZF9pdGVyYWJsZV90b19hcnJheShvLCBtaW5MZW4pIHtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlfbGlrZV90b19hcnJheShvLCBtaW5MZW4pO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG4pO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5X2xpa2VfdG9fYXJyYXkobywgbWluTGVuKTtcbn1cbmZ1bmN0aW9uIF93cmFwX25hdGl2ZV9zdXBlcihDbGFzcykge1xuICAgIHZhciBfY2FjaGUgPSB0eXBlb2YgTWFwID09PSBcImZ1bmN0aW9uXCIgPyBuZXcgTWFwKCkgOiB1bmRlZmluZWQ7XG4gICAgX3dyYXBfbmF0aXZlX3N1cGVyID0gZnVuY3Rpb24gd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhX2lzX25hdGl2ZV9mdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcbiAgICAgICAgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuICAgICAgICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgICAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRfcHJvdG90eXBlX29mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBXcmFwcGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBXcmFwcGVyLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9zZXRfcHJvdG90eXBlX29mKFdyYXBwZXIsIENsYXNzKTtcbiAgICB9O1xuICAgIHJldHVybiBfd3JhcF9uYXRpdmVfc3VwZXIoQ2xhc3MpO1xufVxuZnVuY3Rpb24gX2lzX25hdGl2ZV9yZWZsZWN0X2NvbnN0cnVjdCgpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24oKSB7fSkpO1xuICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgcmV0dXJuIChfaXNfbmF0aXZlX3JlZmxlY3RfY29uc3RydWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9KSgpO1xufVxuZnVuY3Rpb24gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG8sIGFsbG93QXJyYXlMaWtlKSB7XG4gICAgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07XG4gICAgaWYgKGl0KSByZXR1cm4gKGl0ID0gaXQuY2FsbChvKSkubmV4dC5iaW5kKGl0KTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRfaXRlcmFibGVfdG9fYXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlKSB7XG4gICAgICAgIGlmIChpdCkgbyA9IGl0O1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBvW2krK11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX3RzX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIGYsIHksIHQsIGcsIF8gPSB7XG4gICAgICAgIGxhYmVsOiAwLFxuICAgICAgICBzZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTtcbiAgICAgICAgICAgIHJldHVybiB0WzFdO1xuICAgICAgICB9LFxuICAgICAgICB0cnlzOiBbXSxcbiAgICAgICAgb3BzOiBbXVxuICAgIH07XG4gICAgcmV0dXJuIGcgPSB7XG4gICAgICAgIG5leHQ6IHZlcmIoMCksXG4gICAgICAgIFwidGhyb3dcIjogdmVyYigxKSxcbiAgICAgICAgXCJyZXR1cm5cIjogdmVyYigyKVxuICAgIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAoW1xuICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgdlxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZShfKXRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW1xuICAgICAgICAgICAgICAgIG9wWzBdICYgMixcbiAgICAgICAgICAgICAgICB0LnZhbHVlXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgc3dpdGNoKG9wWzBdKXtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9wWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIF8ubGFiZWwrKztcbiAgICAgICAgICAgICAgICAgICAgeSA9IG9wWzFdO1xuICAgICAgICAgICAgICAgICAgICBvcCA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICBvcCA9IF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgb3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubGFiZWwgPSBvcFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgXy5sYWJlbCA9IHRbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBfLm9wcy5wdXNoKG9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBvcCA9IFtcbiAgICAgICAgICAgICAgICA2LFxuICAgICAgICAgICAgICAgIGVcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgZiA9IHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsXG4gICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gX3RzX3ZhbHVlcyhvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG8gJiYgb1tpKytdLFxuICAgICAgICAgICAgICAgIGRvbmU6ICFvXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbn07XG52YXIgX19wdWJsaWNGaWVsZCA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBfX2RlZk5vcm1hbFByb3Aob2JqLCAodHlwZW9mIGtleSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihrZXkpKSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbn07XG52YXIgX2E7XG52YXIgX19kZWZQcm9wJDEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wJDEgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcCQxKG9iaiwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbn07XG52YXIgX19wdWJsaWNGaWVsZCQxID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIF9fZGVmTm9ybWFsUHJvcCQxKG9iaiwgKHR5cGVvZiBrZXkgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2Yoa2V5KSkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG59O1xudmFyIE5vZGVUeXBlJDMgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oTm9kZVR5cGUyKSB7XG4gICAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50XCJdID0gMF0gPSBcIkRvY3VtZW50XCI7XG4gICAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkRvY3VtZW50VHlwZVwiXSA9IDFdID0gXCJEb2N1bWVudFR5cGVcIjtcbiAgICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiRWxlbWVudFwiXSA9IDJdID0gXCJFbGVtZW50XCI7XG4gICAgTm9kZVR5cGUyW05vZGVUeXBlMltcIlRleHRcIl0gPSAzXSA9IFwiVGV4dFwiO1xuICAgIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJDREFUQVwiXSA9IDRdID0gXCJDREFUQVwiO1xuICAgIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJDb21tZW50XCJdID0gNV0gPSBcIkNvbW1lbnRcIjtcbiAgICByZXR1cm4gTm9kZVR5cGUyO1xufShOb2RlVHlwZSQzIHx8IHt9KTtcbnZhciB0ZXN0YWJsZUFjY2Vzc29ycyQxID0ge1xuICAgIE5vZGU6IFtcbiAgICAgICAgXCJjaGlsZE5vZGVzXCIsXG4gICAgICAgIFwicGFyZW50Tm9kZVwiLFxuICAgICAgICBcInBhcmVudEVsZW1lbnRcIixcbiAgICAgICAgXCJ0ZXh0Q29udGVudFwiXG4gICAgXSxcbiAgICBTaGFkb3dSb290OiBbXG4gICAgICAgIFwiaG9zdFwiLFxuICAgICAgICBcInN0eWxlU2hlZXRzXCJcbiAgICBdLFxuICAgIEVsZW1lbnQ6IFtcbiAgICAgICAgXCJzaGFkb3dSb290XCIsXG4gICAgICAgIFwicXVlcnlTZWxlY3RvclwiLFxuICAgICAgICBcInF1ZXJ5U2VsZWN0b3JBbGxcIlxuICAgIF0sXG4gICAgTXV0YXRpb25PYnNlcnZlcjogW11cbn07XG52YXIgdGVzdGFibGVNZXRob2RzJDEgPSB7XG4gICAgTm9kZTogW1xuICAgICAgICBcImNvbnRhaW5zXCIsXG4gICAgICAgIFwiZ2V0Um9vdE5vZGVcIlxuICAgIF0sXG4gICAgU2hhZG93Um9vdDogW1xuICAgICAgICBcImdldFNlbGVjdGlvblwiXG4gICAgXSxcbiAgICBFbGVtZW50OiBbXSxcbiAgICBNdXRhdGlvbk9ic2VydmVyOiBbXG4gICAgICAgIFwiY29uc3RydWN0b3JcIlxuICAgIF1cbn07XG52YXIgdW50YWludGVkQmFzZVByb3RvdHlwZSQxID0ge307XG52YXIgaXNBbmd1bGFyWm9uZVByZXNlbnQkMSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIWdsb2JhbFRoaXMuWm9uZTtcbn07XG5mdW5jdGlvbiBnZXRVbnRhaW50ZWRQcm90b3R5cGUkMShrZXkpIHtcbiAgICBpZiAodW50YWludGVkQmFzZVByb3RvdHlwZSQxW2tleV0pIHJldHVybiB1bnRhaW50ZWRCYXNlUHJvdG90eXBlJDFba2V5XTtcbiAgICB2YXIgZGVmYXVsdE9iaiA9IGdsb2JhbFRoaXNba2V5XTtcbiAgICB2YXIgZGVmYXVsdFByb3RvdHlwZSA9IGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICAgIHZhciBhY2Nlc3Nvck5hbWVzID0ga2V5IGluIHRlc3RhYmxlQWNjZXNzb3JzJDEgPyB0ZXN0YWJsZUFjY2Vzc29ycyQxW2tleV0gOiB2b2lkIDA7XG4gICAgdmFyIGlzVW50YWludGVkQWNjZXNzb3JzID0gQm9vbGVhbihhY2Nlc3Nvck5hbWVzICYmIC8vIEB0cy1leHBlY3QtZXJyb3IgMjM0NVxuICAgIGFjY2Vzc29yTmFtZXMuZXZlcnkoZnVuY3Rpb24oYWNjZXNzb3IpIHtcbiAgICAgICAgdmFyIF9hMiwgX2I7XG4gICAgICAgIHJldHVybiBCb29sZWFuKChfYiA9IChfYTIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRlZmF1bHRQcm90b3R5cGUsIGFjY2Vzc29yKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5nZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYi50b1N0cmluZygpLmluY2x1ZGVzKFwiW25hdGl2ZSBjb2RlXVwiKSk7XG4gICAgfSkpO1xuICAgIHZhciBtZXRob2ROYW1lcyA9IGtleSBpbiB0ZXN0YWJsZU1ldGhvZHMkMSA/IHRlc3RhYmxlTWV0aG9kcyQxW2tleV0gOiB2b2lkIDA7XG4gICAgdmFyIGlzVW50YWludGVkTWV0aG9kcyA9IEJvb2xlYW4obWV0aG9kTmFtZXMgJiYgbWV0aG9kTmFtZXMuZXZlcnkoLy8gQHRzLWV4cGVjdC1lcnJvciAyMzQ1XG4gICAgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgIHZhciBfYTI7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFByb3RvdHlwZVttZXRob2RdID09PSBcImZ1bmN0aW9uXCIgJiYgKChfYTIgPSBkZWZhdWx0UHJvdG90eXBlW21ldGhvZF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTIudG9TdHJpbmcoKS5pbmNsdWRlcyhcIltuYXRpdmUgY29kZV1cIikpO1xuICAgIH0pKTtcbiAgICBpZiAoaXNVbnRhaW50ZWRBY2Nlc3NvcnMgJiYgaXNVbnRhaW50ZWRNZXRob2RzICYmICFpc0FuZ3VsYXJab25lUHJlc2VudCQxKCkpIHtcbiAgICAgICAgdW50YWludGVkQmFzZVByb3RvdHlwZSQxW2tleV0gPSBkZWZhdWx0T2JqLnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB2YXIgaWZyYW1lRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZUVsKTtcbiAgICAgICAgdmFyIHdpbiA9IGlmcmFtZUVsLmNvbnRlbnRXaW5kb3c7XG4gICAgICAgIGlmICghd2luKSByZXR1cm4gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gICAgICAgIHZhciB1bnRhaW50ZWRPYmplY3QgPSB3aW5ba2V5XS5wcm90b3R5cGU7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lRWwpO1xuICAgICAgICBpZiAoIXVudGFpbnRlZE9iamVjdCkgcmV0dXJuIGRlZmF1bHRQcm90b3R5cGU7XG4gICAgICAgIHJldHVybiB1bnRhaW50ZWRCYXNlUHJvdG90eXBlJDFba2V5XSA9IHVudGFpbnRlZE9iamVjdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0UHJvdG90eXBlO1xuICAgIH1cbn1cbnZhciB1bnRhaW50ZWRBY2Nlc3NvckNhY2hlJDEgPSB7fTtcbmZ1bmN0aW9uIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoa2V5LCBpbnN0YW5jZSwgYWNjZXNzb3IpIHtcbiAgICB2YXIgX2EyO1xuICAgIHZhciBjYWNoZUtleSA9IGtleSArIFwiLlwiICsgU3RyaW5nKGFjY2Vzc29yKTtcbiAgICBpZiAodW50YWludGVkQWNjZXNzb3JDYWNoZSQxW2NhY2hlS2V5XSkgcmV0dXJuIHVudGFpbnRlZEFjY2Vzc29yQ2FjaGUkMVtjYWNoZUtleV0uY2FsbChpbnN0YW5jZSk7XG4gICAgdmFyIHVudGFpbnRlZFByb3RvdHlwZSA9IGdldFVudGFpbnRlZFByb3RvdHlwZSQxKGtleSk7XG4gICAgdmFyIHVudGFpbnRlZEFjY2Vzc29yID0gKF9hMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodW50YWludGVkUHJvdG90eXBlLCBhY2Nlc3NvcikpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0O1xuICAgIGlmICghdW50YWludGVkQWNjZXNzb3IpIHJldHVybiBpbnN0YW5jZVthY2Nlc3Nvcl07XG4gICAgdW50YWludGVkQWNjZXNzb3JDYWNoZSQxW2NhY2hlS2V5XSA9IHVudGFpbnRlZEFjY2Vzc29yO1xuICAgIHJldHVybiB1bnRhaW50ZWRBY2Nlc3Nvci5jYWxsKGluc3RhbmNlKTtcbn1cbnZhciB1bnRhaW50ZWRNZXRob2RDYWNoZSQxID0ge307XG5mdW5jdGlvbiBnZXRVbnRhaW50ZWRNZXRob2QkMShrZXksIGluc3RhbmNlLCBtZXRob2QpIHtcbiAgICB2YXIgY2FjaGVLZXkgPSBrZXkgKyBcIi5cIiArIFN0cmluZyhtZXRob2QpO1xuICAgIGlmICh1bnRhaW50ZWRNZXRob2RDYWNoZSQxW2NhY2hlS2V5XSkgcmV0dXJuIHVudGFpbnRlZE1ldGhvZENhY2hlJDFbY2FjaGVLZXldLmJpbmQoaW5zdGFuY2UpO1xuICAgIHZhciB1bnRhaW50ZWRQcm90b3R5cGUgPSBnZXRVbnRhaW50ZWRQcm90b3R5cGUkMShrZXkpO1xuICAgIHZhciB1bnRhaW50ZWRNZXRob2QgPSB1bnRhaW50ZWRQcm90b3R5cGVbbWV0aG9kXTtcbiAgICBpZiAodHlwZW9mIHVudGFpbnRlZE1ldGhvZCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gaW5zdGFuY2VbbWV0aG9kXTtcbiAgICB1bnRhaW50ZWRNZXRob2RDYWNoZSQxW2NhY2hlS2V5XSA9IHVudGFpbnRlZE1ldGhvZDtcbiAgICByZXR1cm4gdW50YWludGVkTWV0aG9kLmJpbmQoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gY2hpbGROb2RlcyQxKG4yKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJOb2RlXCIsIG4yLCBcImNoaWxkTm9kZXNcIik7XG59XG5mdW5jdGlvbiBwYXJlbnROb2RlJDEobjIpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IkMShcIk5vZGVcIiwgbjIsIFwicGFyZW50Tm9kZVwiKTtcbn1cbmZ1bmN0aW9uIHBhcmVudEVsZW1lbnQkMShuMikge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiTm9kZVwiLCBuMiwgXCJwYXJlbnRFbGVtZW50XCIpO1xufVxuZnVuY3Rpb24gdGV4dENvbnRlbnQkMShuMikge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiTm9kZVwiLCBuMiwgXCJ0ZXh0Q29udGVudFwiKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zJDEobjIsIG90aGVyKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZE1ldGhvZCQxKFwiTm9kZVwiLCBuMiwgXCJjb250YWluc1wiKShvdGhlcik7XG59XG5mdW5jdGlvbiBnZXRSb290Tm9kZSQxKG4yKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZE1ldGhvZCQxKFwiTm9kZVwiLCBuMiwgXCJnZXRSb290Tm9kZVwiKSgpO1xufVxuZnVuY3Rpb24gaG9zdCQxKG4yKSB7XG4gICAgaWYgKCFuMiB8fCAhKFwiaG9zdFwiIGluIG4yKSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJTaGFkb3dSb290XCIsIG4yLCBcImhvc3RcIik7XG59XG5mdW5jdGlvbiBzdHlsZVNoZWV0cyQxKG4yKSB7XG4gICAgcmV0dXJuIG4yLnN0eWxlU2hlZXRzO1xufVxuZnVuY3Rpb24gc2hhZG93Um9vdCQxKG4yKSB7XG4gICAgaWYgKCFuMiB8fCAhKFwic2hhZG93Um9vdFwiIGluIG4yKSkgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yJDEoXCJFbGVtZW50XCIsIG4yLCBcInNoYWRvd1Jvb3RcIik7XG59XG5mdW5jdGlvbiBxdWVyeVNlbGVjdG9yJDEobjIsIHNlbGVjdG9ycykge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiRWxlbWVudFwiLCBuMiwgXCJxdWVyeVNlbGVjdG9yXCIpKHNlbGVjdG9ycyk7XG59XG5mdW5jdGlvbiBxdWVyeVNlbGVjdG9yQWxsJDEobjIsIHNlbGVjdG9ycykge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvciQxKFwiRWxlbWVudFwiLCBuMiwgXCJxdWVyeVNlbGVjdG9yQWxsXCIpKHNlbGVjdG9ycyk7XG59XG5mdW5jdGlvbiBtdXRhdGlvbk9ic2VydmVyQ3RvciQxKCkge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRQcm90b3R5cGUkMShcIk11dGF0aW9uT2JzZXJ2ZXJcIikuY29uc3RydWN0b3I7XG59XG52YXIgaW5kZXgkMSA9IHtcbiAgICBjaGlsZE5vZGVzOiBjaGlsZE5vZGVzJDEsXG4gICAgcGFyZW50Tm9kZTogcGFyZW50Tm9kZSQxLFxuICAgIHBhcmVudEVsZW1lbnQ6IHBhcmVudEVsZW1lbnQkMSxcbiAgICB0ZXh0Q29udGVudDogdGV4dENvbnRlbnQkMSxcbiAgICBjb250YWluczogY29udGFpbnMkMSxcbiAgICBnZXRSb290Tm9kZTogZ2V0Um9vdE5vZGUkMSxcbiAgICBob3N0OiBob3N0JDEsXG4gICAgc3R5bGVTaGVldHM6IHN0eWxlU2hlZXRzJDEsXG4gICAgc2hhZG93Um9vdDogc2hhZG93Um9vdCQxLFxuICAgIHF1ZXJ5U2VsZWN0b3I6IHF1ZXJ5U2VsZWN0b3IkMSxcbiAgICBxdWVyeVNlbGVjdG9yQWxsOiBxdWVyeVNlbGVjdG9yQWxsJDEsXG4gICAgbXV0YXRpb25PYnNlcnZlcjogbXV0YXRpb25PYnNlcnZlckN0b3IkMVxufTtcbmZ1bmN0aW9uIGlzRWxlbWVudChuMikge1xuICAgIHJldHVybiBuMi5ub2RlVHlwZSA9PT0gbjIuRUxFTUVOVF9OT0RFO1xufVxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG4yKSB7XG4gICAgdmFyIGhvc3RFbCA9IC8vIGFuY2hvciBhbmQgdGV4dGFyZWEgZWxlbWVudHMgYWxzbyBoYXZlIGEgYGhvc3RgIHByb3BlcnR5XG4gICAgLy8gYnV0IG9ubHkgc2hhZG93IHJvb3RzIGhhdmUgYSBgbW9kZWAgcHJvcGVydHlcbiAgICBuMiAmJiBcImhvc3RcIiBpbiBuMiAmJiBcIm1vZGVcIiBpbiBuMiAmJiBpbmRleCQxLmhvc3QobjIpIHx8IG51bGw7XG4gICAgcmV0dXJuIEJvb2xlYW4oaG9zdEVsICYmIFwic2hhZG93Um9vdFwiIGluIGhvc3RFbCAmJiBpbmRleCQxLnNoYWRvd1Jvb3QoaG9zdEVsKSA9PT0gbjIpO1xufVxuZnVuY3Rpb24gaXNOYXRpdmVTaGFkb3dEb20oc2hhZG93Um9vdDIpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNoYWRvd1Jvb3QyKSA9PT0gXCJbb2JqZWN0IFNoYWRvd1Jvb3RdXCI7XG59XG5mdW5jdGlvbiBmaXhCcm93c2VyQ29tcGF0aWJpbGl0eUlzc3Vlc0luQ1NTKGNzc1RleHQpIHtcbiAgICBpZiAoY3NzVGV4dC5pbmNsdWRlcyhcIiBiYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XCIpICYmICFjc3NUZXh0LmluY2x1ZGVzKFwiIC13ZWJraXQtYmFja2dyb3VuZC1jbGlwOiB0ZXh0O1wiKSkge1xuICAgICAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKC9cXHNiYWNrZ3JvdW5kLWNsaXA6XFxzKnRleHQ7L2csIFwiIC13ZWJraXQtYmFja2dyb3VuZC1jbGlwOiB0ZXh0OyBiYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XCIpO1xuICAgIH1cbiAgICByZXR1cm4gY3NzVGV4dDtcbn1cbmZ1bmN0aW9uIGVzY2FwZUltcG9ydFN0YXRlbWVudChydWxlMikge1xuICAgIHZhciBjc3NUZXh0ID0gcnVsZTIuY3NzVGV4dDtcbiAgICBpZiAoY3NzVGV4dC5zcGxpdCgnXCInKS5sZW5ndGggPCAzKSByZXR1cm4gY3NzVGV4dDtcbiAgICB2YXIgc3RhdGVtZW50ID0gW1xuICAgICAgICBcIkBpbXBvcnRcIixcbiAgICAgICAgXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShydWxlMi5ocmVmKSArIFwiKVwiXG4gICAgXTtcbiAgICBpZiAocnVsZTIubGF5ZXJOYW1lID09PSBcIlwiKSB7XG4gICAgICAgIHN0YXRlbWVudC5wdXNoKFwibGF5ZXJcIik7XG4gICAgfSBlbHNlIGlmIChydWxlMi5sYXllck5hbWUpIHtcbiAgICAgICAgc3RhdGVtZW50LnB1c2goXCJsYXllcihcIiArIHJ1bGUyLmxheWVyTmFtZSArIFwiKVwiKTtcbiAgICB9XG4gICAgaWYgKHJ1bGUyLnN1cHBvcnRzVGV4dCkge1xuICAgICAgICBzdGF0ZW1lbnQucHVzaChcInN1cHBvcnRzKFwiICsgcnVsZTIuc3VwcG9ydHNUZXh0ICsgXCIpXCIpO1xuICAgIH1cbiAgICBpZiAocnVsZTIubWVkaWEubGVuZ3RoKSB7XG4gICAgICAgIHN0YXRlbWVudC5wdXNoKHJ1bGUyLm1lZGlhLm1lZGlhVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZW1lbnQuam9pbihcIiBcIikgKyBcIjtcIjtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlc2hlZXQoczIpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgcnVsZXMyID0gczIucnVsZXMgfHwgczIuY3NzUnVsZXM7XG4gICAgICAgIGlmICghcnVsZXMyKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hlZXRIcmVmID0gczIuaHJlZjtcbiAgICAgICAgaWYgKCFzaGVldEhyZWYgJiYgczIub3duZXJOb2RlICYmIHMyLm93bmVyTm9kZS5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgICBzaGVldEhyZWYgPSBzMi5vd25lck5vZGUub3duZXJEb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJpbmdpZmllZFJ1bGVzID0gQXJyYXkuZnJvbShydWxlczIsIGZ1bmN0aW9uKHJ1bGUyKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5UnVsZShydWxlMiwgc2hlZXRIcmVmKTtcbiAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgICAgcmV0dXJuIGZpeEJyb3dzZXJDb21wYXRpYmlsaXR5SXNzdWVzSW5DU1Moc3RyaW5naWZpZWRSdWxlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RyaW5naWZ5UnVsZShydWxlMiwgc2hlZXRIcmVmKSB7XG4gICAgaWYgKGlzQ1NTSW1wb3J0UnVsZShydWxlMikpIHtcbiAgICAgICAgdmFyIGltcG9ydFN0cmluZ2lmaWVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW1wb3J0U3RyaW5naWZpZWQgPSAvLyB3ZSBjYW4gYWNjZXNzIHRoZSBpbXBvcnRlZCBzdHlsZXNoZWV0IHJ1bGVzIGRpcmVjdGx5XG4gICAgICAgICAgICBzdHJpbmdpZnlTdHlsZXNoZWV0KHJ1bGUyLnN0eWxlU2hlZXQpIHx8IC8vIHdvcmsgYXJvdW5kIGJyb3dzZXIgaXNzdWVzIHdpdGggdGhlIHJhdyBzdHJpbmcgYEBpbXBvcnQgdXJsKC4uLilgIHN0YXRlbWVudFxuICAgICAgICAgICAgZXNjYXBlSW1wb3J0U3RhdGVtZW50KHJ1bGUyKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGltcG9ydFN0cmluZ2lmaWVkID0gcnVsZTIuY3NzVGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocnVsZTIuc3R5bGVTaGVldC5ocmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gYWJzb2x1dGlmeVVSTHMoaW1wb3J0U3RyaW5naWZpZWQsIHJ1bGUyLnN0eWxlU2hlZXQuaHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGltcG9ydFN0cmluZ2lmaWVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBydWxlU3RyaW5naWZpZWQgPSBydWxlMi5jc3NUZXh0O1xuICAgICAgICBpZiAoaXNDU1NTdHlsZVJ1bGUocnVsZTIpICYmIHJ1bGUyLnNlbGVjdG9yVGV4dC5pbmNsdWRlcyhcIjpcIikpIHtcbiAgICAgICAgICAgIHJ1bGVTdHJpbmdpZmllZCA9IGZpeFNhZmFyaUNvbG9ucyhydWxlU3RyaW5naWZpZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGVldEhyZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBhYnNvbHV0aWZ5VVJMcyhydWxlU3RyaW5naWZpZWQsIHNoZWV0SHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bGVTdHJpbmdpZmllZDtcbiAgICB9XG59XG5mdW5jdGlvbiBmaXhTYWZhcmlDb2xvbnMoY3NzU3RyaW5naWZpZWQpIHtcbiAgICB2YXIgcmVnZXggPSAvKFxcWyg/OltcXHctXSspW15cXFxcXSkoOig/OltcXHctXSspXFxdKS9nbTtcbiAgICByZXR1cm4gY3NzU3RyaW5naWZpZWQucmVwbGFjZShyZWdleCwgXCIkMVxcXFwkMlwiKTtcbn1cbmZ1bmN0aW9uIGlzQ1NTSW1wb3J0UnVsZShydWxlMikge1xuICAgIHJldHVybiBcInN0eWxlU2hlZXRcIiBpbiBydWxlMjtcbn1cbmZ1bmN0aW9uIGlzQ1NTU3R5bGVSdWxlKHJ1bGUyKSB7XG4gICAgcmV0dXJuIFwic2VsZWN0b3JUZXh0XCIgaW4gcnVsZTI7XG59XG52YXIgTWlycm9yID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBNaXJyb3IoKSB7XG4gICAgICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImlkTm9kZU1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibm9kZU1ldGFNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gTWlycm9yLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZ2V0SWQgPSBmdW5jdGlvbiBnZXRJZChuMikge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBpZiAoIW4yKSByZXR1cm4gLTE7XG4gICAgICAgIHZhciBpZCA9IChfYTIgPSB0aGlzLmdldE1ldGEobjIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmlkO1xuICAgICAgICByZXR1cm4gaWQgIT0gbnVsbCA/IGlkIDogLTE7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0Tm9kZSA9IGZ1bmN0aW9uIGdldE5vZGUoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWROb2RlTWFwLmdldChpZCkgfHwgbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5nZXRJZHMgPSBmdW5jdGlvbiBnZXRJZHMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuaWROb2RlTWFwLmtleXMoKSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0TWV0YSA9IGZ1bmN0aW9uIGdldE1ldGEobjIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZU1ldGFNYXAuZ2V0KG4yKSB8fCBudWxsO1xuICAgIH07XG4gICAgLy8gcmVtb3ZlcyB0aGUgbm9kZSBmcm9tIGlkTm9kZU1hcFxuICAgIC8vIGRvZXNuJ3QgcmVtb3ZlIHRoZSBub2RlIGZyb20gbm9kZU1ldGFNYXBcbiAgICBfcHJvdG8ucmVtb3ZlTm9kZUZyb21NYXAgPSBmdW5jdGlvbiByZW1vdmVOb2RlRnJvbU1hcChuMikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmdldElkKG4yKTtcbiAgICAgICAgdGhpcy5pZE5vZGVNYXAuZGVsZXRlKGlkKTtcbiAgICAgICAgaWYgKG4yLmNoaWxkTm9kZXMpIHtcbiAgICAgICAgICAgIG4yLmNoaWxkTm9kZXMuZm9yRWFjaChmdW5jdGlvbihjaGlsZE5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVtb3ZlTm9kZUZyb21NYXAoY2hpbGROb2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uaGFzID0gZnVuY3Rpb24gaGFzKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkTm9kZU1hcC5oYXMoaWQpO1xuICAgIH07XG4gICAgX3Byb3RvLmhhc05vZGUgPSBmdW5jdGlvbiBoYXNOb2RlKG5vZGUyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVNZXRhTWFwLmhhcyhub2RlMik7XG4gICAgfTtcbiAgICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKG4yLCBtZXRhKSB7XG4gICAgICAgIHZhciBpZCA9IG1ldGEuaWQ7XG4gICAgICAgIHRoaXMuaWROb2RlTWFwLnNldChpZCwgbjIpO1xuICAgICAgICB0aGlzLm5vZGVNZXRhTWFwLnNldChuMiwgbWV0YSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVwbGFjZSA9IGZ1bmN0aW9uIHJlcGxhY2UoaWQsIG4yKSB7XG4gICAgICAgIHZhciBvbGROb2RlID0gdGhpcy5nZXROb2RlKGlkKTtcbiAgICAgICAgaWYgKG9sZE5vZGUpIHtcbiAgICAgICAgICAgIHZhciBtZXRhID0gdGhpcy5ub2RlTWV0YU1hcC5nZXQob2xkTm9kZSk7XG4gICAgICAgICAgICBpZiAobWV0YSkgdGhpcy5ub2RlTWV0YU1hcC5zZXQobjIsIG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWROb2RlTWFwLnNldChpZCwgbjIpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuaWROb2RlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5ub2RlTWV0YU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgIH07XG4gICAgcmV0dXJuIE1pcnJvcjtcbn0oKTtcbmZ1bmN0aW9uIGNyZWF0ZU1pcnJvciQyKCkge1xuICAgIHJldHVybiBuZXcgTWlycm9yKCk7XG59XG5mdW5jdGlvbiBtYXNrSW5wdXRWYWx1ZShwYXJhbSkge1xuICAgIHZhciBlbGVtZW50ID0gcGFyYW0uZWxlbWVudCwgbWFza0lucHV0T3B0aW9ucyA9IHBhcmFtLm1hc2tJbnB1dE9wdGlvbnMsIHRhZ05hbWUgPSBwYXJhbS50YWdOYW1lLCB0eXBlID0gcGFyYW0udHlwZSwgdmFsdWUgPSBwYXJhbS52YWx1ZSwgbWFza0lucHV0Rm4gPSBwYXJhbS5tYXNrSW5wdXRGbjtcbiAgICB2YXIgdGV4dCA9IHZhbHVlIHx8IFwiXCI7XG4gICAgdmFyIGFjdHVhbFR5cGUgPSB0eXBlICYmIHRvTG93ZXJDYXNlKHR5cGUpO1xuICAgIGlmIChtYXNrSW5wdXRPcHRpb25zW3RhZ05hbWUudG9Mb3dlckNhc2UoKV0gfHwgYWN0dWFsVHlwZSAmJiBtYXNrSW5wdXRPcHRpb25zW2FjdHVhbFR5cGVdKSB7XG4gICAgICAgIGlmIChtYXNrSW5wdXRGbikge1xuICAgICAgICAgICAgdGV4dCA9IG1hc2tJbnB1dEZuKHRleHQsIGVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dCA9IFwiKlwiLnJlcGVhdCh0ZXh0Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG59XG5mdW5jdGlvbiB0b0xvd2VyQ2FzZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG59XG52YXIgT1JJR0lOQUxfQVRUUklCVVRFX05BTUUgPSBcIl9fcnJ3ZWJfb3JpZ2luYWxfX1wiO1xuZnVuY3Rpb24gaXMyRENhbnZhc0JsYW5rKGNhbnZhcykge1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGlmICghY3R4KSByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgY2h1bmtTaXplID0gNTA7XG4gICAgZm9yKHZhciB4MiA9IDA7IHgyIDwgY2FudmFzLndpZHRoOyB4MiArPSBjaHVua1NpemUpe1xuICAgICAgICBmb3IodmFyIHkgPSAwOyB5IDwgY2FudmFzLmhlaWdodDsgeSArPSBjaHVua1NpemUpe1xuICAgICAgICAgICAgdmFyIGdldEltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGE7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxHZXRJbWFnZURhdGEgPSBPUklHSU5BTF9BVFRSSUJVVEVfTkFNRSBpbiBnZXRJbWFnZURhdGEgPyBnZXRJbWFnZURhdGFbT1JJR0lOQUxfQVRUUklCVVRFX05BTUVdIDogZ2V0SW1hZ2VEYXRhO1xuICAgICAgICAgICAgdmFyIHBpeGVsQnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgIG9yaWdpbmFsR2V0SW1hZ2VEYXRhLmNhbGwoY3R4LCB4MiwgeSwgTWF0aC5taW4oY2h1bmtTaXplLCBjYW52YXMud2lkdGggLSB4MiksIE1hdGgubWluKGNodW5rU2l6ZSwgY2FudmFzLmhlaWdodCAtIHkpKS5kYXRhLmJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAocGl4ZWxCdWZmZXIuc29tZShmdW5jdGlvbihwaXhlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwaXhlbCAhPT0gMDtcbiAgICAgICAgICAgIH0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRJbnB1dFR5cGUoZWxlbWVudCkge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZShcImRhdGEtcnItaXMtcGFzc3dvcmRcIikgPyBcInBhc3N3b3JkXCIgOiB0eXBlID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS10eXBlLWFzc2VydGlvblxuICAgIHRvTG93ZXJDYXNlKHR5cGUpIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RGaWxlRXh0ZW5zaW9uKHBhdGgsIGJhc2VVUkwpIHtcbiAgICB2YXIgdXJsO1xuICAgIHRyeSB7XG4gICAgICAgIHVybCA9IG5ldyBVUkwocGF0aCwgYmFzZVVSTCAhPSBudWxsID8gYmFzZVVSTCA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciByZWdleCA9IC9cXC4oWzAtOWEtel0rKSg/OiQpL2k7XG4gICAgdmFyIG1hdGNoID0gdXJsLnBhdGhuYW1lLm1hdGNoKHJlZ2V4KTtcbiAgICB2YXIgX3JlZjtcbiAgICByZXR1cm4gKF9yZWYgPSBtYXRjaCA9PSBudWxsID8gdm9pZCAwIDogbWF0Y2hbMV0pICE9IG51bGwgPyBfcmVmIDogbnVsbDtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RPcmlnaW4odXJsKSB7XG4gICAgdmFyIG9yaWdpbiA9IFwiXCI7XG4gICAgaWYgKHVybC5pbmRleE9mKFwiLy9cIikgPiAtMSkge1xuICAgICAgICBvcmlnaW4gPSB1cmwuc3BsaXQoXCIvXCIpLnNsaWNlKDAsIDMpLmpvaW4oXCIvXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9yaWdpbiA9IHVybC5zcGxpdChcIi9cIilbMF07XG4gICAgfVxuICAgIG9yaWdpbiA9IG9yaWdpbi5zcGxpdChcIj9cIilbMF07XG4gICAgcmV0dXJuIG9yaWdpbjtcbn1cbnZhciBVUkxfSU5fQ1NTX1JFRiA9IC91cmxcXCgoPzooJykoW14nXSopJ3woXCIpKC4qPylcInwoW14pXSopKVxcKS9nbTtcbnZhciBVUkxfUFJPVE9DT0xfTUFUQ0ggPSAvXig/OlthLXorXSs6KT9cXC9cXC8vaTtcbnZhciBVUkxfV1dXX01BVENIID0gL153d3dcXC4uKi9pO1xudmFyIERBVEFfVVJJID0gL14oZGF0YTopKFteLF0qKSwoLiopL2k7XG5mdW5jdGlvbiBhYnNvbHV0aWZ5VVJMcyhjc3NUZXh0LCBocmVmKSB7XG4gICAgcmV0dXJuIChjc3NUZXh0IHx8IFwiXCIpLnJlcGxhY2UoVVJMX0lOX0NTU19SRUYsIGZ1bmN0aW9uKG9yaWdpbiwgcXVvdGUxLCBwYXRoMSwgcXVvdGUyLCBwYXRoMiwgcGF0aDMpIHtcbiAgICAgICAgdmFyIGZpbGVQYXRoID0gcGF0aDEgfHwgcGF0aDIgfHwgcGF0aDM7XG4gICAgICAgIHZhciBtYXliZVF1b3RlID0gcXVvdGUxIHx8IHF1b3RlMiB8fCBcIlwiO1xuICAgICAgICBpZiAoIWZpbGVQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIGlmIChVUkxfUFJPVE9DT0xfTUFUQ0gudGVzdChmaWxlUGF0aCkgfHwgVVJMX1dXV19NQVRDSC50ZXN0KGZpbGVQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwidXJsKFwiICsgbWF5YmVRdW90ZSArIGZpbGVQYXRoICsgbWF5YmVRdW90ZSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChEQVRBX1VSSS50ZXN0KGZpbGVQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwidXJsKFwiICsgbWF5YmVRdW90ZSArIGZpbGVQYXRoICsgbWF5YmVRdW90ZSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxlUGF0aFswXSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBcInVybChcIiArIG1heWJlUXVvdGUgKyAoZXh0cmFjdE9yaWdpbihocmVmKSArIGZpbGVQYXRoKSArIG1heWJlUXVvdGUgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhY2sgPSBocmVmLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgdmFyIHBhcnRzID0gZmlsZVBhdGguc3BsaXQoXCIvXCIpO1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UocGFydHMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgcGFydCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHBhcnQgPT09IFwiLlwiKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09IFwiLi5cIikge1xuICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcInVybChcIiArIG1heWJlUXVvdGUgKyBzdGFjay5qb2luKFwiL1wiKSArIG1heWJlUXVvdGUgKyBcIilcIjtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNzc1N0cmluZyhjc3NUZXh0KSB7XG4gICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZSgvKFxcL1xcKlteKl0qXFwqXFwvKXxbXFxzO10vZywgXCJcIik7XG59XG5mdW5jdGlvbiBzcGxpdENzc1RleHQoY3NzVGV4dCwgc3R5bGUpIHtcbiAgICB2YXIgY2hpbGROb2RlczIgPSBBcnJheS5mcm9tKHN0eWxlLmNoaWxkTm9kZXMpO1xuICAgIHZhciBzcGxpdHMgPSBbXTtcbiAgICBpZiAoY2hpbGROb2RlczIubGVuZ3RoID4gMSAmJiBjc3NUZXh0ICYmIHR5cGVvZiBjc3NUZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBjc3NUZXh0Tm9ybSA9IG5vcm1hbGl6ZUNzc1N0cmluZyhjc3NUZXh0KTtcbiAgICAgICAgZm9yKHZhciBpMiA9IDE7IGkyIDwgY2hpbGROb2RlczIubGVuZ3RoOyBpMisrKXtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGVzMltpMl0udGV4dENvbnRlbnQgJiYgdHlwZW9mIGNoaWxkTm9kZXMyW2kyXS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0Q29udGVudE5vcm0gPSBub3JtYWxpemVDc3NTdHJpbmcoY2hpbGROb2RlczJbaTJdLnRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAzOyBqIDwgdGV4dENvbnRlbnROb3JtLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpdCA9IHRleHRDb250ZW50Tm9ybS5zdWJzdHJpbmcoMCwgaik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjc3NUZXh0Tm9ybS5zcGxpdChiaXQpLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGl0Tm9ybSA9IGNzc1RleHROb3JtLmluZGV4T2YoYml0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgayA9IHNwbGl0Tm9ybTsgayA8IGNzc1RleHQubGVuZ3RoOyBrKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub3JtYWxpemVDc3NTdHJpbmcoY3NzVGV4dC5zdWJzdHJpbmcoMCwgaykpLmxlbmd0aCA9PT0gc3BsaXROb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0cy5wdXNoKGNzc1RleHQuc3Vic3RyaW5nKDAsIGspKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzVGV4dCA9IGNzc1RleHQuc3Vic3RyaW5nKGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzcGxpdHMucHVzaChjc3NUZXh0KTtcbiAgICByZXR1cm4gc3BsaXRzO1xufVxuZnVuY3Rpb24gbWFya0Nzc1NwbGl0cyhjc3NUZXh0LCBzdHlsZSkge1xuICAgIHJldHVybiBzcGxpdENzc1RleHQoY3NzVGV4dCwgc3R5bGUpLmpvaW4oXCIvKiBycl9zcGxpdCAqL1wiKTtcbn1cbnZhciBfaWQgPSAxO1xudmFyIHRhZ05hbWVSZWdleCA9IG5ldyBSZWdFeHAoXCJbXmEtejAtOS1fOl1cIik7XG52YXIgSUdOT1JFRF9OT0RFID0gLTI7XG5mdW5jdGlvbiBnZW5JZCgpIHtcbiAgICByZXR1cm4gX2lkKys7XG59XG5mdW5jdGlvbiBnZXRWYWxpZFRhZ05hbWUkMShlbGVtZW50KSB7XG4gICAgaWYgKF9pbnN0YW5jZW9mKGVsZW1lbnQsIEhUTUxGb3JtRWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIFwiZm9ybVwiO1xuICAgIH1cbiAgICB2YXIgcHJvY2Vzc2VkVGFnTmFtZSA9IHRvTG93ZXJDYXNlKGVsZW1lbnQudGFnTmFtZSk7XG4gICAgaWYgKHRhZ05hbWVSZWdleC50ZXN0KHByb2Nlc3NlZFRhZ05hbWUpKSB7XG4gICAgICAgIHJldHVybiBcImRpdlwiO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzc2VkVGFnTmFtZTtcbn1cbnZhciBjYW52YXNTZXJ2aWNlO1xudmFyIGNhbnZhc0N0eDtcbnZhciBTUkNTRVRfTk9UX1NQQUNFUyA9IC9eW14gXFx0XFxuXFxyXFx1MDAwY10rLztcbnZhciBTUkNTRVRfQ09NTUFTX09SX1NQQUNFUyA9IC9eWywgXFx0XFxuXFxyXFx1MDAwY10rLztcbmZ1bmN0aW9uIGdldEFic29sdXRlU3Jjc2V0U3RyaW5nKGRvYywgYXR0cmlidXRlVmFsdWUpIHtcbiAgICBpZiAoYXR0cmlidXRlVmFsdWUudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgZnVuY3Rpb24gY29sbGVjdENoYXJhY3RlcnMocmVnRXgpIHtcbiAgICAgICAgdmFyIGNoYXJzMjtcbiAgICAgICAgdmFyIG1hdGNoID0gcmVnRXguZXhlYyhhdHRyaWJ1dGVWYWx1ZS5zdWJzdHJpbmcocG9zKSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY2hhcnMyID0gbWF0Y2hbMF07XG4gICAgICAgICAgICBwb3MgKz0gY2hhcnMyLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBjaGFyczI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICB3aGlsZSh0cnVlKXtcbiAgICAgICAgY29sbGVjdENoYXJhY3RlcnMoU1JDU0VUX0NPTU1BU19PUl9TUEFDRVMpO1xuICAgICAgICBpZiAocG9zID49IGF0dHJpYnV0ZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVybCA9IGNvbGxlY3RDaGFyYWN0ZXJzKFNSQ1NFVF9OT1RfU1BBQ0VTKTtcbiAgICAgICAgaWYgKHVybC5zbGljZSgtMSkgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICB1cmwgPSBhYnNvbHV0ZVRvRG9jKGRvYywgdXJsLnN1YnN0cmluZygwLCB1cmwubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgb3V0cHV0LnB1c2godXJsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBkZXNjcmlwdG9yc1N0ciA9IFwiXCI7XG4gICAgICAgICAgICB1cmwgPSBhYnNvbHV0ZVRvRG9jKGRvYywgdXJsKTtcbiAgICAgICAgICAgIHZhciBpblBhcmVucyA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUodHJ1ZSl7XG4gICAgICAgICAgICAgICAgdmFyIGMyID0gYXR0cmlidXRlVmFsdWUuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKGMyID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCh1cmwgKyBkZXNjcmlwdG9yc1N0cikudHJpbSgpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaW5QYXJlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMyID09PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgodXJsICsgZGVzY3JpcHRvcnNTdHIpLnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjMiA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUGFyZW5zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjMiA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUGFyZW5zID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvcnNTdHIgKz0gYzI7XG4gICAgICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dC5qb2luKFwiLCBcIik7XG59XG52YXIgY2FjaGVkRG9jdW1lbnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGFic29sdXRlVG9Eb2MoZG9jLCBhdHRyaWJ1dGVWYWx1ZSkge1xuICAgIGlmICghYXR0cmlidXRlVmFsdWUgfHwgYXR0cmlidXRlVmFsdWUudHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEhyZWYoZG9jLCBhdHRyaWJ1dGVWYWx1ZSk7XG59XG5mdW5jdGlvbiBpc1NWR0VsZW1lbnQoZWwpIHtcbiAgICByZXR1cm4gQm9vbGVhbihlbC50YWdOYW1lID09PSBcInN2Z1wiIHx8IGVsLm93bmVyU1ZHRWxlbWVudCk7XG59XG5mdW5jdGlvbiBnZXRIcmVmKGRvYywgY3VzdG9tSHJlZikge1xuICAgIHZhciBhMiA9IGNhY2hlZERvY3VtZW50LmdldChkb2MpO1xuICAgIGlmICghYTIpIHtcbiAgICAgICAgYTIgPSBkb2MuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgIGNhY2hlZERvY3VtZW50LnNldChkb2MsIGEyKTtcbiAgICB9XG4gICAgaWYgKCFjdXN0b21IcmVmKSB7XG4gICAgICAgIGN1c3RvbUhyZWYgPSBcIlwiO1xuICAgIH0gZWxzZSBpZiAoY3VzdG9tSHJlZi5zdGFydHNXaXRoKFwiYmxvYjpcIikgfHwgY3VzdG9tSHJlZi5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICAgICAgcmV0dXJuIGN1c3RvbUhyZWY7XG4gICAgfVxuICAgIGEyLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgY3VzdG9tSHJlZik7XG4gICAgcmV0dXJuIGEyLmhyZWY7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1BdHRyaWJ1dGUoZG9jLCB0YWdOYW1lLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gXCJzcmNcIiB8fCBuYW1lID09PSBcImhyZWZcIiAmJiAhKHRhZ05hbWUgPT09IFwidXNlXCIgJiYgdmFsdWVbMF0gPT09IFwiI1wiKSkge1xuICAgICAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwieGxpbms6aHJlZlwiICYmIHZhbHVlWzBdICE9PSBcIiNcIikge1xuICAgICAgICByZXR1cm4gYWJzb2x1dGVUb0RvYyhkb2MsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwiYmFja2dyb3VuZFwiICYmICh0YWdOYW1lID09PSBcInRhYmxlXCIgfHwgdGFnTmFtZSA9PT0gXCJ0ZFwiIHx8IHRhZ05hbWUgPT09IFwidGhcIikpIHtcbiAgICAgICAgcmV0dXJuIGFic29sdXRlVG9Eb2MoZG9jLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSBcInNyY3NldFwiKSB7XG4gICAgICAgIHJldHVybiBnZXRBYnNvbHV0ZVNyY3NldFN0cmluZyhkb2MsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwic3R5bGVcIikge1xuICAgICAgICByZXR1cm4gYWJzb2x1dGlmeVVSTHModmFsdWUsIGdldEhyZWYoZG9jKSk7XG4gICAgfSBlbHNlIGlmICh0YWdOYW1lID09PSBcIm9iamVjdFwiICYmIG5hbWUgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBpZ25vcmVBdHRyaWJ1dGUodGFnTmFtZSwgbmFtZSwgX3ZhbHVlKSB7XG4gICAgcmV0dXJuICh0YWdOYW1lID09PSBcInZpZGVvXCIgfHwgdGFnTmFtZSA9PT0gXCJhdWRpb1wiKSAmJiBuYW1lID09PSBcImF1dG9wbGF5XCI7XG59XG5mdW5jdGlvbiBfaXNCbG9ja2VkRWxlbWVudChlbGVtZW50LCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBibG9ja0NsYXNzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoYmxvY2tDbGFzcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcih2YXIgZUluZGV4ID0gZWxlbWVudC5jbGFzc0xpc3QubGVuZ3RoOyBlSW5kZXgtLTspe1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTGlzdFtlSW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChibG9ja0NsYXNzLnRlc3QoY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoYmxvY2tTZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlMikge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjbGFzc01hdGNoZXNSZWdleChub2RlMiwgcmVnZXgsIGNoZWNrQW5jZXN0b3JzKSB7XG4gICAgaWYgKCFub2RlMikgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChub2RlMi5ub2RlVHlwZSAhPT0gbm9kZTIuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGlmICghY2hlY2tBbmNlc3RvcnMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGNsYXNzTWF0Y2hlc1JlZ2V4KGluZGV4JDEucGFyZW50Tm9kZShub2RlMiksIHJlZ2V4LCBjaGVja0FuY2VzdG9ycyk7XG4gICAgfVxuICAgIGZvcih2YXIgZUluZGV4ID0gbm9kZTIuY2xhc3NMaXN0Lmxlbmd0aDsgZUluZGV4LS07KXtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IG5vZGUyLmNsYXNzTGlzdFtlSW5kZXhdO1xuICAgICAgICBpZiAocmVnZXgudGVzdChjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNoZWNrQW5jZXN0b3JzKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGNsYXNzTWF0Y2hlc1JlZ2V4KGluZGV4JDEucGFyZW50Tm9kZShub2RlMiksIHJlZ2V4LCBjaGVja0FuY2VzdG9ycyk7XG59XG5mdW5jdGlvbiBuZWVkTWFza2luZ1RleHQobm9kZTIsIG1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0U2VsZWN0b3IsIGNoZWNrQW5jZXN0b3JzKSB7XG4gICAgdmFyIGVsO1xuICAgIGlmIChpc0VsZW1lbnQobm9kZTIpKSB7XG4gICAgICAgIGVsID0gbm9kZTI7XG4gICAgICAgIGlmICghaW5kZXgkMS5jaGlsZE5vZGVzKGVsKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5kZXgkMS5wYXJlbnRFbGVtZW50KG5vZGUyKSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZWwgPSBpbmRleCQxLnBhcmVudEVsZW1lbnQobm9kZTIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIG1hc2tUZXh0Q2xhc3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChjaGVja0FuY2VzdG9ycykge1xuICAgICAgICAgICAgICAgIGlmIChlbC5jbG9zZXN0KFwiLlwiICsgbWFza1RleHRDbGFzcykpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG1hc2tUZXh0Q2xhc3MpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjbGFzc01hdGNoZXNSZWdleChlbCwgbWFza1RleHRDbGFzcywgY2hlY2tBbmNlc3RvcnMpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFza1RleHRTZWxlY3Rvcikge1xuICAgICAgICAgICAgaWYgKGNoZWNrQW5jZXN0b3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLmNsb3Nlc3QobWFza1RleHRTZWxlY3RvcikpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZWwubWF0Y2hlcyhtYXNrVGV4dFNlbGVjdG9yKSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlMikge31cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBvbmNlSWZyYW1lTG9hZGVkKGlmcmFtZUVsLCBsaXN0ZW5lciwgaWZyYW1lTG9hZFRpbWVvdXQpIHtcbiAgICB2YXIgd2luID0gaWZyYW1lRWwuY29udGVudFdpbmRvdztcbiAgICBpZiAoIXdpbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBmaXJlZCA9IGZhbHNlO1xuICAgIHZhciByZWFkeVN0YXRlO1xuICAgIHRyeSB7XG4gICAgICAgIHJlYWR5U3RhdGUgPSB3aW4uZG9jdW1lbnQucmVhZHlTdGF0ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZWFkeVN0YXRlICE9PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghZmlyZWQpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaWZyYW1lTG9hZFRpbWVvdXQpO1xuICAgICAgICBpZnJhbWVFbC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICBmaXJlZCA9IHRydWU7XG4gICAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYmxhbmtVcmwgPSBcImFib3V0OmJsYW5rXCI7XG4gICAgaWYgKHdpbi5sb2NhdGlvbi5ocmVmICE9PSBibGFua1VybCB8fCBpZnJhbWVFbC5zcmMgPT09IGJsYW5rVXJsIHx8IGlmcmFtZUVsLnNyYyA9PT0gXCJcIikge1xuICAgICAgICBzZXRUaW1lb3V0KGxpc3RlbmVyLCAwKTtcbiAgICAgICAgcmV0dXJuIGlmcmFtZUVsLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgaWZyYW1lRWwuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgbGlzdGVuZXIpO1xufVxuZnVuY3Rpb24gb25jZVN0eWxlc2hlZXRMb2FkZWQobGluaywgbGlzdGVuZXIsIHN0eWxlU2hlZXRMb2FkVGltZW91dCkge1xuICAgIHZhciBmaXJlZCA9IGZhbHNlO1xuICAgIHZhciBzdHlsZVNoZWV0TG9hZGVkO1xuICAgIHRyeSB7XG4gICAgICAgIHN0eWxlU2hlZXRMb2FkZWQgPSBsaW5rLnNoZWV0O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHN0eWxlU2hlZXRMb2FkZWQpIHJldHVybjtcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIWZpcmVkKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSwgc3R5bGVTaGVldExvYWRUaW1lb3V0KTtcbiAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICBmaXJlZCA9IHRydWU7XG4gICAgICAgIGxpc3RlbmVyKCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVOb2RlKG4yLCBvcHRpb25zKSB7XG4gICAgdmFyIGRvYyA9IG9wdGlvbnMuZG9jLCBtaXJyb3IyID0gb3B0aW9ucy5taXJyb3IsIGJsb2NrQ2xhc3MgPSBvcHRpb25zLmJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IgPSBvcHRpb25zLmJsb2NrU2VsZWN0b3IsIG5lZWRzTWFzayA9IG9wdGlvbnMubmVlZHNNYXNrLCBpbmxpbmVTdHlsZXNoZWV0ID0gb3B0aW9ucy5pbmxpbmVTdHlsZXNoZWV0LCBfb3B0aW9uc19tYXNrSW5wdXRPcHRpb25zID0gb3B0aW9ucy5tYXNrSW5wdXRPcHRpb25zLCBtYXNrSW5wdXRPcHRpb25zID0gX29wdGlvbnNfbWFza0lucHV0T3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfb3B0aW9uc19tYXNrSW5wdXRPcHRpb25zLCBtYXNrVGV4dEZuID0gb3B0aW9ucy5tYXNrVGV4dEZuLCBtYXNrSW5wdXRGbiA9IG9wdGlvbnMubWFza0lucHV0Rm4sIF9vcHRpb25zX2RhdGFVUkxPcHRpb25zID0gb3B0aW9ucy5kYXRhVVJMT3B0aW9ucywgZGF0YVVSTE9wdGlvbnMgPSBfb3B0aW9uc19kYXRhVVJMT3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfb3B0aW9uc19kYXRhVVJMT3B0aW9ucywgaW5saW5lSW1hZ2VzID0gb3B0aW9ucy5pbmxpbmVJbWFnZXMsIHJlY29yZENhbnZhcyA9IG9wdGlvbnMucmVjb3JkQ2FudmFzLCBrZWVwSWZyYW1lU3JjRm4gPSBvcHRpb25zLmtlZXBJZnJhbWVTcmNGbiwgX29wdGlvbnNfbmV3bHlBZGRlZEVsZW1lbnQgPSBvcHRpb25zLm5ld2x5QWRkZWRFbGVtZW50LCBuZXdseUFkZGVkRWxlbWVudCA9IF9vcHRpb25zX25ld2x5QWRkZWRFbGVtZW50ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zX25ld2x5QWRkZWRFbGVtZW50LCBfb3B0aW9uc19jc3NDYXB0dXJlZCA9IG9wdGlvbnMuY3NzQ2FwdHVyZWQsIGNzc0NhcHR1cmVkID0gX29wdGlvbnNfY3NzQ2FwdHVyZWQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfY3NzQ2FwdHVyZWQ7XG4gICAgdmFyIHJvb3RJZCA9IGdldFJvb3RJZChkb2MsIG1pcnJvcjIpO1xuICAgIHN3aXRjaChuMi5ub2RlVHlwZSl7XG4gICAgICAgIGNhc2UgbjIuRE9DVU1FTlRfTk9ERTpcbiAgICAgICAgICAgIGlmIChuMi5jb21wYXRNb2RlICE9PSBcIkNTUzFDb21wYXRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlJDMuRG9jdW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBjb21wYXRNb2RlOiBuMi5jb21wYXRNb2RlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUkMy5Eb2N1bWVudCxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlczogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIG4yLkRPQ1VNRU5UX1RZUEVfTk9ERTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogTm9kZVR5cGUkMy5Eb2N1bWVudFR5cGUsXG4gICAgICAgICAgICAgICAgbmFtZTogbjIubmFtZSxcbiAgICAgICAgICAgICAgICBwdWJsaWNJZDogbjIucHVibGljSWQsXG4gICAgICAgICAgICAgICAgc3lzdGVtSWQ6IG4yLnN5c3RlbUlkLFxuICAgICAgICAgICAgICAgIHJvb3RJZDogcm9vdElkXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIG4yLkVMRU1FTlRfTk9ERTpcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVFbGVtZW50Tm9kZShuMiwge1xuICAgICAgICAgICAgICAgIGRvYzogZG9jLFxuICAgICAgICAgICAgICAgIGJsb2NrQ2xhc3M6IGJsb2NrQ2xhc3MsXG4gICAgICAgICAgICAgICAgYmxvY2tTZWxlY3RvcjogYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0OiBpbmxpbmVTdHlsZXNoZWV0LFxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgbWFza0lucHV0Rm46IG1hc2tJbnB1dEZuLFxuICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zOiBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpbmxpbmVJbWFnZXM6IGlubGluZUltYWdlcyxcbiAgICAgICAgICAgICAgICByZWNvcmRDYW52YXM6IHJlY29yZENhbnZhcyxcbiAgICAgICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm46IGtlZXBJZnJhbWVTcmNGbixcbiAgICAgICAgICAgICAgICBuZXdseUFkZGVkRWxlbWVudDogbmV3bHlBZGRlZEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgcm9vdElkOiByb290SWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBjYXNlIG4yLlRFWFRfTk9ERTpcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVUZXh0Tm9kZShuMiwge1xuICAgICAgICAgICAgICAgIGRvYzogZG9jLFxuICAgICAgICAgICAgICAgIG5lZWRzTWFzazogbmVlZHNNYXNrLFxuICAgICAgICAgICAgICAgIG1hc2tUZXh0Rm46IG1hc2tUZXh0Rm4sXG4gICAgICAgICAgICAgICAgcm9vdElkOiByb290SWQsXG4gICAgICAgICAgICAgICAgY3NzQ2FwdHVyZWQ6IGNzc0NhcHR1cmVkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSBuMi5DREFUQV9TRUNUSU9OX05PREU6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlJDMuQ0RBVEEsXG4gICAgICAgICAgICAgICAgdGV4dENvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgcm9vdElkOiByb290SWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgbjIuQ09NTUVOVF9OT0RFOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZSQzLkNvbW1lbnQsXG4gICAgICAgICAgICAgICAgdGV4dENvbnRlbnQ6IGluZGV4JDEudGV4dENvbnRlbnQobjIpIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgcm9vdElkOiByb290SWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Um9vdElkKGRvYywgbWlycm9yMikge1xuICAgIGlmICghbWlycm9yMi5oYXNOb2RlKGRvYykpIHJldHVybiB2b2lkIDA7XG4gICAgdmFyIGRvY0lkID0gbWlycm9yMi5nZXRJZChkb2MpO1xuICAgIHJldHVybiBkb2NJZCA9PT0gMSA/IHZvaWQgMCA6IGRvY0lkO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplVGV4dE5vZGUobjIsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmVlZHNNYXNrID0gb3B0aW9ucy5uZWVkc01hc2ssIG1hc2tUZXh0Rm4gPSBvcHRpb25zLm1hc2tUZXh0Rm4sIHJvb3RJZCA9IG9wdGlvbnMucm9vdElkLCBjc3NDYXB0dXJlZCA9IG9wdGlvbnMuY3NzQ2FwdHVyZWQ7XG4gICAgdmFyIHBhcmVudCA9IGluZGV4JDEucGFyZW50Tm9kZShuMik7XG4gICAgdmFyIHBhcmVudFRhZ05hbWUgPSBwYXJlbnQgJiYgcGFyZW50LnRhZ05hbWU7XG4gICAgdmFyIHRleHRDb250ZW50MiA9IFwiXCI7XG4gICAgdmFyIGlzU3R5bGUgPSBwYXJlbnRUYWdOYW1lID09PSBcIlNUWUxFXCIgPyB0cnVlIDogdm9pZCAwO1xuICAgIHZhciBpc1NjcmlwdCA9IHBhcmVudFRhZ05hbWUgPT09IFwiU0NSSVBUXCIgPyB0cnVlIDogdm9pZCAwO1xuICAgIGlmIChpc1NjcmlwdCkge1xuICAgICAgICB0ZXh0Q29udGVudDIgPSBcIlNDUklQVF9QTEFDRUhPTERFUlwiO1xuICAgIH0gZWxzZSBpZiAoIWNzc0NhcHR1cmVkKSB7XG4gICAgICAgIHRleHRDb250ZW50MiA9IGluZGV4JDEudGV4dENvbnRlbnQobjIpO1xuICAgICAgICBpZiAoaXNTdHlsZSAmJiB0ZXh0Q29udGVudDIpIHtcbiAgICAgICAgICAgIHRleHRDb250ZW50MiA9IGFic29sdXRpZnlVUkxzKHRleHRDb250ZW50MiwgZ2V0SHJlZihvcHRpb25zLmRvYykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNTdHlsZSAmJiAhaXNTY3JpcHQgJiYgdGV4dENvbnRlbnQyICYmIG5lZWRzTWFzaykge1xuICAgICAgICB0ZXh0Q29udGVudDIgPSBtYXNrVGV4dEZuID8gbWFza1RleHRGbih0ZXh0Q29udGVudDIsIGluZGV4JDEucGFyZW50RWxlbWVudChuMikpIDogdGV4dENvbnRlbnQyLnJlcGxhY2UoL1tcXFNdL2csIFwiKlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogTm9kZVR5cGUkMy5UZXh0LFxuICAgICAgICB0ZXh0Q29udGVudDogdGV4dENvbnRlbnQyIHx8IFwiXCIsXG4gICAgICAgIHJvb3RJZDogcm9vdElkXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVsZW1lbnROb2RlKG4yLCBvcHRpb25zKSB7XG4gICAgdmFyIGRvYyA9IG9wdGlvbnMuZG9jLCBibG9ja0NsYXNzID0gb3B0aW9ucy5ibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yID0gb3B0aW9ucy5ibG9ja1NlbGVjdG9yLCBpbmxpbmVTdHlsZXNoZWV0ID0gb3B0aW9ucy5pbmxpbmVTdHlsZXNoZWV0LCBfb3B0aW9uc19tYXNrSW5wdXRPcHRpb25zID0gb3B0aW9ucy5tYXNrSW5wdXRPcHRpb25zLCBtYXNrSW5wdXRPcHRpb25zID0gX29wdGlvbnNfbWFza0lucHV0T3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfb3B0aW9uc19tYXNrSW5wdXRPcHRpb25zLCBtYXNrSW5wdXRGbiA9IG9wdGlvbnMubWFza0lucHV0Rm4sIF9vcHRpb25zX2RhdGFVUkxPcHRpb25zID0gb3B0aW9ucy5kYXRhVVJMT3B0aW9ucywgZGF0YVVSTE9wdGlvbnMgPSBfb3B0aW9uc19kYXRhVVJMT3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfb3B0aW9uc19kYXRhVVJMT3B0aW9ucywgaW5saW5lSW1hZ2VzID0gb3B0aW9ucy5pbmxpbmVJbWFnZXMsIHJlY29yZENhbnZhcyA9IG9wdGlvbnMucmVjb3JkQ2FudmFzLCBrZWVwSWZyYW1lU3JjRm4gPSBvcHRpb25zLmtlZXBJZnJhbWVTcmNGbiwgX29wdGlvbnNfbmV3bHlBZGRlZEVsZW1lbnQgPSBvcHRpb25zLm5ld2x5QWRkZWRFbGVtZW50LCBuZXdseUFkZGVkRWxlbWVudCA9IF9vcHRpb25zX25ld2x5QWRkZWRFbGVtZW50ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zX25ld2x5QWRkZWRFbGVtZW50LCByb290SWQgPSBvcHRpb25zLnJvb3RJZDtcbiAgICB2YXIgbmVlZEJsb2NrID0gX2lzQmxvY2tlZEVsZW1lbnQobjIsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpO1xuICAgIHZhciB0YWdOYW1lID0gZ2V0VmFsaWRUYWdOYW1lJDEobjIpO1xuICAgIHZhciBhdHRyaWJ1dGVzID0ge307XG4gICAgdmFyIGxlbiA9IG4yLmF0dHJpYnV0ZXMubGVuZ3RoO1xuICAgIGZvcih2YXIgaTIgPSAwOyBpMiA8IGxlbjsgaTIrKyl7XG4gICAgICAgIHZhciBhdHRyID0gbjIuYXR0cmlidXRlc1tpMl07XG4gICAgICAgIGlmICghaWdub3JlQXR0cmlidXRlKHRhZ05hbWUsIGF0dHIubmFtZSwgYXR0ci52YWx1ZSkpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbYXR0ci5uYW1lXSA9IHRyYW5zZm9ybUF0dHJpYnV0ZShkb2MsIHRhZ05hbWUsIHRvTG93ZXJDYXNlKGF0dHIubmFtZSksIGF0dHIudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0YWdOYW1lID09PSBcImxpbmtcIiAmJiBpbmxpbmVTdHlsZXNoZWV0KSB7XG4gICAgICAgIHZhciBzdHlsZXNoZWV0ID0gQXJyYXkuZnJvbShkb2Muc3R5bGVTaGVldHMpLmZpbmQoZnVuY3Rpb24oczIpIHtcbiAgICAgICAgICAgIHJldHVybiBzMi5ocmVmID09PSBuMi5ocmVmO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNzc1RleHQgPSBudWxsO1xuICAgICAgICBpZiAoc3R5bGVzaGVldCkge1xuICAgICAgICAgICAgY3NzVGV4dCA9IHN0cmluZ2lmeVN0eWxlc2hlZXQoc3R5bGVzaGVldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNzc1RleHQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLnJlbDtcbiAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLmhyZWY7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLl9jc3NUZXh0ID0gY3NzVGV4dDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFnTmFtZSA9PT0gXCJzdHlsZVwiICYmIG4yLnNoZWV0KSB7XG4gICAgICAgIHZhciBjc3NUZXh0MSA9IHN0cmluZ2lmeVN0eWxlc2hlZXQobjIuc2hlZXQpO1xuICAgICAgICBpZiAoY3NzVGV4dDEpIHtcbiAgICAgICAgICAgIGlmIChuMi5jaGlsZE5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjc3NUZXh0MSA9IG1hcmtDc3NTcGxpdHMoY3NzVGV4dDEsIG4yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuX2Nzc1RleHQgPSBjc3NUZXh0MTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFnTmFtZSA9PT0gXCJpbnB1dFwiIHx8IHRhZ05hbWUgPT09IFwidGV4dGFyZWFcIiB8fCB0YWdOYW1lID09PSBcInNlbGVjdFwiKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG4yLnZhbHVlO1xuICAgICAgICB2YXIgY2hlY2tlZCA9IG4yLmNoZWNrZWQ7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzLnR5cGUgIT09IFwicmFkaW9cIiAmJiBhdHRyaWJ1dGVzLnR5cGUgIT09IFwiY2hlY2tib3hcIiAmJiBhdHRyaWJ1dGVzLnR5cGUgIT09IFwic3VibWl0XCIgJiYgYXR0cmlidXRlcy50eXBlICE9PSBcImJ1dHRvblwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnZhbHVlID0gbWFza0lucHV0VmFsdWUoe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IG4yLFxuICAgICAgICAgICAgICAgIHR5cGU6IGdldElucHV0VHlwZShuMiksXG4gICAgICAgICAgICAgICAgdGFnTmFtZTogdGFnTmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGNoZWNrZWQpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMuY2hlY2tlZCA9IGNoZWNrZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZ05hbWUgPT09IFwib3B0aW9uXCIpIHtcbiAgICAgICAgaWYgKG4yLnNlbGVjdGVkICYmICFtYXNrSW5wdXRPcHRpb25zW1wic2VsZWN0XCJdKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLnNlbGVjdGVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0YWdOYW1lID09PSBcImRpYWxvZ1wiICYmIG4yLm9wZW4pIHtcbiAgICAgICAgYXR0cmlidXRlcy5ycl9vcGVuX21vZGUgPSBuMi5tYXRjaGVzKFwiZGlhbG9nOm1vZGFsXCIpID8gXCJtb2RhbFwiIDogXCJub24tbW9kYWxcIjtcbiAgICB9XG4gICAgaWYgKHRhZ05hbWUgPT09IFwiY2FudmFzXCIgJiYgcmVjb3JkQ2FudmFzKSB7XG4gICAgICAgIGlmIChuMi5fX2NvbnRleHQgPT09IFwiMmRcIikge1xuICAgICAgICAgICAgaWYgKCFpczJEQ2FudmFzQmxhbmsobjIpKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5ycl9kYXRhVVJMID0gbjIudG9EYXRhVVJMKGRhdGFVUkxPcHRpb25zLnR5cGUsIGRhdGFVUkxPcHRpb25zLnF1YWxpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEoXCJfX2NvbnRleHRcIiBpbiBuMikpIHtcbiAgICAgICAgICAgIHZhciBjYW52YXNEYXRhVVJMID0gbjIudG9EYXRhVVJMKGRhdGFVUkxPcHRpb25zLnR5cGUsIGRhdGFVUkxPcHRpb25zLnF1YWxpdHkpO1xuICAgICAgICAgICAgdmFyIGJsYW5rQ2FudmFzID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgICAgICBibGFua0NhbnZhcy53aWR0aCA9IG4yLndpZHRoO1xuICAgICAgICAgICAgYmxhbmtDYW52YXMuaGVpZ2h0ID0gbjIuaGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGJsYW5rQ2FudmFzRGF0YVVSTCA9IGJsYW5rQ2FudmFzLnRvRGF0YVVSTChkYXRhVVJMT3B0aW9ucy50eXBlLCBkYXRhVVJMT3B0aW9ucy5xdWFsaXR5KTtcbiAgICAgICAgICAgIGlmIChjYW52YXNEYXRhVVJMICE9PSBibGFua0NhbnZhc0RhdGFVUkwpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX2RhdGFVUkwgPSBjYW52YXNEYXRhVVJMO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0YWdOYW1lID09PSBcImltZ1wiICYmIGlubGluZUltYWdlcykge1xuICAgICAgICBpZiAoIWNhbnZhc1NlcnZpY2UpIHtcbiAgICAgICAgICAgIGNhbnZhc1NlcnZpY2UgPSBkb2MuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgICAgIGNhbnZhc0N0eCA9IGNhbnZhc1NlcnZpY2UuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbWFnZSA9IG4yO1xuICAgICAgICB2YXIgaW1hZ2VTcmMgPSBpbWFnZS5jdXJyZW50U3JjIHx8IGltYWdlLmdldEF0dHJpYnV0ZShcInNyY1wiKSB8fCBcIjx1bmtub3duLXNyYz5cIjtcbiAgICAgICAgdmFyIHByaW9yQ3Jvc3NPcmlnaW4gPSBpbWFnZS5jcm9zc09yaWdpbjtcbiAgICAgICAgdmFyIHJlY29yZElubGluZUltYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCByZWNvcmRJbmxpbmVJbWFnZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbnZhc1NlcnZpY2Uud2lkdGggPSBpbWFnZS5uYXR1cmFsV2lkdGg7XG4gICAgICAgICAgICAgICAgY2FudmFzU2VydmljZS5oZWlnaHQgPSBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNhbnZhc0N0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDApO1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMucnJfZGF0YVVSTCA9IGNhbnZhc1NlcnZpY2UudG9EYXRhVVJMKGRhdGFVUkxPcHRpb25zLnR5cGUsIGRhdGFVUkxPcHRpb25zLnF1YWxpdHkpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlLmNyb3NzT3JpZ2luICE9PSBcImFub255bW91c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlLmNvbXBsZXRlICYmIGltYWdlLm5hdHVyYWxXaWR0aCAhPT0gMCkgcmVjb3JkSW5saW5lSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpbWFnZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCByZWNvcmRJbmxpbmVJbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDYW5ub3QgaW5saW5lIGltZyBzcmM9XCIgKyBpbWFnZVNyYyArIFwiISBFcnJvcjogXCIgKyBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbWFnZS5jcm9zc09yaWdpbiA9PT0gXCJhbm9ueW1vdXNcIikge1xuICAgICAgICAgICAgICAgIHByaW9yQ3Jvc3NPcmlnaW4gPyBhdHRyaWJ1dGVzLmNyb3NzT3JpZ2luID0gcHJpb3JDcm9zc09yaWdpbiA6IGltYWdlLnJlbW92ZUF0dHJpYnV0ZShcImNyb3Nzb3JpZ2luXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW1hZ2UuY29tcGxldGUgJiYgaW1hZ2UubmF0dXJhbFdpZHRoICE9PSAwKSByZWNvcmRJbmxpbmVJbWFnZSgpO1xuICAgICAgICBlbHNlIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHJlY29yZElubGluZUltYWdlKTtcbiAgICB9XG4gICAgaWYgKHRhZ05hbWUgPT09IFwiYXVkaW9cIiB8fCB0YWdOYW1lID09PSBcInZpZGVvXCIpIHtcbiAgICAgICAgdmFyIG1lZGlhQXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYVN0YXRlID0gbjIucGF1c2VkID8gXCJwYXVzZWRcIiA6IFwicGxheWVkXCI7XG4gICAgICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYUN1cnJlbnRUaW1lID0gbjIuY3VycmVudFRpbWU7XG4gICAgICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYVBsYXliYWNrUmF0ZSA9IG4yLnBsYXliYWNrUmF0ZTtcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhTXV0ZWQgPSBuMi5tdXRlZDtcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhTG9vcCA9IG4yLmxvb3A7XG4gICAgICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYVZvbHVtZSA9IG4yLnZvbHVtZTtcbiAgICB9XG4gICAgaWYgKCFuZXdseUFkZGVkRWxlbWVudCkge1xuICAgICAgICBpZiAobjIuc2Nyb2xsTGVmdCkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5ycl9zY3JvbGxMZWZ0ID0gbjIuc2Nyb2xsTGVmdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobjIuc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnJyX3Njcm9sbFRvcCA9IG4yLnNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobmVlZEJsb2NrKSB7XG4gICAgICAgIHZhciBfbjJfZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gbjIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHdpZHRoID0gX24yX2dldEJvdW5kaW5nQ2xpZW50UmVjdC53aWR0aCwgaGVpZ2h0ID0gX24yX2dldEJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQ7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICBjbGFzczogYXR0cmlidXRlcy5jbGFzcyxcbiAgICAgICAgICAgIHJyX3dpZHRoOiBcIlwiICsgd2lkdGggKyBcInB4XCIsXG4gICAgICAgICAgICBycl9oZWlnaHQ6IFwiXCIgKyBoZWlnaHQgKyBcInB4XCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRhZ05hbWUgPT09IFwiaWZyYW1lXCIgJiYgIWtlZXBJZnJhbWVTcmNGbihhdHRyaWJ1dGVzLnNyYykpIHtcbiAgICAgICAgaWYgKCFuMi5jb250ZW50RG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMucnJfc3JjID0gYXR0cmlidXRlcy5zcmM7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMuc3JjO1xuICAgIH1cbiAgICB2YXIgaXNDdXN0b21FbGVtZW50O1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpIGlzQ3VzdG9tRWxlbWVudCA9IHRydWU7XG4gICAgfSBjYXRjaCAoZTIpIHt9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogTm9kZVR5cGUkMy5FbGVtZW50LFxuICAgICAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgICAgICBjaGlsZE5vZGVzOiBbXSxcbiAgICAgICAgaXNTVkc6IGlzU1ZHRWxlbWVudChuMikgfHwgdm9pZCAwLFxuICAgICAgICBuZWVkQmxvY2s6IG5lZWRCbG9jayxcbiAgICAgICAgcm9vdElkOiByb290SWQsXG4gICAgICAgIGlzQ3VzdG9tOiBpc0N1c3RvbUVsZW1lbnRcbiAgICB9O1xufVxuZnVuY3Rpb24gbG93ZXJJZkV4aXN0cyhtYXliZUF0dHIpIHtcbiAgICBpZiAobWF5YmVBdHRyID09PSB2b2lkIDAgfHwgbWF5YmVBdHRyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBtYXliZUF0dHIudG9Mb3dlckNhc2UoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzbGltRE9NRXhjbHVkZWQoc24sIHNsaW1ET01PcHRpb25zKSB7XG4gICAgaWYgKHNsaW1ET01PcHRpb25zLmNvbW1lbnQgJiYgc24udHlwZSA9PT0gTm9kZVR5cGUkMy5Db21tZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoc24udHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50KSB7XG4gICAgICAgIGlmIChzbGltRE9NT3B0aW9ucy5zY3JpcHQgJiYgLy8gc2NyaXB0IHRhZ1xuICAgICAgICAoc24udGFnTmFtZSA9PT0gXCJzY3JpcHRcIiB8fCAvLyAobW9kdWxlKXByZWxvYWQgbGlua1xuICAgICAgICBzbi50YWdOYW1lID09PSBcImxpbmtcIiAmJiAoc24uYXR0cmlidXRlcy5yZWwgPT09IFwicHJlbG9hZFwiIHx8IHNuLmF0dHJpYnV0ZXMucmVsID09PSBcIm1vZHVsZXByZWxvYWRcIikgJiYgc24uYXR0cmlidXRlcy5hcyA9PT0gXCJzY3JpcHRcIiB8fCAvLyBwcmVmZXRjaCBsaW5rXG4gICAgICAgIHNuLnRhZ05hbWUgPT09IFwibGlua1wiICYmIHNuLmF0dHJpYnV0ZXMucmVsID09PSBcInByZWZldGNoXCIgJiYgdHlwZW9mIHNuLmF0dHJpYnV0ZXMuaHJlZiA9PT0gXCJzdHJpbmdcIiAmJiBleHRyYWN0RmlsZUV4dGVuc2lvbihzbi5hdHRyaWJ1dGVzLmhyZWYpID09PSBcImpzXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkRmF2aWNvbiAmJiAoc24udGFnTmFtZSA9PT0gXCJsaW5rXCIgJiYgc24uYXR0cmlidXRlcy5yZWwgPT09IFwic2hvcnRjdXQgaWNvblwiIHx8IHNuLnRhZ05hbWUgPT09IFwibWV0YVwiICYmIChsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkubWF0Y2goL15tc2FwcGxpY2F0aW9uLXRpbGUoaW1hZ2V8Y29sb3IpJC8pIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJhcHBsaWNhdGlvbi1uYW1lXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnJlbCkgPT09IFwiaWNvblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5yZWwpID09PSBcImFwcGxlLXRvdWNoLWljb25cIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucmVsKSA9PT0gXCJzaG9ydGN1dCBpY29uXCIpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoc24udGFnTmFtZSA9PT0gXCJtZXRhXCIpIHtcbiAgICAgICAgICAgIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YURlc2NLZXl3b3JkcyAmJiBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkubWF0Y2goL15kZXNjcmlwdGlvbnxrZXl3b3JkcyQvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YVNvY2lhbCAmJiAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnByb3BlcnR5KS5tYXRjaCgvXihvZ3x0d2l0dGVyfGZiKTovKSB8fCAvLyBvZyA9IG9wZW5ncmFwaCAoZmFjZWJvb2spXG4gICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkubWF0Y2goL14ob2d8dHdpdHRlcik6LykgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInBpbnRlcmVzdFwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YVJvYm90cyAmJiAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInJvYm90c1wiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJnb29nbGVib3RcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiYmluZ2JvdFwiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YUh0dHBFcXVpdiAmJiBzbi5hdHRyaWJ1dGVzW1wiaHR0cC1lcXVpdlwiXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhQXV0aG9yc2hpcCAmJiAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcImF1dGhvclwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJnZW5lcmF0b3JcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwiZnJhbWV3b3JrXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInB1Ymxpc2hlclwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJwcm9naWRcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucHJvcGVydHkpLm1hdGNoKC9eYXJ0aWNsZTovKSB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucHJvcGVydHkpLm1hdGNoKC9ecHJvZHVjdDovKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZE1ldGFWZXJpZmljYXRpb24gJiYgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJnb29nbGUtc2l0ZS12ZXJpZmljYXRpb25cIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwieWFuZGV4LXZlcmlmaWNhdGlvblwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJjc3JmLXRva2VuXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInA6ZG9tYWluX3ZlcmlmeVwiIHx8IGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gXCJ2ZXJpZnktdjFcIiB8fCBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09IFwidmVyaWZpY2F0aW9uXCIgfHwgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSBcInNob3BpZnktY2hlY2tvdXQtYXBpLXRva2VuXCIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplTm9kZVdpdGhJZChuMiwgb3B0aW9ucykge1xuICAgIHZhciBkb2MgPSBvcHRpb25zLmRvYywgbWlycm9yMiA9IG9wdGlvbnMubWlycm9yLCBibG9ja0NsYXNzID0gb3B0aW9ucy5ibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yID0gb3B0aW9ucy5ibG9ja1NlbGVjdG9yLCBtYXNrVGV4dENsYXNzID0gb3B0aW9ucy5tYXNrVGV4dENsYXNzLCBtYXNrVGV4dFNlbGVjdG9yID0gb3B0aW9ucy5tYXNrVGV4dFNlbGVjdG9yLCBfb3B0aW9uc19za2lwQ2hpbGQgPSBvcHRpb25zLnNraXBDaGlsZCwgc2tpcENoaWxkID0gX29wdGlvbnNfc2tpcENoaWxkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zX3NraXBDaGlsZCwgX29wdGlvbnNfaW5saW5lU3R5bGVzaGVldCA9IG9wdGlvbnMuaW5saW5lU3R5bGVzaGVldCwgaW5saW5lU3R5bGVzaGVldCA9IF9vcHRpb25zX2lubGluZVN0eWxlc2hlZXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9uc19pbmxpbmVTdHlsZXNoZWV0LCBfb3B0aW9uc19tYXNrSW5wdXRPcHRpb25zID0gb3B0aW9ucy5tYXNrSW5wdXRPcHRpb25zLCBtYXNrSW5wdXRPcHRpb25zID0gX29wdGlvbnNfbWFza0lucHV0T3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfb3B0aW9uc19tYXNrSW5wdXRPcHRpb25zLCBtYXNrVGV4dEZuID0gb3B0aW9ucy5tYXNrVGV4dEZuLCBtYXNrSW5wdXRGbiA9IG9wdGlvbnMubWFza0lucHV0Rm4sIHNsaW1ET01PcHRpb25zID0gb3B0aW9ucy5zbGltRE9NT3B0aW9ucywgX29wdGlvbnNfZGF0YVVSTE9wdGlvbnMgPSBvcHRpb25zLmRhdGFVUkxPcHRpb25zLCBkYXRhVVJMT3B0aW9ucyA9IF9vcHRpb25zX2RhdGFVUkxPcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zX2RhdGFVUkxPcHRpb25zLCBfb3B0aW9uc19pbmxpbmVJbWFnZXMgPSBvcHRpb25zLmlubGluZUltYWdlcywgaW5saW5lSW1hZ2VzID0gX29wdGlvbnNfaW5saW5lSW1hZ2VzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zX2lubGluZUltYWdlcywgX29wdGlvbnNfcmVjb3JkQ2FudmFzID0gb3B0aW9ucy5yZWNvcmRDYW52YXMsIHJlY29yZENhbnZhcyA9IF9vcHRpb25zX3JlY29yZENhbnZhcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9uc19yZWNvcmRDYW52YXMsIG9uU2VyaWFsaXplID0gb3B0aW9ucy5vblNlcmlhbGl6ZSwgb25JZnJhbWVMb2FkID0gb3B0aW9ucy5vbklmcmFtZUxvYWQsIF9vcHRpb25zX2lmcmFtZUxvYWRUaW1lb3V0ID0gb3B0aW9ucy5pZnJhbWVMb2FkVGltZW91dCwgaWZyYW1lTG9hZFRpbWVvdXQgPSBfb3B0aW9uc19pZnJhbWVMb2FkVGltZW91dCA9PT0gdm9pZCAwID8gNWUzIDogX29wdGlvbnNfaWZyYW1lTG9hZFRpbWVvdXQsIG9uU3R5bGVzaGVldExvYWQgPSBvcHRpb25zLm9uU3R5bGVzaGVldExvYWQsIF9vcHRpb25zX3N0eWxlc2hlZXRMb2FkVGltZW91dCA9IG9wdGlvbnMuc3R5bGVzaGVldExvYWRUaW1lb3V0LCBzdHlsZXNoZWV0TG9hZFRpbWVvdXQgPSBfb3B0aW9uc19zdHlsZXNoZWV0TG9hZFRpbWVvdXQgPT09IHZvaWQgMCA/IDVlMyA6IF9vcHRpb25zX3N0eWxlc2hlZXRMb2FkVGltZW91dCwgX29wdGlvbnNfa2VlcElmcmFtZVNyY0ZuID0gb3B0aW9ucy5rZWVwSWZyYW1lU3JjRm4sIGtlZXBJZnJhbWVTcmNGbiA9IF9vcHRpb25zX2tlZXBJZnJhbWVTcmNGbiA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IDogX29wdGlvbnNfa2VlcElmcmFtZVNyY0ZuLCBfb3B0aW9uc19uZXdseUFkZGVkRWxlbWVudCA9IG9wdGlvbnMubmV3bHlBZGRlZEVsZW1lbnQsIG5ld2x5QWRkZWRFbGVtZW50ID0gX29wdGlvbnNfbmV3bHlBZGRlZEVsZW1lbnQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfbmV3bHlBZGRlZEVsZW1lbnQsIF9vcHRpb25zX2Nzc0NhcHR1cmVkID0gb3B0aW9ucy5jc3NDYXB0dXJlZCwgY3NzQ2FwdHVyZWQgPSBfb3B0aW9uc19jc3NDYXB0dXJlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9uc19jc3NDYXB0dXJlZDtcbiAgICB2YXIgbmVlZHNNYXNrID0gb3B0aW9ucy5uZWVkc01hc2s7XG4gICAgdmFyIF9vcHRpb25zX3ByZXNlcnZlV2hpdGVTcGFjZSA9IG9wdGlvbnMucHJlc2VydmVXaGl0ZVNwYWNlLCBwcmVzZXJ2ZVdoaXRlU3BhY2UgPSBfb3B0aW9uc19wcmVzZXJ2ZVdoaXRlU3BhY2UgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9uc19wcmVzZXJ2ZVdoaXRlU3BhY2U7XG4gICAgaWYgKCFuZWVkc01hc2spIHtcbiAgICAgICAgdmFyIGNoZWNrQW5jZXN0b3JzID0gbmVlZHNNYXNrID09PSB2b2lkIDA7XG4gICAgICAgIG5lZWRzTWFzayA9IG5lZWRNYXNraW5nVGV4dChuMiwgbWFza1RleHRDbGFzcywgbWFza1RleHRTZWxlY3RvciwgY2hlY2tBbmNlc3RvcnMpO1xuICAgIH1cbiAgICB2YXIgX3NlcmlhbGl6ZWROb2RlID0gc2VyaWFsaXplTm9kZShuMiwge1xuICAgICAgICBkb2M6IGRvYyxcbiAgICAgICAgbWlycm9yOiBtaXJyb3IyLFxuICAgICAgICBibG9ja0NsYXNzOiBibG9ja0NsYXNzLFxuICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxuICAgICAgICBuZWVkc01hc2s6IG5lZWRzTWFzayxcbiAgICAgICAgaW5saW5lU3R5bGVzaGVldDogaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgbWFza0lucHV0T3B0aW9uczogbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgbWFza1RleHRGbjogbWFza1RleHRGbixcbiAgICAgICAgbWFza0lucHV0Rm46IG1hc2tJbnB1dEZuLFxuICAgICAgICBkYXRhVVJMT3B0aW9uczogZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgIGlubGluZUltYWdlczogaW5saW5lSW1hZ2VzLFxuICAgICAgICByZWNvcmRDYW52YXM6IHJlY29yZENhbnZhcyxcbiAgICAgICAga2VlcElmcmFtZVNyY0ZuOiBrZWVwSWZyYW1lU3JjRm4sXG4gICAgICAgIG5ld2x5QWRkZWRFbGVtZW50OiBuZXdseUFkZGVkRWxlbWVudCxcbiAgICAgICAgY3NzQ2FwdHVyZWQ6IGNzc0NhcHR1cmVkXG4gICAgfSk7XG4gICAgaWYgKCFfc2VyaWFsaXplZE5vZGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKG4yLCBcIm5vdCBzZXJpYWxpemVkXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGlkO1xuICAgIGlmIChtaXJyb3IyLmhhc05vZGUobjIpKSB7XG4gICAgICAgIGlkID0gbWlycm9yMi5nZXRJZChuMik7XG4gICAgfSBlbHNlIGlmIChzbGltRE9NRXhjbHVkZWQoX3NlcmlhbGl6ZWROb2RlLCBzbGltRE9NT3B0aW9ucykgfHwgIXByZXNlcnZlV2hpdGVTcGFjZSAmJiBfc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5UZXh0ICYmICFfc2VyaWFsaXplZE5vZGUudGV4dENvbnRlbnQucmVwbGFjZSgvXlxccyt8XFxzKyQvZ20sIFwiXCIpLmxlbmd0aCkge1xuICAgICAgICBpZCA9IElHTk9SRURfTk9ERTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZCA9IGdlbklkKCk7XG4gICAgfVxuICAgIHZhciBzZXJpYWxpemVkTm9kZSA9IE9iamVjdC5hc3NpZ24oX3NlcmlhbGl6ZWROb2RlLCB7XG4gICAgICAgIGlkOiBpZFxuICAgIH0pO1xuICAgIG1pcnJvcjIuYWRkKG4yLCBzZXJpYWxpemVkTm9kZSk7XG4gICAgaWYgKGlkID09PSBJR05PUkVEX05PREUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChvblNlcmlhbGl6ZSkge1xuICAgICAgICBvblNlcmlhbGl6ZShuMik7XG4gICAgfVxuICAgIHZhciByZWNvcmRDaGlsZCA9ICFza2lwQ2hpbGQ7XG4gICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCkge1xuICAgICAgICByZWNvcmRDaGlsZCA9IHJlY29yZENoaWxkICYmICFzZXJpYWxpemVkTm9kZS5uZWVkQmxvY2s7XG4gICAgICAgIGRlbGV0ZSBzZXJpYWxpemVkTm9kZS5uZWVkQmxvY2s7XG4gICAgICAgIHZhciBzaGFkb3dSb290RWwgPSBpbmRleCQxLnNoYWRvd1Jvb3QobjIpO1xuICAgICAgICBpZiAoc2hhZG93Um9vdEVsICYmIGlzTmF0aXZlU2hhZG93RG9tKHNoYWRvd1Jvb3RFbCkpIHNlcmlhbGl6ZWROb2RlLmlzU2hhZG93SG9zdCA9IHRydWU7XG4gICAgfVxuICAgIGlmICgoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5Eb2N1bWVudCB8fCBzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLkVsZW1lbnQpICYmIHJlY29yZENoaWxkKSB7XG4gICAgICAgIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkV2hpdGVzcGFjZSAmJiBzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLkVsZW1lbnQgJiYgc2VyaWFsaXplZE5vZGUudGFnTmFtZSA9PT0gXCJoZWFkXCIpIHtcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVTcGFjZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBieXBhc3NPcHRpb25zID0ge1xuICAgICAgICAgICAgZG9jOiBkb2MsXG4gICAgICAgICAgICBtaXJyb3I6IG1pcnJvcjIsXG4gICAgICAgICAgICBibG9ja0NsYXNzOiBibG9ja0NsYXNzLFxuICAgICAgICAgICAgYmxvY2tTZWxlY3RvcjogYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgIG5lZWRzTWFzazogbmVlZHNNYXNrLFxuICAgICAgICAgICAgbWFza1RleHRDbGFzczogbWFza1RleHRDbGFzcyxcbiAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3I6IG1hc2tUZXh0U2VsZWN0b3IsXG4gICAgICAgICAgICBza2lwQ2hpbGQ6IHNraXBDaGlsZCxcbiAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IGlubGluZVN0eWxlc2hlZXQsXG4gICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgbWFza1RleHRGbjogbWFza1RleHRGbixcbiAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBtYXNrSW5wdXRGbixcbiAgICAgICAgICAgIHNsaW1ET01PcHRpb25zOiBzbGltRE9NT3B0aW9ucyxcbiAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zOiBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgICAgIGlubGluZUltYWdlczogaW5saW5lSW1hZ2VzLFxuICAgICAgICAgICAgcmVjb3JkQ2FudmFzOiByZWNvcmRDYW52YXMsXG4gICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2U6IHByZXNlcnZlV2hpdGVTcGFjZSxcbiAgICAgICAgICAgIG9uU2VyaWFsaXplOiBvblNlcmlhbGl6ZSxcbiAgICAgICAgICAgIG9uSWZyYW1lTG9hZDogb25JZnJhbWVMb2FkLFxuICAgICAgICAgICAgaWZyYW1lTG9hZFRpbWVvdXQ6IGlmcmFtZUxvYWRUaW1lb3V0LFxuICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZDogb25TdHlsZXNoZWV0TG9hZCxcbiAgICAgICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dDogc3R5bGVzaGVldExvYWRUaW1lb3V0LFxuICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuOiBrZWVwSWZyYW1lU3JjRm4sXG4gICAgICAgICAgICBjc3NDYXB0dXJlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCAmJiBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSBcInRleHRhcmVhXCIgJiYgc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy52YWx1ZSAhPT0gdm9pZCAwKSA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlJDMuRWxlbWVudCAmJiBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLl9jc3NUZXh0ICE9PSB2b2lkIDAgJiYgdHlwZW9mIHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMuX2Nzc1RleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBieXBhc3NPcHRpb25zLmNzc0NhcHR1cmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKEFycmF5LmZyb20oaW5kZXgkMS5jaGlsZE5vZGVzKG4yKSkpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkTiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemVkQ2hpbGROb2RlID0gc2VyaWFsaXplTm9kZVdpdGhJZChjaGlsZE4sIGJ5cGFzc09wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkQ2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROb2RlLmNoaWxkTm9kZXMucHVzaChzZXJpYWxpemVkQ2hpbGROb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNoYWRvd1Jvb3RFbDEgPSBudWxsO1xuICAgICAgICBpZiAoaXNFbGVtZW50KG4yKSAmJiAoc2hhZG93Um9vdEVsMSA9IGluZGV4JDEuc2hhZG93Um9vdChuMikpKSB7XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvcjEgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoQXJyYXkuZnJvbShpbmRleCQxLmNoaWxkTm9kZXMoc2hhZG93Um9vdEVsMSkpKSwgX3N0ZXAxOyAhKF9zdGVwMSA9IF9pdGVyYXRvcjEoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZE4xID0gX3N0ZXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemVkQ2hpbGROb2RlMSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQoY2hpbGROMSwgYnlwYXNzT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRDaGlsZE5vZGUxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzTmF0aXZlU2hhZG93RG9tKHNoYWRvd1Jvb3RFbDEpICYmIChzZXJpYWxpemVkQ2hpbGROb2RlMS5pc1NoYWRvdyA9IHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkTm9kZS5jaGlsZE5vZGVzLnB1c2goc2VyaWFsaXplZENoaWxkTm9kZTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcGFyZW50ID0gaW5kZXgkMS5wYXJlbnROb2RlKG4yKTtcbiAgICBpZiAocGFyZW50ICYmIGlzU2hhZG93Um9vdChwYXJlbnQpICYmIGlzTmF0aXZlU2hhZG93RG9tKHBhcmVudCkpIHtcbiAgICAgICAgc2VyaWFsaXplZE5vZGUuaXNTaGFkb3cgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUkMy5FbGVtZW50ICYmIHNlcmlhbGl6ZWROb2RlLnRhZ05hbWUgPT09IFwiaWZyYW1lXCIpIHtcbiAgICAgICAgb25jZUlmcmFtZUxvYWRlZChuMiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaWZyYW1lRG9jID0gbjIuY29udGVudERvY3VtZW50O1xuICAgICAgICAgICAgaWYgKGlmcmFtZURvYyAmJiBvbklmcmFtZUxvYWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWFsaXplZElmcmFtZU5vZGUgPSBzZXJpYWxpemVOb2RlV2l0aElkKGlmcmFtZURvYywge1xuICAgICAgICAgICAgICAgICAgICBkb2M6IGlmcmFtZURvYyxcbiAgICAgICAgICAgICAgICAgICAgbWlycm9yOiBtaXJyb3IyLFxuICAgICAgICAgICAgICAgICAgICBibG9ja0NsYXNzOiBibG9ja0NsYXNzLFxuICAgICAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBuZWVkc01hc2s6IG5lZWRzTWFzayxcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRDbGFzczogbWFza1RleHRDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcjogbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgc2tpcENoaWxkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldDogaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRGbjogbWFza1RleHRGbixcbiAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0Rm46IG1hc2tJbnB1dEZuLFxuICAgICAgICAgICAgICAgICAgICBzbGltRE9NT3B0aW9uczogc2xpbURPTU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zOiBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lSW1hZ2VzOiBpbmxpbmVJbWFnZXMsXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZENhbnZhczogcmVjb3JkQ2FudmFzLFxuICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2U6IHByZXNlcnZlV2hpdGVTcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgb25TZXJpYWxpemU6IG9uU2VyaWFsaXplLFxuICAgICAgICAgICAgICAgICAgICBvbklmcmFtZUxvYWQ6IG9uSWZyYW1lTG9hZCxcbiAgICAgICAgICAgICAgICAgICAgaWZyYW1lTG9hZFRpbWVvdXQ6IGlmcmFtZUxvYWRUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkOiBvblN0eWxlc2hlZXRMb2FkLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQ6IHN0eWxlc2hlZXRMb2FkVGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuOiBrZWVwSWZyYW1lU3JjRm5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZElmcmFtZU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb25JZnJhbWVMb2FkKG4yLCBzZXJpYWxpemVkSWZyYW1lTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpZnJhbWVMb2FkVGltZW91dCk7XG4gICAgfVxuICAgIGlmIChzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZSQzLkVsZW1lbnQgJiYgc2VyaWFsaXplZE5vZGUudGFnTmFtZSA9PT0gXCJsaW5rXCIgJiYgdHlwZW9mIHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMucmVsID09PSBcInN0cmluZ1wiICYmIChzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIgfHwgc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5yZWwgPT09IFwicHJlbG9hZFwiICYmIHR5cGVvZiBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLmhyZWYgPT09IFwic3RyaW5nXCIgJiYgZXh0cmFjdEZpbGVFeHRlbnNpb24oc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5ocmVmKSA9PT0gXCJjc3NcIikpIHtcbiAgICAgICAgb25jZVN0eWxlc2hlZXRMb2FkZWQobjIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKG9uU3R5bGVzaGVldExvYWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VyaWFsaXplZExpbmtOb2RlID0gc2VyaWFsaXplTm9kZVdpdGhJZChuMiwge1xuICAgICAgICAgICAgICAgICAgICBkb2M6IGRvYyxcbiAgICAgICAgICAgICAgICAgICAgbWlycm9yOiBtaXJyb3IyLFxuICAgICAgICAgICAgICAgICAgICBibG9ja0NsYXNzOiBibG9ja0NsYXNzLFxuICAgICAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgICAgICAgICBuZWVkc01hc2s6IG5lZWRzTWFzayxcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRDbGFzczogbWFza1RleHRDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcjogbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgc2tpcENoaWxkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldDogaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRGbjogbWFza1RleHRGbixcbiAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0Rm46IG1hc2tJbnB1dEZuLFxuICAgICAgICAgICAgICAgICAgICBzbGltRE9NT3B0aW9uczogc2xpbURPTU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zOiBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lSW1hZ2VzOiBpbmxpbmVJbWFnZXMsXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZENhbnZhczogcmVjb3JkQ2FudmFzLFxuICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2U6IHByZXNlcnZlV2hpdGVTcGFjZSxcbiAgICAgICAgICAgICAgICAgICAgb25TZXJpYWxpemU6IG9uU2VyaWFsaXplLFxuICAgICAgICAgICAgICAgICAgICBvbklmcmFtZUxvYWQ6IG9uSWZyYW1lTG9hZCxcbiAgICAgICAgICAgICAgICAgICAgaWZyYW1lTG9hZFRpbWVvdXQ6IGlmcmFtZUxvYWRUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkOiBvblN0eWxlc2hlZXRMb2FkLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQ6IHN0eWxlc2hlZXRMb2FkVGltZW91dCxcbiAgICAgICAgICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuOiBrZWVwSWZyYW1lU3JjRm5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZExpbmtOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQobjIsIHNlcmlhbGl6ZWRMaW5rTm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzdHlsZXNoZWV0TG9hZFRpbWVvdXQpO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZE5vZGU7XG59XG5mdW5jdGlvbiBzbmFwc2hvdChuMiwgb3B0aW9ucykge1xuICAgIHZhciBfcmVmID0gb3B0aW9ucyB8fCB7fSwgdG1wID0gX3JlZi5taXJyb3IsIG1pcnJvcjIgPSB0bXAgPT09IHZvaWQgMCA/IG5ldyBNaXJyb3IoKSA6IHRtcCwgX3JlZl9ibG9ja0NsYXNzID0gX3JlZi5ibG9ja0NsYXNzLCBibG9ja0NsYXNzID0gX3JlZl9ibG9ja0NsYXNzID09PSB2b2lkIDAgPyBcInJyLWJsb2NrXCIgOiBfcmVmX2Jsb2NrQ2xhc3MsIF9yZWZfYmxvY2tTZWxlY3RvciA9IF9yZWYuYmxvY2tTZWxlY3RvciwgYmxvY2tTZWxlY3RvciA9IF9yZWZfYmxvY2tTZWxlY3RvciA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWZfYmxvY2tTZWxlY3RvciwgX3JlZl9tYXNrVGV4dENsYXNzID0gX3JlZi5tYXNrVGV4dENsYXNzLCBtYXNrVGV4dENsYXNzID0gX3JlZl9tYXNrVGV4dENsYXNzID09PSB2b2lkIDAgPyBcInJyLW1hc2tcIiA6IF9yZWZfbWFza1RleHRDbGFzcywgX3JlZl9tYXNrVGV4dFNlbGVjdG9yID0gX3JlZi5tYXNrVGV4dFNlbGVjdG9yLCBtYXNrVGV4dFNlbGVjdG9yID0gX3JlZl9tYXNrVGV4dFNlbGVjdG9yID09PSB2b2lkIDAgPyBudWxsIDogX3JlZl9tYXNrVGV4dFNlbGVjdG9yLCBfcmVmX2lubGluZVN0eWxlc2hlZXQgPSBfcmVmLmlubGluZVN0eWxlc2hlZXQsIGlubGluZVN0eWxlc2hlZXQgPSBfcmVmX2lubGluZVN0eWxlc2hlZXQgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmX2lubGluZVN0eWxlc2hlZXQsIF9yZWZfaW5saW5lSW1hZ2VzID0gX3JlZi5pbmxpbmVJbWFnZXMsIGlubGluZUltYWdlcyA9IF9yZWZfaW5saW5lSW1hZ2VzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWZfaW5saW5lSW1hZ2VzLCBfcmVmX3JlY29yZENhbnZhcyA9IF9yZWYucmVjb3JkQ2FudmFzLCByZWNvcmRDYW52YXMgPSBfcmVmX3JlY29yZENhbnZhcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmX3JlY29yZENhbnZhcywgX3JlZl9tYXNrQWxsSW5wdXRzID0gX3JlZi5tYXNrQWxsSW5wdXRzLCBtYXNrQWxsSW5wdXRzID0gX3JlZl9tYXNrQWxsSW5wdXRzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWZfbWFza0FsbElucHV0cywgbWFza1RleHRGbiA9IF9yZWYubWFza1RleHRGbiwgbWFza0lucHV0Rm4gPSBfcmVmLm1hc2tJbnB1dEZuLCBfcmVmX3NsaW1ET00gPSBfcmVmLnNsaW1ET00sIHNsaW1ET00gPSBfcmVmX3NsaW1ET00gPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZl9zbGltRE9NLCBkYXRhVVJMT3B0aW9ucyA9IF9yZWYuZGF0YVVSTE9wdGlvbnMsIHByZXNlcnZlV2hpdGVTcGFjZSA9IF9yZWYucHJlc2VydmVXaGl0ZVNwYWNlLCBvblNlcmlhbGl6ZSA9IF9yZWYub25TZXJpYWxpemUsIG9uSWZyYW1lTG9hZCA9IF9yZWYub25JZnJhbWVMb2FkLCBpZnJhbWVMb2FkVGltZW91dCA9IF9yZWYuaWZyYW1lTG9hZFRpbWVvdXQsIG9uU3R5bGVzaGVldExvYWQgPSBfcmVmLm9uU3R5bGVzaGVldExvYWQsIHN0eWxlc2hlZXRMb2FkVGltZW91dCA9IF9yZWYuc3R5bGVzaGVldExvYWRUaW1lb3V0LCBfcmVmX2tlZXBJZnJhbWVTcmNGbiA9IF9yZWYua2VlcElmcmFtZVNyY0ZuLCBrZWVwSWZyYW1lU3JjRm4gPSBfcmVmX2tlZXBJZnJhbWVTcmNGbiA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IDogX3JlZl9rZWVwSWZyYW1lU3JjRm47XG4gICAgdmFyIG1hc2tJbnB1dE9wdGlvbnMgPSBtYXNrQWxsSW5wdXRzID09PSB0cnVlID8ge1xuICAgICAgICBjb2xvcjogdHJ1ZSxcbiAgICAgICAgZGF0ZTogdHJ1ZSxcbiAgICAgICAgXCJkYXRldGltZS1sb2NhbFwiOiB0cnVlLFxuICAgICAgICBlbWFpbDogdHJ1ZSxcbiAgICAgICAgbW9udGg6IHRydWUsXG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgcmFuZ2U6IHRydWUsXG4gICAgICAgIHNlYXJjaDogdHJ1ZSxcbiAgICAgICAgdGVsOiB0cnVlLFxuICAgICAgICB0ZXh0OiB0cnVlLFxuICAgICAgICB0aW1lOiB0cnVlLFxuICAgICAgICB1cmw6IHRydWUsXG4gICAgICAgIHdlZWs6IHRydWUsXG4gICAgICAgIHRleHRhcmVhOiB0cnVlLFxuICAgICAgICBzZWxlY3Q6IHRydWUsXG4gICAgICAgIHBhc3N3b3JkOiB0cnVlXG4gICAgfSA6IG1hc2tBbGxJbnB1dHMgPT09IGZhbHNlID8ge1xuICAgICAgICBwYXNzd29yZDogdHJ1ZVxuICAgIH0gOiBtYXNrQWxsSW5wdXRzO1xuICAgIHZhciBzbGltRE9NT3B0aW9ucyA9IHNsaW1ET00gPT09IHRydWUgfHwgc2xpbURPTSA9PT0gXCJhbGxcIiA/IC8vIGlmIHRydWU6IHNldCBvZiBzZW5zaWJsZSBvcHRpb25zIHRoYXQgc2hvdWxkIG5vdCB0aHJvdyBhd2F5IGFueSBpbmZvcm1hdGlvblxuICAgIHtcbiAgICAgICAgc2NyaXB0OiB0cnVlLFxuICAgICAgICBjb21tZW50OiB0cnVlLFxuICAgICAgICBoZWFkRmF2aWNvbjogdHJ1ZSxcbiAgICAgICAgaGVhZFdoaXRlc3BhY2U6IHRydWUsXG4gICAgICAgIGhlYWRNZXRhRGVzY0tleXdvcmRzOiBzbGltRE9NID09PSBcImFsbFwiLFxuICAgICAgICAvLyBkZXN0cnVjdGl2ZVxuICAgICAgICBoZWFkTWV0YVNvY2lhbDogdHJ1ZSxcbiAgICAgICAgaGVhZE1ldGFSb2JvdHM6IHRydWUsXG4gICAgICAgIGhlYWRNZXRhSHR0cEVxdWl2OiB0cnVlLFxuICAgICAgICBoZWFkTWV0YUF1dGhvcnNoaXA6IHRydWUsXG4gICAgICAgIGhlYWRNZXRhVmVyaWZpY2F0aW9uOiB0cnVlXG4gICAgfSA6IHNsaW1ET00gPT09IGZhbHNlID8ge30gOiBzbGltRE9NO1xuICAgIHJldHVybiBzZXJpYWxpemVOb2RlV2l0aElkKG4yLCB7XG4gICAgICAgIGRvYzogbjIsXG4gICAgICAgIG1pcnJvcjogbWlycm9yMixcbiAgICAgICAgYmxvY2tDbGFzczogYmxvY2tDbGFzcyxcbiAgICAgICAgYmxvY2tTZWxlY3RvcjogYmxvY2tTZWxlY3RvcixcbiAgICAgICAgbWFza1RleHRDbGFzczogbWFza1RleHRDbGFzcyxcbiAgICAgICAgbWFza1RleHRTZWxlY3RvcjogbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgc2tpcENoaWxkOiBmYWxzZSxcbiAgICAgICAgaW5saW5lU3R5bGVzaGVldDogaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgbWFza0lucHV0T3B0aW9uczogbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgbWFza1RleHRGbjogbWFza1RleHRGbixcbiAgICAgICAgbWFza0lucHV0Rm46IG1hc2tJbnB1dEZuLFxuICAgICAgICBzbGltRE9NT3B0aW9uczogc2xpbURPTU9wdGlvbnMsXG4gICAgICAgIGRhdGFVUkxPcHRpb25zOiBkYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgaW5saW5lSW1hZ2VzOiBpbmxpbmVJbWFnZXMsXG4gICAgICAgIHJlY29yZENhbnZhczogcmVjb3JkQ2FudmFzLFxuICAgICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2U6IHByZXNlcnZlV2hpdGVTcGFjZSxcbiAgICAgICAgb25TZXJpYWxpemU6IG9uU2VyaWFsaXplLFxuICAgICAgICBvbklmcmFtZUxvYWQ6IG9uSWZyYW1lTG9hZCxcbiAgICAgICAgaWZyYW1lTG9hZFRpbWVvdXQ6IGlmcmFtZUxvYWRUaW1lb3V0LFxuICAgICAgICBvblN0eWxlc2hlZXRMb2FkOiBvblN0eWxlc2hlZXRMb2FkLFxuICAgICAgICBzdHlsZXNoZWV0TG9hZFRpbWVvdXQ6IHN0eWxlc2hlZXRMb2FkVGltZW91dCxcbiAgICAgICAga2VlcElmcmFtZVNyY0ZuOiBrZWVwSWZyYW1lU3JjRm4sXG4gICAgICAgIG5ld2x5QWRkZWRFbGVtZW50OiBmYWxzZVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMkMSh4Mikge1xuICAgIHJldHVybiB4MiAmJiB4Mi5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4MiwgXCJkZWZhdWx0XCIpID8geDJbXCJkZWZhdWx0XCJdIDogeDI7XG59XG5mdW5jdGlvbiBnZXRBdWdtZW50ZWROYW1lc3BhY2UkMShuMikge1xuICAgIGlmIChuMi5fX2VzTW9kdWxlKSByZXR1cm4gbjI7XG4gICAgdmFyIGYyID0gbjIuZGVmYXVsdDtcbiAgICBpZiAodHlwZW9mIGYyID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgYTIgPSBmdW5jdGlvbiBhMjIoKSB7XG4gICAgICAgICAgICBpZiAoX2luc3RhbmNlb2YodGhpcywgYTIyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdChmMiwgYXJndW1lbnRzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICBhMi5wcm90b3R5cGUgPSBmMi5wcm90b3R5cGU7XG4gICAgfSBlbHNlIGEyID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEyLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5rZXlzKG4yKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4yLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEyLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG4yW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYTI7XG59XG52YXIgcGljb2NvbG9yc19icm93c2VyJDEgPSB7XG4gICAgZXhwb3J0czoge31cbn07XG52YXIgeCQxID0gU3RyaW5nO1xudmFyIGNyZWF0ZSQxID0gZnVuY3Rpb24gY3JlYXRlJDEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNDb2xvclN1cHBvcnRlZDogZmFsc2UsXG4gICAgICAgIHJlc2V0OiB4JDEsXG4gICAgICAgIGJvbGQ6IHgkMSxcbiAgICAgICAgZGltOiB4JDEsXG4gICAgICAgIGl0YWxpYzogeCQxLFxuICAgICAgICB1bmRlcmxpbmU6IHgkMSxcbiAgICAgICAgaW52ZXJzZTogeCQxLFxuICAgICAgICBoaWRkZW46IHgkMSxcbiAgICAgICAgc3RyaWtldGhyb3VnaDogeCQxLFxuICAgICAgICBibGFjazogeCQxLFxuICAgICAgICByZWQ6IHgkMSxcbiAgICAgICAgZ3JlZW46IHgkMSxcbiAgICAgICAgeWVsbG93OiB4JDEsXG4gICAgICAgIGJsdWU6IHgkMSxcbiAgICAgICAgbWFnZW50YTogeCQxLFxuICAgICAgICBjeWFuOiB4JDEsXG4gICAgICAgIHdoaXRlOiB4JDEsXG4gICAgICAgIGdyYXk6IHgkMSxcbiAgICAgICAgYmdCbGFjazogeCQxLFxuICAgICAgICBiZ1JlZDogeCQxLFxuICAgICAgICBiZ0dyZWVuOiB4JDEsXG4gICAgICAgIGJnWWVsbG93OiB4JDEsXG4gICAgICAgIGJnQmx1ZTogeCQxLFxuICAgICAgICBiZ01hZ2VudGE6IHgkMSxcbiAgICAgICAgYmdDeWFuOiB4JDEsXG4gICAgICAgIGJnV2hpdGU6IHgkMVxuICAgIH07XG59O1xucGljb2NvbG9yc19icm93c2VyJDEuZXhwb3J0cyA9IGNyZWF0ZSQxKCk7XG5waWNvY29sb3JzX2Jyb3dzZXIkMS5leHBvcnRzLmNyZWF0ZUNvbG9ycyA9IGNyZWF0ZSQxO1xudmFyIHBpY29jb2xvcnNfYnJvd3NlckV4cG9ydHMkMSA9IHBpY29jb2xvcnNfYnJvd3NlciQxLmV4cG9ydHM7XG52YXIgX192aXRlQnJvd3NlckV4dGVybmFsJDIgPSB7fTtcbnZhciBfX3ZpdGVCcm93c2VyRXh0ZXJuYWwkMSQxID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGRlZmF1bHQ6IF9fdml0ZUJyb3dzZXJFeHRlcm5hbCQyXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcbiAgICB2YWx1ZTogXCJNb2R1bGVcIlxufSkpO1xudmFyIHJlcXVpcmUkJDIkMSA9IC8qIEBfX1BVUkVfXyAqLyBnZXRBdWdtZW50ZWROYW1lc3BhY2UkMShfX3ZpdGVCcm93c2VyRXh0ZXJuYWwkMSQxKTtcbnZhciBwaWNvJDEgPSBwaWNvY29sb3JzX2Jyb3dzZXJFeHBvcnRzJDE7XG52YXIgdGVybWluYWxIaWdobGlnaHQkMSQxID0gcmVxdWlyZSQkMiQxO1xudmFyIENzc1N5bnRheEVycm9yJDMkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oRXJyb3IxKSB7XG4gICAgX2luaGVyaXRzKENzc1N5bnRheEVycm9yLCBFcnJvcjEpO1xuICAgIGZ1bmN0aW9uIENzc1N5bnRheEVycm9yKG1lc3NhZ2UsIGxpbmUsIGNvbHVtbiwgc291cmNlLCBmaWxlLCBwbHVnaW4yMikge1xuICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgIF90aGlzID0gRXJyb3IxLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IFwiQ3NzU3ludGF4RXJyb3JcIjtcbiAgICAgICAgX3RoaXMucmVhc29uID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgIF90aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIF90aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGx1Z2luMjIpIHtcbiAgICAgICAgICAgIF90aGlzLnBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGluZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29sdW1uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpbmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmxpbmUgPSBsaW5lLmxpbmU7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29sdW1uID0gbGluZS5jb2x1bW47XG4gICAgICAgICAgICAgICAgX3RoaXMuZW5kTGluZSA9IGNvbHVtbi5saW5lO1xuICAgICAgICAgICAgICAgIF90aGlzLmVuZENvbHVtbiA9IGNvbHVtbi5jb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuc2V0TWVzc2FnZSgpO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBDc3NTeW50YXhFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQ3NzU3ludGF4RXJyb3IucHJvdG90eXBlO1xuICAgIF9wcm90by5zZXRNZXNzYWdlID0gZnVuY3Rpb24gc2V0TWVzc2FnZSgpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5wbHVnaW4gPyB0aGlzLnBsdWdpbiArIFwiOiBcIiA6IFwiXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSArPSB0aGlzLmZpbGUgPyB0aGlzLmZpbGUgOiBcIjxjc3MgaW5wdXQ+XCI7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5saW5lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgKz0gXCI6XCIgKyB0aGlzLmxpbmUgKyBcIjpcIiArIHRoaXMuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZSArPSBcIjogXCIgKyB0aGlzLnJlYXNvbjtcbiAgICB9O1xuICAgIF9wcm90by5zaG93U291cmNlQ29kZSA9IGZ1bmN0aW9uIHNob3dTb3VyY2VDb2RlKGNvbG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5zb3VyY2UpIHJldHVybiBcIlwiO1xuICAgICAgICB2YXIgY3NzID0gdGhpcy5zb3VyY2U7XG4gICAgICAgIGlmIChjb2xvciA9PSBudWxsKSBjb2xvciA9IHBpY28kMS5pc0NvbG9yU3VwcG9ydGVkO1xuICAgICAgICBpZiAodGVybWluYWxIaWdobGlnaHQkMSQxKSB7XG4gICAgICAgICAgICBpZiAoY29sb3IpIGNzcyA9IHRlcm1pbmFsSGlnaGxpZ2h0JDEkMShjc3MpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaW5lcyA9IGNzcy5zcGxpdCgvXFxyP1xcbi8pO1xuICAgICAgICB2YXIgc3RhcnQgPSBNYXRoLm1heCh0aGlzLmxpbmUgLSAzLCAwKTtcbiAgICAgICAgdmFyIGVuZCA9IE1hdGgubWluKHRoaXMubGluZSArIDIsIGxpbmVzLmxlbmd0aCk7XG4gICAgICAgIHZhciBtYXhXaWR0aCA9IFN0cmluZyhlbmQpLmxlbmd0aDtcbiAgICAgICAgdmFyIG1hcmssIGFzaWRlO1xuICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgIHZhciBfcGljbyQxX2NyZWF0ZUNvbG9ycyA9IHBpY28kMS5jcmVhdGVDb2xvcnModHJ1ZSksIGJvbGQgPSBfcGljbyQxX2NyZWF0ZUNvbG9ycy5ib2xkLCBncmF5ID0gX3BpY28kMV9jcmVhdGVDb2xvcnMuZ3JheSwgcmVkID0gX3BpY28kMV9jcmVhdGVDb2xvcnMucmVkO1xuICAgICAgICAgICAgbWFyayA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYm9sZChyZWQodGV4dCkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFzaWRlID0gZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBncmF5KHRleHQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcmsgPSBhc2lkZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lcy5zbGljZShzdGFydCwgZW5kKS5tYXAoZnVuY3Rpb24obGluZSwgaW5kZXgyKSB7XG4gICAgICAgICAgICB2YXIgbnVtYmVyID0gc3RhcnQgKyAxICsgaW5kZXgyO1xuICAgICAgICAgICAgdmFyIGd1dHRlciA9IFwiIFwiICsgKFwiIFwiICsgbnVtYmVyKS5zbGljZSgtbWF4V2lkdGgpICsgXCIgfCBcIjtcbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IF90aGlzLmxpbmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2luZyA9IGFzaWRlKGd1dHRlci5yZXBsYWNlKC9cXGQvZywgXCIgXCIpKSArIGxpbmUuc2xpY2UoMCwgX3RoaXMuY29sdW1uIC0gMSkucmVwbGFjZSgvW15cXHRdL2csIFwiIFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFyayhcIj5cIikgKyBhc2lkZShndXR0ZXIpICsgbGluZSArIFwiXFxuIFwiICsgc3BhY2luZyArIG1hcmsoXCJeXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwiIFwiICsgYXNpZGUoZ3V0dGVyKSArIGxpbmU7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbiAgICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgdmFyIGNvZGUgPSB0aGlzLnNob3dTb3VyY2VDb2RlKCk7XG4gICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICBjb2RlID0gXCJcXG5cXG5cIiArIGNvZGUgKyBcIlxcblwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2UgKyBjb2RlO1xuICAgIH07XG4gICAgcmV0dXJuIENzc1N5bnRheEVycm9yO1xufShfd3JhcF9uYXRpdmVfc3VwZXIoRXJyb3IpKTtcbnZhciBjc3NTeW50YXhFcnJvciQxID0gQ3NzU3ludGF4RXJyb3IkMyQxO1xuQ3NzU3ludGF4RXJyb3IkMyQxLmRlZmF1bHQgPSBDc3NTeW50YXhFcnJvciQzJDE7XG52YXIgc3ltYm9scyQxID0ge307XG5zeW1ib2xzJDEuaXNDbGVhbiA9IFN5bWJvbChcImlzQ2xlYW5cIik7XG5zeW1ib2xzJDEubXkgPSBTeW1ib2woXCJteVwiKTtcbnZhciBERUZBVUxUX1JBVyQxID0ge1xuICAgIGFmdGVyOiBcIlxcblwiLFxuICAgIGJlZm9yZUNsb3NlOiBcIlxcblwiLFxuICAgIGJlZm9yZUNvbW1lbnQ6IFwiXFxuXCIsXG4gICAgYmVmb3JlRGVjbDogXCJcXG5cIixcbiAgICBiZWZvcmVPcGVuOiBcIiBcIixcbiAgICBiZWZvcmVSdWxlOiBcIlxcblwiLFxuICAgIGNvbG9uOiBcIjogXCIsXG4gICAgY29tbWVudExlZnQ6IFwiIFwiLFxuICAgIGNvbW1lbnRSaWdodDogXCIgXCIsXG4gICAgZW1wdHlCb2R5OiBcIlwiLFxuICAgIGluZGVudDogXCIgICAgXCIsXG4gICAgc2VtaWNvbG9uOiBmYWxzZVxufTtcbmZ1bmN0aW9uIGNhcGl0YWxpemUkMShzdHIpIHtcbiAgICByZXR1cm4gc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG52YXIgU3RyaW5naWZpZXIkMiQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTdHJpbmdpZmllcihidWlsZGVyKSB7XG4gICAgICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXI7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBTdHJpbmdpZmllci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmF0cnVsZSA9IGZ1bmN0aW9uIGF0cnVsZShub2RlMiwgc2VtaWNvbG9uKSB7XG4gICAgICAgIHZhciBuYW1lID0gXCJAXCIgKyBub2RlMi5uYW1lO1xuICAgICAgICB2YXIgcGFyYW1zID0gbm9kZTIucGFyYW1zID8gdGhpcy5yYXdWYWx1ZShub2RlMiwgXCJwYXJhbXNcIikgOiBcIlwiO1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUyLnJhd3MuYWZ0ZXJOYW1lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBuYW1lICs9IG5vZGUyLnJhd3MuYWZ0ZXJOYW1lO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmFtcykge1xuICAgICAgICAgICAgbmFtZSArPSBcIiBcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZTIubm9kZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYmxvY2sobm9kZTIsIG5hbWUgKyBwYXJhbXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGVuZCA9IChub2RlMi5yYXdzLmJldHdlZW4gfHwgXCJcIikgKyAoc2VtaWNvbG9uID8gXCI7XCIgOiBcIlwiKTtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRlcihuYW1lICsgcGFyYW1zICsgZW5kLCBub2RlMik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5iZWZvcmVBZnRlciA9IGZ1bmN0aW9uIGJlZm9yZUFmdGVyKG5vZGUyLCBkZXRlY3QpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAobm9kZTIudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlRGVjbFwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVDb21tZW50XCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGRldGVjdCA9PT0gXCJiZWZvcmVcIikge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVSdWxlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVDbG9zZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmID0gbm9kZTIucGFyZW50O1xuICAgICAgICB2YXIgZGVwdGggPSAwO1xuICAgICAgICB3aGlsZShidWYgJiYgYnVmLnR5cGUgIT09IFwicm9vdFwiKXtcbiAgICAgICAgICAgIGRlcHRoICs9IDE7XG4gICAgICAgICAgICBidWYgPSBidWYucGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgdmFyIGluZGVudCA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImluZGVudFwiKTtcbiAgICAgICAgICAgIGlmIChpbmRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBzdGVwID0gMDsgc3RlcCA8IGRlcHRoOyBzdGVwKyspdmFsdWUgKz0gaW5kZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5ibG9jayA9IGZ1bmN0aW9uIGJsb2NrKG5vZGUyLCBzdGFydCkge1xuICAgICAgICB2YXIgYmV0d2VlbiA9IHRoaXMucmF3KG5vZGUyLCBcImJldHdlZW5cIiwgXCJiZWZvcmVPcGVuXCIpO1xuICAgICAgICB0aGlzLmJ1aWxkZXIoc3RhcnQgKyBiZXR3ZWVuICsgXCJ7XCIsIG5vZGUyLCBcInN0YXJ0XCIpO1xuICAgICAgICB2YXIgYWZ0ZXI7XG4gICAgICAgIGlmIChub2RlMi5ub2RlcyAmJiBub2RlMi5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keShub2RlMik7XG4gICAgICAgICAgICBhZnRlciA9IHRoaXMucmF3KG5vZGUyLCBcImFmdGVyXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWZ0ZXIgPSB0aGlzLnJhdyhub2RlMiwgXCJhZnRlclwiLCBcImVtcHR5Qm9keVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZ0ZXIpIHRoaXMuYnVpbGRlcihhZnRlcik7XG4gICAgICAgIHRoaXMuYnVpbGRlcihcIn1cIiwgbm9kZTIsIFwiZW5kXCIpO1xuICAgIH07XG4gICAgX3Byb3RvLmJvZHkgPSBmdW5jdGlvbiBib2R5KG5vZGUyKSB7XG4gICAgICAgIHZhciBsYXN0ID0gbm9kZTIubm9kZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUobGFzdCA+IDApe1xuICAgICAgICAgICAgaWYgKG5vZGUyLm5vZGVzW2xhc3RdLnR5cGUgIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgICAgICAgIGxhc3QgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VtaWNvbG9uID0gdGhpcy5yYXcobm9kZTIsIFwic2VtaWNvbG9uXCIpO1xuICAgICAgICBmb3IodmFyIGkyID0gMDsgaTIgPCBub2RlMi5ub2Rlcy5sZW5ndGg7IGkyKyspe1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZTIubm9kZXNbaTJdO1xuICAgICAgICAgICAgdmFyIGJlZm9yZSA9IHRoaXMucmF3KGNoaWxkLCBcImJlZm9yZVwiKTtcbiAgICAgICAgICAgIGlmIChiZWZvcmUpIHRoaXMuYnVpbGRlcihiZWZvcmUpO1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdpZnkoY2hpbGQsIGxhc3QgIT09IGkyIHx8IHNlbWljb2xvbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5jb21tZW50ID0gZnVuY3Rpb24gY29tbWVudChub2RlMikge1xuICAgICAgICB2YXIgbGVmdCA9IHRoaXMucmF3KG5vZGUyLCBcImxlZnRcIiwgXCJjb21tZW50TGVmdFwiKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5yYXcobm9kZTIsIFwicmlnaHRcIiwgXCJjb21tZW50UmlnaHRcIik7XG4gICAgICAgIHRoaXMuYnVpbGRlcihcIi8qXCIgKyBsZWZ0ICsgbm9kZTIudGV4dCArIHJpZ2h0ICsgXCIqL1wiLCBub2RlMik7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVjbCA9IGZ1bmN0aW9uIGRlY2wobm9kZTIsIHNlbWljb2xvbikge1xuICAgICAgICB2YXIgYmV0d2VlbiA9IHRoaXMucmF3KG5vZGUyLCBcImJldHdlZW5cIiwgXCJjb2xvblwiKTtcbiAgICAgICAgdmFyIHN0cmluZyA9IG5vZGUyLnByb3AgKyBiZXR3ZWVuICsgdGhpcy5yYXdWYWx1ZShub2RlMiwgXCJ2YWx1ZVwiKTtcbiAgICAgICAgaWYgKG5vZGUyLmltcG9ydGFudCkge1xuICAgICAgICAgICAgc3RyaW5nICs9IG5vZGUyLnJhd3MuaW1wb3J0YW50IHx8IFwiICFpbXBvcnRhbnRcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VtaWNvbG9uKSBzdHJpbmcgKz0gXCI7XCI7XG4gICAgICAgIHRoaXMuYnVpbGRlcihzdHJpbmcsIG5vZGUyKTtcbiAgICB9O1xuICAgIF9wcm90by5kb2N1bWVudCA9IGZ1bmN0aW9uIGRvY3VtZW50MShub2RlMikge1xuICAgICAgICB0aGlzLmJvZHkobm9kZTIpO1xuICAgIH07XG4gICAgX3Byb3RvLnJhdyA9IGZ1bmN0aW9uIHJhdyhub2RlMiwgb3duLCBkZXRlY3QpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAoIWRldGVjdCkgZGV0ZWN0ID0gb3duO1xuICAgICAgICBpZiAob3duKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5vZGUyLnJhd3Nbb3duXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyZW50ID0gbm9kZTIucGFyZW50O1xuICAgICAgICBpZiAoZGV0ZWN0ID09PSBcImJlZm9yZVwiKSB7XG4gICAgICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQudHlwZSA9PT0gXCJyb290XCIgJiYgcGFyZW50LmZpcnN0ID09PSBub2RlMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnQpIHJldHVybiBERUZBVUxUX1JBVyQxW2RldGVjdF07XG4gICAgICAgIHZhciByb290MiA9IG5vZGUyLnJvb3QoKTtcbiAgICAgICAgaWYgKCFyb290Mi5yYXdDYWNoZSkgcm9vdDIucmF3Q2FjaGUgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiByb290Mi5yYXdDYWNoZVtkZXRlY3RdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDIucmF3Q2FjaGVbZGV0ZWN0XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV0ZWN0ID09PSBcImJlZm9yZVwiIHx8IGRldGVjdCA9PT0gXCJhZnRlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVBZnRlcihub2RlMiwgZGV0ZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBcInJhd1wiICsgY2FwaXRhbGl6ZSQxKGRldGVjdCk7XG4gICAgICAgICAgICBpZiAodGhpc1ttZXRob2RdKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzW21ldGhvZF0ocm9vdDIsIG5vZGUyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3Nbb3duXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHZhbHVlID0gREVGQVVMVF9SQVckMVtkZXRlY3RdO1xuICAgICAgICByb290Mi5yYXdDYWNoZVtkZXRlY3RdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdCZWZvcmVDbG9zZSA9IGZ1bmN0aW9uIHJhd0JlZm9yZUNsb3NlKHJvb3QyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKGkyLm5vZGVzICYmIGkyLm5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYWZ0ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmFmdGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHZhbHVlKSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0JlZm9yZUNvbW1lbnQgPSBmdW5jdGlvbiByYXdCZWZvcmVDb21tZW50KHJvb3QyLCBub2RlMikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGtDb21tZW50cyhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVEZWNsXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3QmVmb3JlRGVjbCA9IGZ1bmN0aW9uIHJhd0JlZm9yZURlY2wocm9vdDIsIG5vZGUyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2Fsa0RlY2xzKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJlZm9yZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZVJ1bGVcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdCZWZvcmVPcGVuID0gZnVuY3Rpb24gcmF3QmVmb3JlT3Blbihyb290Mikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGsoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmIChpMi50eXBlICE9PSBcImRlY2xcIikge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5iZXR3ZWVuO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdCZWZvcmVSdWxlID0gZnVuY3Rpb24gcmF3QmVmb3JlUnVsZShyb290Mikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGsoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmIChpMi5ub2RlcyAmJiAoaTIucGFyZW50ICE9PSByb290MiB8fCByb290Mi5maXJzdCAhPT0gaTIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvW15cXG5dKyQvLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHZhbHVlKSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0NvbG9uID0gZnVuY3Rpb24gcmF3Q29sb24ocm9vdDIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrRGVjbHMoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZXR3ZWVuICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJldHdlZW4ucmVwbGFjZSgvW15cXHM6XS9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3RW1wdHlCb2R5ID0gZnVuY3Rpb24gcmF3RW1wdHlCb2R5KHJvb3QyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKGkyLm5vZGVzICYmIGkyLm5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5hZnRlcjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3SW5kZW50ID0gZnVuY3Rpb24gcmF3SW5kZW50KHJvb3QyKSB7XG4gICAgICAgIGlmIChyb290Mi5yYXdzLmluZGVudCkgcmV0dXJuIHJvb3QyLnJhd3MuaW5kZW50O1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGsoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIHZhciBwID0gaTIucGFyZW50O1xuICAgICAgICAgICAgaWYgKHAgJiYgcCAhPT0gcm9vdDIgJiYgcC5wYXJlbnQgJiYgcC5wYXJlbnQgPT09IHJvb3QyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBpMi5yYXdzLmJlZm9yZS5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3U2VtaWNvbG9uID0gZnVuY3Rpb24gcmF3U2VtaWNvbG9uKHJvb3QyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKGkyLm5vZGVzICYmIGkyLm5vZGVzLmxlbmd0aCAmJiBpMi5sYXN0LnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLnNlbWljb2xvbjtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3VmFsdWUgPSBmdW5jdGlvbiByYXdWYWx1ZShub2RlMiwgcHJvcCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBub2RlMltwcm9wXTtcbiAgICAgICAgdmFyIHJhdyA9IG5vZGUyLnJhd3NbcHJvcF07XG4gICAgICAgIGlmIChyYXcgJiYgcmF3LnZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJhdy5yYXc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJvb3QgPSBmdW5jdGlvbiByb290KG5vZGUyKSB7XG4gICAgICAgIHRoaXMuYm9keShub2RlMik7XG4gICAgICAgIGlmIChub2RlMi5yYXdzLmFmdGVyKSB0aGlzLmJ1aWxkZXIobm9kZTIucmF3cy5hZnRlcik7XG4gICAgfTtcbiAgICBfcHJvdG8ucnVsZSA9IGZ1bmN0aW9uIHJ1bGUobm9kZTIpIHtcbiAgICAgICAgdGhpcy5ibG9jayhub2RlMiwgdGhpcy5yYXdWYWx1ZShub2RlMiwgXCJzZWxlY3RvclwiKSk7XG4gICAgICAgIGlmIChub2RlMi5yYXdzLm93blNlbWljb2xvbikge1xuICAgICAgICAgICAgdGhpcy5idWlsZGVyKG5vZGUyLnJhd3Mub3duU2VtaWNvbG9uLCBub2RlMiwgXCJlbmRcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5zdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkobm9kZTIsIHNlbWljb2xvbikge1xuICAgICAgICBpZiAoIXRoaXNbbm9kZTIudHlwZV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gQVNUIG5vZGUgdHlwZSBcIiArIG5vZGUyLnR5cGUgKyBcIi4gTWF5YmUgeW91IG5lZWQgdG8gY2hhbmdlIFBvc3RDU1Mgc3RyaW5naWZpZXIuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbbm9kZTIudHlwZV0obm9kZTIsIHNlbWljb2xvbik7XG4gICAgfTtcbiAgICByZXR1cm4gU3RyaW5naWZpZXI7XG59KCk7XG52YXIgc3RyaW5naWZpZXIkMSA9IFN0cmluZ2lmaWVyJDIkMTtcblN0cmluZ2lmaWVyJDIkMS5kZWZhdWx0ID0gU3RyaW5naWZpZXIkMiQxO1xudmFyIFN0cmluZ2lmaWVyJDEkMSA9IHN0cmluZ2lmaWVyJDE7XG5mdW5jdGlvbiBzdHJpbmdpZnkkNCQxKG5vZGUyLCBidWlsZGVyKSB7XG4gICAgdmFyIHN0ciA9IG5ldyBTdHJpbmdpZmllciQxJDEoYnVpbGRlcik7XG4gICAgc3RyLnN0cmluZ2lmeShub2RlMik7XG59XG52YXIgc3RyaW5naWZ5XzEkMSA9IHN0cmluZ2lmeSQ0JDE7XG5zdHJpbmdpZnkkNCQxLmRlZmF1bHQgPSBzdHJpbmdpZnkkNCQxO1xudmFyIGlzQ2xlYW4kMiQxID0gc3ltYm9scyQxLmlzQ2xlYW4sIG15JDIkMSA9IHN5bWJvbHMkMS5teTtcbnZhciBDc3NTeW50YXhFcnJvciQyJDEgPSBjc3NTeW50YXhFcnJvciQxO1xudmFyIFN0cmluZ2lmaWVyMiQxID0gc3RyaW5naWZpZXIkMTtcbnZhciBzdHJpbmdpZnkkMyQxID0gc3RyaW5naWZ5XzEkMTtcbmZ1bmN0aW9uIGNsb25lTm9kZSQxKG9iaiwgcGFyZW50KSB7XG4gICAgdmFyIGNsb25lZCA9IG5ldyBvYmouY29uc3RydWN0b3IoKTtcbiAgICBmb3IodmFyIGkyIGluIG9iail7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaTIpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaTIgPT09IFwicHJveHlDYWNoZVwiKSBjb250aW51ZTtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqW2kyXTtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YodmFsdWUpO1xuICAgICAgICBpZiAoaTIgPT09IFwicGFyZW50XCIgJiYgdHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKHBhcmVudCkgY2xvbmVkW2kyXSA9IHBhcmVudDtcbiAgICAgICAgfSBlbHNlIGlmIChpMiA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgICAgICAgY2xvbmVkW2kyXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBjbG9uZWRbaTJdID0gdmFsdWUubWFwKGZ1bmN0aW9uKGopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVOb2RlJDEoaiwgY2xvbmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHZhbHVlID0gY2xvbmVOb2RlJDEodmFsdWUpO1xuICAgICAgICAgICAgY2xvbmVkW2kyXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbG9uZWQ7XG59XG52YXIgTm9kZSQ0JDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE5vZGUyKGRlZmF1bHRzKSB7XG4gICAgICAgIGlmIChkZWZhdWx0cyA9PT0gdm9pZCAwKSBkZWZhdWx0cyA9IHt9O1xuICAgICAgICB0aGlzLnJhd3MgPSB7fTtcbiAgICAgICAgdGhpc1tpc0NsZWFuJDIkMV0gPSBmYWxzZTtcbiAgICAgICAgdGhpc1tteSQyJDFdID0gdHJ1ZTtcbiAgICAgICAgZm9yKHZhciBuYW1lIGluIGRlZmF1bHRzKXtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSBcIm5vZGVzXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoZGVmYXVsdHNbbmFtZV0pLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5vZGUyLmNsb25lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKG5vZGUyLmNsb25lKCkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQobm9kZTIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW25hbWVdID0gZGVmYXVsdHNbbmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9wcm90byA9IE5vZGUyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYWRkVG9FcnJvciA9IGZ1bmN0aW9uIGFkZFRvRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgZXJyb3IucG9zdGNzc05vZGUgPSB0aGlzO1xuICAgICAgICBpZiAoZXJyb3Iuc3RhY2sgJiYgdGhpcy5zb3VyY2UgJiYgL1xcblxcc3s0fWF0IC8udGVzdChlcnJvci5zdGFjaykpIHtcbiAgICAgICAgICAgIHZhciBzMiA9IHRoaXMuc291cmNlO1xuICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSBlcnJvci5zdGFjay5yZXBsYWNlKC9cXG5cXHN7NH1hdCAvLCBcIiQmXCIgKyBzMi5pbnB1dC5mcm9tICsgXCI6XCIgKyBzMi5zdGFydC5saW5lICsgXCI6XCIgKyBzMi5zdGFydC5jb2x1bW4gKyBcIiQmXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9O1xuICAgIF9wcm90by5hZnRlciA9IGZ1bmN0aW9uIGFmdGVyKGFkZCkge1xuICAgICAgICB0aGlzLnBhcmVudC5pbnNlcnRBZnRlcih0aGlzLCBhZGQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5hc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24ob3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIGZvcih2YXIgbmFtZSBpbiBvdmVycmlkZXMpe1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IG92ZXJyaWRlc1tuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5iZWZvcmUgPSBmdW5jdGlvbiBiZWZvcmUoYWRkKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBhZGQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5jbGVhblJhd3MgPSBmdW5jdGlvbiBjbGVhblJhd3Moa2VlcEJldHdlZW4pIHtcbiAgICAgICAgZGVsZXRlIHRoaXMucmF3cy5iZWZvcmU7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJhd3MuYWZ0ZXI7XG4gICAgICAgIGlmICgha2VlcEJldHdlZW4pIGRlbGV0ZSB0aGlzLnJhd3MuYmV0d2VlbjtcbiAgICB9O1xuICAgIF9wcm90by5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKG92ZXJyaWRlcykge1xuICAgICAgICBpZiAob3ZlcnJpZGVzID09PSB2b2lkIDApIG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICB2YXIgY2xvbmVkID0gY2xvbmVOb2RlJDEodGhpcyk7XG4gICAgICAgIGZvcih2YXIgbmFtZSBpbiBvdmVycmlkZXMpe1xuICAgICAgICAgICAgY2xvbmVkW25hbWVdID0gb3ZlcnJpZGVzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uY2xvbmVBZnRlciA9IGZ1bmN0aW9uIGNsb25lQWZ0ZXIob3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIHZhciBjbG9uZWQgPSB0aGlzLmNsb25lKG92ZXJyaWRlcyk7XG4gICAgICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVyKHRoaXMsIGNsb25lZCk7XG4gICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uY2xvbmVCZWZvcmUgPSBmdW5jdGlvbiBjbG9uZUJlZm9yZShvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcyA9PT0gdm9pZCAwKSBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgdmFyIGNsb25lZCA9IHRoaXMuY2xvbmUob3ZlcnJpZGVzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIGNsb25lZCk7XG4gICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtZXNzYWdlLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXNfcmFuZ2VCeSA9IHRoaXMucmFuZ2VCeShvcHRzKSwgZW5kID0gX3RoaXNfcmFuZ2VCeS5lbmQsIHN0YXJ0ID0gX3RoaXNfcmFuZ2VCeS5zdGFydDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5pbnB1dC5lcnJvcihtZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBzdGFydC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogc3RhcnQubGluZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogZW5kLmNvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBlbmQubGluZVxuICAgICAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDc3NTeW50YXhFcnJvciQyJDEobWVzc2FnZSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0UHJveHlQcm9jZXNzb3IgPSBmdW5jdGlvbiBnZXRQcm94eVByb2Nlc3NvcigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KG5vZGUyLCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IFwicHJveHlPZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMi5yb290KCkudG9Qcm94eSgpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobm9kZTIsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyW3Byb3BdID09PSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgbm9kZTJbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJwcm9wXCIgfHwgcHJvcCA9PT0gXCJ2YWx1ZVwiIHx8IHByb3AgPT09IFwibmFtZVwiIHx8IHByb3AgPT09IFwicGFyYW1zXCIgfHwgcHJvcCA9PT0gXCJpbXBvcnRhbnRcIiB8fCAvKiBjOCBpZ25vcmUgbmV4dCAqLyBwcm9wID09PSBcInRleHRcIikge1xuICAgICAgICAgICAgICAgICAgICBub2RlMi5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8ubWFya0RpcnR5ID0gZnVuY3Rpb24gbWFya0RpcnR5KCkge1xuICAgICAgICBpZiAodGhpc1tpc0NsZWFuJDIkMV0pIHtcbiAgICAgICAgICAgIHRoaXNbaXNDbGVhbiQyJDFdID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZShuZXh0ID0gbmV4dC5wYXJlbnQpe1xuICAgICAgICAgICAgICAgIG5leHRbaXNDbGVhbiQyJDFdID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5uZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgdmFyIGluZGV4MiA9IHRoaXMucGFyZW50LmluZGV4KHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQubm9kZXNbaW5kZXgyICsgMV07XG4gICAgfTtcbiAgICBfcHJvdG8ucG9zaXRpb25CeSA9IGZ1bmN0aW9uIHBvc2l0aW9uQnkob3B0cywgc3RyaW5nUmVwcmVzZW50YXRpb24pIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuc291cmNlLnN0YXJ0O1xuICAgICAgICBpZiAob3B0cy5pbmRleCkge1xuICAgICAgICAgICAgcG9zID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4LCBzdHJpbmdSZXByZXNlbnRhdGlvbik7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0cy53b3JkKSB7XG4gICAgICAgICAgICBzdHJpbmdSZXByZXNlbnRhdGlvbiA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHZhciBpbmRleDIgPSBzdHJpbmdSZXByZXNlbnRhdGlvbi5pbmRleE9mKG9wdHMud29yZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXgyICE9PSAtMSkgcG9zID0gdGhpcy5wb3NpdGlvbkluc2lkZShpbmRleDIsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH07XG4gICAgX3Byb3RvLnBvc2l0aW9uSW5zaWRlID0gZnVuY3Rpb24gcG9zaXRpb25JbnNpZGUoaW5kZXgyLCBzdHJpbmdSZXByZXNlbnRhdGlvbikge1xuICAgICAgICB2YXIgc3RyaW5nID0gc3RyaW5nUmVwcmVzZW50YXRpb24gfHwgdGhpcy50b1N0cmluZygpO1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5zb3VyY2Uuc3RhcnQuY29sdW1uO1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMuc291cmNlLnN0YXJ0LmxpbmU7XG4gICAgICAgIGZvcih2YXIgaTIgPSAwOyBpMiA8IGluZGV4MjsgaTIrKyl7XG4gICAgICAgICAgICBpZiAoc3RyaW5nW2kyXSA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgICAgICAgICAgbGluZSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICBsaW5lOiBsaW5lXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8ucHJldiA9IGZ1bmN0aW9uIHByZXYoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHJldHVybiB2b2lkIDA7XG4gICAgICAgIHZhciBpbmRleDIgPSB0aGlzLnBhcmVudC5pbmRleCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm5vZGVzW2luZGV4MiAtIDFdO1xuICAgIH07XG4gICAgX3Byb3RvLnJhbmdlQnkgPSBmdW5jdGlvbiByYW5nZUJ5KG9wdHMpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0ge1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNvdXJjZS5zdGFydC5jb2x1bW4sXG4gICAgICAgICAgICBsaW5lOiB0aGlzLnNvdXJjZS5zdGFydC5saW5lXG4gICAgICAgIH07XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnNvdXJjZS5lbmQgPyB7XG4gICAgICAgICAgICBjb2x1bW46IHRoaXMuc291cmNlLmVuZC5jb2x1bW4gKyAxLFxuICAgICAgICAgICAgbGluZTogdGhpcy5zb3VyY2UuZW5kLmxpbmVcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIGNvbHVtbjogc3RhcnQuY29sdW1uICsgMSxcbiAgICAgICAgICAgIGxpbmU6IHN0YXJ0LmxpbmVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdHMud29yZCkge1xuICAgICAgICAgICAgdmFyIHN0cmluZ1JlcHJlc2VudGF0aW9uID0gdGhpcy50b1N0cmluZygpO1xuICAgICAgICAgICAgdmFyIGluZGV4MiA9IHN0cmluZ1JlcHJlc2VudGF0aW9uLmluZGV4T2Yob3B0cy53b3JkKTtcbiAgICAgICAgICAgIGlmIChpbmRleDIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4Miwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMucG9zaXRpb25JbnNpZGUoaW5kZXgyICsgb3B0cy53b3JkLmxlbmd0aCwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9wdHMuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBvcHRzLnN0YXJ0LmNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgbGluZTogb3B0cy5zdGFydC5saW5lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0cy5pbmRleCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRzLmVuZCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBvcHRzLmVuZC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IG9wdHMuZW5kLmxpbmVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy5lbmRJbmRleCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5lbmRJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuaW5kZXggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kLmxpbmUgPCBzdGFydC5saW5lIHx8IGVuZC5saW5lID09PSBzdGFydC5saW5lICYmIGVuZC5jb2x1bW4gPD0gc3RhcnQuY29sdW1uKSB7XG4gICAgICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBzdGFydC5jb2x1bW4gKyAxLFxuICAgICAgICAgICAgICAgIGxpbmU6IHN0YXJ0LmxpbmVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3ID0gZnVuY3Rpb24gcmF3KHByb3AsIGRlZmF1bHRUeXBlKSB7XG4gICAgICAgIHZhciBzdHIgPSBuZXcgU3RyaW5naWZpZXIyJDEoKTtcbiAgICAgICAgcmV0dXJuIHN0ci5yYXcodGhpcywgcHJvcCwgZGVmYXVsdFR5cGUpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudCA9IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVwbGFjZVdpdGggPSBmdW5jdGlvbiByZXBsYWNlV2l0aCgpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbm9kZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIG5vZGVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdmFyIGJvb2ttYXJrID0gdGhpcztcbiAgICAgICAgICAgIHZhciBmb3VuZFNlbGYgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlMiA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZFNlbGYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZm91bmRTZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVyKGJvb2ttYXJrLCBub2RlMik7XG4gICAgICAgICAgICAgICAgICAgIGJvb2ttYXJrID0gbm9kZTI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGJvb2ttYXJrLCBub2RlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZFNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnJvb3QgPSBmdW5jdGlvbiByb290KCkge1xuICAgICAgICB2YXIgcmVzdWx0MiA9IHRoaXM7XG4gICAgICAgIHdoaWxlKHJlc3VsdDIucGFyZW50ICYmIHJlc3VsdDIucGFyZW50LnR5cGUgIT09IFwiZG9jdW1lbnRcIil7XG4gICAgICAgICAgICByZXN1bHQyID0gcmVzdWx0Mi5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfTtcbiAgICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKF8sIGlucHV0cykge1xuICAgICAgICB2YXIgZml4ZWQgPSB7fTtcbiAgICAgICAgdmFyIGVtaXRJbnB1dHMgPSBpbnB1dHMgPT0gbnVsbDtcbiAgICAgICAgaW5wdXRzID0gaW5wdXRzIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBpbnB1dHNOZXh0SW5kZXggPSAwO1xuICAgICAgICBmb3IodmFyIG5hbWUgaW4gdGhpcyl7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwicGFyZW50XCIgfHwgbmFtZSA9PT0gXCJwcm94eUNhY2hlXCIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZpeGVkW25hbWVdID0gdmFsdWUubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGkyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGkyKSkgPT09IFwib2JqZWN0XCIgJiYgaTIudG9KU09OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTIudG9KU09OKG51bGwsIGlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZih2YWx1ZSkpID09PSBcIm9iamVjdFwiICYmIHZhbHVlLnRvSlNPTikge1xuICAgICAgICAgICAgICAgIGZpeGVkW25hbWVdID0gdmFsdWUudG9KU09OKG51bGwsIGlucHV0cyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwic291cmNlXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRJZCA9IGlucHV0cy5nZXQodmFsdWUuaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dElkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRJZCA9IGlucHV0c05leHRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnNldCh2YWx1ZS5pbnB1dCwgaW5wdXRzTmV4dEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzTmV4dEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpeGVkW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICBlbmQ6IHZhbHVlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRJZDogaW5wdXRJZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHZhbHVlLnN0YXJ0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW1pdElucHV0cykge1xuICAgICAgICAgICAgZml4ZWQuaW5wdXRzID0gW10uY29uY2F0KGlucHV0cy5rZXlzKCkpLm1hcChmdW5jdGlvbihpbnB1dDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQyLnRvSlNPTigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpeGVkO1xuICAgIH07XG4gICAgX3Byb3RvLnRvUHJveHkgPSBmdW5jdGlvbiB0b1Byb3h5KCkge1xuICAgICAgICBpZiAoIXRoaXMucHJveHlDYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5wcm94eUNhY2hlID0gbmV3IFByb3h5KHRoaXMsIHRoaXMuZ2V0UHJveHlQcm9jZXNzb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJveHlDYWNoZTtcbiAgICB9O1xuICAgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmaWVyMikge1xuICAgICAgICBpZiAoc3RyaW5naWZpZXIyID09PSB2b2lkIDApIHN0cmluZ2lmaWVyMiA9IHN0cmluZ2lmeSQzJDE7XG4gICAgICAgIGlmIChzdHJpbmdpZmllcjIuc3RyaW5naWZ5KSBzdHJpbmdpZmllcjIgPSBzdHJpbmdpZmllcjIuc3RyaW5naWZ5O1xuICAgICAgICB2YXIgcmVzdWx0MiA9IFwiXCI7XG4gICAgICAgIHN0cmluZ2lmaWVyMih0aGlzLCBmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgcmVzdWx0MiArPSBpMjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH07XG4gICAgX3Byb3RvLndhcm4gPSBmdW5jdGlvbiB3YXJuKHJlc3VsdDIsIHRleHQsIG9wdHMpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBub2RlOiB0aGlzXG4gICAgICAgIH07XG4gICAgICAgIGZvcih2YXIgaTIgaW4gb3B0cylkYXRhW2kyXSA9IG9wdHNbaTJdO1xuICAgICAgICByZXR1cm4gcmVzdWx0Mi53YXJuKHRleHQsIGRhdGEpO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhOb2RlMiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicHJveHlPZlwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gTm9kZTI7XG59KCk7XG52YXIgbm9kZSQxID0gTm9kZSQ0JDE7XG5Ob2RlJDQkMS5kZWZhdWx0ID0gTm9kZSQ0JDE7XG52YXIgTm9kZSQzJDEgPSBub2RlJDE7XG52YXIgRGVjbGFyYXRpb24kNCQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihOb2RlJDMkMSkge1xuICAgIF9pbmhlcml0cyhEZWNsYXJhdGlvbiwgTm9kZSQzJDEpO1xuICAgIGZ1bmN0aW9uIERlY2xhcmF0aW9uKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgaWYgKGRlZmF1bHRzICYmIHR5cGVvZiBkZWZhdWx0cy52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZGVmYXVsdHMudmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRlZmF1bHRzID0gX2V4dGVuZHMoe30sIGRlZmF1bHRzLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZyhkZWZhdWx0cy52YWx1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzID0gTm9kZSQzJDEuY2FsbCh0aGlzLCBkZWZhdWx0cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9IFwiZGVjbFwiO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9jcmVhdGVfY2xhc3MoRGVjbGFyYXRpb24sIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInZhcmlhYmxlXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9wLnN0YXJ0c1dpdGgoXCItLVwiKSB8fCB0aGlzLnByb3BbMF0gPT09IFwiJFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIERlY2xhcmF0aW9uO1xufShOb2RlJDMkMSk7XG52YXIgZGVjbGFyYXRpb24kMSA9IERlY2xhcmF0aW9uJDQkMTtcbkRlY2xhcmF0aW9uJDQkMS5kZWZhdWx0ID0gRGVjbGFyYXRpb24kNCQxO1xudmFyIHVybEFscGhhYmV0JDEgPSBcInVzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3RcIjtcbnZhciBuYW5vaWQkMSQxID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIGlmIChzaXplID09PSB2b2lkIDApIHNpemUgPSAyMTtcbiAgICB2YXIgaWQgPSBcIlwiO1xuICAgIHZhciBpMiA9IHNpemU7XG4gICAgd2hpbGUoaTItLSl7XG4gICAgICAgIGlkICs9IHVybEFscGhhYmV0JDFbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF07XG4gICAgfVxuICAgIHJldHVybiBpZDtcbn07XG52YXIgbm9uU2VjdXJlJDEgPSB7XG4gICAgbmFub2lkOiBuYW5vaWQkMSQxfTtcbnZhciBTb3VyY2VNYXBDb25zdW1lciQyJDEgPSByZXF1aXJlJCQyJDEuU291cmNlTWFwQ29uc3VtZXIsIFNvdXJjZU1hcEdlbmVyYXRvciQyJDEgPSByZXF1aXJlJCQyJDEuU291cmNlTWFwR2VuZXJhdG9yO1xudmFyIGV4aXN0c1N5bmMkMSA9IHJlcXVpcmUkJDIkMS5leGlzdHNTeW5jLCByZWFkRmlsZVN5bmMkMSA9IHJlcXVpcmUkJDIkMS5yZWFkRmlsZVN5bmM7XG52YXIgZGlybmFtZSQxJDEgPSByZXF1aXJlJCQyJDEuZGlybmFtZSwgam9pbiQxID0gcmVxdWlyZSQkMiQxLmpvaW47XG5mdW5jdGlvbiBmcm9tQmFzZTY0JDEoc3RyKSB7XG4gICAgaWYgKEJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCBcImJhc2U2NFwiKS50b1N0cmluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuYXRvYihzdHIpO1xuICAgIH1cbn1cbnZhciBQcmV2aW91c01hcCQyJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFByZXZpb3VzTWFwKGNzcywgb3B0cykge1xuICAgICAgICBpZiAob3B0cy5tYXAgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIHRoaXMubG9hZEFubm90YXRpb24oY3NzKTtcbiAgICAgICAgdGhpcy5pbmxpbmUgPSB0aGlzLnN0YXJ0V2l0aCh0aGlzLmFubm90YXRpb24sIFwiZGF0YTpcIik7XG4gICAgICAgIHZhciBwcmV2ID0gb3B0cy5tYXAgPyBvcHRzLm1hcC5wcmV2IDogdm9pZCAwO1xuICAgICAgICB2YXIgdGV4dCA9IHRoaXMubG9hZE1hcChvcHRzLmZyb20sIHByZXYpO1xuICAgICAgICBpZiAoIXRoaXMubWFwRmlsZSAmJiBvcHRzLmZyb20pIHtcbiAgICAgICAgICAgIHRoaXMubWFwRmlsZSA9IG9wdHMuZnJvbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXBGaWxlKSB0aGlzLnJvb3QgPSBkaXJuYW1lJDEkMSh0aGlzLm1hcEZpbGUpO1xuICAgICAgICBpZiAodGV4dCkgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFByZXZpb3VzTWFwLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uY29uc3VtZXIgPSBmdW5jdGlvbiBjb25zdW1lcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnN1bWVyQ2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZXJDYWNoZSA9IG5ldyBTb3VyY2VNYXBDb25zdW1lciQyJDEodGhpcy50ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lckNhY2hlO1xuICAgIH07XG4gICAgX3Byb3RvLmRlY29kZUlubGluZSA9IGZ1bmN0aW9uIGRlY29kZUlubGluZSh0ZXh0KSB7XG4gICAgICAgIHZhciBiYXNlQ2hhcnNldFVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247Y2hhcnNldD11dGYtPzg7YmFzZTY0LC87XG4gICAgICAgIHZhciBiYXNlVXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjtiYXNlNjQsLztcbiAgICAgICAgdmFyIGNoYXJzZXRVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2NoYXJzZXQ9dXRmLT84LC87XG4gICAgICAgIHZhciB1cmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uLC87XG4gICAgICAgIGlmIChjaGFyc2V0VXJpLnRlc3QodGV4dCkgfHwgdXJpLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodGV4dC5zdWJzdHIoUmVnRXhwLmxhc3RNYXRjaC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZUNoYXJzZXRVcmkudGVzdCh0ZXh0KSB8fCBiYXNlVXJpLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tQmFzZTY0JDEodGV4dC5zdWJzdHIoUmVnRXhwLmxhc3RNYXRjaC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5jb2RpbmcgPSB0ZXh0Lm1hdGNoKC9kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjsoW14sXSspLC8pWzFdO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBzb3VyY2UgbWFwIGVuY29kaW5nIFwiICsgZW5jb2RpbmcpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldEFubm90YXRpb25VUkwgPSBmdW5jdGlvbiBnZXRBbm5vdGF0aW9uVVJMKHNvdXJjZU1hcFN0cmluZykge1xuICAgICAgICByZXR1cm4gc291cmNlTWFwU3RyaW5nLnJlcGxhY2UoL15cXC9cXCpcXHMqIyBzb3VyY2VNYXBwaW5nVVJMPS8sIFwiXCIpLnRyaW0oKTtcbiAgICB9O1xuICAgIF9wcm90by5pc01hcCA9IGZ1bmN0aW9uIGlzTWFwKG1hcCkge1xuICAgICAgICBpZiAoKHR5cGVvZiBtYXAgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YobWFwKSkgIT09IFwib2JqZWN0XCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBtYXAubWFwcGluZ3MgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1hcC5fbWFwcGluZ3MgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheShtYXAuc2VjdGlvbnMpO1xuICAgIH07XG4gICAgX3Byb3RvLmxvYWRBbm5vdGF0aW9uID0gZnVuY3Rpb24gbG9hZEFubm90YXRpb24oY3NzKSB7XG4gICAgICAgIHZhciBjb21tZW50cyA9IGNzcy5tYXRjaCgvXFwvXFwqXFxzKiMgc291cmNlTWFwcGluZ1VSTD0vZ20pO1xuICAgICAgICBpZiAoIWNvbW1lbnRzKSByZXR1cm47XG4gICAgICAgIHZhciBzdGFydCA9IGNzcy5sYXN0SW5kZXhPZihjb21tZW50cy5wb3AoKSk7XG4gICAgICAgIHZhciBlbmQgPSBjc3MuaW5kZXhPZihcIiovXCIsIHN0YXJ0KTtcbiAgICAgICAgaWYgKHN0YXJ0ID4gLTEgJiYgZW5kID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbiA9IHRoaXMuZ2V0QW5ub3RhdGlvblVSTChjc3Muc3Vic3RyaW5nKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmxvYWRGaWxlID0gZnVuY3Rpb24gbG9hZEZpbGUocGF0aCkge1xuICAgICAgICB0aGlzLnJvb3QgPSBkaXJuYW1lJDEkMShwYXRoKTtcbiAgICAgICAgaWYgKGV4aXN0c1N5bmMkMShwYXRoKSkge1xuICAgICAgICAgICAgdGhpcy5tYXBGaWxlID0gcGF0aDtcbiAgICAgICAgICAgIHJldHVybiByZWFkRmlsZVN5bmMkMShwYXRoLCBcInV0Zi04XCIpLnRvU3RyaW5nKCkudHJpbSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZE1hcCA9IGZ1bmN0aW9uIGxvYWRNYXAoZmlsZSwgcHJldikge1xuICAgICAgICBpZiAocHJldiA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJldiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcHJldiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZQYXRoID0gcHJldihmaWxlKTtcbiAgICAgICAgICAgICAgICBpZiAocHJldlBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMubG9hZEZpbGUocHJldlBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGxvYWQgcHJldmlvdXMgc291cmNlIG1hcDogXCIgKyBwcmV2UGF0aC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocHJldiwgU291cmNlTWFwQ29uc3VtZXIkMiQxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTb3VyY2VNYXBHZW5lcmF0b3IkMiQxLmZyb21Tb3VyY2VNYXAocHJldikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocHJldiwgU291cmNlTWFwR2VuZXJhdG9yJDIkMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldi50b1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzTWFwKHByZXYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByZXYpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBwcmV2aW91cyBzb3VyY2UgbWFwIGZvcm1hdDogXCIgKyBwcmV2LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaW5saW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWNvZGVJbmxpbmUodGhpcy5hbm5vdGF0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFubm90YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBtYXAxID0gdGhpcy5hbm5vdGF0aW9uO1xuICAgICAgICAgICAgaWYgKGZpbGUpIG1hcDEgPSBqb2luJDEoZGlybmFtZSQxJDEoZmlsZSksIG1hcDEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZEZpbGUobWFwMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5zdGFydFdpdGggPSBmdW5jdGlvbiBzdGFydFdpdGgoc3RyaW5nLCBzdGFydCkge1xuICAgICAgICBpZiAoIXN0cmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gc3RyaW5nLnN1YnN0cigwLCBzdGFydC5sZW5ndGgpID09PSBzdGFydDtcbiAgICB9O1xuICAgIF9wcm90by53aXRoQ29udGVudCA9IGZ1bmN0aW9uIHdpdGhDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5jb25zdW1lcigpLnNvdXJjZXNDb250ZW50ICYmIHRoaXMuY29uc3VtZXIoKS5zb3VyY2VzQ29udGVudC5sZW5ndGggPiAwKTtcbiAgICB9O1xuICAgIHJldHVybiBQcmV2aW91c01hcDtcbn0oKTtcbnZhciBwcmV2aW91c01hcCQxID0gUHJldmlvdXNNYXAkMiQxO1xuUHJldmlvdXNNYXAkMiQxLmRlZmF1bHQgPSBQcmV2aW91c01hcCQyJDE7XG52YXIgU291cmNlTWFwQ29uc3VtZXIkMSQxID0gcmVxdWlyZSQkMiQxLlNvdXJjZU1hcENvbnN1bWVyLCBTb3VyY2VNYXBHZW5lcmF0b3IkMSQxID0gcmVxdWlyZSQkMiQxLlNvdXJjZU1hcEdlbmVyYXRvcjtcbnZhciBmaWxlVVJMVG9QYXRoJDEgPSByZXF1aXJlJCQyJDEuZmlsZVVSTFRvUGF0aCwgcGF0aFRvRmlsZVVSTCQxJDEgPSByZXF1aXJlJCQyJDEucGF0aFRvRmlsZVVSTDtcbnZhciBpc0Fic29sdXRlJDEgPSByZXF1aXJlJCQyJDEuaXNBYnNvbHV0ZSwgcmVzb2x2ZSQxJDEgPSByZXF1aXJlJCQyJDEucmVzb2x2ZTtcbnZhciBuYW5vaWQkMiA9IG5vblNlY3VyZSQxLm5hbm9pZDtcbnZhciB0ZXJtaW5hbEhpZ2hsaWdodCQyID0gcmVxdWlyZSQkMiQxO1xudmFyIENzc1N5bnRheEVycm9yJDEkMSA9IGNzc1N5bnRheEVycm9yJDE7XG52YXIgUHJldmlvdXNNYXAkMSQxID0gcHJldmlvdXNNYXAkMTtcbnZhciBmcm9tT2Zmc2V0Q2FjaGUkMSA9IFN5bWJvbChcImZyb21PZmZzZXRDYWNoZVwiKTtcbnZhciBzb3VyY2VNYXBBdmFpbGFibGUkMSQxID0gQm9vbGVhbihTb3VyY2VNYXBDb25zdW1lciQxJDEgJiYgU291cmNlTWFwR2VuZXJhdG9yJDEkMSk7XG52YXIgcGF0aEF2YWlsYWJsZSQxJDEgPSBCb29sZWFuKHJlc29sdmUkMSQxICYmIGlzQWJzb2x1dGUkMSk7XG52YXIgSW5wdXQkNCQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBJbnB1dChjc3MsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICBpZiAoY3NzID09PSBudWxsIHx8IHR5cGVvZiBjc3MgPT09IFwidW5kZWZpbmVkXCIgfHwgKHR5cGVvZiBjc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YoY3NzKSkgPT09IFwib2JqZWN0XCIgJiYgIWNzcy50b1N0cmluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9zdENTUyByZWNlaXZlZCBcIiArIGNzcyArIFwiIGluc3RlYWQgb2YgQ1NTIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNzcyA9IGNzcy50b1N0cmluZygpO1xuICAgICAgICBpZiAodGhpcy5jc3NbMF0gPT09IFwiXFx1RkVGRlwiIHx8IHRoaXMuY3NzWzBdID09PSBcIu+/vlwiKSB7XG4gICAgICAgICAgICB0aGlzLmhhc0JPTSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNzcyA9IHRoaXMuY3NzLnNsaWNlKDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYXNCT00gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5mcm9tKSB7XG4gICAgICAgICAgICBpZiAoIXBhdGhBdmFpbGFibGUkMSQxIHx8IC9eXFx3KzpcXC9cXC8vLnRlc3Qob3B0cy5mcm9tKSB8fCBpc0Fic29sdXRlJDEob3B0cy5mcm9tKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZSA9IG9wdHMuZnJvbTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlID0gcmVzb2x2ZSQxJDEob3B0cy5mcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aEF2YWlsYWJsZSQxJDEgJiYgc291cmNlTWFwQXZhaWxhYmxlJDEkMSkge1xuICAgICAgICAgICAgdmFyIG1hcCA9IG5ldyBQcmV2aW91c01hcCQxJDEodGhpcy5jc3MsIG9wdHMpO1xuICAgICAgICAgICAgaWYgKG1hcC50ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgICAgICAgICAgdmFyIGZpbGUgPSBtYXAuY29uc3VtZXIoKS5maWxlO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5maWxlICYmIGZpbGUpIHRoaXMuZmlsZSA9IHRoaXMubWFwUmVzb2x2ZShmaWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuZmlsZSkge1xuICAgICAgICAgICAgdGhpcy5pZCA9IFwiPGlucHV0IGNzcyBcIiArIG5hbm9pZCQyKDYpICsgXCI+XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWFwKSB0aGlzLm1hcC5maWxlID0gdGhpcy5mcm9tO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gSW5wdXQucHJvdG90eXBlO1xuICAgIF9wcm90by5lcnJvciA9IGZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UsIGxpbmUsIGNvbHVtbiwgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIHZhciByZXN1bHQyLCBlbmRMaW5lLCBlbmRDb2x1bW47XG4gICAgICAgIGlmIChsaW5lICYmICh0eXBlb2YgbGluZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihsaW5lKSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGxpbmU7XG4gICAgICAgICAgICB2YXIgZW5kID0gY29sdW1uO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGFydC5vZmZzZXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5mcm9tT2Zmc2V0KHN0YXJ0Lm9mZnNldCk7XG4gICAgICAgICAgICAgICAgbGluZSA9IHBvcy5saW5lO1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IHBvcy5jb2w7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmUgPSBzdGFydC5saW5lO1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IHN0YXJ0LmNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5kLm9mZnNldCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHZhciBwb3MxID0gdGhpcy5mcm9tT2Zmc2V0KGVuZC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGVuZExpbmUgPSBwb3MxLmxpbmU7XG4gICAgICAgICAgICAgICAgZW5kQ29sdW1uID0gcG9zMS5jb2w7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZExpbmUgPSBlbmQubGluZTtcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW4gPSBlbmQuY29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFjb2x1bW4pIHtcbiAgICAgICAgICAgIHZhciBwb3MyID0gdGhpcy5mcm9tT2Zmc2V0KGxpbmUpO1xuICAgICAgICAgICAgbGluZSA9IHBvczIubGluZTtcbiAgICAgICAgICAgIGNvbHVtbiA9IHBvczIuY29sO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbihsaW5lLCBjb2x1bW4sIGVuZExpbmUsIGVuZENvbHVtbik7XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBuZXcgQ3NzU3ludGF4RXJyb3IkMSQxKG1lc3NhZ2UsIG9yaWdpbi5lbmRMaW5lID09PSB2b2lkIDAgPyBvcmlnaW4ubGluZSA6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbi5jb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogb3JpZ2luLmxpbmVcbiAgICAgICAgICAgIH0sIG9yaWdpbi5lbmRMaW5lID09PSB2b2lkIDAgPyBvcmlnaW4uY29sdW1uIDoge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luLmVuZENvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBvcmlnaW4uZW5kTGluZVxuICAgICAgICAgICAgfSwgb3JpZ2luLnNvdXJjZSwgb3JpZ2luLmZpbGUsIG9wdHMucGx1Z2luKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBuZXcgQ3NzU3ludGF4RXJyb3IkMSQxKG1lc3NhZ2UsIGVuZExpbmUgPT09IHZvaWQgMCA/IGxpbmUgOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogbGluZVxuICAgICAgICAgICAgfSwgZW5kTGluZSA9PT0gdm9pZCAwID8gY29sdW1uIDoge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogZW5kQ29sdW1uLFxuICAgICAgICAgICAgICAgIGxpbmU6IGVuZExpbmVcbiAgICAgICAgICAgIH0sIHRoaXMuY3NzLCB0aGlzLmZpbGUsIG9wdHMucGx1Z2luKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQyLmlucHV0ID0ge1xuICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICBlbmRDb2x1bW46IGVuZENvbHVtbixcbiAgICAgICAgICAgIGVuZExpbmU6IGVuZExpbmUsXG4gICAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLmNzc1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5maWxlKSB7XG4gICAgICAgICAgICBpZiAocGF0aFRvRmlsZVVSTCQxJDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyLmlucHV0LnVybCA9IHBhdGhUb0ZpbGVVUkwkMSQxKHRoaXMuZmlsZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdDIuaW5wdXQuZmlsZSA9IHRoaXMuZmlsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9O1xuICAgIF9wcm90by5mcm9tT2Zmc2V0ID0gZnVuY3Rpb24gZnJvbU9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgdmFyIGxhc3RMaW5lLCBsaW5lVG9JbmRleDtcbiAgICAgICAgaWYgKCF0aGlzW2Zyb21PZmZzZXRDYWNoZSQxXSkge1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5jc3Muc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICBsaW5lVG9JbmRleCA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHByZXZJbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IodmFyIGkyID0gMCwgbDIgPSBsaW5lcy5sZW5ndGg7IGkyIDwgbDI7IGkyKyspe1xuICAgICAgICAgICAgICAgIGxpbmVUb0luZGV4W2kyXSA9IHByZXZJbmRleDtcbiAgICAgICAgICAgICAgICBwcmV2SW5kZXggKz0gbGluZXNbaTJdLmxlbmd0aCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW2Zyb21PZmZzZXRDYWNoZSQxXSA9IGxpbmVUb0luZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluZVRvSW5kZXggPSB0aGlzW2Zyb21PZmZzZXRDYWNoZSQxXTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0TGluZSA9IGxpbmVUb0luZGV4W2xpbmVUb0luZGV4Lmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbWluID0gMDtcbiAgICAgICAgaWYgKG9mZnNldCA+PSBsYXN0TGluZSkge1xuICAgICAgICAgICAgbWluID0gbGluZVRvSW5kZXgubGVuZ3RoIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXggPSBsaW5lVG9JbmRleC5sZW5ndGggLSAyO1xuICAgICAgICAgICAgdmFyIG1pZDtcbiAgICAgICAgICAgIHdoaWxlKG1pbiA8IG1heCl7XG4gICAgICAgICAgICAgICAgbWlkID0gbWluICsgKG1heCAtIG1pbiA+PiAxKTtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0IDwgbGluZVRvSW5kZXhbbWlkXSkge1xuICAgICAgICAgICAgICAgICAgICBtYXggPSBtaWQgLSAxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID49IGxpbmVUb0luZGV4W21pZCArIDFdKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IG1pZCArIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gbWlkO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbDogb2Zmc2V0IC0gbGluZVRvSW5kZXhbbWluXSArIDEsXG4gICAgICAgICAgICBsaW5lOiBtaW4gKyAxXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8ubWFwUmVzb2x2ZSA9IGZ1bmN0aW9uIG1hcFJlc29sdmUoZmlsZSkge1xuICAgICAgICBpZiAoL15cXHcrOlxcL1xcLy8udGVzdChmaWxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmUkMSQxKHRoaXMubWFwLmNvbnN1bWVyKCkuc291cmNlUm9vdCB8fCB0aGlzLm1hcC5yb290IHx8IFwiLlwiLCBmaWxlKTtcbiAgICB9O1xuICAgIF9wcm90by5vcmlnaW4gPSBmdW5jdGlvbiBvcmlnaW4obGluZSwgY29sdW1uLCBlbmRMaW5lLCBlbmRDb2x1bW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hcCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgY29uc3VtZXIgPSB0aGlzLm1hcC5jb25zdW1lcigpO1xuICAgICAgICB2YXIgZnJvbSA9IGNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICBsaW5lOiBsaW5lXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWZyb20uc291cmNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciB0bztcbiAgICAgICAgaWYgKHR5cGVvZiBlbmRMaW5lID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0byA9IGNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgICAgICAgIGNvbHVtbjogZW5kQ29sdW1uLFxuICAgICAgICAgICAgICAgIGxpbmU6IGVuZExpbmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmcm9tVXJsO1xuICAgICAgICBpZiAoaXNBYnNvbHV0ZSQxKGZyb20uc291cmNlKSkge1xuICAgICAgICAgICAgZnJvbVVybCA9IHBhdGhUb0ZpbGVVUkwkMSQxKGZyb20uc291cmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyb21VcmwgPSBuZXcgVVJMKGZyb20uc291cmNlLCB0aGlzLm1hcC5jb25zdW1lcigpLnNvdXJjZVJvb3QgfHwgcGF0aFRvRmlsZVVSTCQxJDEodGhpcy5tYXAubWFwRmlsZSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQyID0ge1xuICAgICAgICAgICAgY29sdW1uOiBmcm9tLmNvbHVtbixcbiAgICAgICAgICAgIGVuZENvbHVtbjogdG8gJiYgdG8uY29sdW1uLFxuICAgICAgICAgICAgZW5kTGluZTogdG8gJiYgdG8ubGluZSxcbiAgICAgICAgICAgIGxpbmU6IGZyb20ubGluZSxcbiAgICAgICAgICAgIHVybDogZnJvbVVybC50b1N0cmluZygpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmcm9tVXJsLnByb3RvY29sID09PSBcImZpbGU6XCIpIHtcbiAgICAgICAgICAgIGlmIChmaWxlVVJMVG9QYXRoJDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyLmZpbGUgPSBmaWxlVVJMVG9QYXRoJDEoZnJvbVVybCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZpbGU6IHByb3RvY29sIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBQb3N0Q1NTIGJ1aWxkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzb3VyY2UgPSBjb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGZyb20uc291cmNlKTtcbiAgICAgICAgaWYgKHNvdXJjZSkgcmVzdWx0Mi5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH07XG4gICAgX3Byb3RvLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgdmFyIGpzb24gPSB7fTtcbiAgICAgICAgZm9yKHZhciBfaSA9IDAsIF9pdGVyID0gW1xuICAgICAgICAgICAgXCJoYXNCT01cIixcbiAgICAgICAgICAgIFwiY3NzXCIsXG4gICAgICAgICAgICBcImZpbGVcIixcbiAgICAgICAgICAgIFwiaWRcIlxuICAgICAgICBdOyBfaSA8IF9pdGVyLmxlbmd0aDsgX2krKyl7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9pdGVyW19pXTtcbiAgICAgICAgICAgIGlmICh0aGlzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBqc29uW25hbWVdID0gdGhpc1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXApIHtcbiAgICAgICAgICAgIGpzb24ubWFwID0gX2V4dGVuZHMoe30sIHRoaXMubWFwKTtcbiAgICAgICAgICAgIGlmIChqc29uLm1hcC5jb25zdW1lckNhY2hlKSB7XG4gICAgICAgICAgICAgICAganNvbi5tYXAuY29uc3VtZXJDYWNoZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9O1xuICAgIF9jcmVhdGVfY2xhc3MoSW5wdXQsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21cIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGUgfHwgdGhpcy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBJbnB1dDtcbn0oKTtcbnZhciBpbnB1dCQxID0gSW5wdXQkNCQxO1xuSW5wdXQkNCQxLmRlZmF1bHQgPSBJbnB1dCQ0JDE7XG5pZiAodGVybWluYWxIaWdobGlnaHQkMiAmJiB0ZXJtaW5hbEhpZ2hsaWdodCQyLnJlZ2lzdGVySW5wdXQpIHtcbiAgICB0ZXJtaW5hbEhpZ2hsaWdodCQyLnJlZ2lzdGVySW5wdXQoSW5wdXQkNCQxKTtcbn1cbnZhciBTb3VyY2VNYXBDb25zdW1lciQzID0gcmVxdWlyZSQkMiQxLlNvdXJjZU1hcENvbnN1bWVyLCBTb3VyY2VNYXBHZW5lcmF0b3IkMyA9IHJlcXVpcmUkJDIkMS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgZGlybmFtZSQyID0gcmVxdWlyZSQkMiQxLmRpcm5hbWUsIHJlbGF0aXZlJDEgPSByZXF1aXJlJCQyJDEucmVsYXRpdmUsIHJlc29sdmUkMiA9IHJlcXVpcmUkJDIkMS5yZXNvbHZlLCBzZXAkMSA9IHJlcXVpcmUkJDIkMS5zZXA7XG52YXIgcGF0aFRvRmlsZVVSTCQyID0gcmVxdWlyZSQkMiQxLnBhdGhUb0ZpbGVVUkw7XG52YXIgSW5wdXQkMyQxID0gaW5wdXQkMTtcbnZhciBzb3VyY2VNYXBBdmFpbGFibGUkMiA9IEJvb2xlYW4oU291cmNlTWFwQ29uc3VtZXIkMyAmJiBTb3VyY2VNYXBHZW5lcmF0b3IkMyk7XG52YXIgcGF0aEF2YWlsYWJsZSQyID0gQm9vbGVhbihkaXJuYW1lJDIgJiYgcmVzb2x2ZSQyICYmIHJlbGF0aXZlJDEgJiYgc2VwJDEpO1xudmFyIE1hcEdlbmVyYXRvciQyJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE1hcEdlbmVyYXRvcihzdHJpbmdpZnkyLCByb290Miwgb3B0cywgY3NzU3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5MjtcbiAgICAgICAgdGhpcy5tYXBPcHRzID0gb3B0cy5tYXAgfHwge307XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3QyO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLmNzcyA9IGNzc1N0cmluZztcbiAgICAgICAgdGhpcy5vcmlnaW5hbENTUyA9IGNzc1N0cmluZztcbiAgICAgICAgdGhpcy51c2VzRmlsZVVybHMgPSAhdGhpcy5tYXBPcHRzLmZyb20gJiYgdGhpcy5tYXBPcHRzLmFic29sdXRlO1xuICAgICAgICB0aGlzLm1lbW9pemVkRmlsZVVSTHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm1lbW9pemVkUGF0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm1lbW9pemVkVVJMcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBNYXBHZW5lcmF0b3IucHJvdG90eXBlO1xuICAgIF9wcm90by5hZGRBbm5vdGF0aW9uID0gZnVuY3Rpb24gYWRkQW5ub3RhdGlvbigpIHtcbiAgICAgICAgdmFyIGNvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBcImRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyB0aGlzLnRvQmFzZTY0KHRoaXMubWFwLnRvU3RyaW5nKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29udGVudCA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gdGhpcy5tYXBPcHRzLmFubm90YXRpb24odGhpcy5vcHRzLnRvLCB0aGlzLnJvb3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGVudCA9IHRoaXMub3V0cHV0RmlsZSgpICsgXCIubWFwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVvbCA9IFwiXFxuXCI7XG4gICAgICAgIGlmICh0aGlzLmNzcy5pbmNsdWRlcyhcIlxcclxcblwiKSkgZW9sID0gXCJcXHJcXG5cIjtcbiAgICAgICAgdGhpcy5jc3MgKz0gZW9sICsgXCIvKiMgc291cmNlTWFwcGluZ1VSTD1cIiArIGNvbnRlbnQgKyBcIiAqL1wiO1xuICAgIH07XG4gICAgX3Byb3RvLmFwcGx5UHJldk1hcHMgPSBmdW5jdGlvbiBhcHBseVByZXZNYXBzKCkge1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh0aGlzLnByZXZpb3VzKCkpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgcHJldiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGZyb20gPSB0aGlzLnRvVXJsKHRoaXMucGF0aChwcmV2LmZpbGUpKTtcbiAgICAgICAgICAgIHZhciByb290MiA9IHByZXYucm9vdCB8fCBkaXJuYW1lJDIocHJldi5maWxlKTtcbiAgICAgICAgICAgIHZhciBtYXAgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIG1hcCA9IG5ldyBTb3VyY2VNYXBDb25zdW1lciQzKHByZXYudGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcC5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwID0gcHJldi5jb25zdW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXAuYXBwbHlTb3VyY2VNYXAobWFwLCBmcm9tLCB0aGlzLnRvVXJsKHRoaXMucGF0aChyb290MikpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNsZWFyQW5ub3RhdGlvbiA9IGZ1bmN0aW9uIGNsZWFyQW5ub3RhdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICB2YXIgbm9kZTI7XG4gICAgICAgICAgICBmb3IodmFyIGkyID0gdGhpcy5yb290Lm5vZGVzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pe1xuICAgICAgICAgICAgICAgIG5vZGUyID0gdGhpcy5yb290Lm5vZGVzW2kyXTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJjb21tZW50XCIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlMi50ZXh0LmluZGV4T2YoXCIjIHNvdXJjZU1hcHBpbmdVUkw9XCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdC5yZW1vdmVDaGlsZChpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3NzKSB7XG4gICAgICAgICAgICB0aGlzLmNzcyA9IHRoaXMuY3NzLnJlcGxhY2UoL1xcbio/XFwvXFwqI1tcXFNcXHNdKj9cXCpcXC8kL2dtLCBcIlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJBbm5vdGF0aW9uKCk7XG4gICAgICAgIGlmIChwYXRoQXZhaWxhYmxlJDIgJiYgc291cmNlTWFwQXZhaWxhYmxlJDIgJiYgdGhpcy5pc01hcCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZU1hcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDIgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdpZnkodGhpcy5yb290LCBmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgKz0gaTI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgcmVzdWx0MlxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdlbmVyYXRlTWFwID0gZnVuY3Rpb24gZ2VuZXJhdGVNYXAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVTdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHRoaXMucHJldmlvdXMoKVswXS5jb25zdW1lcigpO1xuICAgICAgICAgICAgcHJldi5maWxlID0gdGhpcy5vdXRwdXRGaWxlKCk7XG4gICAgICAgICAgICB0aGlzLm1hcCA9IFNvdXJjZU1hcEdlbmVyYXRvciQzLmZyb21Tb3VyY2VNYXAocHJldiwge1xuICAgICAgICAgICAgICAgIGlnbm9yZUludmFsaWRNYXBwaW5nOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvciQzKHtcbiAgICAgICAgICAgICAgICBmaWxlOiB0aGlzLm91dHB1dEZpbGUoKSxcbiAgICAgICAgICAgICAgICBpZ25vcmVJbnZhbGlkTWFwcGluZzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm1hcC5hZGRNYXBwaW5nKHtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiAwLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAxXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IDFcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5vcHRzLmZyb20gPyB0aGlzLnRvVXJsKHRoaXMucGF0aCh0aGlzLm9wdHMuZnJvbSkpIDogXCI8bm8gc291cmNlPlwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1NvdXJjZXNDb250ZW50KCkpIHRoaXMuc2V0U291cmNlc0NvbnRlbnQoKTtcbiAgICAgICAgaWYgKHRoaXMucm9vdCAmJiB0aGlzLnByZXZpb3VzKCkubGVuZ3RoID4gMCkgdGhpcy5hcHBseVByZXZNYXBzKCk7XG4gICAgICAgIGlmICh0aGlzLmlzQW5ub3RhdGlvbigpKSB0aGlzLmFkZEFubm90YXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB0aGlzLmNzc1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpcy5jc3MsXG4gICAgICAgICAgICAgICAgdGhpcy5tYXBcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5nZW5lcmF0ZVN0cmluZyA9IGZ1bmN0aW9uIGdlbmVyYXRlU3RyaW5nKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmNzcyA9IFwiXCI7XG4gICAgICAgIHRoaXMubWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvciQzKHtcbiAgICAgICAgICAgIGZpbGU6IHRoaXMub3V0cHV0RmlsZSgpLFxuICAgICAgICAgICAgaWdub3JlSW52YWxpZE1hcHBpbmc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsaW5lID0gMTtcbiAgICAgICAgdmFyIGNvbHVtbiA9IDE7XG4gICAgICAgIHZhciBub1NvdXJjZSA9IFwiPG5vIHNvdXJjZT5cIjtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgbGluZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiAwLFxuICAgICAgICAgICAgICAgIGxpbmU6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb3VyY2U6IFwiXCJcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGxpbmVzLCBsYXN0O1xuICAgICAgICB0aGlzLnN0cmluZ2lmeSh0aGlzLnJvb3QsIGZ1bmN0aW9uKHN0ciwgbm9kZTIsIHR5cGUpIHtcbiAgICAgICAgICAgIF90aGlzLmNzcyArPSBzdHI7XG4gICAgICAgICAgICBpZiAobm9kZTIgJiYgdHlwZSAhPT0gXCJlbmRcIikge1xuICAgICAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDE7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSAmJiBub2RlMi5zb3VyY2Uuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBfdGhpcy5zb3VyY2VQYXRoKG5vZGUyKTtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5saW5lID0gbm9kZTIuc291cmNlLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gbm9kZTIuc291cmNlLnN0YXJ0LmNvbHVtbiAtIDE7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gbm9Tb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwuY29sdW1uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZXMgPSBzdHIubWF0Y2goL1xcbi9nKTtcbiAgICAgICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgICAgIGxpbmUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxhc3QgPSBzdHIubGFzdEluZGV4T2YoXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gc3RyLmxlbmd0aCAtIGxhc3Q7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbHVtbiArPSBzdHIubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUyICYmIHR5cGUgIT09IFwic3RhcnRcIikge1xuICAgICAgICAgICAgICAgIHZhciBwID0gbm9kZTIucGFyZW50IHx8IHtcbiAgICAgICAgICAgICAgICAgICAgcmF3czoge31cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZGxlc3MgPSBub2RlMi50eXBlID09PSBcImRlY2xcIiB8fCBub2RlMi50eXBlID09PSBcImF0cnVsZVwiICYmICFub2RlMi5ub2RlcztcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkbGVzcyB8fCBub2RlMiAhPT0gcC5sYXN0IHx8IHAucmF3cy5zZW1pY29sb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSAmJiBub2RlMi5zb3VyY2UuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IF90aGlzLnNvdXJjZVBhdGgobm9kZTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5saW5lID0gbm9kZTIuc291cmNlLmVuZC5saW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSBub2RlMi5zb3VyY2UuZW5kLmNvbHVtbiAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5saW5lID0gbGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gbm9Tb3VyY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5jb2x1bW4gPSBjb2x1bW4gLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmlzQW5ub3RhdGlvbiA9IGZ1bmN0aW9uIGlzQW5ub3RhdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNJbmxpbmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTIuYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgX3Byb3RvLmlzSW5saW5lID0gZnVuY3Rpb24gaXNJbmxpbmUoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmlubGluZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwT3B0cy5pbmxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFubm90YXRpb24gPSB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbjtcbiAgICAgICAgaWYgKHR5cGVvZiBhbm5vdGF0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIGFubm90YXRpb24gIT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcmV2aW91cygpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXMoKS5zb21lKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkyLmlubGluZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgX3Byb3RvLmlzTWFwID0gZnVuY3Rpb24gaXNNYXAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLm1hcCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5vcHRzLm1hcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLmxlbmd0aCA+IDA7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNTb3VyY2VzQ29udGVudCA9IGZ1bmN0aW9uIGlzU291cmNlc0NvbnRlbnQoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLnNvdXJjZXNDb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTIud2l0aENvbnRlbnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgX3Byb3RvLm91dHB1dEZpbGUgPSBmdW5jdGlvbiBvdXRwdXRGaWxlKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLnRvKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXRoKHRoaXMub3B0cy50byk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLmZyb20pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGgodGhpcy5vcHRzLmZyb20pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwidG8uY3NzXCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5wYXRoID0gZnVuY3Rpb24gcGF0aChmaWxlKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcE9wdHMuYWJzb2x1dGUpIHJldHVybiBmaWxlO1xuICAgICAgICBpZiAoZmlsZS5jaGFyQ29kZUF0KDApID09PSA2MCkgcmV0dXJuIGZpbGU7XG4gICAgICAgIGlmICgvXlxcdys6XFwvXFwvLy50ZXN0KGZpbGUpKSByZXR1cm4gZmlsZTtcbiAgICAgICAgdmFyIGNhY2hlZCA9IHRoaXMubWVtb2l6ZWRQYXRocy5nZXQoZmlsZSk7XG4gICAgICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIHZhciBmcm9tID0gdGhpcy5vcHRzLnRvID8gZGlybmFtZSQyKHRoaXMub3B0cy50bykgOiBcIi5cIjtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZnJvbSA9IGRpcm5hbWUkMihyZXNvbHZlJDIoZnJvbSwgdGhpcy5tYXBPcHRzLmFubm90YXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGF0aCA9IHJlbGF0aXZlJDEoZnJvbSwgZmlsZSk7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRQYXRocy5zZXQoZmlsZSwgcGF0aCk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG4gICAgX3Byb3RvLnByZXZpb3VzID0gZnVuY3Rpb24gcHJldmlvdXMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5wcmV2aW91c01hcHMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNNYXBzID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LndhbGsoZnVuY3Rpb24obm9kZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSAmJiBub2RlMi5zb3VyY2UuaW5wdXQubWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gbm9kZTIuc291cmNlLmlucHV0Lm1hcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMucHJldmlvdXNNYXBzLmluY2x1ZGVzKG1hcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcmV2aW91c01hcHMucHVzaChtYXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dDIgPSBuZXcgSW5wdXQkMyQxKHRoaXMub3JpZ2luYWxDU1MsIHRoaXMub3B0cyk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0Mi5tYXApIHRoaXMucHJldmlvdXNNYXBzLnB1c2goaW5wdXQyLm1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXNNYXBzO1xuICAgIH07XG4gICAgX3Byb3RvLnNldFNvdXJjZXNDb250ZW50ID0gZnVuY3Rpb24gc2V0U291cmNlc0NvbnRlbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhbHJlYWR5ID0ge307XG4gICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC53YWxrKGZ1bmN0aW9uKG5vZGUyKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IG5vZGUyLnNvdXJjZS5pbnB1dC5mcm9tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSAmJiAhYWxyZWFkeVtmcm9tXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxyZWFkeVtmcm9tXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbVVybCA9IF90aGlzLnVzZXNGaWxlVXJscyA/IF90aGlzLnRvRmlsZVVybChmcm9tKSA6IF90aGlzLnRvVXJsKF90aGlzLnBhdGgoZnJvbSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFwLnNldFNvdXJjZUNvbnRlbnQoZnJvbVVybCwgbm9kZTIuc291cmNlLmlucHV0LmNzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNzcykge1xuICAgICAgICAgICAgdmFyIGZyb20gPSB0aGlzLm9wdHMuZnJvbSA/IHRoaXMudG9VcmwodGhpcy5wYXRoKHRoaXMub3B0cy5mcm9tKSkgOiBcIjxubyBzb3VyY2U+XCI7XG4gICAgICAgICAgICB0aGlzLm1hcC5zZXRTb3VyY2VDb250ZW50KGZyb20sIHRoaXMuY3NzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnNvdXJjZVBhdGggPSBmdW5jdGlvbiBzb3VyY2VQYXRoKG5vZGUyKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcE9wdHMuZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9VcmwodGhpcy5tYXBPcHRzLmZyb20pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudXNlc0ZpbGVVcmxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0ZpbGVVcmwobm9kZTIuc291cmNlLmlucHV0LmZyb20pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9VcmwodGhpcy5wYXRoKG5vZGUyLnNvdXJjZS5pbnB1dC5mcm9tKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by50b0Jhc2U2NCA9IGZ1bmN0aW9uIHRvQmFzZTY0KHN0cikge1xuICAgICAgICBpZiAoQnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udG9GaWxlVXJsID0gZnVuY3Rpb24gdG9GaWxlVXJsKHBhdGgpIHtcbiAgICAgICAgdmFyIGNhY2hlZCA9IHRoaXMubWVtb2l6ZWRGaWxlVVJMcy5nZXQocGF0aCk7XG4gICAgICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIGlmIChwYXRoVG9GaWxlVVJMJDIpIHtcbiAgICAgICAgICAgIHZhciBmaWxlVVJMID0gcGF0aFRvRmlsZVVSTCQyKHBhdGgpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLm1lbW9pemVkRmlsZVVSTHMuc2V0KHBhdGgsIGZpbGVVUkwpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGVVUkw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgbWFwLmFic29sdXRlYCBvcHRpb24gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIFBvc3RDU1MgYnVpbGRcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by50b1VybCA9IGZ1bmN0aW9uIHRvVXJsKHBhdGgpIHtcbiAgICAgICAgdmFyIGNhY2hlZCA9IHRoaXMubWVtb2l6ZWRVUkxzLmdldChwYXRoKTtcbiAgICAgICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgaWYgKHNlcCQxID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFxcXC9nLCBcIi9cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVybCA9IGVuY29kZVVSSShwYXRoKS5yZXBsYWNlKC9bIz9dL2csIGVuY29kZVVSSUNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRVUkxzLnNldChwYXRoLCB1cmwpO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcEdlbmVyYXRvcjtcbn0oKTtcbnZhciBtYXBHZW5lcmF0b3IkMSA9IE1hcEdlbmVyYXRvciQyJDE7XG52YXIgTm9kZSQyJDEgPSBub2RlJDE7XG52YXIgQ29tbWVudCQ0JDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vZGUkMiQxKSB7XG4gICAgX2luaGVyaXRzKENvbW1lbnQsIE5vZGUkMiQxKTtcbiAgICBmdW5jdGlvbiBDb21tZW50KGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBOb2RlJDIkMS5jYWxsKHRoaXMsIGRlZmF1bHRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gXCJjb21tZW50XCI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIENvbW1lbnQ7XG59KE5vZGUkMiQxKTtcbnZhciBjb21tZW50JDEgPSBDb21tZW50JDQkMTtcbkNvbW1lbnQkNCQxLmRlZmF1bHQgPSBDb21tZW50JDQkMTtcbnZhciBpc0NsZWFuJDEkMSA9IHN5bWJvbHMkMS5pc0NsZWFuLCBteSQxJDEgPSBzeW1ib2xzJDEubXk7XG52YXIgRGVjbGFyYXRpb24kMyQxID0gZGVjbGFyYXRpb24kMTtcbnZhciBDb21tZW50JDMkMSA9IGNvbW1lbnQkMTtcbnZhciBOb2RlJDEkMSA9IG5vZGUkMTtcbnZhciBwYXJzZSQ0JDEsIFJ1bGUkNCQxLCBBdFJ1bGUkNCQxLCBSb290JDYkMTtcbmZ1bmN0aW9uIGNsZWFuU291cmNlJDEobm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIGlmIChpMi5ub2RlcykgaTIubm9kZXMgPSBjbGVhblNvdXJjZSQxKGkyLm5vZGVzKTtcbiAgICAgICAgZGVsZXRlIGkyLnNvdXJjZTtcbiAgICAgICAgcmV0dXJuIGkyO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbWFya0RpcnR5VXAkMShub2RlMikge1xuICAgIG5vZGUyW2lzQ2xlYW4kMSQxXSA9IGZhbHNlO1xuICAgIGlmIChub2RlMi5wcm94eU9mLm5vZGVzKSB7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGUyLnByb3h5T2Yubm9kZXMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgaTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIG1hcmtEaXJ0eVVwJDEoaTIpO1xuICAgICAgICB9XG4gICAgfVxufVxudmFyIENvbnRhaW5lciQ3JDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vZGUkMSQxKSB7XG4gICAgX2luaGVyaXRzKENvbnRhaW5lciwgTm9kZSQxJDEpO1xuICAgIGZ1bmN0aW9uIENvbnRhaW5lcigpIHtcbiAgICAgICAgcmV0dXJuIE5vZGUkMSQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IENvbnRhaW5lci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCgpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY2hpbGRyZW4gPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIGNoaWxkcmVuW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKGNoaWxkcmVuKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShjaGlsZCwgdGhpcy5sYXN0KTtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yMSA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwMTsgIShfc3RlcDEgPSBfaXRlcmF0b3IxKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzLnB1c2gobm9kZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLmNsZWFuUmF3cyA9IGZ1bmN0aW9uIGNsZWFuUmF3cyhrZWVwQmV0d2Vlbikge1xuICAgICAgICBOb2RlJDEkMS5wcm90b3R5cGUuY2xlYW5SYXdzLmNhbGwodGhpcywga2VlcEJldHdlZW4pO1xuICAgICAgICBpZiAodGhpcy5ub2Rlcykge1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UodGhpcy5ub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICBub2RlMi5jbGVhblJhd3Moa2VlcEJldHdlZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZWFjaCA9IGZ1bmN0aW9uIGVhY2goY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHJldHVybiB2b2lkIDA7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMuZ2V0SXRlcmF0b3IoKTtcbiAgICAgICAgdmFyIGluZGV4MiwgcmVzdWx0MjtcbiAgICAgICAgd2hpbGUodGhpcy5pbmRleGVzW2l0ZXJhdG9yXSA8IHRoaXMucHJveHlPZi5ub2Rlcy5sZW5ndGgpe1xuICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2l0ZXJhdG9yXTtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBjYWxsYmFjayh0aGlzLnByb3h5T2Yubm9kZXNbaW5kZXgyXSwgaW5kZXgyKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyID09PSBmYWxzZSkgYnJlYWs7XG4gICAgICAgICAgICB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuaW5kZXhlc1tpdGVyYXRvcl07XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH07XG4gICAgX3Byb3RvLmV2ZXJ5ID0gZnVuY3Rpb24gZXZlcnkoY29uZGl0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzLmV2ZXJ5KGNvbmRpdGlvbik7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0SXRlcmF0b3IgPSBmdW5jdGlvbiBnZXRJdGVyYXRvcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxhc3RFYWNoKSB0aGlzLmxhc3RFYWNoID0gMDtcbiAgICAgICAgaWYgKCF0aGlzLmluZGV4ZXMpIHRoaXMuaW5kZXhlcyA9IHt9O1xuICAgICAgICB0aGlzLmxhc3RFYWNoICs9IDE7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IHRoaXMubGFzdEVhY2g7XG4gICAgICAgIHRoaXMuaW5kZXhlc1tpdGVyYXRvcl0gPSAwO1xuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0UHJveHlQcm9jZXNzb3IgPSBmdW5jdGlvbiBnZXRQcm94eVByb2Nlc3NvcigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KG5vZGUyLCBwcm9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IFwicHJveHlPZlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFub2RlMltwcm9wXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcImVhY2hcIiB8fCB0eXBlb2YgcHJvcCA9PT0gXCJzdHJpbmdcIiAmJiBwcm9wLnN0YXJ0c1dpdGgoXCJ3YWxrXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9ub2RlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoX25vZGUyID0gbm9kZTIpW3Byb3BdLmFwcGx5KF9ub2RlMiwgW10uY29uY2F0KGFyZ3MubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjaGlsZCwgaW5kZXgyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTIoY2hpbGQudG9Qcm94eSgpLCBpbmRleDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJldmVyeVwiIHx8IHByb3AgPT09IFwic29tZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgb3RoZXIgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQudG9Qcm94eSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSwgb3RoZXIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyLnJvb3QoKS50b1Byb3h5KCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcIm5vZGVzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyLm5vZGVzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkyLnRvUHJveHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcImZpcnN0XCIgfHwgcHJvcCA9PT0gXCJsYXN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyW3Byb3BdLnRvUHJveHkoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5vZGUyLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlMltwcm9wXSA9PT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIG5vZGUyW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IFwibmFtZVwiIHx8IHByb3AgPT09IFwicGFyYW1zXCIgfHwgcHJvcCA9PT0gXCJzZWxlY3RvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLm1hcmtEaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5pbmRleCA9IGZ1bmN0aW9uIGluZGV4KGNoaWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09IFwibnVtYmVyXCIpIHJldHVybiBjaGlsZDtcbiAgICAgICAgaWYgKGNoaWxkLnByb3h5T2YpIGNoaWxkID0gY2hpbGQucHJveHlPZjtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJveHlPZi5ub2Rlcy5pbmRleE9mKGNoaWxkKTtcbiAgICB9O1xuICAgIF9wcm90by5pbnNlcnRBZnRlciA9IGZ1bmN0aW9uIGluc2VydEFmdGVyKGV4aXN0LCBhZGQpIHtcbiAgICAgICAgdmFyIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub3JtYWxpemUoYWRkLCB0aGlzLnByb3h5T2Yubm9kZXNbZXhpc3RJbmRleF0pLnJldmVyc2UoKTtcbiAgICAgICAgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzLnNwbGljZShleGlzdEluZGV4ICsgMSwgMCwgbm9kZTIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleDI7XG4gICAgICAgIGZvcih2YXIgaWQgaW4gdGhpcy5pbmRleGVzKXtcbiAgICAgICAgICAgIGluZGV4MiA9IHRoaXMuaW5kZXhlc1tpZF07XG4gICAgICAgICAgICBpZiAoZXhpc3RJbmRleCA8IGluZGV4Mikge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleDIgKyBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8uaW5zZXJ0QmVmb3JlID0gZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKGV4aXN0LCBhZGQpIHtcbiAgICAgICAgdmFyIGV4aXN0SW5kZXggPSB0aGlzLmluZGV4KGV4aXN0KTtcbiAgICAgICAgdmFyIHR5cGUgPSBleGlzdEluZGV4ID09PSAwID8gXCJwcmVwZW5kXCIgOiBmYWxzZTtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub3JtYWxpemUoYWRkLCB0aGlzLnByb3h5T2Yubm9kZXNbZXhpc3RJbmRleF0sIHR5cGUpLnJldmVyc2UoKTtcbiAgICAgICAgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzLnNwbGljZShleGlzdEluZGV4LCAwLCBub2RlMik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4MjtcbiAgICAgICAgZm9yKHZhciBpZCBpbiB0aGlzLmluZGV4ZXMpe1xuICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2lkXTtcbiAgICAgICAgICAgIGlmIChleGlzdEluZGV4IDw9IGluZGV4Mikge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhlc1tpZF0gPSBpbmRleDIgKyBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8ubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKG5vZGVzLCBzYW1wbGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiBub2RlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbm9kZXMgPSBjbGVhblNvdXJjZSQxKHBhcnNlJDQkMShub2Rlcykubm9kZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2RlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbm9kZXMgPSBbXTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSkge1xuICAgICAgICAgICAgbm9kZXMgPSBub2Rlcy5zbGljZSgwKTtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBpMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpMi5wYXJlbnQpIGkyLnBhcmVudC5yZW1vdmVDaGlsZChpMiwgXCJpZ25vcmVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMudHlwZSA9PT0gXCJyb290XCIgJiYgdGhpcy50eXBlICE9PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICAgIG5vZGVzID0gbm9kZXMubm9kZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvcjEgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDE7ICEoX3N0ZXAxID0gX2l0ZXJhdG9yMSgpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIGkyMSA9IF9zdGVwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaTIxLnBhcmVudCkgaTIxLnBhcmVudC5yZW1vdmVDaGlsZChpMjEsIFwiaWdub3JlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzLnR5cGUpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW1xuICAgICAgICAgICAgICAgIG5vZGVzXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzLnByb3ApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZXMudmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSBmaWVsZCBpcyBtaXNzZWQgaW4gbm9kZSBjcmVhdGlvblwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGVzLnZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbm9kZXMudmFsdWUgPSBTdHJpbmcobm9kZXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IERlY2xhcmF0aW9uJDMkMShub2RlcylcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW1xuICAgICAgICAgICAgICAgIG5ldyBSdWxlJDQkMShub2RlcylcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMubmFtZSkge1xuICAgICAgICAgICAgbm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IEF0UnVsZSQ0JDEobm9kZXMpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzLnRleHQpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW1xuICAgICAgICAgICAgICAgIG5ldyBDb21tZW50JDMkMShub2RlcylcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZSBpbiBub2RlIGNyZWF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9jZXNzZWQgPSBub2Rlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmICghaTJbbXkkMSQxXSkgQ29udGFpbmVyLnJlYnVpbGQoaTIpO1xuICAgICAgICAgICAgaTIgPSBpMi5wcm94eU9mO1xuICAgICAgICAgICAgaWYgKGkyLnBhcmVudCkgaTIucGFyZW50LnJlbW92ZUNoaWxkKGkyKTtcbiAgICAgICAgICAgIGlmIChpMltpc0NsZWFuJDEkMV0pIG1hcmtEaXJ0eVVwJDEoaTIpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGlmIChzYW1wbGUgJiYgdHlwZW9mIHNhbXBsZS5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBpMi5yYXdzLmJlZm9yZSA9IHNhbXBsZS5yYXdzLmJlZm9yZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaTIucGFyZW50ID0gX3RoaXMucHJveHlPZjtcbiAgICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQoKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNoaWxkcmVuID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBjaGlsZHJlbltfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLnJldmVyc2UoKTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoY2hpbGRyZW4pLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMubm9ybWFsaXplKGNoaWxkLCB0aGlzLmZpcnN0LCBcInByZXBlbmRcIikucmV2ZXJzZSgpO1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IxID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXAxOyAhKF9zdGVwMSA9IF9pdGVyYXRvcjEoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMudW5zaGlmdChub2RlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IodmFyIGlkIGluIHRoaXMuaW5kZXhlcyl7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IHRoaXMuaW5kZXhlc1tpZF0gKyBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8ucHVzaCA9IGZ1bmN0aW9uIHB1c2goY2hpbGQpIHtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzLnB1c2goY2hpbGQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5yZW1vdmVBbGwgPSBmdW5jdGlvbiByZW1vdmVBbGwoKSB7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHRoaXMucHJveHlPZi5ub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgbm9kZTIucGFyZW50ID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJveHlPZi5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkID0gdGhpcy5pbmRleChjaGlsZCk7XG4gICAgICAgIHRoaXMucHJveHlPZi5ub2Rlc1tjaGlsZF0ucGFyZW50ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMuc3BsaWNlKGNoaWxkLCAxKTtcbiAgICAgICAgdmFyIGluZGV4MjtcbiAgICAgICAgZm9yKHZhciBpZCBpbiB0aGlzLmluZGV4ZXMpe1xuICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2lkXTtcbiAgICAgICAgICAgIGlmIChpbmRleDIgPj0gY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXgyIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5yZXBsYWNlVmFsdWVzID0gZnVuY3Rpb24gcmVwbGFjZVZhbHVlcyhwYXR0ZXJuLCBvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YWxrRGVjbHMoZnVuY3Rpb24oZGVjbCkge1xuICAgICAgICAgICAgaWYgKG9wdHMucHJvcHMgJiYgIW9wdHMucHJvcHMuaW5jbHVkZXMoZGVjbC5wcm9wKSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKG9wdHMuZmFzdCAmJiAhZGVjbC52YWx1ZS5pbmNsdWRlcyhvcHRzLmZhc3QpKSByZXR1cm47XG4gICAgICAgICAgICBkZWNsLnZhbHVlID0gZGVjbC52YWx1ZS5yZXBsYWNlKHBhdHRlcm4sIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnNvbWUgPSBmdW5jdGlvbiBzb21lKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5zb21lKGNvbmRpdGlvbik7XG4gICAgfTtcbiAgICBfcHJvdG8ud2FsayA9IGZ1bmN0aW9uIHdhbGsoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQyO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY2hpbGQuYWRkVG9FcnJvcihlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gZmFsc2UgJiYgY2hpbGQud2Fsaykge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBjaGlsZC53YWxrKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by53YWxrQXRSdWxlcyA9IGZ1bmN0aW9uIHdhbGtBdFJ1bGVzKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9pbnN0YW5jZW9mKG5hbWUsIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiYXRydWxlXCIgJiYgbmFtZS50ZXN0KGNoaWxkLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIiAmJiBjaGlsZC5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLndhbGtDb21tZW50cyA9IGZ1bmN0aW9uIHdhbGtDb21tZW50cyhjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLndhbGtEZWNscyA9IGZ1bmN0aW9uIHdhbGtEZWNscyhwcm9wLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHByb3A7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2luc3RhbmNlb2YocHJvcCwgUmVnRXhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJkZWNsXCIgJiYgcHJvcC50ZXN0KGNoaWxkLnByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJkZWNsXCIgJiYgY2hpbGQucHJvcCA9PT0gcHJvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by53YWxrUnVsZXMgPSBmdW5jdGlvbiB3YWxrUnVsZXMoc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcInJ1bGVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2luc3RhbmNlb2Yoc2VsZWN0b3IsIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwicnVsZVwiICYmIHNlbGVjdG9yLnRlc3QoY2hpbGQuc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJydWxlXCIgJiYgY2hpbGQuc2VsZWN0b3IgPT09IHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhDb250YWluZXIsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZpcnN0XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibGFzdFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJveHlPZi5ub2Rlc1t0aGlzLnByb3h5T2Yubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gQ29udGFpbmVyO1xufShOb2RlJDEkMSk7XG5Db250YWluZXIkNyQxLnJlZ2lzdGVyUGFyc2UgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBwYXJzZSQ0JDEgPSBkZXBlbmRhbnQ7XG59O1xuQ29udGFpbmVyJDckMS5yZWdpc3RlclJ1bGUgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBSdWxlJDQkMSA9IGRlcGVuZGFudDtcbn07XG5Db250YWluZXIkNyQxLnJlZ2lzdGVyQXRSdWxlID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgQXRSdWxlJDQkMSA9IGRlcGVuZGFudDtcbn07XG5Db250YWluZXIkNyQxLnJlZ2lzdGVyUm9vdCA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIFJvb3QkNiQxID0gZGVwZW5kYW50O1xufTtcbnZhciBjb250YWluZXIkMSA9IENvbnRhaW5lciQ3JDE7XG5Db250YWluZXIkNyQxLmRlZmF1bHQgPSBDb250YWluZXIkNyQxO1xuQ29udGFpbmVyJDckMS5yZWJ1aWxkID0gZnVuY3Rpb24obm9kZTIpIHtcbiAgICBpZiAobm9kZTIudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIEF0UnVsZSQ0JDEucHJvdG90eXBlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwicnVsZVwiKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgUnVsZSQ0JDEucHJvdG90eXBlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgRGVjbGFyYXRpb24kMyQxLnByb3RvdHlwZSk7XG4gICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIENvbW1lbnQkMyQxLnByb3RvdHlwZSk7XG4gICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcInJvb3RcIikge1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yobm9kZTIsIFJvb3QkNiQxLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIG5vZGUyW215JDEkMV0gPSB0cnVlO1xuICAgIGlmIChub2RlMi5ub2Rlcykge1xuICAgICAgICBub2RlMi5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBDb250YWluZXIkNyQxLnJlYnVpbGQoY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xudmFyIENvbnRhaW5lciQ2JDEgPSBjb250YWluZXIkMTtcbnZhciBMYXp5UmVzdWx0JDQkMSwgUHJvY2Vzc29yJDMkMTtcbnZhciBEb2N1bWVudCQzJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKENvbnRhaW5lciQ2JDEpIHtcbiAgICBfaW5oZXJpdHMoRG9jdW1lbnQyLCBDb250YWluZXIkNiQxKTtcbiAgICBmdW5jdGlvbiBEb2N1bWVudDIoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IENvbnRhaW5lciQ2JDEuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICB0eXBlOiBcImRvY3VtZW50XCJcbiAgICAgICAgfSwgZGVmYXVsdHMpKSB8fCB0aGlzO1xuICAgICAgICBpZiAoIV90aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBfdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IERvY3VtZW50Mi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnRvUmVzdWx0ID0gZnVuY3Rpb24gdG9SZXN1bHQob3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIHZhciBsYXp5ID0gbmV3IExhenlSZXN1bHQkNCQxKG5ldyBQcm9jZXNzb3IkMyQxKCksIHRoaXMsIG9wdHMpO1xuICAgICAgICByZXR1cm4gbGF6eS5zdHJpbmdpZnkoKTtcbiAgICB9O1xuICAgIHJldHVybiBEb2N1bWVudDI7XG59KENvbnRhaW5lciQ2JDEpO1xuRG9jdW1lbnQkMyQxLnJlZ2lzdGVyTGF6eVJlc3VsdCA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIExhenlSZXN1bHQkNCQxID0gZGVwZW5kYW50O1xufTtcbkRvY3VtZW50JDMkMS5yZWdpc3RlclByb2Nlc3NvciA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIFByb2Nlc3NvciQzJDEgPSBkZXBlbmRhbnQ7XG59O1xudmFyIGRvY3VtZW50JDEkMSA9IERvY3VtZW50JDMkMTtcbkRvY3VtZW50JDMkMS5kZWZhdWx0ID0gRG9jdW1lbnQkMyQxO1xudmFyIHByaW50ZWQkMSA9IHt9O1xudmFyIHdhcm5PbmNlJDIkMSA9IGZ1bmN0aW9uIHdhcm5PbmNlKG1lc3NhZ2UpIHtcbiAgICBpZiAocHJpbnRlZCQxW21lc3NhZ2VdKSByZXR1cm47XG4gICAgcHJpbnRlZCQxW21lc3NhZ2VdID0gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG59O1xudmFyIFdhcm5pbmckMiQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBXYXJuaW5nKHRleHQsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICB0aGlzLnR5cGUgPSBcIndhcm5pbmdcIjtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgaWYgKG9wdHMubm9kZSAmJiBvcHRzLm5vZGUuc291cmNlKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBvcHRzLm5vZGUucmFuZ2VCeShvcHRzKTtcbiAgICAgICAgICAgIHRoaXMubGluZSA9IHJhbmdlLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbiA9IHJhbmdlLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuZW5kTGluZSA9IHJhbmdlLmVuZC5saW5lO1xuICAgICAgICAgICAgdGhpcy5lbmRDb2x1bW4gPSByYW5nZS5lbmQuY29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgb3B0IGluIG9wdHMpdGhpc1tvcHRdID0gb3B0c1tvcHRdO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gV2FybmluZy5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGUuZXJyb3IodGhpcy50ZXh0LCB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IHRoaXMuaW5kZXgsXG4gICAgICAgICAgICAgICAgcGx1Z2luOiB0aGlzLnBsdWdpbixcbiAgICAgICAgICAgICAgICB3b3JkOiB0aGlzLndvcmRcbiAgICAgICAgICAgIH0pLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGx1Z2luKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wbHVnaW4gKyBcIjogXCIgKyB0aGlzLnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dDtcbiAgICB9O1xuICAgIHJldHVybiBXYXJuaW5nO1xufSgpO1xudmFyIHdhcm5pbmckMSA9IFdhcm5pbmckMiQxO1xuV2FybmluZyQyJDEuZGVmYXVsdCA9IFdhcm5pbmckMiQxO1xudmFyIFdhcm5pbmckMSQxID0gd2FybmluZyQxO1xudmFyIFJlc3VsdCQzJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFJlc3VsdChwcm9jZXNzb3IyLCByb290Miwgb3B0cykge1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjI7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDI7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgICAgIHRoaXMuY3NzID0gdm9pZCAwO1xuICAgICAgICB0aGlzLm1hcCA9IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFJlc3VsdC5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNzcztcbiAgICB9O1xuICAgIF9wcm90by53YXJuID0gZnVuY3Rpb24gd2Fybih0ZXh0LCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgaWYgKCFvcHRzLnBsdWdpbikge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFzdFBsdWdpbiAmJiB0aGlzLmxhc3RQbHVnaW4ucG9zdGNzc1BsdWdpbikge1xuICAgICAgICAgICAgICAgIG9wdHMucGx1Z2luID0gdGhpcy5sYXN0UGx1Z2luLnBvc3Rjc3NQbHVnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdhcm5pbmcyID0gbmV3IFdhcm5pbmckMSQxKHRleHQsIG9wdHMpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzLnB1c2god2FybmluZzIpO1xuICAgICAgICByZXR1cm4gd2FybmluZzI7XG4gICAgfTtcbiAgICBfcHJvdG8ud2FybmluZ3MgPSBmdW5jdGlvbiB3YXJuaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuZmlsdGVyKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICByZXR1cm4gaTIudHlwZSA9PT0gXCJ3YXJuaW5nXCI7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhSZXN1bHQsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNvbnRlbnRcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBSZXN1bHQ7XG59KCk7XG52YXIgcmVzdWx0JDEgPSBSZXN1bHQkMyQxO1xuUmVzdWx0JDMkMS5kZWZhdWx0ID0gUmVzdWx0JDMkMTtcbnZhciBTSU5HTEVfUVVPVEUkMSA9IFwiJ1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgRE9VQkxFX1FVT1RFJDEgPSAnXCInLmNoYXJDb2RlQXQoMCk7XG52YXIgQkFDS1NMQVNIJDEgPSBcIlxcXFxcIi5jaGFyQ29kZUF0KDApO1xudmFyIFNMQVNIJDEgPSBcIi9cIi5jaGFyQ29kZUF0KDApO1xudmFyIE5FV0xJTkUkMSA9IFwiXFxuXCIuY2hhckNvZGVBdCgwKTtcbnZhciBTUEFDRSQxID0gXCIgXCIuY2hhckNvZGVBdCgwKTtcbnZhciBGRUVEJDEgPSBcIlxcZlwiLmNoYXJDb2RlQXQoMCk7XG52YXIgVEFCJDEgPSBcIlx0XCIuY2hhckNvZGVBdCgwKTtcbnZhciBDUiQxID0gXCJcXHJcIi5jaGFyQ29kZUF0KDApO1xudmFyIE9QRU5fU1FVQVJFJDEgPSBcIltcIi5jaGFyQ29kZUF0KDApO1xudmFyIENMT1NFX1NRVUFSRSQxID0gXCJdXCIuY2hhckNvZGVBdCgwKTtcbnZhciBPUEVOX1BBUkVOVEhFU0VTJDEgPSBcIihcIi5jaGFyQ29kZUF0KDApO1xudmFyIENMT1NFX1BBUkVOVEhFU0VTJDEgPSBcIilcIi5jaGFyQ29kZUF0KDApO1xudmFyIE9QRU5fQ1VSTFkkMSA9IFwie1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgQ0xPU0VfQ1VSTFkkMSA9IFwifVwiLmNoYXJDb2RlQXQoMCk7XG52YXIgU0VNSUNPTE9OJDEgPSBcIjtcIi5jaGFyQ29kZUF0KDApO1xudmFyIEFTVEVSSVNLJDEgPSBcIipcIi5jaGFyQ29kZUF0KDApO1xudmFyIENPTE9OJDEgPSBcIjpcIi5jaGFyQ29kZUF0KDApO1xudmFyIEFUJDEgPSBcIkBcIi5jaGFyQ29kZUF0KDApO1xudmFyIFJFX0FUX0VORCQxID0gL1tcXHRcXG5cXGZcXHIgXCIjJygpLztbXFxcXFxcXXt9XS9nO1xudmFyIFJFX1dPUkRfRU5EJDEgPSAvW1xcdFxcblxcZlxcciAhXCIjJygpOjtAW1xcXFxcXF17fV18XFwvKD89XFwqKS9nO1xudmFyIFJFX0JBRF9CUkFDS0VUJDEgPSAvLltcXHJcXG5cIicoL1xcXFxdLztcbnZhciBSRV9IRVhfRVNDQVBFJDEgPSAvW1xcZGEtZl0vaTtcbnZhciB0b2tlbml6ZSQxID0gZnVuY3Rpb24gdG9rZW5pemVyKGlucHV0Miwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgY3NzID0gaW5wdXQyLmNzcy52YWx1ZU9mKCk7XG4gICAgdmFyIGlnbm9yZSA9IG9wdGlvbnMuaWdub3JlRXJyb3JzO1xuICAgIHZhciBjb2RlLCBuZXh0LCBxdW90ZSwgY29udGVudCwgZXNjYXBlO1xuICAgIHZhciBlc2NhcGVkLCBlc2NhcGVQb3MsIHByZXYsIG4yLCBjdXJyZW50VG9rZW47XG4gICAgdmFyIGxlbmd0aCA9IGNzcy5sZW5ndGg7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgdmFyIGJ1ZmZlciA9IFtdO1xuICAgIHZhciByZXR1cm5lZCA9IFtdO1xuICAgIGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmNsb3NlZCh3aGF0KSB7XG4gICAgICAgIHRocm93IGlucHV0Mi5lcnJvcihcIlVuY2xvc2VkIFwiICsgd2hhdCwgcG9zKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5kT2ZGaWxlKCkge1xuICAgICAgICByZXR1cm4gcmV0dXJuZWQubGVuZ3RoID09PSAwICYmIHBvcyA+PSBsZW5ndGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5leHRUb2tlbihvcHRzKSB7XG4gICAgICAgIGlmIChyZXR1cm5lZC5sZW5ndGgpIHJldHVybiByZXR1cm5lZC5wb3AoKTtcbiAgICAgICAgaWYgKHBvcyA+PSBsZW5ndGgpIHJldHVybjtcbiAgICAgICAgdmFyIGlnbm9yZVVuY2xvc2VkID0gb3B0cyA/IG9wdHMuaWdub3JlVW5jbG9zZWQgOiBmYWxzZTtcbiAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIHN3aXRjaChjb2RlKXtcbiAgICAgICAgICAgIGNhc2UgTkVXTElORSQxOlxuICAgICAgICAgICAgY2FzZSBTUEFDRSQxOlxuICAgICAgICAgICAgY2FzZSBUQUIkMTpcbiAgICAgICAgICAgIGNhc2UgQ1IkMTpcbiAgICAgICAgICAgIGNhc2UgRkVFRCQxOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZSA9IGNzcy5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgICAgICAgICAgICAgICB9d2hpbGUgKGNvZGUgPT09IFNQQUNFJDEgfHwgY29kZSA9PT0gTkVXTElORSQxIHx8IGNvZGUgPT09IFRBQiQxIHx8IGNvZGUgPT09IENSJDEgfHwgY29kZSA9PT0gRkVFRCQxKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzcGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dClcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgT1BFTl9TUVVBUkUkMTpcbiAgICAgICAgICAgIGNhc2UgQ0xPU0VfU1FVQVJFJDE6XG4gICAgICAgICAgICBjYXNlIE9QRU5fQ1VSTFkkMTpcbiAgICAgICAgICAgIGNhc2UgQ0xPU0VfQ1VSTFkkMTpcbiAgICAgICAgICAgIGNhc2UgQ09MT04kMTpcbiAgICAgICAgICAgIGNhc2UgU0VNSUNPTE9OJDE6XG4gICAgICAgICAgICBjYXNlIENMT1NFX1BBUkVOVEhFU0VTJDE6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbENoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sQ2hhcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xDaGFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgT1BFTl9QQVJFTlRIRVNFUyQxOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldiA9IGJ1ZmZlci5sZW5ndGggPyBidWZmZXIucG9wKClbMV0gOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBuMiA9IGNzcy5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldiA9PT0gXCJ1cmxcIiAmJiBuMiAhPT0gU0lOR0xFX1FVT1RFJDEgJiYgbjIgIT09IERPVUJMRV9RVU9URSQxICYmIG4yICE9PSBTUEFDRSQxICYmIG4yICE9PSBORVdMSU5FJDEgJiYgbjIgIT09IFRBQiQxICYmIG4yICE9PSBGRUVEJDEgJiYgbjIgIT09IENSJDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihcIilcIiwgbmV4dCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlIHx8IGlnbm9yZVVuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmNsb3NlZChcImJyYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShjc3MuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gQkFDS1NMQVNIJDEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVQb3MgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH13aGlsZSAoZXNjYXBlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJicmFja2V0c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3NzLmluZGV4T2YoXCIpXCIsIHBvcyArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGNzcy5zbGljZShwb3MsIG5leHQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAtMSB8fCBSRV9CQURfQlJBQ0tFVCQxLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImJyYWNrZXRzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFNJTkdMRV9RVU9URSQxOlxuICAgICAgICAgICAgY2FzZSBET1VCTEVfUVVPVEUkMTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHF1b3RlID0gY29kZSA9PT0gU0lOR0xFX1FVT1RFJDEgPyBcIidcIiA6ICdcIic7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihxdW90ZSwgbmV4dCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZSB8fCBpZ25vcmVVbmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5jbG9zZWQoXCJzdHJpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKGNzcy5jaGFyQ29kZUF0KGVzY2FwZVBvcyAtIDEpID09PSBCQUNLU0xBU0gkMSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlUG9zIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9d2hpbGUgKGVzY2FwZWQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEFUJDE6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBSRV9BVF9FTkQkMS5sYXN0SW5kZXggPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgICAgICBSRV9BVF9FTkQkMS50ZXN0KGNzcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChSRV9BVF9FTkQkMS5sYXN0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBSRV9BVF9FTkQkMS5sYXN0SW5kZXggLSAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiYXQtd29yZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEJBQ0tTTEFTSCQxOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoY3NzLmNoYXJDb2RlQXQobmV4dCArIDEpID09PSBCQUNLU0xBU0gkMSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGUgPSAhZXNjYXBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlc2NhcGUgJiYgY29kZSAhPT0gU0xBU0gkMSAmJiBjb2RlICE9PSBTUEFDRSQxICYmIGNvZGUgIT09IE5FV0xJTkUkMSAmJiBjb2RlICE9PSBUQUIkMSAmJiBjb2RlICE9PSBDUiQxICYmIGNvZGUgIT09IEZFRUQkMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJFX0hFWF9FU0NBUEUkMS50ZXN0KGNzcy5jaGFyQXQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUoUkVfSEVYX0VTQ0FQRSQxLnRlc3QoY3NzLmNoYXJBdChuZXh0ICsgMSkpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3NzLmNoYXJDb2RlQXQobmV4dCArIDEpID09PSBTUEFDRSQxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3b3JkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gU0xBU0gkMSAmJiBjc3MuY2hhckNvZGVBdChwb3MgKyAxKSA9PT0gQVNURVJJU0skMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKFwiKi9cIiwgcG9zICsgMikgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlIHx8IGlnbm9yZVVuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuY2xvc2VkKFwiY29tbWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb21tZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJFX1dPUkRfRU5EJDEubGFzdEluZGV4ID0gcG9zICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJFX1dPUkRfRU5EJDEudGVzdChjc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFJFX1dPUkRfRU5EJDEubGFzdEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gUkVfV09SRF9FTkQkMS5sYXN0SW5kZXggLSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid29yZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNzcy5zbGljZShwb3MsIG5leHQgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGN1cnJlbnRUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwb3MrKztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRUb2tlbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYmFjayh0b2tlbikge1xuICAgICAgICByZXR1cm5lZC5wdXNoKHRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFjazogYmFjayxcbiAgICAgICAgZW5kT2ZGaWxlOiBlbmRPZkZpbGUsXG4gICAgICAgIG5leHRUb2tlbjogbmV4dFRva2VuLFxuICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICB9O1xufTtcbnZhciBDb250YWluZXIkNSQxID0gY29udGFpbmVyJDE7XG52YXIgQXRSdWxlJDMkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQ29udGFpbmVyJDUkMSkge1xuICAgIF9pbmhlcml0cyhBdFJ1bGUsIENvbnRhaW5lciQ1JDEpO1xuICAgIGZ1bmN0aW9uIEF0UnVsZShkZWZhdWx0cykge1xuICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgIF90aGlzID0gQ29udGFpbmVyJDUkMS5jYWxsKHRoaXMsIGRlZmF1bHRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gXCJhdHJ1bGVcIjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQXRSdWxlLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjaGlsZHJlbiA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgY2hpbGRyZW5bX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9Db250YWluZXIkNSQxX3Byb3RvdHlwZV9hcHBlbmQ7XG4gICAgICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHJldHVybiAoX0NvbnRhaW5lciQ1JDFfcHJvdG90eXBlX2FwcGVuZCA9IENvbnRhaW5lciQ1JDEucHJvdG90eXBlLmFwcGVuZCkuY2FsbC5hcHBseShfQ29udGFpbmVyJDUkMV9wcm90b3R5cGVfYXBwZW5kLCBbXS5jb25jYXQoW1xuICAgICAgICAgICAgdGhpc1xuICAgICAgICBdLCBjaGlsZHJlbikpO1xuICAgIH07XG4gICAgX3Byb3RvLnByZXBlbmQgPSBmdW5jdGlvbiBwcmVwZW5kKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjaGlsZHJlbiA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgY2hpbGRyZW5bX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9Db250YWluZXIkNSQxX3Byb3RvdHlwZV9wcmVwZW5kO1xuICAgICAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICByZXR1cm4gKF9Db250YWluZXIkNSQxX3Byb3RvdHlwZV9wcmVwZW5kID0gQ29udGFpbmVyJDUkMS5wcm90b3R5cGUucHJlcGVuZCkuY2FsbC5hcHBseShfQ29udGFpbmVyJDUkMV9wcm90b3R5cGVfcHJlcGVuZCwgW10uY29uY2F0KFtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgXSwgY2hpbGRyZW4pKTtcbiAgICB9O1xuICAgIHJldHVybiBBdFJ1bGU7XG59KENvbnRhaW5lciQ1JDEpO1xudmFyIGF0UnVsZSQxID0gQXRSdWxlJDMkMTtcbkF0UnVsZSQzJDEuZGVmYXVsdCA9IEF0UnVsZSQzJDE7XG5Db250YWluZXIkNSQxLnJlZ2lzdGVyQXRSdWxlKEF0UnVsZSQzJDEpO1xudmFyIENvbnRhaW5lciQ0JDEgPSBjb250YWluZXIkMTtcbnZhciBMYXp5UmVzdWx0JDMkMSwgUHJvY2Vzc29yJDIkMTtcbnZhciBSb290JDUkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQ29udGFpbmVyJDQkMSkge1xuICAgIF9pbmhlcml0cyhSb290LCBDb250YWluZXIkNCQxKTtcbiAgICBmdW5jdGlvbiBSb290KGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBDb250YWluZXIkNCQxLmNhbGwodGhpcywgZGVmYXVsdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBcInJvb3RcIjtcbiAgICAgICAgaWYgKCFfdGhpcy5ub2RlcykgX3RoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gUm9vdC5wcm90b3R5cGU7XG4gICAgX3Byb3RvLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShjaGlsZCwgc2FtcGxlLCB0eXBlKSB7XG4gICAgICAgIHZhciBub2RlcyA9IENvbnRhaW5lciQ0JDEucHJvdG90eXBlLm5vcm1hbGl6ZS5jYWxsKHRoaXMsIGNoaWxkKTtcbiAgICAgICAgaWYgKHNhbXBsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwicHJlcGVuZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBzYW1wbGUucmF3cy5iZWZvcmUgPSB0aGlzLm5vZGVzWzFdLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzYW1wbGUucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZpcnN0ICE9PSBzYW1wbGUpIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLnJhd3MuYmVmb3JlID0gc2FtcGxlLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVtb3ZlQ2hpbGQgPSBmdW5jdGlvbiByZW1vdmVDaGlsZChjaGlsZCwgaWdub3JlKSB7XG4gICAgICAgIHZhciBpbmRleDIgPSB0aGlzLmluZGV4KGNoaWxkKTtcbiAgICAgICAgaWYgKCFpZ25vcmUgJiYgaW5kZXgyID09PSAwICYmIHRoaXMubm9kZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5ub2Rlc1sxXS5yYXdzLmJlZm9yZSA9IHRoaXMubm9kZXNbaW5kZXgyXS5yYXdzLmJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29udGFpbmVyJDQkMS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQuY2FsbCh0aGlzLCBjaGlsZCk7XG4gICAgfTtcbiAgICBfcHJvdG8udG9SZXN1bHQgPSBmdW5jdGlvbiB0b1Jlc3VsdChvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgdmFyIGxhenkgPSBuZXcgTGF6eVJlc3VsdCQzJDEobmV3IFByb2Nlc3NvciQyJDEoKSwgdGhpcywgb3B0cyk7XG4gICAgICAgIHJldHVybiBsYXp5LnN0cmluZ2lmeSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFJvb3Q7XG59KENvbnRhaW5lciQ0JDEpO1xuUm9vdCQ1JDEucmVnaXN0ZXJMYXp5UmVzdWx0ID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgTGF6eVJlc3VsdCQzJDEgPSBkZXBlbmRhbnQ7XG59O1xuUm9vdCQ1JDEucmVnaXN0ZXJQcm9jZXNzb3IgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBQcm9jZXNzb3IkMiQxID0gZGVwZW5kYW50O1xufTtcbnZhciByb290JDEgPSBSb290JDUkMTtcblJvb3QkNSQxLmRlZmF1bHQgPSBSb290JDUkMTtcbkNvbnRhaW5lciQ0JDEucmVnaXN0ZXJSb290KFJvb3QkNSQxKTtcbnZhciBsaXN0JDIkMSA9IHtcbiAgICBjb21tYTogZnVuY3Rpb24gY29tbWEoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBsaXN0JDIkMS5zcGxpdChzdHJpbmcsIFtcbiAgICAgICAgICAgIFwiLFwiXG4gICAgICAgIF0sIHRydWUpO1xuICAgIH0sXG4gICAgc3BhY2U6IGZ1bmN0aW9uIHNwYWNlKHN0cmluZykge1xuICAgICAgICB2YXIgc3BhY2VzID0gW1xuICAgICAgICAgICAgXCIgXCIsXG4gICAgICAgICAgICBcIlxcblwiLFxuICAgICAgICAgICAgXCJcdFwiXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiBsaXN0JDIkMS5zcGxpdChzdHJpbmcsIHNwYWNlcyk7XG4gICAgfSxcbiAgICBzcGxpdDogZnVuY3Rpb24gc3BsaXQoc3RyaW5nLCBzZXBhcmF0b3JzLCBsYXN0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgICB2YXIgY3VycmVudCA9IFwiXCI7XG4gICAgICAgIHZhciBzcGxpdCA9IGZhbHNlO1xuICAgICAgICB2YXIgZnVuYyA9IDA7XG4gICAgICAgIHZhciBpblF1b3RlID0gZmFsc2U7XG4gICAgICAgIHZhciBwcmV2UXVvdGUgPSBcIlwiO1xuICAgICAgICB2YXIgZXNjYXBlID0gZmFsc2U7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHN0cmluZyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBsZXR0ZXIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgICAgICAgICBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgICAgIGVzY2FwZSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluUXVvdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGV0dGVyID09PSBwcmV2UXVvdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5RdW90ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSAnXCInIHx8IGxldHRlciA9PT0gXCInXCIpIHtcbiAgICAgICAgICAgICAgICBpblF1b3RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwcmV2UXVvdGUgPSBsZXR0ZXI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICBmdW5jICs9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnVuYyA+IDApIGZ1bmMgLT0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZnVuYyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3JzLmluY2x1ZGVzKGxldHRlcikpIHNwbGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzcGxpdCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBcIlwiKSBhcnJheS5wdXNoKGN1cnJlbnQudHJpbSgpKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBzcGxpdCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ICs9IGxldHRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdCB8fCBjdXJyZW50ICE9PSBcIlwiKSBhcnJheS5wdXNoKGN1cnJlbnQudHJpbSgpKTtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbn07XG52YXIgbGlzdF8xJDEgPSBsaXN0JDIkMTtcbmxpc3QkMiQxLmRlZmF1bHQgPSBsaXN0JDIkMTtcbnZhciBDb250YWluZXIkMyQxID0gY29udGFpbmVyJDE7XG52YXIgbGlzdCQxJDEgPSBsaXN0XzEkMTtcbnZhciBSdWxlJDMkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oQ29udGFpbmVyJDMkMSkge1xuICAgIF9pbmhlcml0cyhSdWxlLCBDb250YWluZXIkMyQxKTtcbiAgICBmdW5jdGlvbiBSdWxlKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBDb250YWluZXIkMyQxLmNhbGwodGhpcywgZGVmYXVsdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBcInJ1bGVcIjtcbiAgICAgICAgaWYgKCFfdGhpcy5ub2RlcykgX3RoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfY3JlYXRlX2NsYXNzKFJ1bGUsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInNlbGVjdG9yc1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3QkMSQxLmNvbW1hKHRoaXMuc2VsZWN0b3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlcykge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yLm1hdGNoKC8sXFxzKi8pIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgc2VwMiA9IG1hdGNoID8gbWF0Y2hbMF0gOiBcIixcIiArIHRoaXMucmF3KFwiYmV0d2VlblwiLCBcImJlZm9yZU9wZW5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHZhbHVlcy5qb2luKHNlcDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFJ1bGU7XG59KENvbnRhaW5lciQzJDEpO1xudmFyIHJ1bGUkMSA9IFJ1bGUkMyQxO1xuUnVsZSQzJDEuZGVmYXVsdCA9IFJ1bGUkMyQxO1xuQ29udGFpbmVyJDMkMS5yZWdpc3RlclJ1bGUoUnVsZSQzJDEpO1xudmFyIERlY2xhcmF0aW9uJDIkMSA9IGRlY2xhcmF0aW9uJDE7XG52YXIgdG9rZW5pemVyMiQxID0gdG9rZW5pemUkMTtcbnZhciBDb21tZW50JDIkMSA9IGNvbW1lbnQkMTtcbnZhciBBdFJ1bGUkMiQxID0gYXRSdWxlJDE7XG52YXIgUm9vdCQ0JDEgPSByb290JDE7XG52YXIgUnVsZSQyJDEgPSBydWxlJDE7XG52YXIgU0FGRV9DT01NRU5UX05FSUdIQk9SJDEgPSB7XG4gICAgZW1wdHk6IHRydWUsXG4gICAgc3BhY2U6IHRydWVcbn07XG5mdW5jdGlvbiBmaW5kTGFzdFdpdGhQb3NpdGlvbiQxKHRva2Vucykge1xuICAgIGZvcih2YXIgaTIgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSl7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpMl07XG4gICAgICAgIHZhciBwb3MgPSB0b2tlblszXSB8fCB0b2tlblsyXTtcbiAgICAgICAgaWYgKHBvcykgcmV0dXJuIHBvcztcbiAgICB9XG59XG52YXIgUGFyc2VyJDEkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VyKGlucHV0Mikge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQyO1xuICAgICAgICB0aGlzLnJvb3QgPSBuZXcgUm9vdCQ0JDEoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5yb290O1xuICAgICAgICB0aGlzLnNwYWNlcyA9IFwiXCI7XG4gICAgICAgIHRoaXMuc2VtaWNvbG9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3JlYXRlVG9rZW5pemVyKCk7XG4gICAgICAgIHRoaXMucm9vdC5zb3VyY2UgPSB7XG4gICAgICAgICAgICBpbnB1dDogaW5wdXQyLFxuICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IDEsXG4gICAgICAgICAgICAgICAgbGluZTogMSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFBhcnNlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmF0cnVsZSA9IGZ1bmN0aW9uIGF0cnVsZSh0b2tlbikge1xuICAgICAgICB2YXIgbm9kZTIgPSBuZXcgQXRSdWxlJDIkMSgpO1xuICAgICAgICBub2RlMi5uYW1lID0gdG9rZW5bMV0uc2xpY2UoMSk7XG4gICAgICAgIGlmIChub2RlMi5uYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgICB0aGlzLnVubmFtZWRBdHJ1bGUobm9kZTIsIHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluaXQobm9kZTIsIHRva2VuWzJdKTtcbiAgICAgICAgdmFyIHR5cGU7XG4gICAgICAgIHZhciBwcmV2O1xuICAgICAgICB2YXIgc2hpZnQ7XG4gICAgICAgIHZhciBsYXN0ID0gZmFsc2U7XG4gICAgICAgIHZhciBvcGVuID0gZmFsc2U7XG4gICAgICAgIHZhciBwYXJhbXMgPSBbXTtcbiAgICAgICAgdmFyIGJyYWNrZXRzID0gW107XG4gICAgICAgIHdoaWxlKCF0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSl7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgICAgICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiKFwiIHx8IHR5cGUgPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucHVzaCh0eXBlID09PSBcIihcIiA/IFwiKVwiIDogXCJdXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIntcIiAmJiBicmFja2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucHVzaChcIn1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IGJyYWNrZXRzW2JyYWNrZXRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnJhY2tldHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiO1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2VuWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW1pY29sb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hpZnQgPSBwYXJhbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBwYXJhbXNbc2hpZnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUocHJldiAmJiBwcmV2WzBdID09PSBcInNwYWNlXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBwYXJhbXNbLS1zaGlmdF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHByZXZbM10gfHwgcHJldlsyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkge1xuICAgICAgICAgICAgICAgIGxhc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHBhcmFtcyk7XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBub2RlMi5yYXdzLmFmdGVyTmFtZSA9IHRoaXMuc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQocGFyYW1zKTtcbiAgICAgICAgICAgIHRoaXMucmF3KG5vZGUyLCBcInBhcmFtc1wiLCBwYXJhbXMpO1xuICAgICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bM10gfHwgdG9rZW5bMl0pO1xuICAgICAgICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGFjZXMgPSBub2RlMi5yYXdzLmJldHdlZW47XG4gICAgICAgICAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MuYWZ0ZXJOYW1lID0gXCJcIjtcbiAgICAgICAgICAgIG5vZGUyLnBhcmFtcyA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIG5vZGUyLm5vZGVzID0gW107XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBub2RlMjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNoZWNrTWlzc2VkU2VtaWNvbG9uID0gZnVuY3Rpb24gY2hlY2tNaXNzZWRTZW1pY29sb24odG9rZW5zKSB7XG4gICAgICAgIHZhciBjb2xvbiA9IHRoaXMuY29sb24odG9rZW5zKTtcbiAgICAgICAgaWYgKGNvbG9uID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICB2YXIgZm91bmRlZCA9IDA7XG4gICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgZm9yKHZhciBqID0gY29sb24gLSAxOyBqID49IDA7IGotLSl7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tqXTtcbiAgICAgICAgICAgIGlmICh0b2tlblswXSAhPT0gXCJzcGFjZVwiKSB7XG4gICAgICAgICAgICAgICAgZm91bmRlZCArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZGVkID09PSAyKSBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiTWlzc2VkIHNlbWljb2xvblwiLCB0b2tlblswXSA9PT0gXCJ3b3JkXCIgPyB0b2tlblszXSArIDEgOiB0b2tlblsyXSk7XG4gICAgfTtcbiAgICBfcHJvdG8uY29sb24gPSBmdW5jdGlvbiBjb2xvbih0b2tlbnMpIHtcbiAgICAgICAgdmFyIGJyYWNrZXRzID0gMDtcbiAgICAgICAgdmFyIHRva2VuLCB0eXBlLCBwcmV2O1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh0b2tlbnMuZW50cmllcygpKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIF9zdGVwX3ZhbHVlID0gX3N0ZXAudmFsdWUsIGkyID0gX3N0ZXBfdmFsdWVbMF0sIGVsZW1lbnQgPSBfc3RlcF92YWx1ZVsxXTtcbiAgICAgICAgICAgIHRva2VuID0gZWxlbWVudDtcbiAgICAgICAgICAgIHR5cGUgPSB0b2tlblswXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCIpXCIpIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cyAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJyYWNrZXRzID09PSAwICYmIHR5cGUgPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG91YmxlQ29sb24odG9rZW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldlswXSA9PT0gXCJ3b3JkXCIgJiYgcHJldlsxXSA9PT0gXCJwcm9naWRcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5jb21tZW50ID0gZnVuY3Rpb24gY29tbWVudCh0b2tlbikge1xuICAgICAgICB2YXIgbm9kZTIgPSBuZXcgQ29tbWVudCQyJDEoKTtcbiAgICAgICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlblsyXSk7XG4gICAgICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2VuWzNdIHx8IHRva2VuWzJdKTtcbiAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgdmFyIHRleHQgPSB0b2tlblsxXS5zbGljZSgyLCAtMik7XG4gICAgICAgIGlmICgvXlxccyokLy50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICBub2RlMi50ZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MubGVmdCA9IHRleHQ7XG4gICAgICAgICAgICBub2RlMi5yYXdzLnJpZ2h0ID0gXCJcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHRleHQubWF0Y2goL14oXFxzKikoW15dKlxcUykoXFxzKikkLyk7XG4gICAgICAgICAgICBub2RlMi50ZXh0ID0gbWF0Y2hbMl07XG4gICAgICAgICAgICBub2RlMi5yYXdzLmxlZnQgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MucmlnaHQgPSBtYXRjaFszXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNyZWF0ZVRva2VuaXplciA9IGZ1bmN0aW9uIGNyZWF0ZVRva2VuaXplcigpIHtcbiAgICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXIyJDEodGhpcy5pbnB1dCk7XG4gICAgfTtcbiAgICBfcHJvdG8uZGVjbCA9IGZ1bmN0aW9uIGRlY2wodG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB2YXIgbm9kZTIgPSBuZXcgRGVjbGFyYXRpb24kMiQxKCk7XG4gICAgICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5zWzBdWzJdKTtcbiAgICAgICAgdmFyIGxhc3QgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAobGFzdFswXSA9PT0gXCI7XCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2VtaWNvbG9uID0gdHJ1ZTtcbiAgICAgICAgICAgIHRva2Vucy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbihsYXN0WzNdIHx8IGxhc3RbMl0gfHwgZmluZExhc3RXaXRoUG9zaXRpb24kMSh0b2tlbnMpKTtcbiAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgd2hpbGUodG9rZW5zWzBdWzBdICE9PSBcIndvcmRcIil7XG4gICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMSkgdGhpcy51bmtub3duV29yZCh0b2tlbnMpO1xuICAgICAgICAgICAgbm9kZTIucmF3cy5iZWZvcmUgKz0gdG9rZW5zLnNoaWZ0KClbMV07XG4gICAgICAgIH1cbiAgICAgICAgbm9kZTIuc291cmNlLnN0YXJ0ID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlbnNbMF1bMl0pO1xuICAgICAgICBub2RlMi5wcm9wID0gXCJcIjtcbiAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHRva2Vuc1swXVswXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIjpcIiB8fCB0eXBlID09PSBcInNwYWNlXCIgfHwgdHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUyLnByb3AgKz0gdG9rZW5zLnNoaWZ0KClbMV07XG4gICAgICAgIH1cbiAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gXCJcIjtcbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAodG9rZW5bMF0gPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuICs9IHRva2VuWzFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5bMF0gPT09IFwid29yZFwiICYmIC9cXHcvLnRlc3QodG9rZW5bMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5rbm93bldvcmQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiArPSB0b2tlblsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZTIucHJvcFswXSA9PT0gXCJfXCIgfHwgbm9kZTIucHJvcFswXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MuYmVmb3JlICs9IG5vZGUyLnByb3BbMF07XG4gICAgICAgICAgICBub2RlMi5wcm9wID0gbm9kZTIucHJvcC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3RTcGFjZXMgPSBbXTtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHdoaWxlKHRva2Vucy5sZW5ndGgpe1xuICAgICAgICAgICAgbmV4dCA9IHRva2Vuc1swXVswXTtcbiAgICAgICAgICAgIGlmIChuZXh0ICE9PSBcInNwYWNlXCIgJiYgbmV4dCAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgICAgICAgZmlyc3RTcGFjZXMucHVzaCh0b2tlbnMuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVjaGVja01pc3NlZFNlbWljb2xvbih0b2tlbnMpO1xuICAgICAgICBmb3IodmFyIGkyID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pe1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaTJdO1xuICAgICAgICAgICAgaWYgKHRva2VuWzFdLnRvTG93ZXJDYXNlKCkgPT09IFwiIWltcG9ydGFudFwiKSB7XG4gICAgICAgICAgICAgICAgbm9kZTIuaW1wb3J0YW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nID0gdGhpcy5zdHJpbmdGcm9tKHRva2VucywgaTIpO1xuICAgICAgICAgICAgICAgIHN0cmluZyA9IHRoaXMuc3BhY2VzRnJvbUVuZCh0b2tlbnMpICsgc3RyaW5nO1xuICAgICAgICAgICAgICAgIGlmIChzdHJpbmcgIT09IFwiICFpbXBvcnRhbnRcIikgbm9kZTIucmF3cy5pbXBvcnRhbnQgPSBzdHJpbmc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuWzFdLnRvTG93ZXJDYXNlKCkgPT09IFwiaW1wb3J0YW50XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSB0b2tlbnMuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBqID0gaTI7IGogPiAwOyBqLS0pe1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZTEgPSBjYWNoZVtqXVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ci50cmltKCkuaW5kZXhPZihcIiFcIikgPT09IDAgJiYgdHlwZTEgIT09IFwic3BhY2VcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gY2FjaGUucG9wKClbMV0gKyBzdHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHIudHJpbSgpLmluZGV4T2YoXCIhXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLmltcG9ydGFudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLnJhd3MuaW1wb3J0YW50ID0gc3RyO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSBjYWNoZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW5bMF0gIT09IFwic3BhY2VcIiAmJiB0b2tlblswXSAhPT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzV29yZCA9IHRva2Vucy5zb21lKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICByZXR1cm4gaTJbMF0gIT09IFwic3BhY2VcIiAmJiBpMlswXSAhPT0gXCJjb21tZW50XCI7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzV29yZCkge1xuICAgICAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuICs9IGZpcnN0U3BhY2VzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpMlsxXTtcbiAgICAgICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgICAgICAgICBmaXJzdFNwYWNlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmF3KG5vZGUyLCBcInZhbHVlXCIsIGZpcnN0U3BhY2VzLmNvbmNhdCh0b2tlbnMpLCBjdXN0b21Qcm9wZXJ0eSk7XG4gICAgICAgIGlmIChub2RlMi52YWx1ZS5pbmNsdWRlcyhcIjpcIikgJiYgIWN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5kb3VibGVDb2xvbiA9IGZ1bmN0aW9uIGRvdWJsZUNvbG9uKHRva2VuKSB7XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJEb3VibGUgY29sb25cIiwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlblsyXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuWzJdICsgdG9rZW5bMV0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmVtcHR5UnVsZSA9IGZ1bmN0aW9uIGVtcHR5UnVsZSh0b2tlbikge1xuICAgICAgICB2YXIgbm9kZTIgPSBuZXcgUnVsZSQyJDEoKTtcbiAgICAgICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlblsyXSk7XG4gICAgICAgIG5vZGUyLnNlbGVjdG9yID0gXCJcIjtcbiAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gXCJcIjtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbm9kZTI7XG4gICAgfTtcbiAgICBfcHJvdG8uZW5kID0gZnVuY3Rpb24gZW5kKHRva2VuKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQubm9kZXMgJiYgdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnJhd3Muc2VtaWNvbG9uID0gdGhpcy5zZW1pY29sb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW1pY29sb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgPSAodGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgfHwgXCJcIikgKyB0aGlzLnNwYWNlcztcbiAgICAgICAgdGhpcy5zcGFjZXMgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2VuWzJdKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5jdXJyZW50LnBhcmVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZENsb3NlKHRva2VuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmVuZEZpbGUgPSBmdW5jdGlvbiBlbmRGaWxlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50LnBhcmVudCkgdGhpcy51bmNsb3NlZEJsb2NrKCk7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQubm9kZXMgJiYgdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnJhd3Muc2VtaWNvbG9uID0gdGhpcy5zZW1pY29sb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgPSAodGhpcy5jdXJyZW50LnJhd3MuYWZ0ZXIgfHwgXCJcIikgKyB0aGlzLnNwYWNlcztcbiAgICAgICAgdGhpcy5yb290LnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRoaXMudG9rZW5pemVyLnBvc2l0aW9uKCkpO1xuICAgIH07XG4gICAgX3Byb3RvLmZyZWVTZW1pY29sb24gPSBmdW5jdGlvbiBmcmVlU2VtaWNvbG9uKHRva2VuKSB7XG4gICAgICAgIHRoaXMuc3BhY2VzICs9IHRva2VuWzFdO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzKSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IHRoaXMuY3VycmVudC5ub2Rlc1t0aGlzLmN1cnJlbnQubm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2LnR5cGUgPT09IFwicnVsZVwiICYmICFwcmV2LnJhd3Mub3duU2VtaWNvbG9uKSB7XG4gICAgICAgICAgICAgICAgcHJldi5yYXdzLm93blNlbWljb2xvbiA9IHRoaXMuc3BhY2VzO1xuICAgICAgICAgICAgICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSGVscGVyc1xuICAgIF9wcm90by5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldFBvc2l0aW9uKG9mZnNldCkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5pbnB1dC5mcm9tT2Zmc2V0KG9mZnNldCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2x1bW46IHBvcy5jb2wsXG4gICAgICAgICAgICBsaW5lOiBwb3MubGluZSxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQobm9kZTIsIG9mZnNldCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQucHVzaChub2RlMik7XG4gICAgICAgIG5vZGUyLnNvdXJjZSA9IHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLmlucHV0LFxuICAgICAgICAgICAgc3RhcnQ6IHRoaXMuZ2V0UG9zaXRpb24ob2Zmc2V0KVxuICAgICAgICB9O1xuICAgICAgICBub2RlMi5yYXdzLmJlZm9yZSA9IHRoaXMuc3BhY2VzO1xuICAgICAgICB0aGlzLnNwYWNlcyA9IFwiXCI7XG4gICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcImNvbW1lbnRcIikgdGhpcy5zZW1pY29sb24gPSBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5vdGhlciA9IGZ1bmN0aW9uIG90aGVyKHN0YXJ0KSB7XG4gICAgICAgIHZhciBlbmQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHR5cGUgPSBudWxsO1xuICAgICAgICB2YXIgY29sb24gPSBmYWxzZTtcbiAgICAgICAgdmFyIGJyYWNrZXQgPSBudWxsO1xuICAgICAgICB2YXIgYnJhY2tldHMgPSBbXTtcbiAgICAgICAgdmFyIGN1c3RvbVByb3BlcnR5ID0gc3RhcnRbMV0uc3RhcnRzV2l0aChcIi0tXCIpO1xuICAgICAgICB2YXIgdG9rZW5zID0gW107XG4gICAgICAgIHZhciB0b2tlbiA9IHN0YXJ0O1xuICAgICAgICB3aGlsZSh0b2tlbil7XG4gICAgICAgICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCIoXCIgfHwgdHlwZSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJyYWNrZXQpIGJyYWNrZXQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBicmFja2V0cy5wdXNoKHR5cGUgPT09IFwiKFwiID8gXCIpXCIgOiBcIl1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1c3RvbVByb3BlcnR5ICYmIGNvbG9uICYmIHR5cGUgPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFicmFja2V0KSBicmFja2V0ID0gdG9rZW47XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucHVzaChcIn1cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcIjtcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVjbCh0b2tlbnMsIGN1c3RvbVByb3BlcnR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIntcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bGUodG9rZW5zKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2tlbml6ZXIuYmFjayh0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IGJyYWNrZXRzW2JyYWNrZXRzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucG9wKCk7XG4gICAgICAgICAgICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkgYnJhY2tldCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSkgZW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA+IDApIHRoaXMudW5jbG9zZWRCcmFja2V0KGJyYWNrZXQpO1xuICAgICAgICBpZiAoZW5kICYmIGNvbG9uKSB7XG4gICAgICAgICAgICBpZiAoIWN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSBcInNwYWNlXCIgJiYgdG9rZW4gIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2tlbml6ZXIuYmFjayh0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVjbCh0b2tlbnMsIGN1c3RvbVByb3BlcnR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5rbm93bldvcmQodG9rZW5zKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoKSB7XG4gICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgd2hpbGUoIXRoaXMudG9rZW5pemVyLmVuZE9mRmlsZSgpKXtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50b2tlbml6ZXIubmV4dFRva2VuKCk7XG4gICAgICAgICAgICBzd2l0Y2godG9rZW5bMF0pe1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzcGFjZVwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNwYWNlcyArPSB0b2tlblsxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIjtcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmVlU2VtaWNvbG9uKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIn1cIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1lbnQodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiYXQtd29yZFwiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0cnVsZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1wdHlSdWxlKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vdGhlcih0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5kRmlsZSgpO1xuICAgIH07XG4gICAgX3Byb3RvLnByZWNoZWNrTWlzc2VkU2VtaWNvbG9uID0gZnVuY3Rpb24gcHJlY2hlY2tNaXNzZWRTZW1pY29sb24oKSB7fTtcbiAgICBfcHJvdG8ucmF3ID0gZnVuY3Rpb24gcmF3KG5vZGUyLCBwcm9wLCB0b2tlbnMsIGN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHZhciB0b2tlbiwgdHlwZTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRva2Vucy5sZW5ndGg7XG4gICAgICAgIHZhciB2YWx1ZSA9IFwiXCI7XG4gICAgICAgIHZhciBjbGVhbiA9IHRydWU7XG4gICAgICAgIHZhciBuZXh0LCBwcmV2O1xuICAgICAgICBmb3IodmFyIGkyID0gMDsgaTIgPCBsZW5ndGg7IGkyICs9IDEpe1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaTJdO1xuICAgICAgICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwic3BhY2VcIiAmJiBpMiA9PT0gbGVuZ3RoIC0gMSAmJiAhY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICAgICAgICAgIHByZXYgPSB0b2tlbnNbaTIgLSAxXSA/IHRva2Vuc1tpMiAtIDFdWzBdIDogXCJlbXB0eVwiO1xuICAgICAgICAgICAgICAgIG5leHQgPSB0b2tlbnNbaTIgKyAxXSA/IHRva2Vuc1tpMiArIDFdWzBdIDogXCJlbXB0eVwiO1xuICAgICAgICAgICAgICAgIGlmICghU0FGRV9DT01NRU5UX05FSUdIQk9SJDFbcHJldl0gJiYgIVNBRkVfQ09NTUVOVF9ORUlHSEJPUiQxW25leHRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5zbGljZSgtMSkgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdG9rZW5bMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gdG9rZW5bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjbGVhbikge1xuICAgICAgICAgICAgdmFyIHJhdyA9IHRva2Vucy5yZWR1Y2UoZnVuY3Rpb24oYWxsLCBpMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbGwgKyBpMlsxXTtcbiAgICAgICAgICAgIH0sIFwiXCIpO1xuICAgICAgICAgICAgbm9kZTIucmF3c1twcm9wXSA9IHtcbiAgICAgICAgICAgICAgICByYXc6IHJhdyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbm9kZTJbcHJvcF0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5ydWxlID0gZnVuY3Rpb24gcnVsZSh0b2tlbnMpIHtcbiAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICB2YXIgbm9kZTIgPSBuZXcgUnVsZSQyJDEoKTtcbiAgICAgICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlbnNbMF1bMl0pO1xuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gPSB0aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZCh0b2tlbnMpO1xuICAgICAgICB0aGlzLnJhdyhub2RlMiwgXCJzZWxlY3RvclwiLCB0b2tlbnMpO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBub2RlMjtcbiAgICB9O1xuICAgIF9wcm90by5zcGFjZXNBbmRDb21tZW50c0Zyb21FbmQgPSBmdW5jdGlvbiBzcGFjZXNBbmRDb21tZW50c0Zyb21FbmQodG9rZW5zKSB7XG4gICAgICAgIHZhciBsYXN0VG9rZW5UeXBlO1xuICAgICAgICB2YXIgc3BhY2VzID0gXCJcIjtcbiAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICBsYXN0VG9rZW5UeXBlID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXVswXTtcbiAgICAgICAgICAgIGlmIChsYXN0VG9rZW5UeXBlICE9PSBcInNwYWNlXCIgJiYgbGFzdFRva2VuVHlwZSAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgICAgICAgc3BhY2VzID0gdG9rZW5zLnBvcCgpWzFdICsgc3BhY2VzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFjZXM7XG4gICAgfTtcbiAgICAvLyBFcnJvcnNcbiAgICBfcHJvdG8uc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQgPSBmdW5jdGlvbiBzcGFjZXNBbmRDb21tZW50c0Zyb21TdGFydCh0b2tlbnMpIHtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHZhciBzcGFjZXMgPSBcIlwiO1xuICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgIG5leHQgPSB0b2tlbnNbMF1bMF07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gXCJzcGFjZVwiICYmIG5leHQgIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgICAgICAgIHNwYWNlcyArPSB0b2tlbnMuc2hpZnQoKVsxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhY2VzO1xuICAgIH07XG4gICAgX3Byb3RvLnNwYWNlc0Zyb21FbmQgPSBmdW5jdGlvbiBzcGFjZXNGcm9tRW5kKHRva2Vucykge1xuICAgICAgICB2YXIgbGFzdFRva2VuVHlwZTtcbiAgICAgICAgdmFyIHNwYWNlcyA9IFwiXCI7XG4gICAgICAgIHdoaWxlKHRva2Vucy5sZW5ndGgpe1xuICAgICAgICAgICAgbGFzdFRva2VuVHlwZSA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1bMF07XG4gICAgICAgICAgICBpZiAobGFzdFRva2VuVHlwZSAhPT0gXCJzcGFjZVwiKSBicmVhaztcbiAgICAgICAgICAgIHNwYWNlcyA9IHRva2Vucy5wb3AoKVsxXSArIHNwYWNlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhY2VzO1xuICAgIH07XG4gICAgX3Byb3RvLnN0cmluZ0Zyb20gPSBmdW5jdGlvbiBzdHJpbmdGcm9tKHRva2VucywgZnJvbSkge1xuICAgICAgICB2YXIgcmVzdWx0MiA9IFwiXCI7XG4gICAgICAgIGZvcih2YXIgaTIgPSBmcm9tOyBpMiA8IHRva2Vucy5sZW5ndGg7IGkyKyspe1xuICAgICAgICAgICAgcmVzdWx0MiArPSB0b2tlbnNbaTJdWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5zcGxpY2UoZnJvbSwgdG9rZW5zLmxlbmd0aCAtIGZyb20pO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9O1xuICAgIF9wcm90by51bmNsb3NlZEJsb2NrID0gZnVuY3Rpb24gdW5jbG9zZWRCbG9jaygpIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuY3VycmVudC5zb3VyY2Uuc3RhcnQ7XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJVbmNsb3NlZCBibG9ja1wiLCBwb3MubGluZSwgcG9zLmNvbHVtbik7XG4gICAgfTtcbiAgICBfcHJvdG8udW5jbG9zZWRCcmFja2V0ID0gZnVuY3Rpb24gdW5jbG9zZWRCcmFja2V0KGJyYWNrZXQpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIlVuY2xvc2VkIGJyYWNrZXRcIiwge1xuICAgICAgICAgICAgb2Zmc2V0OiBicmFja2V0WzJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9mZnNldDogYnJhY2tldFsyXSArIDFcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8udW5leHBlY3RlZENsb3NlID0gZnVuY3Rpb24gdW5leHBlY3RlZENsb3NlKHRva2VuKSB7XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJVbmV4cGVjdGVkIH1cIiwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlblsyXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuWzJdICsgMVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by51bmtub3duV29yZCA9IGZ1bmN0aW9uIHVua25vd25Xb3JkKHRva2Vucykge1xuICAgICAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiVW5rbm93biB3b3JkXCIsIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5zWzBdWzJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5zWzBdWzJdICsgdG9rZW5zWzBdWzFdLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by51bm5hbWVkQXRydWxlID0gZnVuY3Rpb24gdW5uYW1lZEF0cnVsZShub2RlMiwgdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIkF0LXJ1bGUgd2l0aG91dCBuYW1lXCIsIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5bMl1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlblsyXSArIHRva2VuWzFdLmxlbmd0aFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBQYXJzZXI7XG59KCk7XG52YXIgcGFyc2VyJDEgPSBQYXJzZXIkMSQxO1xudmFyIENvbnRhaW5lciQyJDEgPSBjb250YWluZXIkMTtcbnZhciBQYXJzZXIyJDEgPSBwYXJzZXIkMTtcbnZhciBJbnB1dCQyJDEgPSBpbnB1dCQxO1xuZnVuY3Rpb24gcGFyc2UkMyQxKGNzcywgb3B0cykge1xuICAgIHZhciBpbnB1dDIgPSBuZXcgSW5wdXQkMiQxKGNzcywgb3B0cyk7XG4gICAgdmFyIHBhcnNlcjIgPSBuZXcgUGFyc2VyMiQxKGlucHV0Mik7XG4gICAgdHJ5IHtcbiAgICAgICAgcGFyc2VyMi5wYXJzZSgpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChlMi5uYW1lID09PSBcIkNzc1N5bnRheEVycm9yXCIgJiYgb3B0cyAmJiBvcHRzLmZyb20pIHtcbiAgICAgICAgICAgICAgICBpZiAoL1xcLnNjc3MkL2kudGVzdChvcHRzLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIGUyLm1lc3NhZ2UgKz0gXCJcXG5Zb3UgdHJpZWQgdG8gcGFyc2UgU0NTUyB3aXRoIHRoZSBzdGFuZGFyZCBDU1MgcGFyc2VyOyB0cnkgYWdhaW4gd2l0aCB0aGUgcG9zdGNzcy1zY3NzIHBhcnNlclwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoL1xcLnNhc3MvaS50ZXN0KG9wdHMuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZTIubWVzc2FnZSArPSBcIlxcbllvdSB0cmllZCB0byBwYXJzZSBTYXNzIHdpdGggdGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7IHRyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLXNhc3MgcGFyc2VyXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvXFwubGVzcyQvaS50ZXN0KG9wdHMuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZTIubWVzc2FnZSArPSBcIlxcbllvdSB0cmllZCB0byBwYXJzZSBMZXNzIHdpdGggdGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7IHRyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLWxlc3MgcGFyc2VyXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGUyO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyMi5yb290O1xufVxudmFyIHBhcnNlXzEkMSA9IHBhcnNlJDMkMTtcbnBhcnNlJDMkMS5kZWZhdWx0ID0gcGFyc2UkMyQxO1xuQ29udGFpbmVyJDIkMS5yZWdpc3RlclBhcnNlKHBhcnNlJDMkMSk7XG52YXIgaXNDbGVhbiQzID0gc3ltYm9scyQxLmlzQ2xlYW4sIG15JDMgPSBzeW1ib2xzJDEubXk7XG52YXIgTWFwR2VuZXJhdG9yJDEkMSA9IG1hcEdlbmVyYXRvciQxO1xudmFyIHN0cmluZ2lmeSQyJDEgPSBzdHJpbmdpZnlfMSQxO1xudmFyIENvbnRhaW5lciQxJDEgPSBjb250YWluZXIkMTtcbnZhciBEb2N1bWVudCQyJDEgPSBkb2N1bWVudCQxJDE7XG52YXIgd2Fybk9uY2UkMSQxID0gd2Fybk9uY2UkMiQxO1xudmFyIFJlc3VsdCQyJDEgPSByZXN1bHQkMTtcbnZhciBwYXJzZSQyJDEgPSBwYXJzZV8xJDE7XG52YXIgUm9vdCQzJDEgPSByb290JDE7XG52YXIgVFlQRV9UT19DTEFTU19OQU1FJDEgPSB7XG4gICAgYXRydWxlOiBcIkF0UnVsZVwiLFxuICAgIGNvbW1lbnQ6IFwiQ29tbWVudFwiLFxuICAgIGRlY2w6IFwiRGVjbGFyYXRpb25cIixcbiAgICBkb2N1bWVudDogXCJEb2N1bWVudFwiLFxuICAgIHJvb3Q6IFwiUm9vdFwiLFxuICAgIHJ1bGU6IFwiUnVsZVwiXG59O1xudmFyIFBMVUdJTl9QUk9QUyQxID0ge1xuICAgIEF0UnVsZTogdHJ1ZSxcbiAgICBBdFJ1bGVFeGl0OiB0cnVlLFxuICAgIENvbW1lbnQ6IHRydWUsXG4gICAgQ29tbWVudEV4aXQ6IHRydWUsXG4gICAgRGVjbGFyYXRpb246IHRydWUsXG4gICAgRGVjbGFyYXRpb25FeGl0OiB0cnVlLFxuICAgIERvY3VtZW50OiB0cnVlLFxuICAgIERvY3VtZW50RXhpdDogdHJ1ZSxcbiAgICBPbmNlOiB0cnVlLFxuICAgIE9uY2VFeGl0OiB0cnVlLFxuICAgIHBvc3Rjc3NQbHVnaW46IHRydWUsXG4gICAgcHJlcGFyZTogdHJ1ZSxcbiAgICBSb290OiB0cnVlLFxuICAgIFJvb3RFeGl0OiB0cnVlLFxuICAgIFJ1bGU6IHRydWUsXG4gICAgUnVsZUV4aXQ6IHRydWVcbn07XG52YXIgTk9UX1ZJU0lUT1JTJDEgPSB7XG4gICAgT25jZTogdHJ1ZSxcbiAgICBwb3N0Y3NzUGx1Z2luOiB0cnVlLFxuICAgIHByZXBhcmU6IHRydWVcbn07XG52YXIgQ0hJTERSRU4kMSA9IDA7XG5mdW5jdGlvbiBpc1Byb21pc2UkMShvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2Yob2JqKSkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iai50aGVuID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBnZXRFdmVudHMkMShub2RlMikge1xuICAgIHZhciBrZXkgPSBmYWxzZTtcbiAgICB2YXIgdHlwZSA9IFRZUEVfVE9fQ0xBU1NfTkFNRSQxW25vZGUyLnR5cGVdO1xuICAgIGlmIChub2RlMi50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICBrZXkgPSBub2RlMi5wcm9wLnRvTG93ZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcImF0cnVsZVwiKSB7XG4gICAgICAgIGtleSA9IG5vZGUyLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKGtleSAmJiBub2RlMi5hcHBlbmQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB0eXBlICsgXCItXCIgKyBrZXksXG4gICAgICAgICAgICBDSElMRFJFTiQxLFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdFwiLFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdC1cIiArIGtleVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgdHlwZSArIFwiLVwiICsga2V5LFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdFwiLFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdC1cIiArIGtleVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAobm9kZTIuYXBwZW5kKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgQ0hJTERSRU4kMSxcbiAgICAgICAgICAgIHR5cGUgKyBcIkV4aXRcIlxuICAgICAgICBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdFwiXG4gICAgICAgIF07XG4gICAgfVxufVxuZnVuY3Rpb24gdG9TdGFjayQxKG5vZGUyKSB7XG4gICAgdmFyIGV2ZW50cztcbiAgICBpZiAobm9kZTIudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgIGV2ZW50cyA9IFtcbiAgICAgICAgICAgIFwiRG9jdW1lbnRcIixcbiAgICAgICAgICAgIENISUxEUkVOJDEsXG4gICAgICAgICAgICBcIkRvY3VtZW50RXhpdFwiXG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcInJvb3RcIikge1xuICAgICAgICBldmVudHMgPSBbXG4gICAgICAgICAgICBcIlJvb3RcIixcbiAgICAgICAgICAgIENISUxEUkVOJDEsXG4gICAgICAgICAgICBcIlJvb3RFeGl0XCJcbiAgICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBldmVudHMgPSBnZXRFdmVudHMkMShub2RlMik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGV2ZW50SW5kZXg6IDAsXG4gICAgICAgIGV2ZW50czogZXZlbnRzLFxuICAgICAgICBpdGVyYXRvcjogMCxcbiAgICAgICAgbm9kZTogbm9kZTIsXG4gICAgICAgIHZpc2l0b3JJbmRleDogMCxcbiAgICAgICAgdmlzaXRvcnM6IFtdXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNsZWFuTWFya3MkMShub2RlMikge1xuICAgIG5vZGUyW2lzQ2xlYW4kM10gPSBmYWxzZTtcbiAgICBpZiAobm9kZTIubm9kZXMpIG5vZGUyLm5vZGVzLmZvckVhY2goZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIGNsZWFuTWFya3MkMShpMik7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGUyO1xufVxudmFyIHBvc3Rjc3MkMiQxID0ge307XG52YXIgTGF6eVJlc3VsdCQyJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIExhenlSZXN1bHQocHJvY2Vzc29yMiwgY3NzLCBvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RyaW5naWZpZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIHJvb3QyO1xuICAgICAgICBpZiAoKHR5cGVvZiBjc3MgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YoY3NzKSkgPT09IFwib2JqZWN0XCIgJiYgY3NzICE9PSBudWxsICYmIChjc3MudHlwZSA9PT0gXCJyb290XCIgfHwgY3NzLnR5cGUgPT09IFwiZG9jdW1lbnRcIikpIHtcbiAgICAgICAgICAgIHJvb3QyID0gY2xlYW5NYXJrcyQxKGNzcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YoY3NzLCBMYXp5UmVzdWx0KSB8fCBfaW5zdGFuY2VvZihjc3MsIFJlc3VsdCQyJDEpKSB7XG4gICAgICAgICAgICByb290MiA9IGNsZWFuTWFya3MkMShjc3Mucm9vdCk7XG4gICAgICAgICAgICBpZiAoY3NzLm1hcCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5tYXAgPT09IFwidW5kZWZpbmVkXCIpIG9wdHMubWFwID0ge307XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRzLm1hcC5pbmxpbmUpIG9wdHMubWFwLmlubGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG9wdHMubWFwLnByZXYgPSBjc3MubWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBhcnNlcjIgPSBwYXJzZSQyJDE7XG4gICAgICAgICAgICBpZiAob3B0cy5zeW50YXgpIHBhcnNlcjIgPSBvcHRzLnN5bnRheC5wYXJzZTtcbiAgICAgICAgICAgIGlmIChvcHRzLnBhcnNlcikgcGFyc2VyMiA9IG9wdHMucGFyc2VyO1xuICAgICAgICAgICAgaWYgKHBhcnNlcjIucGFyc2UpIHBhcnNlcjIgPSBwYXJzZXIyLnBhcnNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByb290MiA9IHBhcnNlcjIoY3NzLCBvcHRzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb290MiAmJiAhcm9vdDJbbXkkM10pIHtcbiAgICAgICAgICAgICAgICBDb250YWluZXIkMSQxLnJlYnVpbGQocm9vdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzdWx0ID0gbmV3IFJlc3VsdCQyJDEocHJvY2Vzc29yMiwgcm9vdDIsIG9wdHMpO1xuICAgICAgICB0aGlzLmhlbHBlcnMgPSBfZXh0ZW5kcyh7fSwgcG9zdGNzcyQyJDEsIHtcbiAgICAgICAgICAgIHBvc3Rjc3M6IHBvc3Rjc3MkMiQxLFxuICAgICAgICAgICAgcmVzdWx0OiB0aGlzLnJlc3VsdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wcm9jZXNzb3IucGx1Z2lucy5tYXAoZnVuY3Rpb24ocGx1Z2luMjIpIHtcbiAgICAgICAgICAgIGlmICgodHlwZW9mIHBsdWdpbjIyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKHBsdWdpbjIyKSkgPT09IFwib2JqZWN0XCIgJiYgcGx1Z2luMjIucHJlcGFyZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgcGx1Z2luMjIsIHBsdWdpbjIyLnByZXBhcmUoX3RoaXMucmVzdWx0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW4yMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBMYXp5UmVzdWx0LnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXN5bmMgPSBmdW5jdGlvbiBhc3luYygpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKTtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMucmVzdWx0KTtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2luZyA9IHRoaXMucnVuQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzaW5nO1xuICAgIH07XG4gICAgX3Byb3RvLmNhdGNoID0gZnVuY3Rpb24gX2NhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS5jYXRjaChvblJlamVjdGVkKTtcbiAgICB9O1xuICAgIF9wcm90by5maW5hbGx5ID0gZnVuY3Rpb24gX2ZpbmFsbHkob25GaW5hbGx5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jKCkudGhlbihvbkZpbmFsbHksIG9uRmluYWxseSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0QXN5bmNFcnJvciA9IGZ1bmN0aW9uIGdldEFzeW5jRXJyb3IoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVzZSBwcm9jZXNzKGNzcykudGhlbihjYikgdG8gd29yayB3aXRoIGFzeW5jIHBsdWdpbnNcIik7XG4gICAgfTtcbiAgICBfcHJvdG8uaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvciwgbm9kZTIpIHtcbiAgICAgICAgdmFyIHBsdWdpbjIyID0gdGhpcy5yZXN1bHQubGFzdFBsdWdpbjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChub2RlMikgbm9kZTIuYWRkVG9FcnJvcihlcnJvcik7XG4gICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gXCJDc3NTeW50YXhFcnJvclwiICYmICFlcnJvci5wbHVnaW4pIHtcbiAgICAgICAgICAgICAgICBlcnJvci5wbHVnaW4gPSBwbHVnaW4yMi5wb3N0Y3NzUGx1Z2luO1xuICAgICAgICAgICAgICAgIGVycm9yLnNldE1lc3NhZ2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGx1Z2luMjIucG9zdGNzc1ZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwbHVnaW5OYW1lID0gcGx1Z2luMjIucG9zdGNzc1BsdWdpbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsdWdpblZlciA9IHBsdWdpbjIyLnBvc3Rjc3NWZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnVudGltZVZlciA9IHRoaXMucmVzdWx0LnByb2Nlc3Nvci52ZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYTIgPSBwbHVnaW5WZXIuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IHJ1bnRpbWVWZXIuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYTJbMF0gIT09IGJbMF0gfHwgcGFyc2VJbnQoYTJbMV0pID4gcGFyc2VJbnQoYlsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmtub3duIGVycm9yIGZyb20gUG9zdENTUyBwbHVnaW4uIFlvdXIgY3VycmVudCBQb3N0Q1NTIHZlcnNpb24gaXMgXCIgKyBydW50aW1lVmVyICsgXCIsIGJ1dCBcIiArIHBsdWdpbk5hbWUgKyBcIiB1c2VzIFwiICsgcGx1Z2luVmVyICsgXCIuIFBlcmhhcHMgdGhpcyBpcyB0aGUgc291cmNlIG9mIHRoZSBlcnJvciBiZWxvdy5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9O1xuICAgIF9wcm90by5wcmVwYXJlVmlzaXRvcnMgPSBmdW5jdGlvbiBwcmVwYXJlVmlzaXRvcnMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgICAgIHZhciBhZGQgPSBmdW5jdGlvbihwbHVnaW4yMiwgdHlwZSwgY2IpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMubGlzdGVuZXJzW3R5cGVdKSBfdGhpcy5saXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgICAgIF90aGlzLmxpc3RlbmVyc1t0eXBlXS5wdXNoKFtcbiAgICAgICAgICAgICAgICBwbHVnaW4yMixcbiAgICAgICAgICAgICAgICBjYlxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHRoaXMucGx1Z2lucyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBwbHVnaW4yMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgcGx1Z2luMjIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YocGx1Z2luMjIpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgZXZlbnQgaW4gcGx1Z2luMjIpe1xuICAgICAgICAgICAgICAgICAgICBpZiAoIVBMVUdJTl9QUk9QUyQxW2V2ZW50XSAmJiAvXltBLVpdLy50ZXN0KGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBldmVudCBcIiArIGV2ZW50ICsgXCIgaW4gXCIgKyBwbHVnaW4yMi5wb3N0Y3NzUGx1Z2luICsgXCIuIFRyeSB0byB1cGRhdGUgUG9zdENTUyAoXCIgKyB0aGlzLnByb2Nlc3Nvci52ZXJzaW9uICsgXCIgbm93KS5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFOT1RfVklTSVRPUlMkMVtldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdHlwZV9vZihwbHVnaW4yMltldmVudF0pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBmaWx0ZXIgaW4gcGx1Z2luMjJbZXZlbnRdKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlciA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZChwbHVnaW4yMiwgZXZlbnQsIHBsdWdpbjIyW2V2ZW50XVtmaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZChwbHVnaW4yMiwgZXZlbnQgKyBcIi1cIiArIGZpbHRlci50b0xvd2VyQ2FzZSgpLCBwbHVnaW4yMltldmVudF1bZmlsdGVyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4yMltldmVudF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZChwbHVnaW4yMiwgZXZlbnQsIHBsdWdpbjIyW2V2ZW50XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNMaXN0ZW5lciA9IE9iamVjdC5rZXlzKHRoaXMubGlzdGVuZXJzKS5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgX3Byb3RvLnJ1bkFzeW5jID0gZnVuY3Rpb24gcnVuQXN5bmMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGkyLCBwbHVnaW4yMiwgcHJvbWlzZSwgZXJyb3IsIHJvb3QyLCBzdGFjaywgcHJvbWlzZTEsIGUyLCBub2RlMiwgX2xvb3AsIF9pdGVyYXRvciwgX3N0ZXA7XG4gICAgICAgICAgICByZXR1cm4gX3RzX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2goX3N0YXRlLmxhYmVsKXtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGx1Z2luID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGkyIDwgX3RoaXMucGx1Z2lucy5sZW5ndGgpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbjIyID0gX3RoaXMucGx1Z2luc1tpMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gX3RoaXMucnVuT25Sb290KHBsdWdpbjIyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQcm9taXNlJDEocHJvbWlzZSkpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnRyeXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1XG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDVcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF90aGlzLmhhbmRsZUVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgaTIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcmVwYXJlVmlzaXRvcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaGFzTGlzdGVuZXIpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QyID0gX3RoaXMucmVzdWx0LnJvb3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSA3O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISFyb290Mltpc0NsZWFuJDNdKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTRcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICByb290Mltpc0NsZWFuJDNdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RhY2skMShyb290MilcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSA4O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzdGFjay5sZW5ndGggPiAwKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEzXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZTEgPSBfdGhpcy52aXNpdFRpY2soc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1Byb21pc2UkMShwcm9taXNlMSkpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS50cnlzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEyXG4gICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlMVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTJcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgICAgICAgICAgICBlMiA9IF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlMiA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLm5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfdGhpcy5oYW5kbGVFcnJvcihlMiwgbm9kZTIpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDhcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgN1xuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMubGlzdGVuZXJzLk9uY2VFeGl0KSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfc3RlcF92YWx1ZSwgcGx1Z2luMjIsIHZpc2l0b3IsIHJvb3RzLCBlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RzX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoKF9zdGF0ZS5sYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0ZXBfdmFsdWUgPSBfc3RlcC52YWx1ZSwgcGx1Z2luMjIgPSBfc3RlcF92YWx1ZVswXSwgdmlzaXRvciA9IF9zdGVwX3ZhbHVlWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luMjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUudHJ5cy5wdXNoKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocm9vdDIudHlwZSA9PT0gXCJkb2N1bWVudFwiKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdHMgPSByb290Mi5ub2Rlcy5tYXAoZnVuY3Rpb24oc3ViUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvcihzdWJSb290LCBfdGhpcy5oZWxwZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChyb290cylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRvcihyb290MiwgX3RoaXMuaGVscGVycylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMiA9IF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgX3RoaXMuaGFuZGxlRXJyb3IoZTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKF90aGlzLmxpc3RlbmVycy5PbmNlRXhpdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSAxNTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RzX3ZhbHVlcyhfbG9vcCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSAxNztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RyaW5naWZ5KClcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ucnVuT25Sb290ID0gZnVuY3Rpb24gcnVuT25Sb290KHBsdWdpbjIyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICgodHlwZW9mIHBsdWdpbjIyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKHBsdWdpbjIyKSkgPT09IFwib2JqZWN0XCIgJiYgcGx1Z2luMjIuT25jZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdC5yb290LnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdHMgPSB0aGlzLnJlc3VsdC5yb290Lm5vZGVzLm1hcChmdW5jdGlvbihyb290Mikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjIyLk9uY2Uocm9vdDIsIF90aGlzLmhlbHBlcnMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvbWlzZSQxKHJvb3RzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJvb3RzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW4yMi5PbmNlKHRoaXMucmVzdWx0LnJvb3QsIHRoaXMuaGVscGVycyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4yMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjIyKHRoaXMucmVzdWx0LnJvb3QsIHRoaXMucmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICAgICAgaWYgKHRoaXMuc3RyaW5naWZpZWQpIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICAgICAgdGhpcy5zdHJpbmdpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3luYygpO1xuICAgICAgICB2YXIgb3B0cyA9IHRoaXMucmVzdWx0Lm9wdHM7XG4gICAgICAgIHZhciBzdHIgPSBzdHJpbmdpZnkkMiQxO1xuICAgICAgICBpZiAob3B0cy5zeW50YXgpIHN0ciA9IG9wdHMuc3ludGF4LnN0cmluZ2lmeTtcbiAgICAgICAgaWYgKG9wdHMuc3RyaW5naWZpZXIpIHN0ciA9IG9wdHMuc3RyaW5naWZpZXI7XG4gICAgICAgIGlmIChzdHIuc3RyaW5naWZ5KSBzdHIgPSBzdHIuc3RyaW5naWZ5O1xuICAgICAgICB2YXIgbWFwID0gbmV3IE1hcEdlbmVyYXRvciQxJDEoc3RyLCB0aGlzLnJlc3VsdC5yb290LCB0aGlzLnJlc3VsdC5vcHRzKTtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXAuZ2VuZXJhdGUoKTtcbiAgICAgICAgdGhpcy5yZXN1bHQuY3NzID0gZGF0YVswXTtcbiAgICAgICAgdGhpcy5yZXN1bHQubWFwID0gZGF0YVsxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLnN5bmMgPSBmdW5jdGlvbiBzeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkKSByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2luZykge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5nZXRBc3luY0Vycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UodGhpcy5wbHVnaW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIHBsdWdpbjIyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHRoaXMucnVuT25Sb290KHBsdWdpbjIyKTtcbiAgICAgICAgICAgIGlmIChpc1Byb21pc2UkMShwcm9taXNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZ2V0QXN5bmNFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcGFyZVZpc2l0b3JzKCk7XG4gICAgICAgIGlmICh0aGlzLmhhc0xpc3RlbmVyKSB7XG4gICAgICAgICAgICB2YXIgcm9vdDIgPSB0aGlzLnJlc3VsdC5yb290O1xuICAgICAgICAgICAgd2hpbGUoIXJvb3QyW2lzQ2xlYW4kM10pe1xuICAgICAgICAgICAgICAgIHJvb3QyW2lzQ2xlYW4kM10gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMud2Fsa1N5bmMocm9vdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvb3QyLnR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvcjEgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uocm9vdDIubm9kZXMpLCBfc3RlcDE7ICEoX3N0ZXAxID0gX2l0ZXJhdG9yMSgpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3ViUm9vdCA9IF9zdGVwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRTeW5jKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0LCBzdWJSb290KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXRTeW5jKHRoaXMubGlzdGVuZXJzLk9uY2VFeGl0LCByb290Mik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICB9O1xuICAgIF9wcm90by50aGVuID0gZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoIShcImZyb21cIiBpbiB0aGlzLm9wdHMpKSB7XG4gICAgICAgICAgICAgICAgd2Fybk9uY2UkMSQxKFwiV2l0aG91dCBgZnJvbWAgb3B0aW9uIFBvc3RDU1MgY291bGQgZ2VuZXJhdGUgd3Jvbmcgc291cmNlIG1hcCBhbmQgd2lsbCBub3QgZmluZCBCcm93c2Vyc2xpc3QgY29uZmlnLiBTZXQgaXQgdG8gQ1NTIGZpbGUgcGF0aCBvciB0byBgdW5kZWZpbmVkYCB0byBwcmV2ZW50IHRoaXMgd2FybmluZy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9O1xuICAgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jc3M7XG4gICAgfTtcbiAgICBfcHJvdG8udmlzaXRTeW5jID0gZnVuY3Rpb24gdmlzaXRTeW5jKHZpc2l0b3JzLCBub2RlMikge1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh2aXNpdG9ycyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBfc3RlcF92YWx1ZSA9IF9zdGVwLnZhbHVlLCBwbHVnaW4yMiA9IF9zdGVwX3ZhbHVlWzBdLCB2aXNpdG9yID0gX3N0ZXBfdmFsdWVbMV07XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luMjI7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IHZpc2l0b3Iobm9kZTIsIHRoaXMuaGVscGVycyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZTIsIG5vZGUyLnByb3h5T2YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwicm9vdFwiICYmIG5vZGUyLnR5cGUgIT09IFwiZG9jdW1lbnRcIiAmJiAhbm9kZTIucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlJDEocHJvbWlzZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnZpc2l0VGljayA9IGZ1bmN0aW9uIHZpc2l0VGljayhzdGFjaykge1xuICAgICAgICB2YXIgdmlzaXQyID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBub2RlMiA9IHZpc2l0Mi5ub2RlLCB2aXNpdG9ycyA9IHZpc2l0Mi52aXNpdG9ycztcbiAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwicm9vdFwiICYmIG5vZGUyLnR5cGUgIT09IFwiZG9jdW1lbnRcIiAmJiAhbm9kZTIucGFyZW50KSB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzaXRvcnMubGVuZ3RoID4gMCAmJiB2aXNpdDIudmlzaXRvckluZGV4IDwgdmlzaXRvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgX3Zpc2l0b3JzX3Zpc2l0Ml92aXNpdG9ySW5kZXggPSB2aXNpdG9yc1t2aXNpdDIudmlzaXRvckluZGV4XSwgcGx1Z2luMjIgPSBfdmlzaXRvcnNfdmlzaXQyX3Zpc2l0b3JJbmRleFswXSwgdmlzaXRvciA9IF92aXNpdG9yc192aXNpdDJfdmlzaXRvckluZGV4WzFdO1xuICAgICAgICAgICAgdmlzaXQyLnZpc2l0b3JJbmRleCArPSAxO1xuICAgICAgICAgICAgaWYgKHZpc2l0Mi52aXNpdG9ySW5kZXggPT09IHZpc2l0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZpc2l0Mi52aXNpdG9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIHZpc2l0Mi52aXNpdG9ySW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXRvcihub2RlMi50b1Byb3h5KCksIHRoaXMuaGVscGVycyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZTIsIG5vZGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzaXQyLml0ZXJhdG9yICE9PSAwKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3IgPSB2aXNpdDIuaXRlcmF0b3I7XG4gICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICB3aGlsZShjaGlsZCA9IG5vZGUyLm5vZGVzW25vZGUyLmluZGV4ZXNbaXRlcmF0b3JdXSl7XG4gICAgICAgICAgICAgICAgbm9kZTIuaW5kZXhlc1tpdGVyYXRvcl0gKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkW2lzQ2xlYW4kM10pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRbaXNDbGVhbiQzXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godG9TdGFjayQxKGNoaWxkKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2aXNpdDIuaXRlcmF0b3IgPSAwO1xuICAgICAgICAgICAgZGVsZXRlIG5vZGUyLmluZGV4ZXNbaXRlcmF0b3JdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudHMgPSB2aXNpdDIuZXZlbnRzO1xuICAgICAgICB3aGlsZSh2aXNpdDIuZXZlbnRJbmRleCA8IGV2ZW50cy5sZW5ndGgpe1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gZXZlbnRzW3Zpc2l0Mi5ldmVudEluZGV4XTtcbiAgICAgICAgICAgIHZpc2l0Mi5ldmVudEluZGV4ICs9IDE7XG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09IENISUxEUkVOJDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTIubm9kZXMgJiYgbm9kZTIubm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyW2lzQ2xlYW4kM10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2aXNpdDIuaXRlcmF0b3IgPSBub2RlMi5nZXRJdGVyYXRvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIHZpc2l0Mi52aXNpdG9ycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ud2Fsa1N5bmMgPSBmdW5jdGlvbiB3YWxrU3luYyhub2RlMikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBub2RlMltpc0NsZWFuJDNdID0gdHJ1ZTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IGdldEV2ZW50cyQxKG5vZGUyKTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoZXZlbnRzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICBpZiAoZXZlbnQgPT09IENISUxEUkVOJDEpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTIubm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIuZWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZFtpc0NsZWFuJDNdKSBfdGhpcy53YWxrU3luYyhjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpc2l0b3JzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnRdO1xuICAgICAgICAgICAgICAgIGlmICh2aXNpdG9ycykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy52aXNpdFN5bmModmlzaXRvcnMsIG5vZGUyLnRvUHJveHkoKSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by53YXJuaW5ncyA9IGZ1bmN0aW9uIHdhcm5pbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zeW5jKCkud2FybmluZ3MoKTtcbiAgICB9O1xuICAgIF9jcmVhdGVfY2xhc3MoTGF6eVJlc3VsdCwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY29udGVudFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkuY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNzc1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5naWZ5KCkuY3NzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibWFwXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtZXNzYWdlc1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3luYygpLm1lc3NhZ2VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwib3B0c1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0Lm9wdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJwcm9jZXNzb3JcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5wcm9jZXNzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJyb290XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zeW5jKCkucm9vdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBTeW1ib2wudG9TdHJpbmdUYWcsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJMYXp5UmVzdWx0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gTGF6eVJlc3VsdDtcbn0oKTtcbkxhenlSZXN1bHQkMiQxLnJlZ2lzdGVyUG9zdGNzcyA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIHBvc3Rjc3MkMiQxID0gZGVwZW5kYW50O1xufTtcbnZhciBsYXp5UmVzdWx0JDEgPSBMYXp5UmVzdWx0JDIkMTtcbkxhenlSZXN1bHQkMiQxLmRlZmF1bHQgPSBMYXp5UmVzdWx0JDIkMTtcblJvb3QkMyQxLnJlZ2lzdGVyTGF6eVJlc3VsdChMYXp5UmVzdWx0JDIkMSk7XG5Eb2N1bWVudCQyJDEucmVnaXN0ZXJMYXp5UmVzdWx0KExhenlSZXN1bHQkMiQxKTtcbnZhciBNYXBHZW5lcmF0b3IyJDEgPSBtYXBHZW5lcmF0b3IkMTtcbnZhciBzdHJpbmdpZnkkMSQxID0gc3RyaW5naWZ5XzEkMTtcbnZhciB3YXJuT25jZTIkMSA9IHdhcm5PbmNlJDIkMTtcbnZhciBwYXJzZSQxJDEgPSBwYXJzZV8xJDE7XG52YXIgUmVzdWx0JDEkMSA9IHJlc3VsdCQxO1xudmFyIE5vV29ya1Jlc3VsdCQxJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE5vV29ya1Jlc3VsdChwcm9jZXNzb3IyLCBjc3MsIG9wdHMpIHtcbiAgICAgICAgY3NzID0gY3NzLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuc3RyaW5naWZpZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc29yID0gcHJvY2Vzc29yMjtcbiAgICAgICAgdGhpcy5fY3NzID0gY3NzO1xuICAgICAgICB0aGlzLl9vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5fbWFwID0gdm9pZCAwO1xuICAgICAgICB2YXIgcm9vdDI7XG4gICAgICAgIHZhciBzdHIgPSBzdHJpbmdpZnkkMSQxO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IG5ldyBSZXN1bHQkMSQxKHRoaXMuX3Byb2Nlc3Nvciwgcm9vdDIsIHRoaXMuX29wdHMpO1xuICAgICAgICB0aGlzLnJlc3VsdC5jc3MgPSBjc3M7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMucmVzdWx0LCBcInJvb3RcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucm9vdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtYXAgPSBuZXcgTWFwR2VuZXJhdG9yMiQxKHN0ciwgcm9vdDIsIHRoaXMuX29wdHMsIGNzcyk7XG4gICAgICAgIGlmIChtYXAuaXNNYXAoKSkge1xuICAgICAgICAgICAgdmFyIF9tYXBfZ2VuZXJhdGUgPSBtYXAuZ2VuZXJhdGUoKSwgZ2VuZXJhdGVkQ1NTID0gX21hcF9nZW5lcmF0ZVswXSwgZ2VuZXJhdGVkTWFwID0gX21hcF9nZW5lcmF0ZVsxXTtcbiAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRDU1MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5jc3MgPSBnZW5lcmF0ZWRDU1M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGVkTWFwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQubWFwID0gZ2VuZXJhdGVkTWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWFwLmNsZWFyQW5ub3RhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQuY3NzID0gbWFwLmNzcztcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gTm9Xb3JrUmVzdWx0LnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXN5bmMgPSBmdW5jdGlvbiBhc3luYygpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmVycm9yKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnJlc3VsdCk7XG4gICAgfTtcbiAgICBfcHJvdG8uY2F0Y2ggPSBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3RlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3luYygpLmNhdGNoKG9uUmVqZWN0ZWQpO1xuICAgIH07XG4gICAgX3Byb3RvLmZpbmFsbHkgPSBmdW5jdGlvbiBfZmluYWxseShvbkZpbmFsbHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRmluYWxseSwgb25GaW5hbGx5KTtcbiAgICB9O1xuICAgIF9wcm90by5zeW5jID0gZnVuY3Rpb24gc3luYygpIHtcbiAgICAgICAgaWYgKHRoaXMuZXJyb3IpIHRocm93IHRoaXMuZXJyb3I7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICB9O1xuICAgIF9wcm90by50aGVuID0gZnVuY3Rpb24gdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBpZiAoIShcImZyb21cIiBpbiB0aGlzLl9vcHRzKSkge1xuICAgICAgICAgICAgICAgIHdhcm5PbmNlMiQxKFwiV2l0aG91dCBgZnJvbWAgb3B0aW9uIFBvc3RDU1MgY291bGQgZ2VuZXJhdGUgd3Jvbmcgc291cmNlIG1hcCBhbmQgd2lsbCBub3QgZmluZCBCcm93c2Vyc2xpc3QgY29uZmlnLiBTZXQgaXQgdG8gQ1NTIGZpbGUgcGF0aCBvciB0byBgdW5kZWZpbmVkYCB0byBwcmV2ZW50IHRoaXMgd2FybmluZy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9O1xuICAgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3NzO1xuICAgIH07XG4gICAgX3Byb3RvLndhcm5pbmdzID0gZnVuY3Rpb24gd2FybmluZ3MoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIF9jcmVhdGVfY2xhc3MoTm9Xb3JrUmVzdWx0LCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQuY3NzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY3NzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQuY3NzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibWFwXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQubWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwibWVzc2FnZXNcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm9wdHNcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5vcHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicHJvY2Vzc29yXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQucHJvY2Vzc29yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicm9vdFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Jvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByb290MjtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VyMiA9IHBhcnNlJDEkMTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByb290MiA9IHBhcnNlcjIodGhpcy5fY3NzLCB0aGlzLl9vcHRzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZXJyb3I7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHJvb3QyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFN5bWJvbC50b1N0cmluZ1RhZyxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIk5vV29ya1Jlc3VsdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIE5vV29ya1Jlc3VsdDtcbn0oKTtcbnZhciBub1dvcmtSZXN1bHQkMSA9IE5vV29ya1Jlc3VsdCQxJDE7XG5Ob1dvcmtSZXN1bHQkMSQxLmRlZmF1bHQgPSBOb1dvcmtSZXN1bHQkMSQxO1xudmFyIE5vV29ya1Jlc3VsdDIkMSA9IG5vV29ya1Jlc3VsdCQxO1xudmFyIExhenlSZXN1bHQkMSQxID0gbGF6eVJlc3VsdCQxO1xudmFyIERvY3VtZW50JDEkMSA9IGRvY3VtZW50JDEkMTtcbnZhciBSb290JDIkMSA9IHJvb3QkMTtcbnZhciBQcm9jZXNzb3IkMSQxID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBQcm9jZXNzb3IocGx1Z2lucykge1xuICAgICAgICBpZiAocGx1Z2lucyA9PT0gdm9pZCAwKSBwbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IFwiOC40LjM4XCI7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHRoaXMubm9ybWFsaXplKHBsdWdpbnMpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gUHJvY2Vzc29yLnByb3RvdHlwZTtcbiAgICBfcHJvdG8ubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKHBsdWdpbnMpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBbXTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UocGx1Z2lucyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBpMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGkyLnBvc3Rjc3MgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpMiA9IGkyKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkyLnBvc3Rjc3MpIHtcbiAgICAgICAgICAgICAgICBpMiA9IGkyLnBvc3Rjc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHR5cGVvZiBpMiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihpMikpID09PSBcIm9iamVjdFwiICYmIEFycmF5LmlzQXJyYXkoaTIucGx1Z2lucykpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkID0gbm9ybWFsaXplZC5jb25jYXQoaTIucGx1Z2lucyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgaTIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YoaTIpKSA9PT0gXCJvYmplY3RcIiAmJiBpMi5wb3N0Y3NzUGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKGkyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGkyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkLnB1c2goaTIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIGkyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGkyKSkgPT09IFwib2JqZWN0XCIgJiYgKGkyLnBhcnNlIHx8IGkyLnN0cmluZ2lmeSkpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc3RDU1Mgc3ludGF4ZXMgY2Fubm90IGJlIHVzZWQgYXMgcGx1Z2lucy4gSW5zdGVhZCwgcGxlYXNlIHVzZSBvbmUgb2YgdGhlIHN5bnRheC9wYXJzZXIvc3RyaW5naWZpZXIgb3B0aW9ucyBhcyBvdXRsaW5lZCBpbiB5b3VyIFBvc3RDU1MgcnVubmVyIGRvY3VtZW50YXRpb24uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGkyICsgXCIgaXMgbm90IGEgUG9zdENTUyBwbHVnaW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJvY2VzcyA9IGZ1bmN0aW9uIHByb2Nlc3MxKGNzcywgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIGlmICghdGhpcy5wbHVnaW5zLmxlbmd0aCAmJiAhb3B0cy5wYXJzZXIgJiYgIW9wdHMuc3RyaW5naWZpZXIgJiYgIW9wdHMuc3ludGF4KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vV29ya1Jlc3VsdDIkMSh0aGlzLCBjc3MsIG9wdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMYXp5UmVzdWx0JDEkMSh0aGlzLCBjc3MsIG9wdHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udXNlID0gZnVuY3Rpb24gdXNlKHBsdWdpbjIyKSB7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHRoaXMucGx1Z2lucy5jb25jYXQodGhpcy5ub3JtYWxpemUoW1xuICAgICAgICAgICAgcGx1Z2luMjJcbiAgICAgICAgXSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBQcm9jZXNzb3I7XG59KCk7XG52YXIgcHJvY2Vzc29yJDEgPSBQcm9jZXNzb3IkMSQxO1xuUHJvY2Vzc29yJDEkMS5kZWZhdWx0ID0gUHJvY2Vzc29yJDEkMTtcblJvb3QkMiQxLnJlZ2lzdGVyUHJvY2Vzc29yKFByb2Nlc3NvciQxJDEpO1xuRG9jdW1lbnQkMSQxLnJlZ2lzdGVyUHJvY2Vzc29yKFByb2Nlc3NvciQxJDEpO1xudmFyIERlY2xhcmF0aW9uJDEkMSA9IGRlY2xhcmF0aW9uJDE7XG52YXIgUHJldmlvdXNNYXAyJDEgPSBwcmV2aW91c01hcCQxO1xudmFyIENvbW1lbnQkMSQxID0gY29tbWVudCQxO1xudmFyIEF0UnVsZSQxJDEgPSBhdFJ1bGUkMTtcbnZhciBJbnB1dCQxJDEgPSBpbnB1dCQxO1xudmFyIFJvb3QkMSQxID0gcm9vdCQxO1xudmFyIFJ1bGUkMSQxID0gcnVsZSQxO1xuZnVuY3Rpb24gZnJvbUpTT04kMSQxKGpzb24sIGlucHV0cykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGpzb24pKSByZXR1cm4ganNvbi5tYXAoZnVuY3Rpb24objIpIHtcbiAgICAgICAgcmV0dXJuIGZyb21KU09OJDEkMShuMik7XG4gICAgfSk7XG4gICAgdmFyIG93bklucHV0cyA9IGpzb24uaW5wdXRzLCBkZWZhdWx0cyA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKGpzb24sIFtcbiAgICAgICAgXCJpbnB1dHNcIlxuICAgIF0pO1xuICAgIGlmIChvd25JbnB1dHMpIHtcbiAgICAgICAgaW5wdXRzID0gW107XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG93bklucHV0cyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBpbnB1dDIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBpbnB1dEh5ZHJhdGVkID0gX2V4dGVuZHMoe30sIGlucHV0Miwge1xuICAgICAgICAgICAgICAgIF9fcHJvdG9fXzogSW5wdXQkMSQxLnByb3RvdHlwZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5wdXRIeWRyYXRlZC5tYXApIHtcbiAgICAgICAgICAgICAgICBpbnB1dEh5ZHJhdGVkLm1hcCA9IF9leHRlbmRzKHt9LCBpbnB1dEh5ZHJhdGVkLm1hcCwge1xuICAgICAgICAgICAgICAgICAgICBfX3Byb3RvX186IFByZXZpb3VzTWFwMiQxLnByb3RvdHlwZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRzLnB1c2goaW5wdXRIeWRyYXRlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRzLm5vZGVzKSB7XG4gICAgICAgIGRlZmF1bHRzLm5vZGVzID0ganNvbi5ub2Rlcy5tYXAoZnVuY3Rpb24objIpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tSlNPTiQxJDEobjIsIGlucHV0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdHMuc291cmNlKSB7XG4gICAgICAgIHZhciBfZGVmYXVsdHNfc291cmNlID0gZGVmYXVsdHMuc291cmNlLCBpbnB1dElkID0gX2RlZmF1bHRzX3NvdXJjZS5pbnB1dElkLCBzb3VyY2UgPSBfb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllc19sb29zZShfZGVmYXVsdHNfc291cmNlLCBbXG4gICAgICAgICAgICBcImlucHV0SWRcIlxuICAgICAgICBdKTtcbiAgICAgICAgZGVmYXVsdHMuc291cmNlID0gc291cmNlO1xuICAgICAgICBpZiAoaW5wdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBkZWZhdWx0cy5zb3VyY2UuaW5wdXQgPSBpbnB1dHNbaW5wdXRJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgUm9vdCQxJDEoZGVmYXVsdHMpO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNsYXJhdGlvbiQxJDEoZGVmYXVsdHMpO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJydWxlXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdWxlJDEkMShkZWZhdWx0cyk7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcImNvbW1lbnRcIikge1xuICAgICAgICByZXR1cm4gbmV3IENvbW1lbnQkMSQxKGRlZmF1bHRzKTtcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRzLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdFJ1bGUkMSQxKGRlZmF1bHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIgKyBqc29uLnR5cGUpO1xuICAgIH1cbn1cbnZhciBmcm9tSlNPTl8xJDEgPSBmcm9tSlNPTiQxJDE7XG5mcm9tSlNPTiQxJDEuZGVmYXVsdCA9IGZyb21KU09OJDEkMTtcbnZhciBDc3NTeW50YXhFcnJvcjIkMSA9IGNzc1N5bnRheEVycm9yJDE7XG52YXIgRGVjbGFyYXRpb24yJDEgPSBkZWNsYXJhdGlvbiQxO1xudmFyIExhenlSZXN1bHQyJDEgPSBsYXp5UmVzdWx0JDE7XG52YXIgQ29udGFpbmVyMiQxID0gY29udGFpbmVyJDE7XG52YXIgUHJvY2Vzc29yMiQxID0gcHJvY2Vzc29yJDE7XG52YXIgc3RyaW5naWZ5JDUgPSBzdHJpbmdpZnlfMSQxO1xudmFyIGZyb21KU09OJDIgPSBmcm9tSlNPTl8xJDE7XG52YXIgRG9jdW1lbnQyMiA9IGRvY3VtZW50JDEkMTtcbnZhciBXYXJuaW5nMiQxID0gd2FybmluZyQxO1xudmFyIENvbW1lbnQyJDEgPSBjb21tZW50JDE7XG52YXIgQXRSdWxlMiQxID0gYXRSdWxlJDE7XG52YXIgUmVzdWx0MiQxID0gcmVzdWx0JDE7XG52YXIgSW5wdXQyJDEgPSBpbnB1dCQxO1xudmFyIHBhcnNlJDUgPSBwYXJzZV8xJDE7XG52YXIgbGlzdCQzID0gbGlzdF8xJDE7XG52YXIgUnVsZTIkMSA9IHJ1bGUkMTtcbnZhciBSb290MiQxID0gcm9vdCQxO1xudmFyIE5vZGUyJDEgPSBub2RlJDE7XG5mdW5jdGlvbiBwb3N0Y3NzJDMoKSB7XG4gICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcGx1Z2lucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICBwbHVnaW5zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBpZiAocGx1Z2lucy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShwbHVnaW5zWzBdKSkge1xuICAgICAgICBwbHVnaW5zID0gcGx1Z2luc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQcm9jZXNzb3IyJDEocGx1Z2lucyk7XG59XG5wb3N0Y3NzJDMucGx1Z2luID0gZnVuY3Rpb24gcGx1Z2luKG5hbWUsIGluaXRpYWxpemVyKSB7XG4gICAgdmFyIHdhcm5pbmdQcmludGVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gY3JlYXRvcigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4gJiYgIXdhcm5pbmdQcmludGVkKSB7XG4gICAgICAgICAgICB3YXJuaW5nUHJpbnRlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obmFtZSArIFwiOiBwb3N0Y3NzLnBsdWdpbiB3YXMgZGVwcmVjYXRlZC4gTWlncmF0aW9uIGd1aWRlOlxcbmh0dHBzOi8vZXZpbG1hcnRpYW5zLmNvbS9jaHJvbmljbGVzL3Bvc3Rjc3MtOC1wbHVnaW4tbWlncmF0aW9uXCIpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52LkxBTkcgJiYgcHJvY2Vzcy5lbnYuTEFORy5zdGFydHNXaXRoKFwiY25cIikpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obmFtZSArIFwiOiDph4zpnaIgcG9zdGNzcy5wbHVnaW4g6KKr5byD55SoLiDov4Hnp7vmjIfljZc6XFxuaHR0cHM6Ly93d3cudzNjdGVjaC5jb20vdG9waWMvMjIyNlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSBpbml0aWFsaXplci5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIHRyYW5zZm9ybWVyLnBvc3Rjc3NQbHVnaW4gPSBuYW1lO1xuICAgICAgICB0cmFuc2Zvcm1lci5wb3N0Y3NzVmVyc2lvbiA9IG5ldyBQcm9jZXNzb3IyJDEoKS52ZXJzaW9uO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZXI7XG4gICAgfVxuICAgIHZhciBjYWNoZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRvciwgXCJwb3N0Y3NzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlKSBjYWNoZSA9IGNyZWF0b3IoKTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNyZWF0b3IucHJvY2VzcyA9IGZ1bmN0aW9uKGNzcywgcHJvY2Vzc09wdHMsIHBsdWdpbk9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHBvc3Rjc3MkMyhbXG4gICAgICAgICAgICBjcmVhdG9yKHBsdWdpbk9wdHMpXG4gICAgICAgIF0pLnByb2Nlc3MoY3NzLCBwcm9jZXNzT3B0cyk7XG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRvcjtcbn07XG5wb3N0Y3NzJDMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5JDU7XG5wb3N0Y3NzJDMucGFyc2UgPSBwYXJzZSQ1O1xucG9zdGNzcyQzLmZyb21KU09OID0gZnJvbUpTT04kMjtcbnBvc3Rjc3MkMy5saXN0ID0gbGlzdCQzO1xucG9zdGNzcyQzLmNvbW1lbnQgPSBmdW5jdGlvbihkZWZhdWx0cykge1xuICAgIHJldHVybiBuZXcgQ29tbWVudDIkMShkZWZhdWx0cyk7XG59O1xucG9zdGNzcyQzLmF0UnVsZSA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBBdFJ1bGUyJDEoZGVmYXVsdHMpO1xufTtcbnBvc3Rjc3MkMy5kZWNsID0gZnVuY3Rpb24oZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uMiQxKGRlZmF1bHRzKTtcbn07XG5wb3N0Y3NzJDMucnVsZSA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBSdWxlMiQxKGRlZmF1bHRzKTtcbn07XG5wb3N0Y3NzJDMucm9vdCA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBSb290MiQxKGRlZmF1bHRzKTtcbn07XG5wb3N0Y3NzJDMuZG9jdW1lbnQgPSBmdW5jdGlvbihkZWZhdWx0cykge1xuICAgIHJldHVybiBuZXcgRG9jdW1lbnQyMihkZWZhdWx0cyk7XG59O1xucG9zdGNzcyQzLkNzc1N5bnRheEVycm9yID0gQ3NzU3ludGF4RXJyb3IyJDE7XG5wb3N0Y3NzJDMuRGVjbGFyYXRpb24gPSBEZWNsYXJhdGlvbjIkMTtcbnBvc3Rjc3MkMy5Db250YWluZXIgPSBDb250YWluZXIyJDE7XG5wb3N0Y3NzJDMuUHJvY2Vzc29yID0gUHJvY2Vzc29yMiQxO1xucG9zdGNzcyQzLkRvY3VtZW50ID0gRG9jdW1lbnQyMjtcbnBvc3Rjc3MkMy5Db21tZW50ID0gQ29tbWVudDIkMTtcbnBvc3Rjc3MkMy5XYXJuaW5nID0gV2FybmluZzIkMTtcbnBvc3Rjc3MkMy5BdFJ1bGUgPSBBdFJ1bGUyJDE7XG5wb3N0Y3NzJDMuUmVzdWx0ID0gUmVzdWx0MiQxO1xucG9zdGNzcyQzLklucHV0ID0gSW5wdXQyJDE7XG5wb3N0Y3NzJDMuUnVsZSA9IFJ1bGUyJDE7XG5wb3N0Y3NzJDMuUm9vdCA9IFJvb3QyJDE7XG5wb3N0Y3NzJDMuTm9kZSA9IE5vZGUyJDE7XG5MYXp5UmVzdWx0MiQxLnJlZ2lzdGVyUG9zdGNzcyhwb3N0Y3NzJDMpO1xudmFyIHBvc3Rjc3NfMSQxID0gcG9zdGNzcyQzO1xucG9zdGNzcyQzLmRlZmF1bHQgPSBwb3N0Y3NzJDM7XG52YXIgcG9zdGNzcyQxJDEgPSAvKiBAX19QVVJFX18gKi8gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMkMShwb3N0Y3NzXzEkMSk7XG5wb3N0Y3NzJDEkMS5zdHJpbmdpZnk7XG5wb3N0Y3NzJDEkMS5mcm9tSlNPTjtcbnBvc3Rjc3MkMSQxLnBsdWdpbjtcbnBvc3Rjc3MkMSQxLnBhcnNlO1xucG9zdGNzcyQxJDEubGlzdDtcbnBvc3Rjc3MkMSQxLmRvY3VtZW50O1xucG9zdGNzcyQxJDEuY29tbWVudDtcbnBvc3Rjc3MkMSQxLmF0UnVsZTtcbnBvc3Rjc3MkMSQxLnJ1bGU7XG5wb3N0Y3NzJDEkMS5kZWNsO1xucG9zdGNzcyQxJDEucm9vdDtcbnBvc3Rjc3MkMSQxLkNzc1N5bnRheEVycm9yO1xucG9zdGNzcyQxJDEuRGVjbGFyYXRpb247XG5wb3N0Y3NzJDEkMS5Db250YWluZXI7XG5wb3N0Y3NzJDEkMS5Qcm9jZXNzb3I7XG5wb3N0Y3NzJDEkMS5Eb2N1bWVudDtcbnBvc3Rjc3MkMSQxLkNvbW1lbnQ7XG5wb3N0Y3NzJDEkMS5XYXJuaW5nO1xucG9zdGNzcyQxJDEuQXRSdWxlO1xucG9zdGNzcyQxJDEuUmVzdWx0O1xucG9zdGNzcyQxJDEuSW5wdXQ7XG5wb3N0Y3NzJDEkMS5SdWxlO1xucG9zdGNzcyQxJDEuUm9vdDtcbnBvc3Rjc3MkMSQxLk5vZGU7XG52YXIgX19kZWZQcm9wMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AyID0gZnVuY3Rpb24ob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGtleSBpbiBvYmogPyBfX2RlZlByb3AyKG9iaiwga2V5LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbn07XG52YXIgX19wdWJsaWNGaWVsZDIgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gX19kZWZOb3JtYWxQcm9wMihvYmosICh0eXBlb2Yga2V5ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGtleSkpICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xufTtcbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHgyKSB7XG4gICAgcmV0dXJuIHgyICYmIHgyLl9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgyLCBcImRlZmF1bHRcIikgPyB4MltcImRlZmF1bHRcIl0gOiB4Mjtcbn1cbmZ1bmN0aW9uIGdldEF1Z21lbnRlZE5hbWVzcGFjZShuMikge1xuICAgIGlmIChuMi5fX2VzTW9kdWxlKSByZXR1cm4gbjI7XG4gICAgdmFyIGYyID0gbjIuZGVmYXVsdDtcbiAgICBpZiAodHlwZW9mIGYyID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB2YXIgYTIgPSBmdW5jdGlvbiBhMjIoKSB7XG4gICAgICAgICAgICBpZiAoX2luc3RhbmNlb2YodGhpcywgYTIyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdChmMiwgYXJndW1lbnRzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICBhMi5wcm90b3R5cGUgPSBmMi5wcm90b3R5cGU7XG4gICAgfSBlbHNlIGEyID0ge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEyLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5rZXlzKG4yKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4yLCBrKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGEyLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG4yW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYTI7XG59XG52YXIgcGljb2NvbG9yc19icm93c2VyID0ge1xuICAgIGV4cG9ydHM6IHt9XG59O1xudmFyIHggPSBTdHJpbmc7XG52YXIgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzQ29sb3JTdXBwb3J0ZWQ6IGZhbHNlLFxuICAgICAgICByZXNldDogeCxcbiAgICAgICAgYm9sZDogeCxcbiAgICAgICAgZGltOiB4LFxuICAgICAgICBpdGFsaWM6IHgsXG4gICAgICAgIHVuZGVybGluZTogeCxcbiAgICAgICAgaW52ZXJzZTogeCxcbiAgICAgICAgaGlkZGVuOiB4LFxuICAgICAgICBzdHJpa2V0aHJvdWdoOiB4LFxuICAgICAgICBibGFjazogeCxcbiAgICAgICAgcmVkOiB4LFxuICAgICAgICBncmVlbjogeCxcbiAgICAgICAgeWVsbG93OiB4LFxuICAgICAgICBibHVlOiB4LFxuICAgICAgICBtYWdlbnRhOiB4LFxuICAgICAgICBjeWFuOiB4LFxuICAgICAgICB3aGl0ZTogeCxcbiAgICAgICAgZ3JheTogeCxcbiAgICAgICAgYmdCbGFjazogeCxcbiAgICAgICAgYmdSZWQ6IHgsXG4gICAgICAgIGJnR3JlZW46IHgsXG4gICAgICAgIGJnWWVsbG93OiB4LFxuICAgICAgICBiZ0JsdWU6IHgsXG4gICAgICAgIGJnTWFnZW50YTogeCxcbiAgICAgICAgYmdDeWFuOiB4LFxuICAgICAgICBiZ1doaXRlOiB4XG4gICAgfTtcbn07XG5waWNvY29sb3JzX2Jyb3dzZXIuZXhwb3J0cyA9IGNyZWF0ZSgpO1xucGljb2NvbG9yc19icm93c2VyLmV4cG9ydHMuY3JlYXRlQ29sb3JzID0gY3JlYXRlO1xudmFyIHBpY29jb2xvcnNfYnJvd3NlckV4cG9ydHMgPSBwaWNvY29sb3JzX2Jyb3dzZXIuZXhwb3J0cztcbnZhciBfX3ZpdGVCcm93c2VyRXh0ZXJuYWwgPSB7fTtcbnZhciBfX3ZpdGVCcm93c2VyRXh0ZXJuYWwkMSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBkZWZhdWx0OiBfX3ZpdGVCcm93c2VyRXh0ZXJuYWxcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywge1xuICAgIHZhbHVlOiBcIk1vZHVsZVwiXG59KSk7XG52YXIgcmVxdWlyZSQkMiA9IC8qIEBfX1BVUkVfXyAqLyBnZXRBdWdtZW50ZWROYW1lc3BhY2UoX192aXRlQnJvd3NlckV4dGVybmFsJDEpO1xudmFyIHBpY28gPSBwaWNvY29sb3JzX2Jyb3dzZXJFeHBvcnRzO1xudmFyIHRlcm1pbmFsSGlnaGxpZ2h0JDEgPSByZXF1aXJlJCQyO1xudmFyIENzc1N5bnRheEVycm9yJDMgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKEVycm9yMSkge1xuICAgIF9pbmhlcml0cyhDc3NTeW50YXhFcnJvcjIsIEVycm9yMSk7XG4gICAgZnVuY3Rpb24gQ3NzU3ludGF4RXJyb3IyKG1lc3NhZ2UsIGxpbmUsIGNvbHVtbiwgc291cmNlLCBmaWxlLCBwbHVnaW4yMikge1xuICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgIF90aGlzID0gRXJyb3IxLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IFwiQ3NzU3ludGF4RXJyb3JcIjtcbiAgICAgICAgX3RoaXMucmVhc29uID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgIF90aGlzLmZpbGUgPSBmaWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIF90aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGx1Z2luMjIpIHtcbiAgICAgICAgICAgIF90aGlzLnBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGluZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY29sdW1uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxpbmUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5saW5lID0gbGluZTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmxpbmUgPSBsaW5lLmxpbmU7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29sdW1uID0gbGluZS5jb2x1bW47XG4gICAgICAgICAgICAgICAgX3RoaXMuZW5kTGluZSA9IGNvbHVtbi5saW5lO1xuICAgICAgICAgICAgICAgIF90aGlzLmVuZENvbHVtbiA9IGNvbHVtbi5jb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuc2V0TWVzc2FnZSgpO1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBDc3NTeW50YXhFcnJvcjIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IENzc1N5bnRheEVycm9yMi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnNldE1lc3NhZ2UgPSBmdW5jdGlvbiBzZXRNZXNzYWdlKCkge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnBsdWdpbiA/IHRoaXMucGx1Z2luICsgXCI6IFwiIDogXCJcIjtcbiAgICAgICAgdGhpcy5tZXNzYWdlICs9IHRoaXMuZmlsZSA/IHRoaXMuZmlsZSA6IFwiPGNzcyBpbnB1dD5cIjtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmxpbmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSArPSBcIjpcIiArIHRoaXMubGluZSArIFwiOlwiICsgdGhpcy5jb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tZXNzYWdlICs9IFwiOiBcIiArIHRoaXMucmVhc29uO1xuICAgIH07XG4gICAgX3Byb3RvLnNob3dTb3VyY2VDb2RlID0gZnVuY3Rpb24gc2hvd1NvdXJjZUNvZGUoY29sb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZSkgcmV0dXJuIFwiXCI7XG4gICAgICAgIHZhciBjc3MgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgaWYgKGNvbG9yID09IG51bGwpIGNvbG9yID0gcGljby5pc0NvbG9yU3VwcG9ydGVkO1xuICAgICAgICBpZiAodGVybWluYWxIaWdobGlnaHQkMSkge1xuICAgICAgICAgICAgaWYgKGNvbG9yKSBjc3MgPSB0ZXJtaW5hbEhpZ2hsaWdodCQxKGNzcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxpbmVzID0gY3NzLnNwbGl0KC9cXHI/XFxuLyk7XG4gICAgICAgIHZhciBzdGFydCA9IE1hdGgubWF4KHRoaXMubGluZSAtIDMsIDApO1xuICAgICAgICB2YXIgZW5kID0gTWF0aC5taW4odGhpcy5saW5lICsgMiwgbGluZXMubGVuZ3RoKTtcbiAgICAgICAgdmFyIG1heFdpZHRoID0gU3RyaW5nKGVuZCkubGVuZ3RoO1xuICAgICAgICB2YXIgbWFyaywgYXNpZGU7XG4gICAgICAgIGlmIChjb2xvcikge1xuICAgICAgICAgICAgdmFyIF9waWNvX2NyZWF0ZUNvbG9ycyA9IHBpY28uY3JlYXRlQ29sb3JzKHRydWUpLCBib2xkID0gX3BpY29fY3JlYXRlQ29sb3JzLmJvbGQsIGdyYXkgPSBfcGljb19jcmVhdGVDb2xvcnMuZ3JheSwgcmVkID0gX3BpY29fY3JlYXRlQ29sb3JzLnJlZDtcbiAgICAgICAgICAgIG1hcmsgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvbGQocmVkKHRleHQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhc2lkZSA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JheSh0ZXh0KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXJrID0gYXNpZGUgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXMuc2xpY2Uoc3RhcnQsIGVuZCkubWFwKGZ1bmN0aW9uKGxpbmUsIGluZGV4Mikge1xuICAgICAgICAgICAgdmFyIG51bWJlciA9IHN0YXJ0ICsgMSArIGluZGV4MjtcbiAgICAgICAgICAgIHZhciBndXR0ZXIgPSBcIiBcIiArIChcIiBcIiArIG51bWJlcikuc2xpY2UoLW1heFdpZHRoKSArIFwiIHwgXCI7XG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSBfdGhpcy5saW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwYWNpbmcgPSBhc2lkZShndXR0ZXIucmVwbGFjZSgvXFxkL2csIFwiIFwiKSkgKyBsaW5lLnNsaWNlKDAsIF90aGlzLmNvbHVtbiAtIDEpLnJlcGxhY2UoL1teXFx0XS9nLCBcIiBcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcmsoXCI+XCIpICsgYXNpZGUoZ3V0dGVyKSArIGxpbmUgKyBcIlxcbiBcIiArIHNwYWNpbmcgKyBtYXJrKFwiXlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIiBcIiArIGFzaWRlKGd1dHRlcikgKyBsaW5lO1xuICAgICAgICB9KS5qb2luKFwiXFxuXCIpO1xuICAgIH07XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHZhciBjb2RlID0gdGhpcy5zaG93U291cmNlQ29kZSgpO1xuICAgICAgICBpZiAoY29kZSkge1xuICAgICAgICAgICAgY29kZSA9IFwiXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uYW1lICsgXCI6IFwiICsgdGhpcy5tZXNzYWdlICsgY29kZTtcbiAgICB9O1xuICAgIHJldHVybiBDc3NTeW50YXhFcnJvcjI7XG59KF93cmFwX25hdGl2ZV9zdXBlcihFcnJvcikpO1xudmFyIGNzc1N5bnRheEVycm9yID0gQ3NzU3ludGF4RXJyb3IkMztcbkNzc1N5bnRheEVycm9yJDMuZGVmYXVsdCA9IENzc1N5bnRheEVycm9yJDM7XG52YXIgc3ltYm9scyA9IHt9O1xuc3ltYm9scy5pc0NsZWFuID0gU3ltYm9sKFwiaXNDbGVhblwiKTtcbnN5bWJvbHMubXkgPSBTeW1ib2woXCJteVwiKTtcbnZhciBERUZBVUxUX1JBVyA9IHtcbiAgICBhZnRlcjogXCJcXG5cIixcbiAgICBiZWZvcmVDbG9zZTogXCJcXG5cIixcbiAgICBiZWZvcmVDb21tZW50OiBcIlxcblwiLFxuICAgIGJlZm9yZURlY2w6IFwiXFxuXCIsXG4gICAgYmVmb3JlT3BlbjogXCIgXCIsXG4gICAgYmVmb3JlUnVsZTogXCJcXG5cIixcbiAgICBjb2xvbjogXCI6IFwiLFxuICAgIGNvbW1lbnRMZWZ0OiBcIiBcIixcbiAgICBjb21tZW50UmlnaHQ6IFwiIFwiLFxuICAgIGVtcHR5Qm9keTogXCJcIixcbiAgICBpbmRlbnQ6IFwiICAgIFwiLFxuICAgIHNlbWljb2xvbjogZmFsc2Vcbn07XG5mdW5jdGlvbiBjYXBpdGFsaXplKHN0cikge1xuICAgIHJldHVybiBzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cbnZhciBTdHJpbmdpZmllciQyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBTdHJpbmdpZmllcjIoYnVpbGRlcikge1xuICAgICAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gU3RyaW5naWZpZXIyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYXRydWxlID0gZnVuY3Rpb24gYXRydWxlKG5vZGUyLCBzZW1pY29sb24pIHtcbiAgICAgICAgdmFyIG5hbWUgPSBcIkBcIiArIG5vZGUyLm5hbWU7XG4gICAgICAgIHZhciBwYXJhbXMgPSBub2RlMi5wYXJhbXMgPyB0aGlzLnJhd1ZhbHVlKG5vZGUyLCBcInBhcmFtc1wiKSA6IFwiXCI7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZTIucmF3cy5hZnRlck5hbWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG5hbWUgKz0gbm9kZTIucmF3cy5hZnRlck5hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgICBuYW1lICs9IFwiIFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlMi5ub2Rlcykge1xuICAgICAgICAgICAgdGhpcy5ibG9jayhub2RlMiwgbmFtZSArIHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZW5kID0gKG5vZGUyLnJhd3MuYmV0d2VlbiB8fCBcIlwiKSArIChzZW1pY29sb24gPyBcIjtcIiA6IFwiXCIpO1xuICAgICAgICAgICAgdGhpcy5idWlsZGVyKG5hbWUgKyBwYXJhbXMgKyBlbmQsIG5vZGUyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmJlZm9yZUFmdGVyID0gZnVuY3Rpb24gYmVmb3JlQWZ0ZXIobm9kZTIsIGRldGVjdCkge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIGlmIChub2RlMi50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnJhdyhub2RlMiwgbnVsbCwgXCJiZWZvcmVEZWNsXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZUNvbW1lbnRcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZGV0ZWN0ID09PSBcImJlZm9yZVwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZVJ1bGVcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZUNsb3NlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWYgPSBub2RlMi5wYXJlbnQ7XG4gICAgICAgIHZhciBkZXB0aCA9IDA7XG4gICAgICAgIHdoaWxlKGJ1ZiAmJiBidWYudHlwZSAhPT0gXCJyb290XCIpe1xuICAgICAgICAgICAgZGVwdGggKz0gMTtcbiAgICAgICAgICAgIGJ1ZiA9IGJ1Zi5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICB2YXIgaW5kZW50ID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiaW5kZW50XCIpO1xuICAgICAgICAgICAgaWYgKGluZGVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIHN0ZXAgPSAwOyBzdGVwIDwgZGVwdGg7IHN0ZXArKyl2YWx1ZSArPSBpbmRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLmJsb2NrID0gZnVuY3Rpb24gYmxvY2sobm9kZTIsIHN0YXJ0KSB7XG4gICAgICAgIHZhciBiZXR3ZWVuID0gdGhpcy5yYXcobm9kZTIsIFwiYmV0d2VlblwiLCBcImJlZm9yZU9wZW5cIik7XG4gICAgICAgIHRoaXMuYnVpbGRlcihzdGFydCArIGJldHdlZW4gKyBcIntcIiwgbm9kZTIsIFwic3RhcnRcIik7XG4gICAgICAgIHZhciBhZnRlcjtcbiAgICAgICAgaWYgKG5vZGUyLm5vZGVzICYmIG5vZGUyLm5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5ib2R5KG5vZGUyKTtcbiAgICAgICAgICAgIGFmdGVyID0gdGhpcy5yYXcobm9kZTIsIFwiYWZ0ZXJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZnRlciA9IHRoaXMucmF3KG5vZGUyLCBcImFmdGVyXCIsIFwiZW1wdHlCb2R5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZnRlcikgdGhpcy5idWlsZGVyKGFmdGVyKTtcbiAgICAgICAgdGhpcy5idWlsZGVyKFwifVwiLCBub2RlMiwgXCJlbmRcIik7XG4gICAgfTtcbiAgICBfcHJvdG8uYm9keSA9IGZ1bmN0aW9uIGJvZHkobm9kZTIpIHtcbiAgICAgICAgdmFyIGxhc3QgPSBub2RlMi5ub2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZShsYXN0ID4gMCl7XG4gICAgICAgICAgICBpZiAobm9kZTIubm9kZXNbbGFzdF0udHlwZSAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgICAgICAgbGFzdCAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZW1pY29sb24gPSB0aGlzLnJhdyhub2RlMiwgXCJzZW1pY29sb25cIik7XG4gICAgICAgIGZvcih2YXIgaTIgPSAwOyBpMiA8IG5vZGUyLm5vZGVzLmxlbmd0aDsgaTIrKyl7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlMi5ub2Rlc1tpMl07XG4gICAgICAgICAgICB2YXIgYmVmb3JlID0gdGhpcy5yYXcoY2hpbGQsIFwiYmVmb3JlXCIpO1xuICAgICAgICAgICAgaWYgKGJlZm9yZSkgdGhpcy5idWlsZGVyKGJlZm9yZSk7XG4gICAgICAgICAgICB0aGlzLnN0cmluZ2lmeShjaGlsZCwgbGFzdCAhPT0gaTIgfHwgc2VtaWNvbG9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNvbW1lbnQgPSBmdW5jdGlvbiBjb21tZW50KG5vZGUyKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gdGhpcy5yYXcobm9kZTIsIFwibGVmdFwiLCBcImNvbW1lbnRMZWZ0XCIpO1xuICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnJhdyhub2RlMiwgXCJyaWdodFwiLCBcImNvbW1lbnRSaWdodFwiKTtcbiAgICAgICAgdGhpcy5idWlsZGVyKFwiLypcIiArIGxlZnQgKyBub2RlMi50ZXh0ICsgcmlnaHQgKyBcIiovXCIsIG5vZGUyKTtcbiAgICB9O1xuICAgIF9wcm90by5kZWNsID0gZnVuY3Rpb24gZGVjbChub2RlMiwgc2VtaWNvbG9uKSB7XG4gICAgICAgIHZhciBiZXR3ZWVuID0gdGhpcy5yYXcobm9kZTIsIFwiYmV0d2VlblwiLCBcImNvbG9uXCIpO1xuICAgICAgICB2YXIgc3RyaW5nID0gbm9kZTIucHJvcCArIGJldHdlZW4gKyB0aGlzLnJhd1ZhbHVlKG5vZGUyLCBcInZhbHVlXCIpO1xuICAgICAgICBpZiAobm9kZTIuaW1wb3J0YW50KSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gbm9kZTIucmF3cy5pbXBvcnRhbnQgfHwgXCIgIWltcG9ydGFudFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZW1pY29sb24pIHN0cmluZyArPSBcIjtcIjtcbiAgICAgICAgdGhpcy5idWlsZGVyKHN0cmluZywgbm9kZTIpO1xuICAgIH07XG4gICAgX3Byb3RvLmRvY3VtZW50ID0gZnVuY3Rpb24gZG9jdW1lbnQxKG5vZGUyKSB7XG4gICAgICAgIHRoaXMuYm9keShub2RlMik7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3ID0gZnVuY3Rpb24gcmF3KG5vZGUyLCBvd24sIGRldGVjdCkge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIGlmICghZGV0ZWN0KSBkZXRlY3QgPSBvd247XG4gICAgICAgIGlmIChvd24pIHtcbiAgICAgICAgICAgIHZhbHVlID0gbm9kZTIucmF3c1tvd25dO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlMi5wYXJlbnQ7XG4gICAgICAgIGlmIChkZXRlY3QgPT09IFwiYmVmb3JlXCIpIHtcbiAgICAgICAgICAgIGlmICghcGFyZW50IHx8IHBhcmVudC50eXBlID09PSBcInJvb3RcIiAmJiBwYXJlbnQuZmlyc3QgPT09IG5vZGUyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudCkgcmV0dXJuIERFRkFVTFRfUkFXW2RldGVjdF07XG4gICAgICAgIHZhciByb290MiA9IG5vZGUyLnJvb3QoKTtcbiAgICAgICAgaWYgKCFyb290Mi5yYXdDYWNoZSkgcm9vdDIucmF3Q2FjaGUgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiByb290Mi5yYXdDYWNoZVtkZXRlY3RdICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDIucmF3Q2FjaGVbZGV0ZWN0XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGV0ZWN0ID09PSBcImJlZm9yZVwiIHx8IGRldGVjdCA9PT0gXCJhZnRlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVBZnRlcihub2RlMiwgZGV0ZWN0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBcInJhd1wiICsgY2FwaXRhbGl6ZShkZXRlY3QpO1xuICAgICAgICAgICAgaWYgKHRoaXNbbWV0aG9kXSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpc1ttZXRob2RdKHJvb3QyLCBub2RlMik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJvb3QyLndhbGsoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzW293bl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB2YWx1ZSA9IERFRkFVTFRfUkFXW2RldGVjdF07XG4gICAgICAgIHJvb3QyLnJhd0NhY2hlW2RldGVjdF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0JlZm9yZUNsb3NlID0gZnVuY3Rpb24gcmF3QmVmb3JlQ2xvc2Uocm9vdDIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAoaTIubm9kZXMgJiYgaTIubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5hZnRlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYWZ0ZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFsdWUpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3QmVmb3JlQ29tbWVudCA9IGZ1bmN0aW9uIHJhd0JlZm9yZUNvbW1lbnQocm9vdDIsIG5vZGUyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2Fsa0NvbW1lbnRzKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJlZm9yZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoXCJcXG5cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmF3KG5vZGUyLCBudWxsLCBcImJlZm9yZURlY2xcIik7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdCZWZvcmVEZWNsID0gZnVuY3Rpb24gcmF3QmVmb3JlRGVjbChyb290Miwgbm9kZTIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrRGVjbHMoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaTIucmF3cy5iZWZvcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmVmb3JlO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1teXFxuXSskLywgXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yYXcobm9kZTIsIG51bGwsIFwiYmVmb3JlUnVsZVwiKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0JlZm9yZU9wZW4gPSBmdW5jdGlvbiByYXdCZWZvcmVPcGVuKHJvb3QyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKGkyLnR5cGUgIT09IFwiZGVjbFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmJldHdlZW47XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgX3Byb3RvLnJhd0JlZm9yZVJ1bGUgPSBmdW5jdGlvbiByYXdCZWZvcmVSdWxlKHJvb3QyKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKGkyLm5vZGVzICYmIChpMi5wYXJlbnQgIT09IHJvb3QyIHx8IHJvb3QyLmZpcnN0ICE9PSBpMikpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaTIucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhcIlxcblwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcbl0rJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFsdWUpIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxTL2csIFwiXCIpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucmF3Q29sb24gPSBmdW5jdGlvbiByYXdDb2xvbihyb290Mikge1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIHJvb3QyLndhbGtEZWNscyhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJldHdlZW4gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3MuYmV0d2Vlbi5yZXBsYWNlKC9bXlxcczpdL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdFbXB0eUJvZHkgPSBmdW5jdGlvbiByYXdFbXB0eUJvZHkocm9vdDIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAoaTIubm9kZXMgJiYgaTIubm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpMi5yYXdzLmFmdGVyO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdJbmRlbnQgPSBmdW5jdGlvbiByYXdJbmRlbnQocm9vdDIpIHtcbiAgICAgICAgaWYgKHJvb3QyLnJhd3MuaW5kZW50KSByZXR1cm4gcm9vdDIucmF3cy5pbmRlbnQ7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgcm9vdDIud2FsayhmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgdmFyIHAgPSBpMi5wYXJlbnQ7XG4gICAgICAgICAgICBpZiAocCAmJiBwICE9PSByb290MiAmJiBwLnBhcmVudCAmJiBwLnBhcmVudCA9PT0gcm9vdDIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkyLnJhd3MuYmVmb3JlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IGkyLnJhd3MuYmVmb3JlLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcUy9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdTZW1pY29sb24gPSBmdW5jdGlvbiByYXdTZW1pY29sb24ocm9vdDIpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICByb290Mi53YWxrKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICBpZiAoaTIubm9kZXMgJiYgaTIubm9kZXMubGVuZ3RoICYmIGkyLmxhc3QudHlwZSA9PT0gXCJkZWNsXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkyLnJhd3Muc2VtaWNvbG9uO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5yYXdWYWx1ZSA9IGZ1bmN0aW9uIHJhd1ZhbHVlKG5vZGUyLCBwcm9wKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUyW3Byb3BdO1xuICAgICAgICB2YXIgcmF3ID0gbm9kZTIucmF3c1twcm9wXTtcbiAgICAgICAgaWYgKHJhdyAmJiByYXcudmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmF3LnJhdztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBfcHJvdG8ucm9vdCA9IGZ1bmN0aW9uIHJvb3Qobm9kZTIpIHtcbiAgICAgICAgdGhpcy5ib2R5KG5vZGUyKTtcbiAgICAgICAgaWYgKG5vZGUyLnJhd3MuYWZ0ZXIpIHRoaXMuYnVpbGRlcihub2RlMi5yYXdzLmFmdGVyKTtcbiAgICB9O1xuICAgIF9wcm90by5ydWxlID0gZnVuY3Rpb24gcnVsZShub2RlMikge1xuICAgICAgICB0aGlzLmJsb2NrKG5vZGUyLCB0aGlzLnJhd1ZhbHVlKG5vZGUyLCBcInNlbGVjdG9yXCIpKTtcbiAgICAgICAgaWYgKG5vZGUyLnJhd3Mub3duU2VtaWNvbG9uKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkZXIobm9kZTIucmF3cy5vd25TZW1pY29sb24sIG5vZGUyLCBcImVuZFwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShub2RlMiwgc2VtaWNvbG9uKSB7XG4gICAgICAgIGlmICghdGhpc1tub2RlMi50eXBlXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBBU1Qgbm9kZSB0eXBlIFwiICsgbm9kZTIudHlwZSArIFwiLiBNYXliZSB5b3UgbmVlZCB0byBjaGFuZ2UgUG9zdENTUyBzdHJpbmdpZmllci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tub2RlMi50eXBlXShub2RlMiwgc2VtaWNvbG9uKTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdpZmllcjI7XG59KCk7XG52YXIgc3RyaW5naWZpZXIgPSBTdHJpbmdpZmllciQyO1xuU3RyaW5naWZpZXIkMi5kZWZhdWx0ID0gU3RyaW5naWZpZXIkMjtcbnZhciBTdHJpbmdpZmllciQxID0gc3RyaW5naWZpZXI7XG5mdW5jdGlvbiBzdHJpbmdpZnkkNChub2RlMiwgYnVpbGRlcikge1xuICAgIHZhciBzdHIgPSBuZXcgU3RyaW5naWZpZXIkMShidWlsZGVyKTtcbiAgICBzdHIuc3RyaW5naWZ5KG5vZGUyKTtcbn1cbnZhciBzdHJpbmdpZnlfMSA9IHN0cmluZ2lmeSQ0O1xuc3RyaW5naWZ5JDQuZGVmYXVsdCA9IHN0cmluZ2lmeSQ0O1xudmFyIGlzQ2xlYW4kMiA9IHN5bWJvbHMuaXNDbGVhbiwgbXkkMiA9IHN5bWJvbHMubXk7XG52YXIgQ3NzU3ludGF4RXJyb3IkMiA9IGNzc1N5bnRheEVycm9yO1xudmFyIFN0cmluZ2lmaWVyMjIgPSBzdHJpbmdpZmllcjtcbnZhciBzdHJpbmdpZnkkMyA9IHN0cmluZ2lmeV8xO1xuZnVuY3Rpb24gY2xvbmVOb2RlKG9iaiwgcGFyZW50KSB7XG4gICAgdmFyIGNsb25lZCA9IG5ldyBvYmouY29uc3RydWN0b3IoKTtcbiAgICBmb3IodmFyIGkyIGluIG9iail7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaTIpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaTIgPT09IFwicHJveHlDYWNoZVwiKSBjb250aW51ZTtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqW2kyXTtcbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YodmFsdWUpO1xuICAgICAgICBpZiAoaTIgPT09IFwicGFyZW50XCIgJiYgdHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKHBhcmVudCkgY2xvbmVkW2kyXSA9IHBhcmVudDtcbiAgICAgICAgfSBlbHNlIGlmIChpMiA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgICAgICAgY2xvbmVkW2kyXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBjbG9uZWRbaTJdID0gdmFsdWUubWFwKGZ1bmN0aW9uKGopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmVOb2RlKGosIGNsb25lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB2YWx1ZSA9IGNsb25lTm9kZSh2YWx1ZSk7XG4gICAgICAgICAgICBjbG9uZWRbaTJdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZDtcbn1cbnZhciBOb2RlJDQgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIE5vZGUzKGRlZmF1bHRzKSB7XG4gICAgICAgIGlmIChkZWZhdWx0cyA9PT0gdm9pZCAwKSBkZWZhdWx0cyA9IHt9O1xuICAgICAgICB0aGlzLnJhd3MgPSB7fTtcbiAgICAgICAgdGhpc1tpc0NsZWFuJDJdID0gZmFsc2U7XG4gICAgICAgIHRoaXNbbXkkMl0gPSB0cnVlO1xuICAgICAgICBmb3IodmFyIG5hbWUgaW4gZGVmYXVsdHMpe1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwibm9kZXNcIikge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShkZWZhdWx0c1tuYW1lXSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygbm9kZTIuY2xvbmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQobm9kZTIuY2xvbmUoKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZChub2RlMik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBkZWZhdWx0c1tuYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gTm9kZTMucHJvdG90eXBlO1xuICAgIF9wcm90by5hZGRUb0Vycm9yID0gZnVuY3Rpb24gYWRkVG9FcnJvcihlcnJvcikge1xuICAgICAgICBlcnJvci5wb3N0Y3NzTm9kZSA9IHRoaXM7XG4gICAgICAgIGlmIChlcnJvci5zdGFjayAmJiB0aGlzLnNvdXJjZSAmJiAvXFxuXFxzezR9YXQgLy50ZXN0KGVycm9yLnN0YWNrKSkge1xuICAgICAgICAgICAgdmFyIHMyID0gdGhpcy5zb3VyY2U7XG4gICAgICAgICAgICBlcnJvci5zdGFjayA9IGVycm9yLnN0YWNrLnJlcGxhY2UoL1xcblxcc3s0fWF0IC8sIFwiJCZcIiArIHMyLmlucHV0LmZyb20gKyBcIjpcIiArIHMyLnN0YXJ0LmxpbmUgKyBcIjpcIiArIHMyLnN0YXJ0LmNvbHVtbiArIFwiJCZcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH07XG4gICAgX3Byb3RvLmFmdGVyID0gZnVuY3Rpb24gYWZ0ZXIoYWRkKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVyKHRoaXMsIGFkZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLmFzc2lnbiA9IGZ1bmN0aW9uIGFzc2lnbihvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcyA9PT0gdm9pZCAwKSBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgZm9yKHZhciBuYW1lIGluIG92ZXJyaWRlcyl7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gb3ZlcnJpZGVzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLmJlZm9yZSA9IGZ1bmN0aW9uIGJlZm9yZShhZGQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIGFkZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLmNsZWFuUmF3cyA9IGZ1bmN0aW9uIGNsZWFuUmF3cyhrZWVwQmV0d2Vlbikge1xuICAgICAgICBkZWxldGUgdGhpcy5yYXdzLmJlZm9yZTtcbiAgICAgICAgZGVsZXRlIHRoaXMucmF3cy5hZnRlcjtcbiAgICAgICAgaWYgKCFrZWVwQmV0d2VlbikgZGVsZXRlIHRoaXMucmF3cy5iZXR3ZWVuO1xuICAgIH07XG4gICAgX3Byb3RvLmNsb25lID0gZnVuY3Rpb24gY2xvbmUob3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIHZhciBjbG9uZWQgPSBjbG9uZU5vZGUodGhpcyk7XG4gICAgICAgIGZvcih2YXIgbmFtZSBpbiBvdmVycmlkZXMpe1xuICAgICAgICAgICAgY2xvbmVkW25hbWVdID0gb3ZlcnJpZGVzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uY2xvbmVBZnRlciA9IGZ1bmN0aW9uIGNsb25lQWZ0ZXIob3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkgb3ZlcnJpZGVzID0ge307XG4gICAgICAgIHZhciBjbG9uZWQgPSB0aGlzLmNsb25lKG92ZXJyaWRlcyk7XG4gICAgICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVyKHRoaXMsIGNsb25lZCk7XG4gICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uY2xvbmVCZWZvcmUgPSBmdW5jdGlvbiBjbG9uZUJlZm9yZShvdmVycmlkZXMpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlcyA9PT0gdm9pZCAwKSBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgdmFyIGNsb25lZCA9IHRoaXMuY2xvbmUob3ZlcnJpZGVzKTtcbiAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIGNsb25lZCk7XG4gICAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtZXNzYWdlLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXNfcmFuZ2VCeSA9IHRoaXMucmFuZ2VCeShvcHRzKSwgZW5kID0gX3RoaXNfcmFuZ2VCeS5lbmQsIHN0YXJ0ID0gX3RoaXNfcmFuZ2VCeS5zdGFydDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5pbnB1dC5lcnJvcihtZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBzdGFydC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogc3RhcnQubGluZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogZW5kLmNvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBlbmQubGluZVxuICAgICAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBDc3NTeW50YXhFcnJvciQyKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFByb3h5UHJvY2Vzc29yID0gZnVuY3Rpb24gZ2V0UHJveHlQcm9jZXNzb3IoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldChub2RlMiwgcHJvcCkge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSBcInByb3h5T2ZcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcInJvb3RcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTIucm9vdCgpLnRvUHJveHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KG5vZGUyLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlMltwcm9wXSA9PT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIG5vZGUyW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IFwicHJvcFwiIHx8IHByb3AgPT09IFwidmFsdWVcIiB8fCBwcm9wID09PSBcIm5hbWVcIiB8fCBwcm9wID09PSBcInBhcmFtc1wiIHx8IHByb3AgPT09IFwiaW1wb3J0YW50XCIgfHwgLyogYzggaWdub3JlIG5leHQgKi8gcHJvcCA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIubWFya0RpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLm1hcmtEaXJ0eSA9IGZ1bmN0aW9uIG1hcmtEaXJ0eSgpIHtcbiAgICAgICAgaWYgKHRoaXNbaXNDbGVhbiQyXSkge1xuICAgICAgICAgICAgdGhpc1tpc0NsZWFuJDJdID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZShuZXh0ID0gbmV4dC5wYXJlbnQpe1xuICAgICAgICAgICAgICAgIG5leHRbaXNDbGVhbiQyXSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ubmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHJldHVybiB2b2lkIDA7XG4gICAgICAgIHZhciBpbmRleDIgPSB0aGlzLnBhcmVudC5pbmRleCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50Lm5vZGVzW2luZGV4MiArIDFdO1xuICAgIH07XG4gICAgX3Byb3RvLnBvc2l0aW9uQnkgPSBmdW5jdGlvbiBwb3NpdGlvbkJ5KG9wdHMsIHN0cmluZ1JlcHJlc2VudGF0aW9uKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnNvdXJjZS5zdGFydDtcbiAgICAgICAgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgICAgIHBvcyA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5pbmRleCwgc3RyaW5nUmVwcmVzZW50YXRpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKG9wdHMud29yZCkge1xuICAgICAgICAgICAgc3RyaW5nUmVwcmVzZW50YXRpb24gPSB0aGlzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB2YXIgaW5kZXgyID0gc3RyaW5nUmVwcmVzZW50YXRpb24uaW5kZXhPZihvcHRzLndvcmQpO1xuICAgICAgICAgICAgaWYgKGluZGV4MiAhPT0gLTEpIHBvcyA9IHRoaXMucG9zaXRpb25JbnNpZGUoaW5kZXgyLCBzdHJpbmdSZXByZXNlbnRhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9O1xuICAgIF9wcm90by5wb3NpdGlvbkluc2lkZSA9IGZ1bmN0aW9uIHBvc2l0aW9uSW5zaWRlKGluZGV4Miwgc3RyaW5nUmVwcmVzZW50YXRpb24pIHtcbiAgICAgICAgdmFyIHN0cmluZyA9IHN0cmluZ1JlcHJlc2VudGF0aW9uIHx8IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuc291cmNlLnN0YXJ0LmNvbHVtbjtcbiAgICAgICAgdmFyIGxpbmUgPSB0aGlzLnNvdXJjZS5zdGFydC5saW5lO1xuICAgICAgICBmb3IodmFyIGkyID0gMDsgaTIgPCBpbmRleDI7IGkyKyspe1xuICAgICAgICAgICAgaWYgKHN0cmluZ1tpMl0gPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSAxO1xuICAgICAgICAgICAgICAgIGxpbmUgKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sdW1uICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbHVtbjogY29sdW1uLFxuICAgICAgICAgICAgbGluZTogbGluZVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLnByZXYgPSBmdW5jdGlvbiBwcmV2KCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50KSByZXR1cm4gdm9pZCAwO1xuICAgICAgICB2YXIgaW5kZXgyID0gdGhpcy5wYXJlbnQuaW5kZXgodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5ub2Rlc1tpbmRleDIgLSAxXTtcbiAgICB9O1xuICAgIF9wcm90by5yYW5nZUJ5ID0gZnVuY3Rpb24gcmFuZ2VCeShvcHRzKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHtcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5zb3VyY2Uuc3RhcnQuY29sdW1uLFxuICAgICAgICAgICAgbGluZTogdGhpcy5zb3VyY2Uuc3RhcnQubGluZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5zb3VyY2UuZW5kID8ge1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLnNvdXJjZS5lbmQuY29sdW1uICsgMSxcbiAgICAgICAgICAgIGxpbmU6IHRoaXMuc291cmNlLmVuZC5saW5lXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgICBjb2x1bW46IHN0YXJ0LmNvbHVtbiArIDEsXG4gICAgICAgICAgICBsaW5lOiBzdGFydC5saW5lXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRzLndvcmQpIHtcbiAgICAgICAgICAgIHZhciBzdHJpbmdSZXByZXNlbnRhdGlvbiA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHZhciBpbmRleDIgPSBzdHJpbmdSZXByZXNlbnRhdGlvbi5pbmRleE9mKG9wdHMud29yZCk7XG4gICAgICAgICAgICBpZiAoaW5kZXgyICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5wb3NpdGlvbkluc2lkZShpbmRleDIsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKGluZGV4MiArIG9wdHMud29yZC5sZW5ndGgsIHN0cmluZ1JlcHJlc2VudGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvcHRzLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogb3B0cy5zdGFydC5jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IG9wdHMuc3RhcnQubGluZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHRoaXMucG9zaXRpb25JbnNpZGUob3B0cy5pbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5lbmQpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogb3B0cy5lbmQuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiBvcHRzLmVuZC5saW5lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuZW5kSW5kZXggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSB0aGlzLnBvc2l0aW9uSW5zaWRlKG9wdHMuZW5kSW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRzLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5wb3NpdGlvbkluc2lkZShvcHRzLmluZGV4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZC5saW5lIDwgc3RhcnQubGluZSB8fCBlbmQubGluZSA9PT0gc3RhcnQubGluZSAmJiBlbmQuY29sdW1uIDw9IHN0YXJ0LmNvbHVtbikge1xuICAgICAgICAgICAgZW5kID0ge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogc3RhcnQuY29sdW1uICsgMSxcbiAgICAgICAgICAgICAgICBsaW5lOiBzdGFydC5saW5lXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydFxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLnJhdyA9IGZ1bmN0aW9uIHJhdyhwcm9wLCBkZWZhdWx0VHlwZSkge1xuICAgICAgICB2YXIgc3RyID0gbmV3IFN0cmluZ2lmaWVyMjIoKTtcbiAgICAgICAgcmV0dXJuIHN0ci5yYXcodGhpcywgcHJvcCwgZGVmYXVsdFR5cGUpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudCA9IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVwbGFjZVdpdGggPSBmdW5jdGlvbiByZXBsYWNlV2l0aCgpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbm9kZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIG5vZGVzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdmFyIGJvb2ttYXJrID0gdGhpcztcbiAgICAgICAgICAgIHZhciBmb3VuZFNlbGYgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlMiA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZFNlbGYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZm91bmRTZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50Lmluc2VydEFmdGVyKGJvb2ttYXJrLCBub2RlMik7XG4gICAgICAgICAgICAgICAgICAgIGJvb2ttYXJrID0gbm9kZTI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuaW5zZXJ0QmVmb3JlKGJvb2ttYXJrLCBub2RlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZFNlbGYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnJvb3QgPSBmdW5jdGlvbiByb290KCkge1xuICAgICAgICB2YXIgcmVzdWx0MiA9IHRoaXM7XG4gICAgICAgIHdoaWxlKHJlc3VsdDIucGFyZW50ICYmIHJlc3VsdDIucGFyZW50LnR5cGUgIT09IFwiZG9jdW1lbnRcIil7XG4gICAgICAgICAgICByZXN1bHQyID0gcmVzdWx0Mi5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfTtcbiAgICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKF8sIGlucHV0cykge1xuICAgICAgICB2YXIgZml4ZWQgPSB7fTtcbiAgICAgICAgdmFyIGVtaXRJbnB1dHMgPSBpbnB1dHMgPT0gbnVsbDtcbiAgICAgICAgaW5wdXRzID0gaW5wdXRzIHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHZhciBpbnB1dHNOZXh0SW5kZXggPSAwO1xuICAgICAgICBmb3IodmFyIG5hbWUgaW4gdGhpcyl7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCBuYW1lKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hbWUgPT09IFwicGFyZW50XCIgfHwgbmFtZSA9PT0gXCJwcm94eUNhY2hlXCIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZpeGVkW25hbWVdID0gdmFsdWUubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGkyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGkyKSkgPT09IFwib2JqZWN0XCIgJiYgaTIudG9KU09OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTIudG9KU09OKG51bGwsIGlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZih2YWx1ZSkpID09PSBcIm9iamVjdFwiICYmIHZhbHVlLnRvSlNPTikge1xuICAgICAgICAgICAgICAgIGZpeGVkW25hbWVdID0gdmFsdWUudG9KU09OKG51bGwsIGlucHV0cyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwic291cmNlXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRJZCA9IGlucHV0cy5nZXQodmFsdWUuaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dElkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRJZCA9IGlucHV0c05leHRJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzLnNldCh2YWx1ZS5pbnB1dCwgaW5wdXRzTmV4dEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRzTmV4dEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpeGVkW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICBlbmQ6IHZhbHVlLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRJZDogaW5wdXRJZCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHZhbHVlLnN0YXJ0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZml4ZWRbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW1pdElucHV0cykge1xuICAgICAgICAgICAgZml4ZWQuaW5wdXRzID0gW10uY29uY2F0KGlucHV0cy5rZXlzKCkpLm1hcChmdW5jdGlvbihpbnB1dDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXQyLnRvSlNPTigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpeGVkO1xuICAgIH07XG4gICAgX3Byb3RvLnRvUHJveHkgPSBmdW5jdGlvbiB0b1Byb3h5KCkge1xuICAgICAgICBpZiAoIXRoaXMucHJveHlDYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5wcm94eUNhY2hlID0gbmV3IFByb3h5KHRoaXMsIHRoaXMuZ2V0UHJveHlQcm9jZXNzb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJveHlDYWNoZTtcbiAgICB9O1xuICAgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmaWVyMikge1xuICAgICAgICBpZiAoc3RyaW5naWZpZXIyID09PSB2b2lkIDApIHN0cmluZ2lmaWVyMiA9IHN0cmluZ2lmeSQzO1xuICAgICAgICBpZiAoc3RyaW5naWZpZXIyLnN0cmluZ2lmeSkgc3RyaW5naWZpZXIyID0gc3RyaW5naWZpZXIyLnN0cmluZ2lmeTtcbiAgICAgICAgdmFyIHJlc3VsdDIgPSBcIlwiO1xuICAgICAgICBzdHJpbmdpZmllcjIodGhpcywgZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgKz0gaTI7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9O1xuICAgIF9wcm90by53YXJuID0gZnVuY3Rpb24gd2FybihyZXN1bHQyLCB0ZXh0LCBvcHRzKSB7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgbm9kZTogdGhpc1xuICAgICAgICB9O1xuICAgICAgICBmb3IodmFyIGkyIGluIG9wdHMpZGF0YVtpMl0gPSBvcHRzW2kyXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDIud2Fybih0ZXh0LCBkYXRhKTtcbiAgICB9O1xuICAgIF9jcmVhdGVfY2xhc3MoTm9kZTMsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInByb3h5T2ZcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIE5vZGUzO1xufSgpO1xudmFyIG5vZGUgPSBOb2RlJDQ7XG5Ob2RlJDQuZGVmYXVsdCA9IE5vZGUkNDtcbnZhciBOb2RlJDMgPSBub2RlO1xudmFyIERlY2xhcmF0aW9uJDQgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vZGUkMykge1xuICAgIF9pbmhlcml0cyhEZWNsYXJhdGlvbjIsIE5vZGUkMyk7XG4gICAgZnVuY3Rpb24gRGVjbGFyYXRpb24yKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgaWYgKGRlZmF1bHRzICYmIHR5cGVvZiBkZWZhdWx0cy52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgZGVmYXVsdHMudmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRlZmF1bHRzID0gX2V4dGVuZHMoe30sIGRlZmF1bHRzLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFN0cmluZyhkZWZhdWx0cy52YWx1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzID0gTm9kZSQzLmNhbGwodGhpcywgZGVmYXVsdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBcImRlY2xcIjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBfY3JlYXRlX2NsYXNzKERlY2xhcmF0aW9uMiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwidmFyaWFibGVcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3Auc3RhcnRzV2l0aChcIi0tXCIpIHx8IHRoaXMucHJvcFswXSA9PT0gXCIkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBdKTtcbiAgICByZXR1cm4gRGVjbGFyYXRpb24yO1xufShOb2RlJDMpO1xudmFyIGRlY2xhcmF0aW9uID0gRGVjbGFyYXRpb24kNDtcbkRlY2xhcmF0aW9uJDQuZGVmYXVsdCA9IERlY2xhcmF0aW9uJDQ7XG52YXIgdXJsQWxwaGFiZXQgPSBcInVzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3RcIjtcbnZhciBuYW5vaWQkMSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICBpZiAoc2l6ZSA9PT0gdm9pZCAwKSBzaXplID0gMjE7XG4gICAgdmFyIGlkID0gXCJcIjtcbiAgICB2YXIgaTIgPSBzaXplO1xuICAgIHdoaWxlKGkyLS0pe1xuICAgICAgICBpZCArPSB1cmxBbHBoYWJldFtNYXRoLnJhbmRvbSgpICogNjQgfCAwXTtcbiAgICB9XG4gICAgcmV0dXJuIGlkO1xufTtcbnZhciBub25TZWN1cmUgPSB7XG4gICAgbmFub2lkOiBuYW5vaWQkMX07XG52YXIgU291cmNlTWFwQ29uc3VtZXIkMiA9IHJlcXVpcmUkJDIuU291cmNlTWFwQ29uc3VtZXIsIFNvdXJjZU1hcEdlbmVyYXRvciQyID0gcmVxdWlyZSQkMi5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgZXhpc3RzU3luYyA9IHJlcXVpcmUkJDIuZXhpc3RzU3luYywgcmVhZEZpbGVTeW5jID0gcmVxdWlyZSQkMi5yZWFkRmlsZVN5bmM7XG52YXIgZGlybmFtZSQxID0gcmVxdWlyZSQkMi5kaXJuYW1lLCBqb2luID0gcmVxdWlyZSQkMi5qb2luO1xuZnVuY3Rpb24gZnJvbUJhc2U2NChzdHIpIHtcbiAgICBpZiAoQnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5hdG9iKHN0cik7XG4gICAgfVxufVxudmFyIFByZXZpb3VzTWFwJDIgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFByZXZpb3VzTWFwMihjc3MsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMubWFwID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICB0aGlzLmxvYWRBbm5vdGF0aW9uKGNzcyk7XG4gICAgICAgIHRoaXMuaW5saW5lID0gdGhpcy5zdGFydFdpdGgodGhpcy5hbm5vdGF0aW9uLCBcImRhdGE6XCIpO1xuICAgICAgICB2YXIgcHJldiA9IG9wdHMubWFwID8gb3B0cy5tYXAucHJldiA6IHZvaWQgMDtcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmxvYWRNYXAob3B0cy5mcm9tLCBwcmV2KTtcbiAgICAgICAgaWYgKCF0aGlzLm1hcEZpbGUgJiYgb3B0cy5mcm9tKSB7XG4gICAgICAgICAgICB0aGlzLm1hcEZpbGUgPSBvcHRzLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWFwRmlsZSkgdGhpcy5yb290ID0gZGlybmFtZSQxKHRoaXMubWFwRmlsZSk7XG4gICAgICAgIGlmICh0ZXh0KSB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gUHJldmlvdXNNYXAyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uY29uc3VtZXIgPSBmdW5jdGlvbiBjb25zdW1lcigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnN1bWVyQ2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZXJDYWNoZSA9IG5ldyBTb3VyY2VNYXBDb25zdW1lciQyKHRoaXMudGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZXJDYWNoZTtcbiAgICB9O1xuICAgIF9wcm90by5kZWNvZGVJbmxpbmUgPSBmdW5jdGlvbiBkZWNvZGVJbmxpbmUodGV4dCkge1xuICAgICAgICB2YXIgYmFzZUNoYXJzZXRVcmkgPSAvXmRhdGE6YXBwbGljYXRpb25cXC9qc29uO2NoYXJzZXQ9dXRmLT84O2Jhc2U2NCwvO1xuICAgICAgICB2YXIgYmFzZVVyaSA9IC9eZGF0YTphcHBsaWNhdGlvblxcL2pzb247YmFzZTY0LC87XG4gICAgICAgIHZhciBjaGFyc2V0VXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbjtjaGFyc2V0PXV0Zi0/OCwvO1xuICAgICAgICB2YXIgdXJpID0gL15kYXRhOmFwcGxpY2F0aW9uXFwvanNvbiwvO1xuICAgICAgICBpZiAoY2hhcnNldFVyaS50ZXN0KHRleHQpIHx8IHVyaS50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHRleHQuc3Vic3RyKFJlZ0V4cC5sYXN0TWF0Y2gubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VDaGFyc2V0VXJpLnRlc3QodGV4dCkgfHwgYmFzZVVyaS50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbUJhc2U2NCh0ZXh0LnN1YnN0cihSZWdFeHAubGFzdE1hdGNoLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlbmNvZGluZyA9IHRleHQubWF0Y2goL2RhdGE6YXBwbGljYXRpb25cXC9qc29uOyhbXixdKyksLylbMV07XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHNvdXJjZSBtYXAgZW5jb2RpbmcgXCIgKyBlbmNvZGluZyk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0QW5ub3RhdGlvblVSTCA9IGZ1bmN0aW9uIGdldEFubm90YXRpb25VUkwoc291cmNlTWFwU3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2VNYXBTdHJpbmcucmVwbGFjZSgvXlxcL1xcKlxccyojIHNvdXJjZU1hcHBpbmdVUkw9LywgXCJcIikudHJpbSgpO1xuICAgIH07XG4gICAgX3Byb3RvLmlzTWFwID0gZnVuY3Rpb24gaXNNYXAobWFwKSB7XG4gICAgICAgIGlmICgodHlwZW9mIG1hcCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihtYXApKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG1hcC5tYXBwaW5ncyA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWFwLl9tYXBwaW5ncyA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KG1hcC5zZWN0aW9ucyk7XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZEFubm90YXRpb24gPSBmdW5jdGlvbiBsb2FkQW5ub3RhdGlvbihjc3MpIHtcbiAgICAgICAgdmFyIGNvbW1lbnRzID0gY3NzLm1hdGNoKC9cXC9cXCpcXHMqIyBzb3VyY2VNYXBwaW5nVVJMPS9nbSk7XG4gICAgICAgIGlmICghY29tbWVudHMpIHJldHVybjtcbiAgICAgICAgdmFyIHN0YXJ0ID0gY3NzLmxhc3RJbmRleE9mKGNvbW1lbnRzLnBvcCgpKTtcbiAgICAgICAgdmFyIGVuZCA9IGNzcy5pbmRleE9mKFwiKi9cIiwgc3RhcnQpO1xuICAgICAgICBpZiAoc3RhcnQgPiAtMSAmJiBlbmQgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5hbm5vdGF0aW9uID0gdGhpcy5nZXRBbm5vdGF0aW9uVVJMKGNzcy5zdWJzdHJpbmcoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ubG9hZEZpbGUgPSBmdW5jdGlvbiBsb2FkRmlsZShwYXRoKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IGRpcm5hbWUkMShwYXRoKTtcbiAgICAgICAgaWYgKGV4aXN0c1N5bmMocGF0aCkpIHtcbiAgICAgICAgICAgIHRoaXMubWFwRmlsZSA9IHBhdGg7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpbGVTeW5jKHBhdGgsIFwidXRmLThcIikudG9TdHJpbmcoKS50cmltKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5sb2FkTWFwID0gZnVuY3Rpb24gbG9hZE1hcChmaWxlLCBwcmV2KSB7XG4gICAgICAgIGlmIChwcmV2ID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmV2ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcmV2ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJldlBhdGggPSBwcmV2KGZpbGUpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2UGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5sb2FkRmlsZShwcmV2UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gbG9hZCBwcmV2aW91cyBzb3VyY2UgbWFwOiBcIiArIHByZXZQYXRoLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwcmV2LCBTb3VyY2VNYXBDb25zdW1lciQyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTb3VyY2VNYXBHZW5lcmF0b3IkMi5mcm9tU291cmNlTWFwKHByZXYpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHByZXYsIFNvdXJjZU1hcEdlbmVyYXRvciQyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNNYXAocHJldikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocHJldik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIHByZXZpb3VzIHNvdXJjZSBtYXAgZm9ybWF0OiBcIiArIHByZXYudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5pbmxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlY29kZUlubGluZSh0aGlzLmFubm90YXRpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuYW5ub3RhdGlvbikge1xuICAgICAgICAgICAgdmFyIG1hcDEgPSB0aGlzLmFubm90YXRpb247XG4gICAgICAgICAgICBpZiAoZmlsZSkgbWFwMSA9IGpvaW4oZGlybmFtZSQxKGZpbGUpLCBtYXAxKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRGaWxlKG1hcDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc3RhcnRXaXRoID0gZnVuY3Rpb24gc3RhcnRXaXRoKHN0cmluZywgc3RhcnQpIHtcbiAgICAgICAgaWYgKCFzdHJpbmcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5zdWJzdHIoMCwgc3RhcnQubGVuZ3RoKSA9PT0gc3RhcnQ7XG4gICAgfTtcbiAgICBfcHJvdG8ud2l0aENvbnRlbnQgPSBmdW5jdGlvbiB3aXRoQ29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuY29uc3VtZXIoKS5zb3VyY2VzQ29udGVudCAmJiB0aGlzLmNvbnN1bWVyKCkuc291cmNlc0NvbnRlbnQubGVuZ3RoID4gMCk7XG4gICAgfTtcbiAgICByZXR1cm4gUHJldmlvdXNNYXAyO1xufSgpO1xudmFyIHByZXZpb3VzTWFwID0gUHJldmlvdXNNYXAkMjtcblByZXZpb3VzTWFwJDIuZGVmYXVsdCA9IFByZXZpb3VzTWFwJDI7XG52YXIgU291cmNlTWFwQ29uc3VtZXIkMSA9IHJlcXVpcmUkJDIuU291cmNlTWFwQ29uc3VtZXIsIFNvdXJjZU1hcEdlbmVyYXRvciQxID0gcmVxdWlyZSQkMi5Tb3VyY2VNYXBHZW5lcmF0b3I7XG52YXIgZmlsZVVSTFRvUGF0aCA9IHJlcXVpcmUkJDIuZmlsZVVSTFRvUGF0aCwgcGF0aFRvRmlsZVVSTCQxID0gcmVxdWlyZSQkMi5wYXRoVG9GaWxlVVJMO1xudmFyIGlzQWJzb2x1dGUgPSByZXF1aXJlJCQyLmlzQWJzb2x1dGUsIHJlc29sdmUkMSA9IHJlcXVpcmUkJDIucmVzb2x2ZTtcbnZhciBuYW5vaWQgPSBub25TZWN1cmUubmFub2lkO1xudmFyIHRlcm1pbmFsSGlnaGxpZ2h0ID0gcmVxdWlyZSQkMjtcbnZhciBDc3NTeW50YXhFcnJvciQxID0gY3NzU3ludGF4RXJyb3I7XG52YXIgUHJldmlvdXNNYXAkMSA9IHByZXZpb3VzTWFwO1xudmFyIGZyb21PZmZzZXRDYWNoZSA9IFN5bWJvbChcImZyb21PZmZzZXRDYWNoZVwiKTtcbnZhciBzb3VyY2VNYXBBdmFpbGFibGUkMSA9IEJvb2xlYW4oU291cmNlTWFwQ29uc3VtZXIkMSAmJiBTb3VyY2VNYXBHZW5lcmF0b3IkMSk7XG52YXIgcGF0aEF2YWlsYWJsZSQxID0gQm9vbGVhbihyZXNvbHZlJDEgJiYgaXNBYnNvbHV0ZSk7XG52YXIgSW5wdXQkNCA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gSW5wdXQyKGNzcywgb3B0cykge1xuICAgICAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSBvcHRzID0ge307XG4gICAgICAgIGlmIChjc3MgPT09IG51bGwgfHwgdHlwZW9mIGNzcyA9PT0gXCJ1bmRlZmluZWRcIiB8fCAodHlwZW9mIGNzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihjc3MpKSA9PT0gXCJvYmplY3RcIiAmJiAhY3NzLnRvU3RyaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3N0Q1NTIHJlY2VpdmVkIFwiICsgY3NzICsgXCIgaW5zdGVhZCBvZiBDU1Mgc3RyaW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3NzID0gY3NzLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0aGlzLmNzc1swXSA9PT0gXCJcXHVGRUZGXCIgfHwgdGhpcy5jc3NbMF0gPT09IFwi77++XCIpIHtcbiAgICAgICAgICAgIHRoaXMuaGFzQk9NID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY3NzID0gdGhpcy5jc3Muc2xpY2UoMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhc0JPTSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmZyb20pIHtcbiAgICAgICAgICAgIGlmICghcGF0aEF2YWlsYWJsZSQxIHx8IC9eXFx3KzpcXC9cXC8vLnRlc3Qob3B0cy5mcm9tKSB8fCBpc0Fic29sdXRlKG9wdHMuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGUgPSBvcHRzLmZyb207XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZSA9IHJlc29sdmUkMShvcHRzLmZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoQXZhaWxhYmxlJDEgJiYgc291cmNlTWFwQXZhaWxhYmxlJDEpIHtcbiAgICAgICAgICAgIHZhciBtYXAgPSBuZXcgUHJldmlvdXNNYXAkMSh0aGlzLmNzcywgb3B0cyk7XG4gICAgICAgICAgICBpZiAobWFwLnRleHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IG1hcC5jb25zdW1lcigpLmZpbGU7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZpbGUgJiYgZmlsZSkgdGhpcy5maWxlID0gdGhpcy5tYXBSZXNvbHZlKGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5maWxlKSB7XG4gICAgICAgICAgICB0aGlzLmlkID0gXCI8aW5wdXQgY3NzIFwiICsgbmFub2lkKDYpICsgXCI+XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWFwKSB0aGlzLm1hcC5maWxlID0gdGhpcy5mcm9tO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gSW5wdXQyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uZXJyb3IgPSBmdW5jdGlvbiBlcnJvcihtZXNzYWdlLCBsaW5lLCBjb2x1bW4sIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICB2YXIgcmVzdWx0MiwgZW5kTGluZSwgZW5kQ29sdW1uO1xuICAgICAgICBpZiAobGluZSAmJiAodHlwZW9mIGxpbmUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YobGluZSkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBsaW5lO1xuICAgICAgICAgICAgdmFyIGVuZCA9IGNvbHVtbjtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RhcnQub2Zmc2V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZnJvbU9mZnNldChzdGFydC5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIGxpbmUgPSBwb3MubGluZTtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBwb3MuY29sO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gc3RhcnQubGluZTtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBzdGFydC5jb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZC5vZmZzZXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcG9zMSA9IHRoaXMuZnJvbU9mZnNldChlbmQub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBlbmRMaW5lID0gcG9zMS5saW5lO1xuICAgICAgICAgICAgICAgIGVuZENvbHVtbiA9IHBvczEuY29sO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmRMaW5lID0gZW5kLmxpbmU7XG4gICAgICAgICAgICAgICAgZW5kQ29sdW1uID0gZW5kLmNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghY29sdW1uKSB7XG4gICAgICAgICAgICB2YXIgcG9zMiA9IHRoaXMuZnJvbU9mZnNldChsaW5lKTtcbiAgICAgICAgICAgIGxpbmUgPSBwb3MyLmxpbmU7XG4gICAgICAgICAgICBjb2x1bW4gPSBwb3MyLmNvbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5vcmlnaW4obGluZSwgY29sdW1uLCBlbmRMaW5lLCBlbmRDb2x1bW4pO1xuICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gbmV3IENzc1N5bnRheEVycm9yJDEobWVzc2FnZSwgb3JpZ2luLmVuZExpbmUgPT09IHZvaWQgMCA/IG9yaWdpbi5saW5lIDoge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogb3JpZ2luLmNvbHVtbixcbiAgICAgICAgICAgICAgICBsaW5lOiBvcmlnaW4ubGluZVxuICAgICAgICAgICAgfSwgb3JpZ2luLmVuZExpbmUgPT09IHZvaWQgMCA/IG9yaWdpbi5jb2x1bW4gOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBvcmlnaW4uZW5kQ29sdW1uLFxuICAgICAgICAgICAgICAgIGxpbmU6IG9yaWdpbi5lbmRMaW5lXG4gICAgICAgICAgICB9LCBvcmlnaW4uc291cmNlLCBvcmlnaW4uZmlsZSwgb3B0cy5wbHVnaW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MiA9IG5ldyBDc3NTeW50YXhFcnJvciQxKG1lc3NhZ2UsIGVuZExpbmUgPT09IHZvaWQgMCA/IGxpbmUgOiB7XG4gICAgICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICAgICAgbGluZTogbGluZVxuICAgICAgICAgICAgfSwgZW5kTGluZSA9PT0gdm9pZCAwID8gY29sdW1uIDoge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogZW5kQ29sdW1uLFxuICAgICAgICAgICAgICAgIGxpbmU6IGVuZExpbmVcbiAgICAgICAgICAgIH0sIHRoaXMuY3NzLCB0aGlzLmZpbGUsIG9wdHMucGx1Z2luKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQyLmlucHV0ID0ge1xuICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICBlbmRDb2x1bW46IGVuZENvbHVtbixcbiAgICAgICAgICAgIGVuZExpbmU6IGVuZExpbmUsXG4gICAgICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLmNzc1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5maWxlKSB7XG4gICAgICAgICAgICBpZiAocGF0aFRvRmlsZVVSTCQxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Mi5pbnB1dC51cmwgPSBwYXRoVG9GaWxlVVJMJDEodGhpcy5maWxlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0Mi5pbnB1dC5maWxlID0gdGhpcy5maWxlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH07XG4gICAgX3Byb3RvLmZyb21PZmZzZXQgPSBmdW5jdGlvbiBmcm9tT2Zmc2V0KG9mZnNldCkge1xuICAgICAgICB2YXIgbGFzdExpbmUsIGxpbmVUb0luZGV4O1xuICAgICAgICBpZiAoIXRoaXNbZnJvbU9mZnNldENhY2hlXSkge1xuICAgICAgICAgICAgdmFyIGxpbmVzID0gdGhpcy5jc3Muc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICBsaW5lVG9JbmRleCA9IG5ldyBBcnJheShsaW5lcy5sZW5ndGgpO1xuICAgICAgICAgICAgdmFyIHByZXZJbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IodmFyIGkyID0gMCwgbDIgPSBsaW5lcy5sZW5ndGg7IGkyIDwgbDI7IGkyKyspe1xuICAgICAgICAgICAgICAgIGxpbmVUb0luZGV4W2kyXSA9IHByZXZJbmRleDtcbiAgICAgICAgICAgICAgICBwcmV2SW5kZXggKz0gbGluZXNbaTJdLmxlbmd0aCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW2Zyb21PZmZzZXRDYWNoZV0gPSBsaW5lVG9JbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVUb0luZGV4ID0gdGhpc1tmcm9tT2Zmc2V0Q2FjaGVdO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RMaW5lID0gbGluZVRvSW5kZXhbbGluZVRvSW5kZXgubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBtaW4gPSAwO1xuICAgICAgICBpZiAob2Zmc2V0ID49IGxhc3RMaW5lKSB7XG4gICAgICAgICAgICBtaW4gPSBsaW5lVG9JbmRleC5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1heCA9IGxpbmVUb0luZGV4Lmxlbmd0aCAtIDI7XG4gICAgICAgICAgICB2YXIgbWlkO1xuICAgICAgICAgICAgd2hpbGUobWluIDwgbWF4KXtcbiAgICAgICAgICAgICAgICBtaWQgPSBtaW4gKyAobWF4IC0gbWluID4+IDEpO1xuICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPCBsaW5lVG9JbmRleFttaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heCA9IG1pZCAtIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPj0gbGluZVRvSW5kZXhbbWlkICsgMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gbWlkICsgMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBtaWQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sOiBvZmZzZXQgLSBsaW5lVG9JbmRleFttaW5dICsgMSxcbiAgICAgICAgICAgIGxpbmU6IG1pbiArIDFcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5tYXBSZXNvbHZlID0gZnVuY3Rpb24gbWFwUmVzb2x2ZShmaWxlKSB7XG4gICAgICAgIGlmICgvXlxcdys6XFwvXFwvLy50ZXN0KGZpbGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZSQxKHRoaXMubWFwLmNvbnN1bWVyKCkuc291cmNlUm9vdCB8fCB0aGlzLm1hcC5yb290IHx8IFwiLlwiLCBmaWxlKTtcbiAgICB9O1xuICAgIF9wcm90by5vcmlnaW4gPSBmdW5jdGlvbiBvcmlnaW4obGluZSwgY29sdW1uLCBlbmRMaW5lLCBlbmRDb2x1bW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hcCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgY29uc3VtZXIgPSB0aGlzLm1hcC5jb25zdW1lcigpO1xuICAgICAgICB2YXIgZnJvbSA9IGNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgICAgY29sdW1uOiBjb2x1bW4sXG4gICAgICAgICAgICBsaW5lOiBsaW5lXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWZyb20uc291cmNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciB0bztcbiAgICAgICAgaWYgKHR5cGVvZiBlbmRMaW5lID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICB0byA9IGNvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgICAgICAgIGNvbHVtbjogZW5kQ29sdW1uLFxuICAgICAgICAgICAgICAgIGxpbmU6IGVuZExpbmVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmcm9tVXJsO1xuICAgICAgICBpZiAoaXNBYnNvbHV0ZShmcm9tLnNvdXJjZSkpIHtcbiAgICAgICAgICAgIGZyb21VcmwgPSBwYXRoVG9GaWxlVVJMJDEoZnJvbS5zb3VyY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnJvbVVybCA9IG5ldyBVUkwoZnJvbS5zb3VyY2UsIHRoaXMubWFwLmNvbnN1bWVyKCkuc291cmNlUm9vdCB8fCBwYXRoVG9GaWxlVVJMJDEodGhpcy5tYXAubWFwRmlsZSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQyID0ge1xuICAgICAgICAgICAgY29sdW1uOiBmcm9tLmNvbHVtbixcbiAgICAgICAgICAgIGVuZENvbHVtbjogdG8gJiYgdG8uY29sdW1uLFxuICAgICAgICAgICAgZW5kTGluZTogdG8gJiYgdG8ubGluZSxcbiAgICAgICAgICAgIGxpbmU6IGZyb20ubGluZSxcbiAgICAgICAgICAgIHVybDogZnJvbVVybC50b1N0cmluZygpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChmcm9tVXJsLnByb3RvY29sID09PSBcImZpbGU6XCIpIHtcbiAgICAgICAgICAgIGlmIChmaWxlVVJMVG9QYXRoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0Mi5maWxlID0gZmlsZVVSTFRvUGF0aChmcm9tVXJsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmlsZTogcHJvdG9jb2wgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIFBvc3RDU1MgYnVpbGRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNvdXJjZSA9IGNvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3IoZnJvbS5zb3VyY2UpO1xuICAgICAgICBpZiAoc291cmNlKSByZXN1bHQyLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfTtcbiAgICBfcHJvdG8udG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgICB2YXIganNvbiA9IHt9O1xuICAgICAgICBmb3IodmFyIF9pID0gMCwgX2l0ZXIgPSBbXG4gICAgICAgICAgICBcImhhc0JPTVwiLFxuICAgICAgICAgICAgXCJjc3NcIixcbiAgICAgICAgICAgIFwiZmlsZVwiLFxuICAgICAgICAgICAgXCJpZFwiXG4gICAgICAgIF07IF9pIDwgX2l0ZXIubGVuZ3RoOyBfaSsrKXtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX2l0ZXJbX2ldO1xuICAgICAgICAgICAgaWYgKHRoaXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGpzb25bbmFtZV0gPSB0aGlzW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hcCkge1xuICAgICAgICAgICAganNvbi5tYXAgPSBfZXh0ZW5kcyh7fSwgdGhpcy5tYXApO1xuICAgICAgICAgICAgaWYgKGpzb24ubWFwLmNvbnN1bWVyQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICBqc29uLm1hcC5jb25zdW1lckNhY2hlID0gdm9pZCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhJbnB1dDIsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImZyb21cIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGUgfHwgdGhpcy5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBJbnB1dDI7XG59KCk7XG52YXIgaW5wdXQgPSBJbnB1dCQ0O1xuSW5wdXQkNC5kZWZhdWx0ID0gSW5wdXQkNDtcbmlmICh0ZXJtaW5hbEhpZ2hsaWdodCAmJiB0ZXJtaW5hbEhpZ2hsaWdodC5yZWdpc3RlcklucHV0KSB7XG4gICAgdGVybWluYWxIaWdobGlnaHQucmVnaXN0ZXJJbnB1dChJbnB1dCQ0KTtcbn1cbnZhciBTb3VyY2VNYXBDb25zdW1lciA9IHJlcXVpcmUkJDIuU291cmNlTWFwQ29uc3VtZXIsIFNvdXJjZU1hcEdlbmVyYXRvciA9IHJlcXVpcmUkJDIuU291cmNlTWFwR2VuZXJhdG9yO1xudmFyIGRpcm5hbWUgPSByZXF1aXJlJCQyLmRpcm5hbWUsIHJlbGF0aXZlID0gcmVxdWlyZSQkMi5yZWxhdGl2ZSwgcmVzb2x2ZSQzID0gcmVxdWlyZSQkMi5yZXNvbHZlLCBzZXAgPSByZXF1aXJlJCQyLnNlcDtcbnZhciBwYXRoVG9GaWxlVVJMID0gcmVxdWlyZSQkMi5wYXRoVG9GaWxlVVJMO1xudmFyIElucHV0JDMgPSBpbnB1dDtcbnZhciBzb3VyY2VNYXBBdmFpbGFibGUgPSBCb29sZWFuKFNvdXJjZU1hcENvbnN1bWVyICYmIFNvdXJjZU1hcEdlbmVyYXRvcik7XG52YXIgcGF0aEF2YWlsYWJsZSA9IEJvb2xlYW4oZGlybmFtZSAmJiByZXNvbHZlJDMgJiYgcmVsYXRpdmUgJiYgc2VwKTtcbnZhciBNYXBHZW5lcmF0b3IkMiA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTWFwR2VuZXJhdG9yMihzdHJpbmdpZnkyLCByb290Miwgb3B0cywgY3NzU3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc3RyaW5naWZ5ID0gc3RyaW5naWZ5MjtcbiAgICAgICAgdGhpcy5tYXBPcHRzID0gb3B0cy5tYXAgfHwge307XG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3QyO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLmNzcyA9IGNzc1N0cmluZztcbiAgICAgICAgdGhpcy5vcmlnaW5hbENTUyA9IGNzc1N0cmluZztcbiAgICAgICAgdGhpcy51c2VzRmlsZVVybHMgPSAhdGhpcy5tYXBPcHRzLmZyb20gJiYgdGhpcy5tYXBPcHRzLmFic29sdXRlO1xuICAgICAgICB0aGlzLm1lbW9pemVkRmlsZVVSTHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm1lbW9pemVkUGF0aHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm1lbW9pemVkVVJMcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBNYXBHZW5lcmF0b3IyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uYWRkQW5ub3RhdGlvbiA9IGZ1bmN0aW9uIGFkZEFubm90YXRpb24oKSB7XG4gICAgICAgIHZhciBjb250ZW50O1xuICAgICAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XG4gICAgICAgICAgICBjb250ZW50ID0gXCJkYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgdGhpcy50b0Jhc2U2NCh0aGlzLm1hcC50b1N0cmluZygpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5tYXBPcHRzLmFubm90YXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29udGVudCA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uKHRoaXMub3B0cy50bywgdGhpcy5yb290KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLm91dHB1dEZpbGUoKSArIFwiLm1hcFwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlb2wgPSBcIlxcblwiO1xuICAgICAgICBpZiAodGhpcy5jc3MuaW5jbHVkZXMoXCJcXHJcXG5cIikpIGVvbCA9IFwiXFxyXFxuXCI7XG4gICAgICAgIHRoaXMuY3NzICs9IGVvbCArIFwiLyojIHNvdXJjZU1hcHBpbmdVUkw9XCIgKyBjb250ZW50ICsgXCIgKi9cIjtcbiAgICB9O1xuICAgIF9wcm90by5hcHBseVByZXZNYXBzID0gZnVuY3Rpb24gYXBwbHlQcmV2TWFwcygpIHtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UodGhpcy5wcmV2aW91cygpKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIHByZXYgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBmcm9tID0gdGhpcy50b1VybCh0aGlzLnBhdGgocHJldi5maWxlKSk7XG4gICAgICAgICAgICB2YXIgcm9vdDIgPSBwcmV2LnJvb3QgfHwgZGlybmFtZShwcmV2LmZpbGUpO1xuICAgICAgICAgICAgdmFyIG1hcCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmICh0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgbWFwID0gbmV3IFNvdXJjZU1hcENvbnN1bWVyKHByZXYudGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcC5zb3VyY2VzQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFwID0gcHJldi5jb25zdW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXAuYXBwbHlTb3VyY2VNYXAobWFwLCBmcm9tLCB0aGlzLnRvVXJsKHRoaXMucGF0aChyb290MikpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmNsZWFyQW5ub3RhdGlvbiA9IGZ1bmN0aW9uIGNsZWFyQW5ub3RhdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uID09PSBmYWxzZSkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5yb290KSB7XG4gICAgICAgICAgICB2YXIgbm9kZTI7XG4gICAgICAgICAgICBmb3IodmFyIGkyID0gdGhpcy5yb290Lm5vZGVzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pe1xuICAgICAgICAgICAgICAgIG5vZGUyID0gdGhpcy5yb290Lm5vZGVzW2kyXTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJjb21tZW50XCIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlMi50ZXh0LmluZGV4T2YoXCIjIHNvdXJjZU1hcHBpbmdVUkw9XCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdC5yZW1vdmVDaGlsZChpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3NzKSB7XG4gICAgICAgICAgICB0aGlzLmNzcyA9IHRoaXMuY3NzLnJlcGxhY2UoL1xcbio/XFwvXFwqI1tcXFNcXHNdKj9cXCpcXC8kL2dtLCBcIlwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLmdlbmVyYXRlID0gZnVuY3Rpb24gZ2VuZXJhdGUoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJBbm5vdGF0aW9uKCk7XG4gICAgICAgIGlmIChwYXRoQXZhaWxhYmxlICYmIHNvdXJjZU1hcEF2YWlsYWJsZSAmJiB0aGlzLmlzTWFwKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlTWFwKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MiA9IFwiXCI7XG4gICAgICAgICAgICB0aGlzLnN0cmluZ2lmeSh0aGlzLnJvb3QsIGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiArPSBpMjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICByZXN1bHQyXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2VuZXJhdGVNYXAgPSBmdW5jdGlvbiBnZW5lcmF0ZU1hcCgpIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdCkge1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZVN0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBwcmV2ID0gdGhpcy5wcmV2aW91cygpWzBdLmNvbnN1bWVyKCk7XG4gICAgICAgICAgICBwcmV2LmZpbGUgPSB0aGlzLm91dHB1dEZpbGUoKTtcbiAgICAgICAgICAgIHRoaXMubWFwID0gU291cmNlTWFwR2VuZXJhdG9yLmZyb21Tb3VyY2VNYXAocHJldiwge1xuICAgICAgICAgICAgICAgIGlnbm9yZUludmFsaWRNYXBwaW5nOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICAgICAgICAgICAgZmlsZTogdGhpcy5vdXRwdXRGaWxlKCksXG4gICAgICAgICAgICAgICAgaWdub3JlSW52YWxpZE1hcHBpbmc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5tYXAuYWRkTWFwcGluZyh7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVkOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogMCxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogMVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiAwLFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiAxXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMub3B0cy5mcm9tID8gdGhpcy50b1VybCh0aGlzLnBhdGgodGhpcy5vcHRzLmZyb20pKSA6IFwiPG5vIHNvdXJjZT5cIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNTb3VyY2VzQ29udGVudCgpKSB0aGlzLnNldFNvdXJjZXNDb250ZW50KCk7XG4gICAgICAgIGlmICh0aGlzLnJvb3QgJiYgdGhpcy5wcmV2aW91cygpLmxlbmd0aCA+IDApIHRoaXMuYXBwbHlQcmV2TWFwcygpO1xuICAgICAgICBpZiAodGhpcy5pc0Fubm90YXRpb24oKSkgdGhpcy5hZGRBbm5vdGF0aW9uKCk7XG4gICAgICAgIGlmICh0aGlzLmlzSW5saW5lKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgdGhpcy5jc3NcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRoaXMuY3NzLFxuICAgICAgICAgICAgICAgIHRoaXMubWFwXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uZ2VuZXJhdGVTdHJpbmcgPSBmdW5jdGlvbiBnZW5lcmF0ZVN0cmluZygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jc3MgPSBcIlwiO1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBTb3VyY2VNYXBHZW5lcmF0b3Ioe1xuICAgICAgICAgICAgZmlsZTogdGhpcy5vdXRwdXRGaWxlKCksXG4gICAgICAgICAgICBpZ25vcmVJbnZhbGlkTWFwcGluZzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxpbmUgPSAxO1xuICAgICAgICB2YXIgY29sdW1uID0gMTtcbiAgICAgICAgdmFyIG5vU291cmNlID0gXCI8bm8gc291cmNlPlwiO1xuICAgICAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogMCxcbiAgICAgICAgICAgICAgICBsaW5lOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb3JpZ2luYWw6IHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IDAsXG4gICAgICAgICAgICAgICAgbGluZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNvdXJjZTogXCJcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgbGluZXMsIGxhc3Q7XG4gICAgICAgIHRoaXMuc3RyaW5naWZ5KHRoaXMucm9vdCwgZnVuY3Rpb24oc3RyLCBub2RlMiwgdHlwZSkge1xuICAgICAgICAgICAgX3RoaXMuY3NzICs9IHN0cjtcbiAgICAgICAgICAgIGlmIChub2RlMiAmJiB0eXBlICE9PSBcImVuZFwiKSB7XG4gICAgICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQubGluZSA9IGxpbmU7XG4gICAgICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQuY29sdW1uID0gY29sdW1uIC0gMTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTIuc291cmNlICYmIG5vZGUyLnNvdXJjZS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLnNvdXJjZSA9IF90aGlzLnNvdXJjZVBhdGgobm9kZTIpO1xuICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSBub2RlMi5zb3VyY2Uuc3RhcnQubGluZTtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSBub2RlMi5zb3VyY2Uuc3RhcnQuY29sdW1uIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFwLmFkZE1hcHBpbmcobWFwcGluZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBub1NvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5saW5lID0gMTtcbiAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbC5jb2x1bW4gPSAwO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lcyA9IHN0ci5tYXRjaCgvXFxuL2cpO1xuICAgICAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgbGluZSArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGFzdCA9IHN0ci5sYXN0SW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBzdHIubGVuZ3RoIC0gbGFzdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29sdW1uICs9IHN0ci5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZTIgJiYgdHlwZSAhPT0gXCJzdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBub2RlMi5wYXJlbnQgfHwge1xuICAgICAgICAgICAgICAgICAgICByYXdzOiB7fVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkbGVzcyA9IG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiIHx8IG5vZGUyLnR5cGUgPT09IFwiYXRydWxlXCIgJiYgIW5vZGUyLm5vZGVzO1xuICAgICAgICAgICAgICAgIGlmICghY2hpbGRsZXNzIHx8IG5vZGUyICE9PSBwLmxhc3QgfHwgcC5yYXdzLnNlbWljb2xvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZTIuc291cmNlICYmIG5vZGUyLnNvdXJjZS5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gX3RoaXMuc291cmNlUGF0aChub2RlMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmxpbmUgPSBub2RlMi5zb3VyY2UuZW5kLmxpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IG5vZGUyLnNvdXJjZS5lbmQuY29sdW1uIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWQuY29sdW1uID0gY29sdW1uIC0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm1hcC5hZGRNYXBwaW5nKG1hcHBpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBub1NvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWwubGluZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsLmNvbHVtbiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZC5saW5lID0gbGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBpbmcuZ2VuZXJhdGVkLmNvbHVtbiA9IGNvbHVtbiAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXAuYWRkTWFwcGluZyhtYXBwaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNBbm5vdGF0aW9uID0gZnVuY3Rpb24gaXNBbm5vdGF0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pc0lubGluZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLmFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZShmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpMi5hbm5vdGF0aW9uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNJbmxpbmUgPSBmdW5jdGlvbiBpc0lubGluZSgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuaW5saW5lICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXBPcHRzLmlubGluZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5ub3RhdGlvbiA9IHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uO1xuICAgICAgICBpZiAodHlwZW9mIGFubm90YXRpb24gIT09IFwidW5kZWZpbmVkXCIgJiYgYW5ub3RhdGlvbiAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZXZpb3VzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcmV2aW91cygpLnNvbWUoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTIuaW5saW5lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNNYXAgPSBmdW5jdGlvbiBpc01hcCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMubWFwICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLm9wdHMubWFwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkubGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIF9wcm90by5pc1NvdXJjZXNDb250ZW50ID0gZnVuY3Rpb24gaXNTb3VyY2VzQ29udGVudCgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcE9wdHMuc291cmNlc0NvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMoKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzKCkuc29tZShmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpMi53aXRoQ29udGVudCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBfcHJvdG8ub3V0cHV0RmlsZSA9IGZ1bmN0aW9uIG91dHB1dEZpbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdHMudG8pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhdGgodGhpcy5vcHRzLnRvKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdHMuZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGF0aCh0aGlzLm9wdHMuZnJvbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJ0by5jc3NcIjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnBhdGggPSBmdW5jdGlvbiBwYXRoKGZpbGUpIHtcbiAgICAgICAgaWYgKHRoaXMubWFwT3B0cy5hYnNvbHV0ZSkgcmV0dXJuIGZpbGU7XG4gICAgICAgIGlmIChmaWxlLmNoYXJDb2RlQXQoMCkgPT09IDYwKSByZXR1cm4gZmlsZTtcbiAgICAgICAgaWYgKC9eXFx3KzpcXC9cXC8vLnRlc3QoZmlsZSkpIHJldHVybiBmaWxlO1xuICAgICAgICB2YXIgY2FjaGVkID0gdGhpcy5tZW1vaXplZFBhdGhzLmdldChmaWxlKTtcbiAgICAgICAgaWYgKGNhY2hlZCkgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgdmFyIGZyb20gPSB0aGlzLm9wdHMudG8gPyBkaXJuYW1lKHRoaXMub3B0cy50bykgOiBcIi5cIjtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1hcE9wdHMuYW5ub3RhdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZnJvbSA9IGRpcm5hbWUocmVzb2x2ZSQzKGZyb20sIHRoaXMubWFwT3B0cy5hbm5vdGF0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhdGggPSByZWxhdGl2ZShmcm9tLCBmaWxlKTtcbiAgICAgICAgdGhpcy5tZW1vaXplZFBhdGhzLnNldChmaWxlLCBwYXRoKTtcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJldmlvdXMgPSBmdW5jdGlvbiBwcmV2aW91cygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLnByZXZpb3VzTWFwcykge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c01hcHMgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3Qud2FsayhmdW5jdGlvbihub2RlMikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZTIuc291cmNlICYmIG5vZGUyLnNvdXJjZS5pbnB1dC5tYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXAgPSBub2RlMi5zb3VyY2UuaW5wdXQubWFwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5wcmV2aW91c01hcHMuaW5jbHVkZXMobWFwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByZXZpb3VzTWFwcy5wdXNoKG1hcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGlucHV0MiA9IG5ldyBJbnB1dCQzKHRoaXMub3JpZ2luYWxDU1MsIHRoaXMub3B0cyk7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0Mi5tYXApIHRoaXMucHJldmlvdXNNYXBzLnB1c2goaW5wdXQyLm1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJldmlvdXNNYXBzO1xuICAgIH07XG4gICAgX3Byb3RvLnNldFNvdXJjZXNDb250ZW50ID0gZnVuY3Rpb24gc2V0U291cmNlc0NvbnRlbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhbHJlYWR5ID0ge307XG4gICAgICAgIGlmICh0aGlzLnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC53YWxrKGZ1bmN0aW9uKG5vZGUyKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IG5vZGUyLnNvdXJjZS5pbnB1dC5mcm9tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSAmJiAhYWxyZWFkeVtmcm9tXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxyZWFkeVtmcm9tXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJvbVVybCA9IF90aGlzLnVzZXNGaWxlVXJscyA/IF90aGlzLnRvRmlsZVVybChmcm9tKSA6IF90aGlzLnRvVXJsKF90aGlzLnBhdGgoZnJvbSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFwLnNldFNvdXJjZUNvbnRlbnQoZnJvbVVybCwgbm9kZTIuc291cmNlLmlucHV0LmNzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNzcykge1xuICAgICAgICAgICAgdmFyIGZyb20gPSB0aGlzLm9wdHMuZnJvbSA/IHRoaXMudG9VcmwodGhpcy5wYXRoKHRoaXMub3B0cy5mcm9tKSkgOiBcIjxubyBzb3VyY2U+XCI7XG4gICAgICAgICAgICB0aGlzLm1hcC5zZXRTb3VyY2VDb250ZW50KGZyb20sIHRoaXMuY3NzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnNvdXJjZVBhdGggPSBmdW5jdGlvbiBzb3VyY2VQYXRoKG5vZGUyKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcE9wdHMuZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9VcmwodGhpcy5tYXBPcHRzLmZyb20pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudXNlc0ZpbGVVcmxzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0ZpbGVVcmwobm9kZTIuc291cmNlLmlucHV0LmZyb20pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9VcmwodGhpcy5wYXRoKG5vZGUyLnNvdXJjZS5pbnB1dC5mcm9tKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by50b0Jhc2U2NCA9IGZ1bmN0aW9uIHRvQmFzZTY0KHN0cikge1xuICAgICAgICBpZiAoQnVmZmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8udG9GaWxlVXJsID0gZnVuY3Rpb24gdG9GaWxlVXJsKHBhdGgpIHtcbiAgICAgICAgdmFyIGNhY2hlZCA9IHRoaXMubWVtb2l6ZWRGaWxlVVJMcy5nZXQocGF0aCk7XG4gICAgICAgIGlmIChjYWNoZWQpIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIGlmIChwYXRoVG9GaWxlVVJMKSB7XG4gICAgICAgICAgICB2YXIgZmlsZVVSTCA9IHBhdGhUb0ZpbGVVUkwocGF0aCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHRoaXMubWVtb2l6ZWRGaWxlVVJMcy5zZXQocGF0aCwgZmlsZVVSTCk7XG4gICAgICAgICAgICByZXR1cm4gZmlsZVVSTDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBtYXAuYWJzb2x1dGVgIG9wdGlvbiBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgUG9zdENTUyBidWlsZFwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnRvVXJsID0gZnVuY3Rpb24gdG9VcmwocGF0aCkge1xuICAgICAgICB2YXIgY2FjaGVkID0gdGhpcy5tZW1vaXplZFVSTHMuZ2V0KHBhdGgpO1xuICAgICAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkO1xuICAgICAgICBpZiAoc2VwID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFxcXC9nLCBcIi9cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVybCA9IGVuY29kZVVSSShwYXRoKS5yZXBsYWNlKC9bIz9dL2csIGVuY29kZVVSSUNvbXBvbmVudCk7XG4gICAgICAgIHRoaXMubWVtb2l6ZWRVUkxzLnNldChwYXRoLCB1cmwpO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH07XG4gICAgcmV0dXJuIE1hcEdlbmVyYXRvcjI7XG59KCk7XG52YXIgbWFwR2VuZXJhdG9yID0gTWFwR2VuZXJhdG9yJDI7XG52YXIgTm9kZSQyID0gbm9kZTtcbnZhciBDb21tZW50JDQgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKE5vZGUkMikge1xuICAgIF9pbmhlcml0cyhDb21tZW50MiwgTm9kZSQyKTtcbiAgICBmdW5jdGlvbiBDb21tZW50MihkZWZhdWx0cykge1xuICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgIF90aGlzID0gTm9kZSQyLmNhbGwodGhpcywgZGVmYXVsdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBcImNvbW1lbnRcIjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ29tbWVudDI7XG59KE5vZGUkMik7XG52YXIgY29tbWVudCA9IENvbW1lbnQkNDtcbkNvbW1lbnQkNC5kZWZhdWx0ID0gQ29tbWVudCQ0O1xudmFyIGlzQ2xlYW4kMSA9IHN5bWJvbHMuaXNDbGVhbiwgbXkkMSA9IHN5bWJvbHMubXk7XG52YXIgRGVjbGFyYXRpb24kMyA9IGRlY2xhcmF0aW9uO1xudmFyIENvbW1lbnQkMyA9IGNvbW1lbnQ7XG52YXIgTm9kZSQxID0gbm9kZTtcbnZhciBwYXJzZSQ0LCBSdWxlJDQsIEF0UnVsZSQ0LCBSb290JDY7XG5mdW5jdGlvbiBjbGVhblNvdXJjZShub2Rlcykge1xuICAgIHJldHVybiBub2Rlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgaWYgKGkyLm5vZGVzKSBpMi5ub2RlcyA9IGNsZWFuU291cmNlKGkyLm5vZGVzKTtcbiAgICAgICAgZGVsZXRlIGkyLnNvdXJjZTtcbiAgICAgICAgcmV0dXJuIGkyO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbWFya0RpcnR5VXAobm9kZTIpIHtcbiAgICBub2RlMltpc0NsZWFuJDFdID0gZmFsc2U7XG4gICAgaWYgKG5vZGUyLnByb3h5T2Yubm9kZXMpIHtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZTIucHJveHlPZi5ub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBpMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgbWFya0RpcnR5VXAoaTIpO1xuICAgICAgICB9XG4gICAgfVxufVxudmFyIENvbnRhaW5lciQ3ID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihOb2RlJDEpIHtcbiAgICBfaW5oZXJpdHMoQ29udGFpbmVyMiwgTm9kZSQxKTtcbiAgICBmdW5jdGlvbiBDb250YWluZXIyKCkge1xuICAgICAgICByZXR1cm4gTm9kZSQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IENvbnRhaW5lcjIucHJvdG90eXBlO1xuICAgIF9wcm90by5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNoaWxkcmVuID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBjaGlsZHJlbltfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShjaGlsZHJlbiksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub3JtYWxpemUoY2hpbGQsIHRoaXMubGFzdCk7XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvcjEgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uobm9kZXMpLCBfc3RlcDE7ICEoX3N0ZXAxID0gX2l0ZXJhdG9yMSgpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMucHJveHlPZi5ub2Rlcy5wdXNoKG5vZGUyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5jbGVhblJhd3MgPSBmdW5jdGlvbiBjbGVhblJhd3Moa2VlcEJldHdlZW4pIHtcbiAgICAgICAgTm9kZSQxLnByb3RvdHlwZS5jbGVhblJhd3MuY2FsbCh0aGlzLCBrZWVwQmV0d2Vlbik7XG4gICAgICAgIGlmICh0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh0aGlzLm5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgIG5vZGUyLmNsZWFuUmF3cyhrZWVwQmV0d2Vlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5lYWNoID0gZnVuY3Rpb24gZWFjaChjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5nZXRJdGVyYXRvcigpO1xuICAgICAgICB2YXIgaW5kZXgyLCByZXN1bHQyO1xuICAgICAgICB3aGlsZSh0aGlzLmluZGV4ZXNbaXRlcmF0b3JdIDwgdGhpcy5wcm94eU9mLm5vZGVzLmxlbmd0aCl7XG4gICAgICAgICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaXRlcmF0b3JdO1xuICAgICAgICAgICAgcmVzdWx0MiA9IGNhbGxiYWNrKHRoaXMucHJveHlPZi5ub2Rlc1tpbmRleDJdLCBpbmRleDIpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDIgPT09IGZhbHNlKSBicmVhaztcbiAgICAgICAgICAgIHRoaXMuaW5kZXhlc1tpdGVyYXRvcl0gKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5pbmRleGVzW2l0ZXJhdG9yXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfTtcbiAgICBfcHJvdG8uZXZlcnkgPSBmdW5jdGlvbiBldmVyeShjb25kaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMuZXZlcnkoY29uZGl0aW9uKTtcbiAgICB9O1xuICAgIF9wcm90by5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uIGdldEl0ZXJhdG9yKCkge1xuICAgICAgICBpZiAoIXRoaXMubGFzdEVhY2gpIHRoaXMubGFzdEVhY2ggPSAwO1xuICAgICAgICBpZiAoIXRoaXMuaW5kZXhlcykgdGhpcy5pbmRleGVzID0ge307XG4gICAgICAgIHRoaXMubGFzdEVhY2ggKz0gMTtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gdGhpcy5sYXN0RWFjaDtcbiAgICAgICAgdGhpcy5pbmRleGVzW2l0ZXJhdG9yXSA9IDA7XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9O1xuICAgIF9wcm90by5nZXRQcm94eVByb2Nlc3NvciA9IGZ1bmN0aW9uIGdldFByb3h5UHJvY2Vzc29yKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQobm9kZTIsIHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJwcm94eU9mXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW5vZGUyW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwiZWFjaFwiIHx8IHR5cGVvZiBwcm9wID09PSBcInN0cmluZ1wiICYmIHByb3Auc3RhcnRzV2l0aChcIndhbGtcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX25vZGUyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfbm9kZTIgPSBub2RlMilbcHJvcF0uYXBwbHkoX25vZGUyLCBbXS5jb25jYXQoYXJncy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNoaWxkLCBpbmRleDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpMihjaGlsZC50b1Byb3h5KCksIGluZGV4Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcImV2ZXJ5XCIgfHwgcHJvcCA9PT0gXCJzb21lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF0oZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBvdGhlciA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC50b1Byb3h5KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLCBvdGhlcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSBcInJvb3RcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTIucm9vdCgpLnRvUHJveHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwibm9kZXNcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTIubm9kZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTIudG9Qcm94eSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09IFwiZmlyc3RcIiB8fCBwcm9wID09PSBcImxhc3RcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTJbcHJvcF0udG9Qcm94eSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlMltwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQobm9kZTIsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUyW3Byb3BdID09PSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgbm9kZTJbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJuYW1lXCIgfHwgcHJvcCA9PT0gXCJwYXJhbXNcIiB8fCBwcm9wID09PSBcInNlbGVjdG9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIubWFya0RpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmluZGV4ID0gZnVuY3Rpb24gaW5kZXgoY2hpbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIGNoaWxkO1xuICAgICAgICBpZiAoY2hpbGQucHJveHlPZikgY2hpbGQgPSBjaGlsZC5wcm94eU9mO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm94eU9mLm5vZGVzLmluZGV4T2YoY2hpbGQpO1xuICAgIH07XG4gICAgX3Byb3RvLmluc2VydEFmdGVyID0gZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIoZXhpc3QsIGFkZCkge1xuICAgICAgICB2YXIgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShhZGQsIHRoaXMucHJveHlPZi5ub2Rlc1tleGlzdEluZGV4XSkucmV2ZXJzZSgpO1xuICAgICAgICBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdCk7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMuc3BsaWNlKGV4aXN0SW5kZXggKyAxLCAwLCBub2RlMik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4MjtcbiAgICAgICAgZm9yKHZhciBpZCBpbiB0aGlzLmluZGV4ZXMpe1xuICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2lkXTtcbiAgICAgICAgICAgIGlmIChleGlzdEluZGV4IDwgaW5kZXgyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4MiArIG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiBpbnNlcnRCZWZvcmUoZXhpc3QsIGFkZCkge1xuICAgICAgICB2YXIgZXhpc3RJbmRleCA9IHRoaXMuaW5kZXgoZXhpc3QpO1xuICAgICAgICB2YXIgdHlwZSA9IGV4aXN0SW5kZXggPT09IDAgPyBcInByZXBlbmRcIiA6IGZhbHNlO1xuICAgICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vcm1hbGl6ZShhZGQsIHRoaXMucHJveHlPZi5ub2Rlc1tleGlzdEluZGV4XSwgdHlwZSkucmV2ZXJzZSgpO1xuICAgICAgICBleGlzdEluZGV4ID0gdGhpcy5pbmRleChleGlzdCk7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIG5vZGUyID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMuc3BsaWNlKGV4aXN0SW5kZXgsIDAsIG5vZGUyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXgyO1xuICAgICAgICBmb3IodmFyIGlkIGluIHRoaXMuaW5kZXhlcyl7XG4gICAgICAgICAgICBpbmRleDIgPSB0aGlzLmluZGV4ZXNbaWRdO1xuICAgICAgICAgICAgaWYgKGV4aXN0SW5kZXggPD0gaW5kZXgyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IGluZGV4MiArIG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUobm9kZXMsIHNhbXBsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIG5vZGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBub2RlcyA9IGNsZWFuU291cmNlKHBhcnNlJDQobm9kZXMpLm5vZGVzKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG5vZGVzID0gW107XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlcykpIHtcbiAgICAgICAgICAgIG5vZGVzID0gbm9kZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICB2YXIgaTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaTIucGFyZW50KSBpMi5wYXJlbnQucmVtb3ZlQ2hpbGQoaTIsIFwiaWdub3JlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGVzLnR5cGUgPT09IFwicm9vdFwiICYmIHRoaXMudHlwZSAhPT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgICBub2RlcyA9IG5vZGVzLm5vZGVzLnNsaWNlKDApO1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IxID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXAxOyAhKF9zdGVwMSA9IF9pdGVyYXRvcjEoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBpMjEgPSBfc3RlcDEudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGkyMS5wYXJlbnQpIGkyMS5wYXJlbnQucmVtb3ZlQ2hpbGQoaTIxLCBcImlnbm9yZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2Rlcy50eXBlKSB7XG4gICAgICAgICAgICBub2RlcyA9IFtcbiAgICAgICAgICAgICAgICBub2Rlc1xuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIGlmIChub2Rlcy5wcm9wKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vZGVzLnZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsdWUgZmllbGQgaXMgbWlzc2VkIGluIG5vZGUgY3JlYXRpb25cIik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBub2Rlcy52YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIG5vZGVzLnZhbHVlID0gU3RyaW5nKG5vZGVzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVzID0gW1xuICAgICAgICAgICAgICAgIG5ldyBEZWNsYXJhdGlvbiQzKG5vZGVzKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIGlmIChub2Rlcy5zZWxlY3Rvcikge1xuICAgICAgICAgICAgbm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IFJ1bGUkNChub2RlcylcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZXMubmFtZSkge1xuICAgICAgICAgICAgbm9kZXMgPSBbXG4gICAgICAgICAgICAgICAgbmV3IEF0UnVsZSQ0KG5vZGVzKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIGlmIChub2Rlcy50ZXh0KSB7XG4gICAgICAgICAgICBub2RlcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgQ29tbWVudCQzKG5vZGVzKVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gbm9kZSB0eXBlIGluIG5vZGUgY3JlYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2Nlc3NlZCA9IG5vZGVzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgaWYgKCFpMltteSQxXSkgQ29udGFpbmVyMi5yZWJ1aWxkKGkyKTtcbiAgICAgICAgICAgIGkyID0gaTIucHJveHlPZjtcbiAgICAgICAgICAgIGlmIChpMi5wYXJlbnQpIGkyLnBhcmVudC5yZW1vdmVDaGlsZChpMik7XG4gICAgICAgICAgICBpZiAoaTJbaXNDbGVhbiQxXSkgbWFya0RpcnR5VXAoaTIpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpMi5yYXdzLmJlZm9yZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGlmIChzYW1wbGUgJiYgdHlwZW9mIHNhbXBsZS5yYXdzLmJlZm9yZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBpMi5yYXdzLmJlZm9yZSA9IHNhbXBsZS5yYXdzLmJlZm9yZS5yZXBsYWNlKC9cXFMvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaTIucGFyZW50ID0gX3RoaXMucHJveHlPZjtcbiAgICAgICAgICAgIHJldHVybiBpMjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzZWQ7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQoKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNoaWxkcmVuID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBjaGlsZHJlbltfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLnJldmVyc2UoKTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoY2hpbGRyZW4pLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBub2RlcyA9IHRoaXMubm9ybWFsaXplKGNoaWxkLCB0aGlzLmZpcnN0LCBcInByZXBlbmRcIikucmV2ZXJzZSgpO1xuICAgICAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IxID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXAxOyAhKF9zdGVwMSA9IF9pdGVyYXRvcjEoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMudW5zaGlmdChub2RlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IodmFyIGlkIGluIHRoaXMuaW5kZXhlcyl7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleGVzW2lkXSA9IHRoaXMuaW5kZXhlc1tpZF0gKyBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBfcHJvdG8ucHVzaCA9IGZ1bmN0aW9uIHB1c2goY2hpbGQpIHtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5wcm94eU9mLm5vZGVzLnB1c2goY2hpbGQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5yZW1vdmVBbGwgPSBmdW5jdGlvbiByZW1vdmVBbGwoKSB7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHRoaXMucHJveHlPZi5ub2RlcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBub2RlMiA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgbm9kZTIucGFyZW50ID0gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJveHlPZi5ub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkID0gdGhpcy5pbmRleChjaGlsZCk7XG4gICAgICAgIHRoaXMucHJveHlPZi5ub2Rlc1tjaGlsZF0ucGFyZW50ID0gdm9pZCAwO1xuICAgICAgICB0aGlzLnByb3h5T2Yubm9kZXMuc3BsaWNlKGNoaWxkLCAxKTtcbiAgICAgICAgdmFyIGluZGV4MjtcbiAgICAgICAgZm9yKHZhciBpZCBpbiB0aGlzLmluZGV4ZXMpe1xuICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5pbmRleGVzW2lkXTtcbiAgICAgICAgICAgIGlmIChpbmRleDIgPj0gY2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4ZXNbaWRdID0gaW5kZXgyIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIF9wcm90by5yZXBsYWNlVmFsdWVzID0gZnVuY3Rpb24gcmVwbGFjZVZhbHVlcyhwYXR0ZXJuLCBvcHRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YWxrRGVjbHMoZnVuY3Rpb24oZGVjbCkge1xuICAgICAgICAgICAgaWYgKG9wdHMucHJvcHMgJiYgIW9wdHMucHJvcHMuaW5jbHVkZXMoZGVjbC5wcm9wKSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKG9wdHMuZmFzdCAmJiAhZGVjbC52YWx1ZS5pbmNsdWRlcyhvcHRzLmZhc3QpKSByZXR1cm47XG4gICAgICAgICAgICBkZWNsLnZhbHVlID0gZGVjbC52YWx1ZS5yZXBsYWNlKHBhdHRlcm4sIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgX3Byb3RvLnNvbWUgPSBmdW5jdGlvbiBzb21lKGNvbmRpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlcy5zb21lKGNvbmRpdGlvbik7XG4gICAgfTtcbiAgICBfcHJvdG8ud2FsayA9IGZ1bmN0aW9uIHdhbGsoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQyO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY2hpbGQuYWRkVG9FcnJvcihlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gZmFsc2UgJiYgY2hpbGQud2Fsaykge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBjaGlsZC53YWxrKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by53YWxrQXRSdWxlcyA9IGZ1bmN0aW9uIHdhbGtBdFJ1bGVzKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9pbnN0YW5jZW9mKG5hbWUsIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiYXRydWxlXCIgJiYgbmFtZS50ZXN0KGNoaWxkLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJhdHJ1bGVcIiAmJiBjaGlsZC5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLndhbGtDb21tZW50cyA9IGZ1bmN0aW9uIHdhbGtDb21tZW50cyhjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwiY29tbWVudFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLndhbGtEZWNscyA9IGZ1bmN0aW9uIHdhbGtEZWNscyhwcm9wLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IHByb3A7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2luc3RhbmNlb2YocHJvcCwgUmVnRXhwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsayhmdW5jdGlvbihjaGlsZCwgaTIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJkZWNsXCIgJiYgcHJvcC50ZXN0KGNoaWxkLnByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJkZWNsXCIgJiYgY2hpbGQucHJvcCA9PT0gcHJvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by53YWxrUnVsZXMgPSBmdW5jdGlvbiB3YWxrUnVsZXMoc2VsZWN0b3IsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gc2VsZWN0b3I7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53YWxrKGZ1bmN0aW9uKGNoaWxkLCBpMikge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSBcInJ1bGVcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soY2hpbGQsIGkyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2luc3RhbmNlb2Yoc2VsZWN0b3IsIFJlZ0V4cCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09IFwicnVsZVwiICYmIHNlbGVjdG9yLnRlc3QoY2hpbGQuc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhjaGlsZCwgaTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndhbGsoZnVuY3Rpb24oY2hpbGQsIGkyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gXCJydWxlXCIgJiYgY2hpbGQuc2VsZWN0b3IgPT09IHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoaWxkLCBpMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhDb250YWluZXIyLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJmaXJzdFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHJldHVybiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJveHlPZi5ub2Rlc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImxhc3RcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm94eU9mLm5vZGVzKSByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3h5T2Yubm9kZXNbdGhpcy5wcm94eU9mLm5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIENvbnRhaW5lcjI7XG59KE5vZGUkMSk7XG5Db250YWluZXIkNy5yZWdpc3RlclBhcnNlID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgcGFyc2UkNCA9IGRlcGVuZGFudDtcbn07XG5Db250YWluZXIkNy5yZWdpc3RlclJ1bGUgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBSdWxlJDQgPSBkZXBlbmRhbnQ7XG59O1xuQ29udGFpbmVyJDcucmVnaXN0ZXJBdFJ1bGUgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBBdFJ1bGUkNCA9IGRlcGVuZGFudDtcbn07XG5Db250YWluZXIkNy5yZWdpc3RlclJvb3QgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBSb290JDYgPSBkZXBlbmRhbnQ7XG59O1xudmFyIGNvbnRhaW5lciA9IENvbnRhaW5lciQ3O1xuQ29udGFpbmVyJDcuZGVmYXVsdCA9IENvbnRhaW5lciQ3O1xuQ29udGFpbmVyJDcucmVidWlsZCA9IGZ1bmN0aW9uKG5vZGUyKSB7XG4gICAgaWYgKG5vZGUyLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBBdFJ1bGUkNC5wcm90b3R5cGUpO1xuICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJydWxlXCIpIHtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBSdWxlJDQucHJvdG90eXBlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgRGVjbGFyYXRpb24kMy5wcm90b3R5cGUpO1xuICAgIH0gZWxzZSBpZiAobm9kZTIudHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5vZGUyLCBDb21tZW50JDMucHJvdG90eXBlKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwicm9vdFwiKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihub2RlMiwgUm9vdCQ2LnByb3RvdHlwZSk7XG4gICAgfVxuICAgIG5vZGUyW215JDFdID0gdHJ1ZTtcbiAgICBpZiAobm9kZTIubm9kZXMpIHtcbiAgICAgICAgbm9kZTIubm9kZXMuZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgQ29udGFpbmVyJDcucmVidWlsZChjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG52YXIgQ29udGFpbmVyJDYgPSBjb250YWluZXI7XG52YXIgTGF6eVJlc3VsdCQ0LCBQcm9jZXNzb3IkMztcbnZhciBEb2N1bWVudCQzID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihDb250YWluZXIkNikge1xuICAgIF9pbmhlcml0cyhEb2N1bWVudDIzLCBDb250YWluZXIkNik7XG4gICAgZnVuY3Rpb24gRG9jdW1lbnQyMyhkZWZhdWx0cykge1xuICAgICAgICB2YXIgX3RoaXM7XG4gICAgICAgIF90aGlzID0gQ29udGFpbmVyJDYuY2FsbCh0aGlzLCBfZXh0ZW5kcyh7XG4gICAgICAgICAgICB0eXBlOiBcImRvY3VtZW50XCJcbiAgICAgICAgfSwgZGVmYXVsdHMpKSB8fCB0aGlzO1xuICAgICAgICBpZiAoIV90aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBfdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IERvY3VtZW50MjMucHJvdG90eXBlO1xuICAgIF9wcm90by50b1Jlc3VsdCA9IGZ1bmN0aW9uIHRvUmVzdWx0KG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICB2YXIgbGF6eSA9IG5ldyBMYXp5UmVzdWx0JDQobmV3IFByb2Nlc3NvciQzKCksIHRoaXMsIG9wdHMpO1xuICAgICAgICByZXR1cm4gbGF6eS5zdHJpbmdpZnkoKTtcbiAgICB9O1xuICAgIHJldHVybiBEb2N1bWVudDIzO1xufShDb250YWluZXIkNik7XG5Eb2N1bWVudCQzLnJlZ2lzdGVyTGF6eVJlc3VsdCA9IGZ1bmN0aW9uKGRlcGVuZGFudCkge1xuICAgIExhenlSZXN1bHQkNCA9IGRlcGVuZGFudDtcbn07XG5Eb2N1bWVudCQzLnJlZ2lzdGVyUHJvY2Vzc29yID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgUHJvY2Vzc29yJDMgPSBkZXBlbmRhbnQ7XG59O1xudmFyIGRvY3VtZW50JDEkMiA9IERvY3VtZW50JDM7XG5Eb2N1bWVudCQzLmRlZmF1bHQgPSBEb2N1bWVudCQzO1xudmFyIHByaW50ZWQgPSB7fTtcbnZhciB3YXJuT25jZSQyID0gZnVuY3Rpb24gd2Fybk9uY2UyKG1lc3NhZ2UpIHtcbiAgICBpZiAocHJpbnRlZFttZXNzYWdlXSkgcmV0dXJuO1xuICAgIHByaW50ZWRbbWVzc2FnZV0gPSB0cnVlO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbn07XG52YXIgV2FybmluZyQyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBXYXJuaW5nMih0ZXh0LCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgdGhpcy50eXBlID0gXCJ3YXJuaW5nXCI7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIGlmIChvcHRzLm5vZGUgJiYgb3B0cy5ub2RlLnNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gb3B0cy5ub2RlLnJhbmdlQnkob3B0cyk7XG4gICAgICAgICAgICB0aGlzLmxpbmUgPSByYW5nZS5zdGFydC5saW5lO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW4gPSByYW5nZS5zdGFydC5jb2x1bW47XG4gICAgICAgICAgICB0aGlzLmVuZExpbmUgPSByYW5nZS5lbmQubGluZTtcbiAgICAgICAgICAgIHRoaXMuZW5kQ29sdW1uID0gcmFuZ2UuZW5kLmNvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBmb3IodmFyIG9wdCBpbiBvcHRzKXRoaXNbb3B0XSA9IG9wdHNbb3B0XTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFdhcm5pbmcyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5lcnJvcih0aGlzLnRleHQsIHtcbiAgICAgICAgICAgICAgICBpbmRleDogdGhpcy5pbmRleCxcbiAgICAgICAgICAgICAgICBwbHVnaW46IHRoaXMucGx1Z2luLFxuICAgICAgICAgICAgICAgIHdvcmQ6IHRoaXMud29yZFxuICAgICAgICAgICAgfSkubWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wbHVnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBsdWdpbiArIFwiOiBcIiArIHRoaXMudGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgIH07XG4gICAgcmV0dXJuIFdhcm5pbmcyO1xufSgpO1xudmFyIHdhcm5pbmcgPSBXYXJuaW5nJDI7XG5XYXJuaW5nJDIuZGVmYXVsdCA9IFdhcm5pbmckMjtcbnZhciBXYXJuaW5nJDEgPSB3YXJuaW5nO1xudmFyIFJlc3VsdCQzID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBSZXN1bHQyKHByb2Nlc3NvcjIsIHJvb3QyLCBvcHRzKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yMjtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLnJvb3QgPSByb290MjtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5jc3MgPSB2b2lkIDA7XG4gICAgICAgIHRoaXMubWFwID0gdm9pZCAwO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gUmVzdWx0Mi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNzcztcbiAgICB9O1xuICAgIF9wcm90by53YXJuID0gZnVuY3Rpb24gd2Fybih0ZXh0LCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgaWYgKCFvcHRzLnBsdWdpbikge1xuICAgICAgICAgICAgaWYgKHRoaXMubGFzdFBsdWdpbiAmJiB0aGlzLmxhc3RQbHVnaW4ucG9zdGNzc1BsdWdpbikge1xuICAgICAgICAgICAgICAgIG9wdHMucGx1Z2luID0gdGhpcy5sYXN0UGx1Z2luLnBvc3Rjc3NQbHVnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdhcm5pbmcyID0gbmV3IFdhcm5pbmckMSh0ZXh0LCBvcHRzKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5wdXNoKHdhcm5pbmcyKTtcbiAgICAgICAgcmV0dXJuIHdhcm5pbmcyO1xuICAgIH07XG4gICAgX3Byb3RvLndhcm5pbmdzID0gZnVuY3Rpb24gd2FybmluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VzLmZpbHRlcihmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgcmV0dXJuIGkyLnR5cGUgPT09IFwid2FybmluZ1wiO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9jcmVhdGVfY2xhc3MoUmVzdWx0MiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY29udGVudFwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3NzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFJlc3VsdDI7XG59KCk7XG52YXIgcmVzdWx0ID0gUmVzdWx0JDM7XG5SZXN1bHQkMy5kZWZhdWx0ID0gUmVzdWx0JDM7XG52YXIgU0lOR0xFX1FVT1RFID0gXCInXCIuY2hhckNvZGVBdCgwKTtcbnZhciBET1VCTEVfUVVPVEUgPSAnXCInLmNoYXJDb2RlQXQoMCk7XG52YXIgQkFDS1NMQVNIID0gXCJcXFxcXCIuY2hhckNvZGVBdCgwKTtcbnZhciBTTEFTSCA9IFwiL1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgTkVXTElORSA9IFwiXFxuXCIuY2hhckNvZGVBdCgwKTtcbnZhciBTUEFDRSA9IFwiIFwiLmNoYXJDb2RlQXQoMCk7XG52YXIgRkVFRCA9IFwiXFxmXCIuY2hhckNvZGVBdCgwKTtcbnZhciBUQUIgPSBcIlx0XCIuY2hhckNvZGVBdCgwKTtcbnZhciBDUiA9IFwiXFxyXCIuY2hhckNvZGVBdCgwKTtcbnZhciBPUEVOX1NRVUFSRSA9IFwiW1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgQ0xPU0VfU1FVQVJFID0gXCJdXCIuY2hhckNvZGVBdCgwKTtcbnZhciBPUEVOX1BBUkVOVEhFU0VTID0gXCIoXCIuY2hhckNvZGVBdCgwKTtcbnZhciBDTE9TRV9QQVJFTlRIRVNFUyA9IFwiKVwiLmNoYXJDb2RlQXQoMCk7XG52YXIgT1BFTl9DVVJMWSA9IFwie1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgQ0xPU0VfQ1VSTFkgPSBcIn1cIi5jaGFyQ29kZUF0KDApO1xudmFyIFNFTUlDT0xPTiA9IFwiO1wiLmNoYXJDb2RlQXQoMCk7XG52YXIgQVNURVJJU0sgPSBcIipcIi5jaGFyQ29kZUF0KDApO1xudmFyIENPTE9OID0gXCI6XCIuY2hhckNvZGVBdCgwKTtcbnZhciBBVCA9IFwiQFwiLmNoYXJDb2RlQXQoMCk7XG52YXIgUkVfQVRfRU5EID0gL1tcXHRcXG5cXGZcXHIgXCIjJygpLztbXFxcXFxcXXt9XS9nO1xudmFyIFJFX1dPUkRfRU5EID0gL1tcXHRcXG5cXGZcXHIgIVwiIycoKTo7QFtcXFxcXFxde31dfFxcLyg/PVxcKikvZztcbnZhciBSRV9CQURfQlJBQ0tFVCA9IC8uW1xcclxcblwiJygvXFxcXF0vO1xudmFyIFJFX0hFWF9FU0NBUEUgPSAvW1xcZGEtZl0vaTtcbnZhciB0b2tlbml6ZSA9IGZ1bmN0aW9uIHRva2VuaXplcjIoaW5wdXQyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBjc3MgPSBpbnB1dDIuY3NzLnZhbHVlT2YoKTtcbiAgICB2YXIgaWdub3JlID0gb3B0aW9ucy5pZ25vcmVFcnJvcnM7XG4gICAgdmFyIGNvZGUsIG5leHQsIHF1b3RlLCBjb250ZW50LCBlc2NhcGU7XG4gICAgdmFyIGVzY2FwZWQsIGVzY2FwZVBvcywgcHJldiwgbjIsIGN1cnJlbnRUb2tlbjtcbiAgICB2YXIgbGVuZ3RoID0gY3NzLmxlbmd0aDtcbiAgICB2YXIgcG9zID0gMDtcbiAgICB2YXIgYnVmZmVyID0gW107XG4gICAgdmFyIHJldHVybmVkID0gW107XG4gICAgZnVuY3Rpb24gcG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuY2xvc2VkKHdoYXQpIHtcbiAgICAgICAgdGhyb3cgaW5wdXQyLmVycm9yKFwiVW5jbG9zZWQgXCIgKyB3aGF0LCBwb3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmRPZkZpbGUoKSB7XG4gICAgICAgIHJldHVybiByZXR1cm5lZC5sZW5ndGggPT09IDAgJiYgcG9zID49IGxlbmd0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbmV4dFRva2VuKG9wdHMpIHtcbiAgICAgICAgaWYgKHJldHVybmVkLmxlbmd0aCkgcmV0dXJuIHJldHVybmVkLnBvcCgpO1xuICAgICAgICBpZiAocG9zID49IGxlbmd0aCkgcmV0dXJuO1xuICAgICAgICB2YXIgaWdub3JlVW5jbG9zZWQgPSBvcHRzID8gb3B0cy5pZ25vcmVVbmNsb3NlZCA6IGZhbHNlO1xuICAgICAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgc3dpdGNoKGNvZGUpe1xuICAgICAgICAgICAgY2FzZSBORVdMSU5FOlxuICAgICAgICAgICAgY2FzZSBTUEFDRTpcbiAgICAgICAgICAgIGNhc2UgVEFCOlxuICAgICAgICAgICAgY2FzZSBDUjpcbiAgICAgICAgICAgIGNhc2UgRkVFRDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjc3MuY2hhckNvZGVBdChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfXdoaWxlIChjb2RlID09PSBTUEFDRSB8fCBjb2RlID09PSBORVdMSU5FIHx8IGNvZGUgPT09IFRBQiB8fCBjb2RlID09PSBDUiB8fCBjb2RlID09PSBGRUVEKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzcGFjZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dClcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgT1BFTl9TUVVBUkU6XG4gICAgICAgICAgICBjYXNlIENMT1NFX1NRVUFSRTpcbiAgICAgICAgICAgIGNhc2UgT1BFTl9DVVJMWTpcbiAgICAgICAgICAgIGNhc2UgQ0xPU0VfQ1VSTFk6XG4gICAgICAgICAgICBjYXNlIENPTE9OOlxuICAgICAgICAgICAgY2FzZSBTRU1JQ09MT046XG4gICAgICAgICAgICBjYXNlIENMT1NFX1BBUkVOVEhFU0VTOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbENoYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sQ2hhcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc1xuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE9QRU5fUEFSRU5USEVTRVM6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBwcmV2ID0gYnVmZmVyLmxlbmd0aCA/IGJ1ZmZlci5wb3AoKVsxXSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIG4yID0gY3NzLmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2ID09PSBcInVybFwiICYmIG4yICE9PSBTSU5HTEVfUVVPVEUgJiYgbjIgIT09IERPVUJMRV9RVU9URSAmJiBuMiAhPT0gU1BBQ0UgJiYgbjIgIT09IE5FV0xJTkUgJiYgbjIgIT09IFRBQiAmJiBuMiAhPT0gRkVFRCAmJiBuMiAhPT0gQ1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjc3MuaW5kZXhPZihcIilcIiwgbmV4dCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlIHx8IGlnbm9yZVVuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmNsb3NlZChcImJyYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlUG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShjc3MuY2hhckNvZGVBdChlc2NhcGVQb3MgLSAxKSA9PT0gQkFDS1NMQVNIKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlUG9zIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9d2hpbGUgKGVzY2FwZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYnJhY2tldHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKFwiKVwiLCBwb3MgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gLTEgfHwgUkVfQkFEX0JSQUNLRVQudGVzdChjb250ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYnJhY2tldHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgU0lOR0xFX1FVT1RFOlxuICAgICAgICAgICAgY2FzZSBET1VCTEVfUVVPVEU6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBxdW90ZSA9IGNvZGUgPT09IFNJTkdMRV9RVU9URSA/IFwiJ1wiIDogJ1wiJztcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKHF1b3RlLCBuZXh0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlIHx8IGlnbm9yZVVuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmNsb3NlZChcInN0cmluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlc2NhcGVQb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUoY3NzLmNoYXJDb2RlQXQoZXNjYXBlUG9zIC0gMSkgPT09IEJBQ0tTTEFTSCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlUG9zIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9d2hpbGUgKGVzY2FwZWQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEFUOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgUkVfQVRfRU5ELmxhc3RJbmRleCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgICAgIFJFX0FUX0VORC50ZXN0KGNzcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChSRV9BVF9FTkQubGFzdEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gY3NzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gUkVfQVRfRU5ELmxhc3RJbmRleCAtIDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRva2VuID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJhdC13b3JkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQkFDS1NMQVNIOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUoY3NzLmNoYXJDb2RlQXQobmV4dCArIDEpID09PSBCQUNLU0xBU0gpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlID0gIWVzY2FwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb2RlID0gY3NzLmNoYXJDb2RlQXQobmV4dCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXNjYXBlICYmIGNvZGUgIT09IFNMQVNIICYmIGNvZGUgIT09IFNQQUNFICYmIGNvZGUgIT09IE5FV0xJTkUgJiYgY29kZSAhPT0gVEFCICYmIGNvZGUgIT09IENSICYmIGNvZGUgIT09IEZFRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChSRV9IRVhfRVNDQVBFLnRlc3QoY3NzLmNoYXJBdChuZXh0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShSRV9IRVhfRVNDQVBFLnRlc3QoY3NzLmNoYXJBdChuZXh0ICsgMSkpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3NzLmNoYXJDb2RlQXQobmV4dCArIDEpID09PSBTUEFDRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwid29yZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IFNMQVNIICYmIGNzcy5jaGFyQ29kZUF0KHBvcyArIDEpID09PSBBU1RFUklTSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5pbmRleE9mKFwiKi9cIiwgcG9zICsgMikgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlIHx8IGlnbm9yZVVuY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBjc3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuY2xvc2VkKFwiY29tbWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50VG9rZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb21tZW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3NzLnNsaWNlKHBvcywgbmV4dCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJFX1dPUkRfRU5ELmxhc3RJbmRleCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBSRV9XT1JEX0VORC50ZXN0KGNzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUkVfV09SRF9FTkQubGFzdEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGNzcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0ID0gUkVfV09SRF9FTkQubGFzdEluZGV4IC0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUb2tlbiA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndvcmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjc3Muc2xpY2UocG9zLCBuZXh0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIucHVzaChjdXJyZW50VG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcG9zKys7XG4gICAgICAgIHJldHVybiBjdXJyZW50VG9rZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJhY2sodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuZWQucHVzaCh0b2tlbik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGJhY2s6IGJhY2ssXG4gICAgICAgIGVuZE9mRmlsZTogZW5kT2ZGaWxlLFxuICAgICAgICBuZXh0VG9rZW46IG5leHRUb2tlbixcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uXG4gICAgfTtcbn07XG52YXIgQ29udGFpbmVyJDUgPSBjb250YWluZXI7XG52YXIgQXRSdWxlJDMgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKENvbnRhaW5lciQ1KSB7XG4gICAgX2luaGVyaXRzKEF0UnVsZTIsIENvbnRhaW5lciQ1KTtcbiAgICBmdW5jdGlvbiBBdFJ1bGUyKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBDb250YWluZXIkNS5jYWxsKHRoaXMsIGRlZmF1bHRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gXCJhdHJ1bGVcIjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gQXRSdWxlMi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCgpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY2hpbGRyZW4gPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIGNoaWxkcmVuW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfQ29udGFpbmVyJDVfcHJvdG90eXBlX2FwcGVuZDtcbiAgICAgICAgaWYgKCF0aGlzLnByb3h5T2Yubm9kZXMpIHRoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIChfQ29udGFpbmVyJDVfcHJvdG90eXBlX2FwcGVuZCA9IENvbnRhaW5lciQ1LnByb3RvdHlwZS5hcHBlbmQpLmNhbGwuYXBwbHkoX0NvbnRhaW5lciQ1X3Byb3RvdHlwZV9hcHBlbmQsIFtdLmNvbmNhdChbXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgIF0sIGNoaWxkcmVuKSk7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJlcGVuZCA9IGZ1bmN0aW9uIHByZXBlbmQoKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNoaWxkcmVuID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBjaGlsZHJlbltfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX0NvbnRhaW5lciQ1X3Byb3RvdHlwZV9wcmVwZW5kO1xuICAgICAgICBpZiAoIXRoaXMucHJveHlPZi5ub2RlcykgdGhpcy5ub2RlcyA9IFtdO1xuICAgICAgICByZXR1cm4gKF9Db250YWluZXIkNV9wcm90b3R5cGVfcHJlcGVuZCA9IENvbnRhaW5lciQ1LnByb3RvdHlwZS5wcmVwZW5kKS5jYWxsLmFwcGx5KF9Db250YWluZXIkNV9wcm90b3R5cGVfcHJlcGVuZCwgW10uY29uY2F0KFtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgXSwgY2hpbGRyZW4pKTtcbiAgICB9O1xuICAgIHJldHVybiBBdFJ1bGUyO1xufShDb250YWluZXIkNSk7XG52YXIgYXRSdWxlID0gQXRSdWxlJDM7XG5BdFJ1bGUkMy5kZWZhdWx0ID0gQXRSdWxlJDM7XG5Db250YWluZXIkNS5yZWdpc3RlckF0UnVsZShBdFJ1bGUkMyk7XG52YXIgQ29udGFpbmVyJDQgPSBjb250YWluZXI7XG52YXIgTGF6eVJlc3VsdCQzLCBQcm9jZXNzb3IkMjtcbnZhciBSb290JDUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKENvbnRhaW5lciQ0KSB7XG4gICAgX2luaGVyaXRzKFJvb3QyLCBDb250YWluZXIkNCk7XG4gICAgZnVuY3Rpb24gUm9vdDIoZGVmYXVsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzO1xuICAgICAgICBfdGhpcyA9IENvbnRhaW5lciQ0LmNhbGwodGhpcywgZGVmYXVsdHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSBcInJvb3RcIjtcbiAgICAgICAgaWYgKCFfdGhpcy5ub2RlcykgX3RoaXMubm9kZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gUm9vdDIucHJvdG90eXBlO1xuICAgIF9wcm90by5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUoY2hpbGQsIHNhbXBsZSwgdHlwZSkge1xuICAgICAgICB2YXIgbm9kZXMgPSBDb250YWluZXIkNC5wcm90b3R5cGUubm9ybWFsaXplLmNhbGwodGhpcywgY2hpbGQpO1xuICAgICAgICBpZiAoc2FtcGxlKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJwcmVwZW5kXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHNhbXBsZS5yYXdzLmJlZm9yZSA9IHRoaXMubm9kZXNbMV0ucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNhbXBsZS5yYXdzLmJlZm9yZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZmlyc3QgIT09IHNhbXBsZSkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG5vZGVzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIucmF3cy5iZWZvcmUgPSBzYW1wbGUucmF3cy5iZWZvcmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlcztcbiAgICB9O1xuICAgIF9wcm90by5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKGNoaWxkLCBpZ25vcmUpIHtcbiAgICAgICAgdmFyIGluZGV4MiA9IHRoaXMuaW5kZXgoY2hpbGQpO1xuICAgICAgICBpZiAoIWlnbm9yZSAmJiBpbmRleDIgPT09IDAgJiYgdGhpcy5ub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzWzFdLnJhd3MuYmVmb3JlID0gdGhpcy5ub2Rlc1tpbmRleDJdLnJhd3MuYmVmb3JlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb250YWluZXIkNC5wcm90b3R5cGUucmVtb3ZlQ2hpbGQuY2FsbCh0aGlzLCBjaGlsZCk7XG4gICAgfTtcbiAgICBfcHJvdG8udG9SZXN1bHQgPSBmdW5jdGlvbiB0b1Jlc3VsdChvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIG9wdHMgPSB7fTtcbiAgICAgICAgdmFyIGxhenkgPSBuZXcgTGF6eVJlc3VsdCQzKG5ldyBQcm9jZXNzb3IkMigpLCB0aGlzLCBvcHRzKTtcbiAgICAgICAgcmV0dXJuIGxhenkuc3RyaW5naWZ5KCk7XG4gICAgfTtcbiAgICByZXR1cm4gUm9vdDI7XG59KENvbnRhaW5lciQ0KTtcblJvb3QkNS5yZWdpc3RlckxhenlSZXN1bHQgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBMYXp5UmVzdWx0JDMgPSBkZXBlbmRhbnQ7XG59O1xuUm9vdCQ1LnJlZ2lzdGVyUHJvY2Vzc29yID0gZnVuY3Rpb24oZGVwZW5kYW50KSB7XG4gICAgUHJvY2Vzc29yJDIgPSBkZXBlbmRhbnQ7XG59O1xudmFyIHJvb3QgPSBSb290JDU7XG5Sb290JDUuZGVmYXVsdCA9IFJvb3QkNTtcbkNvbnRhaW5lciQ0LnJlZ2lzdGVyUm9vdChSb290JDUpO1xudmFyIGxpc3QkMiA9IHtcbiAgICBjb21tYTogZnVuY3Rpb24gY29tbWEoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBsaXN0JDIuc3BsaXQoc3RyaW5nLCBbXG4gICAgICAgICAgICBcIixcIlxuICAgICAgICBdLCB0cnVlKTtcbiAgICB9LFxuICAgIHNwYWNlOiBmdW5jdGlvbiBzcGFjZShzdHJpbmcpIHtcbiAgICAgICAgdmFyIHNwYWNlcyA9IFtcbiAgICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgICAgXCJcXG5cIixcbiAgICAgICAgICAgIFwiXHRcIlxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gbGlzdCQyLnNwbGl0KHN0cmluZywgc3BhY2VzKTtcbiAgICB9LFxuICAgIHNwbGl0OiBmdW5jdGlvbiBzcGxpdChzdHJpbmcsIHNlcGFyYXRvcnMsIGxhc3QpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICAgIHZhciBjdXJyZW50ID0gXCJcIjtcbiAgICAgICAgdmFyIHNwbGl0ID0gZmFsc2U7XG4gICAgICAgIHZhciBmdW5jID0gMDtcbiAgICAgICAgdmFyIGluUXVvdGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHByZXZRdW90ZSA9IFwiXCI7XG4gICAgICAgIHZhciBlc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uoc3RyaW5nKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGxldHRlciA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICAgICAgICAgIGVzY2FwZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICAgICAgZXNjYXBlID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5RdW90ZSkge1xuICAgICAgICAgICAgICAgIGlmIChsZXR0ZXIgPT09IHByZXZRdW90ZSkge1xuICAgICAgICAgICAgICAgICAgICBpblF1b3RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsZXR0ZXIgPT09ICdcIicgfHwgbGV0dGVyID09PSBcIidcIikge1xuICAgICAgICAgICAgICAgIGluUXVvdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByZXZRdW90ZSA9IGxldHRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcIihcIikge1xuICAgICAgICAgICAgICAgIGZ1bmMgKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGV0dGVyID09PSBcIilcIikge1xuICAgICAgICAgICAgICAgIGlmIChmdW5jID4gMCkgZnVuYyAtPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmdW5jID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlcGFyYXRvcnMuaW5jbHVkZXMobGV0dGVyKSkgc3BsaXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IFwiXCIpIGFycmF5LnB1c2goY3VycmVudC50cmltKCkpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHNwbGl0ID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgKz0gbGV0dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0IHx8IGN1cnJlbnQgIT09IFwiXCIpIGFycmF5LnB1c2goY3VycmVudC50cmltKCkpO1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxufTtcbnZhciBsaXN0XzEgPSBsaXN0JDI7XG5saXN0JDIuZGVmYXVsdCA9IGxpc3QkMjtcbnZhciBDb250YWluZXIkMyA9IGNvbnRhaW5lcjtcbnZhciBsaXN0JDEgPSBsaXN0XzE7XG52YXIgUnVsZSQzID0gLyojX19QVVJFX18qLyBmdW5jdGlvbihDb250YWluZXIkMykge1xuICAgIF9pbmhlcml0cyhSdWxlMiwgQ29udGFpbmVyJDMpO1xuICAgIGZ1bmN0aW9uIFJ1bGUyKGRlZmF1bHRzKSB7XG4gICAgICAgIHZhciBfdGhpcztcbiAgICAgICAgX3RoaXMgPSBDb250YWluZXIkMy5jYWxsKHRoaXMsIGRlZmF1bHRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50eXBlID0gXCJydWxlXCI7XG4gICAgICAgIGlmICghX3RoaXMubm9kZXMpIF90aGlzLm5vZGVzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2NyZWF0ZV9jbGFzcyhSdWxlMiwgW1xuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwic2VsZWN0b3JzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdCQxLmNvbW1hKHRoaXMuc2VsZWN0b3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlcykge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yLm1hdGNoKC8sXFxzKi8pIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgc2VwMiA9IG1hdGNoID8gbWF0Y2hbMF0gOiBcIixcIiArIHRoaXMucmF3KFwiYmV0d2VlblwiLCBcImJlZm9yZU9wZW5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RvciA9IHZhbHVlcy5qb2luKHNlcDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIFJ1bGUyO1xufShDb250YWluZXIkMyk7XG52YXIgcnVsZSA9IFJ1bGUkMztcblJ1bGUkMy5kZWZhdWx0ID0gUnVsZSQzO1xuQ29udGFpbmVyJDMucmVnaXN0ZXJSdWxlKFJ1bGUkMyk7XG52YXIgRGVjbGFyYXRpb24kMiA9IGRlY2xhcmF0aW9uO1xudmFyIHRva2VuaXplcjIyID0gdG9rZW5pemU7XG52YXIgQ29tbWVudCQyID0gY29tbWVudDtcbnZhciBBdFJ1bGUkMiA9IGF0UnVsZTtcbnZhciBSb290JDQgPSByb290O1xudmFyIFJ1bGUkMiA9IHJ1bGU7XG52YXIgU0FGRV9DT01NRU5UX05FSUdIQk9SID0ge1xuICAgIGVtcHR5OiB0cnVlLFxuICAgIHNwYWNlOiB0cnVlXG59O1xuZnVuY3Rpb24gZmluZExhc3RXaXRoUG9zaXRpb24odG9rZW5zKSB7XG4gICAgZm9yKHZhciBpMiA9IHRva2Vucy5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKXtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2kyXTtcbiAgICAgICAgdmFyIHBvcyA9IHRva2VuWzNdIHx8IHRva2VuWzJdO1xuICAgICAgICBpZiAocG9zKSByZXR1cm4gcG9zO1xuICAgIH1cbn1cbnZhciBQYXJzZXIkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VyMihpbnB1dDIpIHtcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0MjtcbiAgICAgICAgdGhpcy5yb290ID0gbmV3IFJvb3QkNCgpO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnJvb3Q7XG4gICAgICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICAgICAgdGhpcy5zZW1pY29sb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jcmVhdGVUb2tlbml6ZXIoKTtcbiAgICAgICAgdGhpcy5yb290LnNvdXJjZSA9IHtcbiAgICAgICAgICAgIGlucHV0OiBpbnB1dDIsXG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGNvbHVtbjogMSxcbiAgICAgICAgICAgICAgICBsaW5lOiAxLFxuICAgICAgICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gUGFyc2VyMi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmF0cnVsZSA9IGZ1bmN0aW9uIGF0cnVsZSh0b2tlbikge1xuICAgICAgICB2YXIgbm9kZTIgPSBuZXcgQXRSdWxlJDIoKTtcbiAgICAgICAgbm9kZTIubmFtZSA9IHRva2VuWzFdLnNsaWNlKDEpO1xuICAgICAgICBpZiAobm9kZTIubmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhpcy51bm5hbWVkQXRydWxlKG5vZGUyLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlblsyXSk7XG4gICAgICAgIHZhciB0eXBlO1xuICAgICAgICB2YXIgcHJldjtcbiAgICAgICAgdmFyIHNoaWZ0O1xuICAgICAgICB2YXIgbGFzdCA9IGZhbHNlO1xuICAgICAgICB2YXIgb3BlbiA9IGZhbHNlO1xuICAgICAgICB2YXIgcGFyYW1zID0gW107XG4gICAgICAgIHZhciBicmFja2V0cyA9IFtdO1xuICAgICAgICB3aGlsZSghdGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpe1xuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRva2VuaXplci5uZXh0VG9rZW4oKTtcbiAgICAgICAgICAgIHR5cGUgPSB0b2tlblswXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIihcIiB8fCB0eXBlID09PSBcIltcIikge1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzLnB1c2godHlwZSA9PT0gXCIoXCIgPyBcIilcIiA6IFwiXVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ7XCIgJiYgYnJhY2tldHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzLnB1c2goXCJ9XCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBicmFja2V0c1ticmFja2V0cy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJyYWNrZXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBcIjtcIikge1xuICAgICAgICAgICAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblsyXSk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VtaWNvbG9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIntcIikge1xuICAgICAgICAgICAgICAgICAgICBvcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoaWZ0ID0gcGFyYW1zLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gcGFyYW1zW3NoaWZ0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlKHByZXYgJiYgcHJldlswXSA9PT0gXCJzcGFjZVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gcGFyYW1zWy0tc2hpZnRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbihwcmV2WzNdIHx8IHByZXZbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmQodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICBsYXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlMi5yYXdzLmJldHdlZW4gPSB0aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbUVuZChwYXJhbXMpO1xuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgbm9kZTIucmF3cy5hZnRlck5hbWUgPSB0aGlzLnNwYWNlc0FuZENvbW1lbnRzRnJvbVN0YXJ0KHBhcmFtcyk7XG4gICAgICAgICAgICB0aGlzLnJhdyhub2RlMiwgXCJwYXJhbXNcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKHRva2VuWzNdIHx8IHRva2VuWzJdKTtcbiAgICAgICAgICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgIHRoaXMuc3BhY2VzID0gbm9kZTIucmF3cy5iZXR3ZWVuO1xuICAgICAgICAgICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub2RlMi5yYXdzLmFmdGVyTmFtZSA9IFwiXCI7XG4gICAgICAgICAgICBub2RlMi5wYXJhbXMgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcGVuKSB7XG4gICAgICAgICAgICBub2RlMi5ub2RlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gbm9kZTI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5jaGVja01pc3NlZFNlbWljb2xvbiA9IGZ1bmN0aW9uIGNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucykge1xuICAgICAgICB2YXIgY29sb24gPSB0aGlzLmNvbG9uKHRva2Vucyk7XG4gICAgICAgIGlmIChjb2xvbiA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgdmFyIGZvdW5kZWQgPSAwO1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIGZvcih2YXIgaiA9IGNvbG9uIC0gMTsgaiA+PSAwOyBqLS0pe1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbal07XG4gICAgICAgICAgICBpZiAodG9rZW5bMF0gIT09IFwic3BhY2VcIikge1xuICAgICAgICAgICAgICAgIGZvdW5kZWQgKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRlZCA9PT0gMikgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIk1pc3NlZCBzZW1pY29sb25cIiwgdG9rZW5bMF0gPT09IFwid29yZFwiID8gdG9rZW5bM10gKyAxIDogdG9rZW5bMl0pO1xuICAgIH07XG4gICAgX3Byb3RvLmNvbG9uID0gZnVuY3Rpb24gY29sb24odG9rZW5zKSB7XG4gICAgICAgIHZhciBicmFja2V0cyA9IDA7XG4gICAgICAgIHZhciB0b2tlbiwgdHlwZSwgcHJldjtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UodG9rZW5zLmVudHJpZXMoKSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBfc3RlcF92YWx1ZSA9IF9zdGVwLnZhbHVlLCBpMiA9IF9zdGVwX3ZhbHVlWzBdLCBlbGVtZW50ID0gX3N0ZXBfdmFsdWVbMV07XG4gICAgICAgICAgICB0b2tlbiA9IGVsZW1lbnQ7XG4gICAgICAgICAgICB0eXBlID0gdG9rZW5bMF07XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICBicmFja2V0cyArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgYnJhY2tldHMgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChicmFja2V0cyA9PT0gMCAmJiB0eXBlID09PSBcIjpcIikge1xuICAgICAgICAgICAgICAgIGlmICghcHJldikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvdWJsZUNvbG9uKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZXZbMF0gPT09IFwid29yZFwiICYmIHByZXZbMV0gPT09IFwicHJvZ2lkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXYgPSB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBfcHJvdG8uY29tbWVudCA9IGZ1bmN0aW9uIGNvbW1lbnQodG9rZW4pIHtcbiAgICAgICAgdmFyIG5vZGUyID0gbmV3IENvbW1lbnQkMigpO1xuICAgICAgICB0aGlzLmluaXQobm9kZTIsIHRva2VuWzJdKTtcbiAgICAgICAgbm9kZTIuc291cmNlLmVuZCA9IHRoaXMuZ2V0UG9zaXRpb24odG9rZW5bM10gfHwgdG9rZW5bMl0pO1xuICAgICAgICBub2RlMi5zb3VyY2UuZW5kLm9mZnNldCsrO1xuICAgICAgICB2YXIgdGV4dCA9IHRva2VuWzFdLnNsaWNlKDIsIC0yKTtcbiAgICAgICAgaWYgKC9eXFxzKiQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICAgIG5vZGUyLnRleHQgPSBcIlwiO1xuICAgICAgICAgICAgbm9kZTIucmF3cy5sZWZ0ID0gdGV4dDtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MucmlnaHQgPSBcIlwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gdGV4dC5tYXRjaCgvXihcXHMqKShbXl0qXFxTKShcXHMqKSQvKTtcbiAgICAgICAgICAgIG5vZGUyLnRleHQgPSBtYXRjaFsyXTtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MubGVmdCA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgbm9kZTIucmF3cy5yaWdodCA9IG1hdGNoWzNdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uY3JlYXRlVG9rZW5pemVyID0gZnVuY3Rpb24gY3JlYXRlVG9rZW5pemVyKCkge1xuICAgICAgICB0aGlzLnRva2VuaXplciA9IHRva2VuaXplcjIyKHRoaXMuaW5wdXQpO1xuICAgIH07XG4gICAgX3Byb3RvLmRlY2wgPSBmdW5jdGlvbiBkZWNsKHRva2VucywgY3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgdmFyIG5vZGUyID0gbmV3IERlY2xhcmF0aW9uJDIoKTtcbiAgICAgICAgdGhpcy5pbml0KG5vZGUyLCB0b2tlbnNbMF1bMl0pO1xuICAgICAgICB2YXIgbGFzdCA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChsYXN0WzBdID09PSBcIjtcIikge1xuICAgICAgICAgICAgdGhpcy5zZW1pY29sb24gPSB0cnVlO1xuICAgICAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUyLnNvdXJjZS5lbmQgPSB0aGlzLmdldFBvc2l0aW9uKGxhc3RbM10gfHwgbGFzdFsyXSB8fCBmaW5kTGFzdFdpdGhQb3NpdGlvbih0b2tlbnMpKTtcbiAgICAgICAgbm9kZTIuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgd2hpbGUodG9rZW5zWzBdWzBdICE9PSBcIndvcmRcIil7XG4gICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMSkgdGhpcy51bmtub3duV29yZCh0b2tlbnMpO1xuICAgICAgICAgICAgbm9kZTIucmF3cy5iZWZvcmUgKz0gdG9rZW5zLnNoaWZ0KClbMV07XG4gICAgICAgIH1cbiAgICAgICAgbm9kZTIuc291cmNlLnN0YXJ0ID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlbnNbMF1bMl0pO1xuICAgICAgICBub2RlMi5wcm9wID0gXCJcIjtcbiAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHRva2Vuc1swXVswXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIjpcIiB8fCB0eXBlID09PSBcInNwYWNlXCIgfHwgdHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUyLnByb3AgKz0gdG9rZW5zLnNoaWZ0KClbMV07XG4gICAgICAgIH1cbiAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gXCJcIjtcbiAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAodG9rZW5bMF0gPT09IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuICs9IHRva2VuWzFdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5bMF0gPT09IFwid29yZFwiICYmIC9cXHcvLnRlc3QodG9rZW5bMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5rbm93bldvcmQoW1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiArPSB0b2tlblsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZTIucHJvcFswXSA9PT0gXCJfXCIgfHwgbm9kZTIucHJvcFswXSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgIG5vZGUyLnJhd3MuYmVmb3JlICs9IG5vZGUyLnByb3BbMF07XG4gICAgICAgICAgICBub2RlMi5wcm9wID0gbm9kZTIucHJvcC5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3RTcGFjZXMgPSBbXTtcbiAgICAgICAgdmFyIG5leHQ7XG4gICAgICAgIHdoaWxlKHRva2Vucy5sZW5ndGgpe1xuICAgICAgICAgICAgbmV4dCA9IHRva2Vuc1swXVswXTtcbiAgICAgICAgICAgIGlmIChuZXh0ICE9PSBcInNwYWNlXCIgJiYgbmV4dCAhPT0gXCJjb21tZW50XCIpIGJyZWFrO1xuICAgICAgICAgICAgZmlyc3RTcGFjZXMucHVzaCh0b2tlbnMuc2hpZnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVjaGVja01pc3NlZFNlbWljb2xvbih0b2tlbnMpO1xuICAgICAgICBmb3IodmFyIGkyID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pe1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaTJdO1xuICAgICAgICAgICAgaWYgKHRva2VuWzFdLnRvTG93ZXJDYXNlKCkgPT09IFwiIWltcG9ydGFudFwiKSB7XG4gICAgICAgICAgICAgICAgbm9kZTIuaW1wb3J0YW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RyaW5nID0gdGhpcy5zdHJpbmdGcm9tKHRva2VucywgaTIpO1xuICAgICAgICAgICAgICAgIHN0cmluZyA9IHRoaXMuc3BhY2VzRnJvbUVuZCh0b2tlbnMpICsgc3RyaW5nO1xuICAgICAgICAgICAgICAgIGlmIChzdHJpbmcgIT09IFwiICFpbXBvcnRhbnRcIikgbm9kZTIucmF3cy5pbXBvcnRhbnQgPSBzdHJpbmc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuWzFdLnRvTG93ZXJDYXNlKCkgPT09IFwiaW1wb3J0YW50XCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSB0b2tlbnMuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBqID0gaTI7IGogPiAwOyBqLS0pe1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZTEgPSBjYWNoZVtqXVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ci50cmltKCkuaW5kZXhPZihcIiFcIikgPT09IDAgJiYgdHlwZTEgIT09IFwic3BhY2VcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RyID0gY2FjaGUucG9wKClbMV0gKyBzdHI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdHIudHJpbSgpLmluZGV4T2YoXCIhXCIpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLmltcG9ydGFudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUyLnJhd3MuaW1wb3J0YW50ID0gc3RyO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSBjYWNoZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW5bMF0gIT09IFwic3BhY2VcIiAmJiB0b2tlblswXSAhPT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzV29yZCA9IHRva2Vucy5zb21lKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgICAgICByZXR1cm4gaTJbMF0gIT09IFwic3BhY2VcIiAmJiBpMlswXSAhPT0gXCJjb21tZW50XCI7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaGFzV29yZCkge1xuICAgICAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuICs9IGZpcnN0U3BhY2VzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpMlsxXTtcbiAgICAgICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgICAgICAgICBmaXJzdFNwYWNlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmF3KG5vZGUyLCBcInZhbHVlXCIsIGZpcnN0U3BhY2VzLmNvbmNhdCh0b2tlbnMpLCBjdXN0b21Qcm9wZXJ0eSk7XG4gICAgICAgIGlmIChub2RlMi52YWx1ZS5pbmNsdWRlcyhcIjpcIikgJiYgIWN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrTWlzc2VkU2VtaWNvbG9uKHRva2Vucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5kb3VibGVDb2xvbiA9IGZ1bmN0aW9uIGRvdWJsZUNvbG9uKHRva2VuKSB7XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJEb3VibGUgY29sb25cIiwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlblsyXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuWzJdICsgdG9rZW5bMV0ubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmVtcHR5UnVsZSA9IGZ1bmN0aW9uIGVtcHR5UnVsZSh0b2tlbikge1xuICAgICAgICB2YXIgbm9kZTIgPSBuZXcgUnVsZSQyKCk7XG4gICAgICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5bMl0pO1xuICAgICAgICBub2RlMi5zZWxlY3RvciA9IFwiXCI7XG4gICAgICAgIG5vZGUyLnJhd3MuYmV0d2VlbiA9IFwiXCI7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IG5vZGUyO1xuICAgIH07XG4gICAgX3Byb3RvLmVuZCA9IGZ1bmN0aW9uIGVuZCh0b2tlbikge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzICYmIHRoaXMuY3VycmVudC5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5yYXdzLnNlbWljb2xvbiA9IHRoaXMuc2VtaWNvbG9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VtaWNvbG9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3VycmVudC5yYXdzLmFmdGVyID0gKHRoaXMuY3VycmVudC5yYXdzLmFmdGVyIHx8IFwiXCIpICsgdGhpcy5zcGFjZXM7XG4gICAgICAgIHRoaXMuc3BhY2VzID0gXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudC5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0b2tlblsyXSk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuc291cmNlLmVuZC5vZmZzZXQrKztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuY3VycmVudC5wYXJlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWRDbG9zZSh0b2tlbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5lbmRGaWxlID0gZnVuY3Rpb24gZW5kRmlsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudC5wYXJlbnQpIHRoaXMudW5jbG9zZWRCbG9jaygpO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Lm5vZGVzICYmIHRoaXMuY3VycmVudC5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudC5yYXdzLnNlbWljb2xvbiA9IHRoaXMuc2VtaWNvbG9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudC5yYXdzLmFmdGVyID0gKHRoaXMuY3VycmVudC5yYXdzLmFmdGVyIHx8IFwiXCIpICsgdGhpcy5zcGFjZXM7XG4gICAgICAgIHRoaXMucm9vdC5zb3VyY2UuZW5kID0gdGhpcy5nZXRQb3NpdGlvbih0aGlzLnRva2VuaXplci5wb3NpdGlvbigpKTtcbiAgICB9O1xuICAgIF9wcm90by5mcmVlU2VtaWNvbG9uID0gZnVuY3Rpb24gZnJlZVNlbWljb2xvbih0b2tlbikge1xuICAgICAgICB0aGlzLnNwYWNlcyArPSB0b2tlblsxXTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudC5ub2Rlcykge1xuICAgICAgICAgICAgdmFyIHByZXYgPSB0aGlzLmN1cnJlbnQubm9kZXNbdGhpcy5jdXJyZW50Lm5vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldi50eXBlID09PSBcInJ1bGVcIiAmJiAhcHJldi5yYXdzLm93blNlbWljb2xvbikge1xuICAgICAgICAgICAgICAgIHByZXYucmF3cy5vd25TZW1pY29sb24gPSB0aGlzLnNwYWNlcztcbiAgICAgICAgICAgICAgICB0aGlzLnNwYWNlcyA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEhlbHBlcnNcbiAgICBfcHJvdG8uZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRQb3NpdGlvbihvZmZzZXQpIHtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuaW5wdXQuZnJvbU9mZnNldChvZmZzZXQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sdW1uOiBwb3MuY29sLFxuICAgICAgICAgICAgbGluZTogcG9zLmxpbmUsXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgICB9O1xuICAgIH07XG4gICAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KG5vZGUyLCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50LnB1c2gobm9kZTIpO1xuICAgICAgICBub2RlMi5zb3VyY2UgPSB7XG4gICAgICAgICAgICBpbnB1dDogdGhpcy5pbnB1dCxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmdldFBvc2l0aW9uKG9mZnNldClcbiAgICAgICAgfTtcbiAgICAgICAgbm9kZTIucmF3cy5iZWZvcmUgPSB0aGlzLnNwYWNlcztcbiAgICAgICAgdGhpcy5zcGFjZXMgPSBcIlwiO1xuICAgICAgICBpZiAobm9kZTIudHlwZSAhPT0gXCJjb21tZW50XCIpIHRoaXMuc2VtaWNvbG9uID0gZmFsc2U7XG4gICAgfTtcbiAgICBfcHJvdG8ub3RoZXIgPSBmdW5jdGlvbiBvdGhlcihzdGFydCkge1xuICAgICAgICB2YXIgZW5kID0gZmFsc2U7XG4gICAgICAgIHZhciB0eXBlID0gbnVsbDtcbiAgICAgICAgdmFyIGNvbG9uID0gZmFsc2U7XG4gICAgICAgIHZhciBicmFja2V0ID0gbnVsbDtcbiAgICAgICAgdmFyIGJyYWNrZXRzID0gW107XG4gICAgICAgIHZhciBjdXN0b21Qcm9wZXJ0eSA9IHN0YXJ0WzFdLnN0YXJ0c1dpdGgoXCItLVwiKTtcbiAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICB2YXIgdG9rZW4gPSBzdGFydDtcbiAgICAgICAgd2hpbGUodG9rZW4pe1xuICAgICAgICAgICAgdHlwZSA9IHRva2VuWzBdO1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiKFwiIHx8IHR5cGUgPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFicmFja2V0KSBicmFja2V0ID0gdG9rZW47XG4gICAgICAgICAgICAgICAgYnJhY2tldHMucHVzaCh0eXBlID09PSBcIihcIiA/IFwiKVwiIDogXCJdXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjdXN0b21Qcm9wZXJ0eSAmJiBjb2xvbiAmJiB0eXBlID09PSBcIntcIikge1xuICAgICAgICAgICAgICAgIGlmICghYnJhY2tldCkgYnJhY2tldCA9IHRva2VuO1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzLnB1c2goXCJ9XCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCI7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY2wodG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ7XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydWxlKHRva2Vucyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9rZW5pemVyLmJhY2sodG9rZW5zLnBvcCgpKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgICBjb2xvbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBicmFja2V0c1ticmFja2V0cy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIGJyYWNrZXRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChicmFja2V0cy5sZW5ndGggPT09IDApIGJyYWNrZXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRva2VuaXplci5uZXh0VG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50b2tlbml6ZXIuZW5kT2ZGaWxlKCkpIGVuZCA9IHRydWU7XG4gICAgICAgIGlmIChicmFja2V0cy5sZW5ndGggPiAwKSB0aGlzLnVuY2xvc2VkQnJhY2tldChicmFja2V0KTtcbiAgICAgICAgaWYgKGVuZCAmJiBjb2xvbikge1xuICAgICAgICAgICAgaWYgKCFjdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHdoaWxlKHRva2Vucy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gXCJzcGFjZVwiICYmIHRva2VuICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9rZW5pemVyLmJhY2sodG9rZW5zLnBvcCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRlY2wodG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVua25vd25Xb3JkKHRva2Vucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKCkge1xuICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgIHdoaWxlKCF0aGlzLnRva2VuaXplci5lbmRPZkZpbGUoKSl7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5leHRUb2tlbigpO1xuICAgICAgICAgICAgc3dpdGNoKHRva2VuWzBdKXtcbiAgICAgICAgICAgICAgICBjYXNlIFwic3BhY2VcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGFjZXMgKz0gdG9rZW5bMV07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCI7XCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJlZVNlbWljb2xvbih0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ9XCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNvbW1lbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21tZW50KHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImF0LXdvcmRcIjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHJ1bGUodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwie1wiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtcHR5UnVsZSh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3RoZXIodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuZEZpbGUoKTtcbiAgICB9O1xuICAgIF9wcm90by5wcmVjaGVja01pc3NlZFNlbWljb2xvbiA9IGZ1bmN0aW9uIHByZWNoZWNrTWlzc2VkU2VtaWNvbG9uKCkge307XG4gICAgX3Byb3RvLnJhdyA9IGZ1bmN0aW9uIHJhdyhub2RlMiwgcHJvcCwgdG9rZW5zLCBjdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB2YXIgdG9rZW4sIHR5cGU7XG4gICAgICAgIHZhciBsZW5ndGggPSB0b2tlbnMubGVuZ3RoO1xuICAgICAgICB2YXIgdmFsdWUgPSBcIlwiO1xuICAgICAgICB2YXIgY2xlYW4gPSB0cnVlO1xuICAgICAgICB2YXIgbmV4dCwgcHJldjtcbiAgICAgICAgZm9yKHZhciBpMiA9IDA7IGkyIDwgbGVuZ3RoOyBpMiArPSAxKXtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2kyXTtcbiAgICAgICAgICAgIHR5cGUgPSB0b2tlblswXTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcInNwYWNlXCIgJiYgaTIgPT09IGxlbmd0aCAtIDEgJiYgIWN1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gdG9rZW5zW2kyIC0gMV0gPyB0b2tlbnNbaTIgLSAxXVswXSA6IFwiZW1wdHlcIjtcbiAgICAgICAgICAgICAgICBuZXh0ID0gdG9rZW5zW2kyICsgMV0gPyB0b2tlbnNbaTIgKyAxXVswXSA6IFwiZW1wdHlcIjtcbiAgICAgICAgICAgICAgICBpZiAoIVNBRkVfQ09NTUVOVF9ORUlHSEJPUltwcmV2XSAmJiAhU0FGRV9DT01NRU5UX05FSUdIQk9SW25leHRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5zbGljZSgtMSkgPT09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gdG9rZW5bMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gdG9rZW5bMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjbGVhbikge1xuICAgICAgICAgICAgdmFyIHJhdyA9IHRva2Vucy5yZWR1Y2UoZnVuY3Rpb24oYWxsLCBpMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbGwgKyBpMlsxXTtcbiAgICAgICAgICAgIH0sIFwiXCIpO1xuICAgICAgICAgICAgbm9kZTIucmF3c1twcm9wXSA9IHtcbiAgICAgICAgICAgICAgICByYXc6IHJhdyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbm9kZTJbcHJvcF0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIF9wcm90by5ydWxlID0gZnVuY3Rpb24gcnVsZSh0b2tlbnMpIHtcbiAgICAgICAgdG9rZW5zLnBvcCgpO1xuICAgICAgICB2YXIgbm9kZTIgPSBuZXcgUnVsZSQyKCk7XG4gICAgICAgIHRoaXMuaW5pdChub2RlMiwgdG9rZW5zWzBdWzJdKTtcbiAgICAgICAgbm9kZTIucmF3cy5iZXR3ZWVuID0gdGhpcy5zcGFjZXNBbmRDb21tZW50c0Zyb21FbmQodG9rZW5zKTtcbiAgICAgICAgdGhpcy5yYXcobm9kZTIsIFwic2VsZWN0b3JcIiwgdG9rZW5zKTtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbm9kZTI7XG4gICAgfTtcbiAgICBfcHJvdG8uc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kID0gZnVuY3Rpb24gc3BhY2VzQW5kQ29tbWVudHNGcm9tRW5kKHRva2Vucykge1xuICAgICAgICB2YXIgbGFzdFRva2VuVHlwZTtcbiAgICAgICAgdmFyIHNwYWNlcyA9IFwiXCI7XG4gICAgICAgIHdoaWxlKHRva2Vucy5sZW5ndGgpe1xuICAgICAgICAgICAgbGFzdFRva2VuVHlwZSA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1bMF07XG4gICAgICAgICAgICBpZiAobGFzdFRva2VuVHlwZSAhPT0gXCJzcGFjZVwiICYmIGxhc3RUb2tlblR5cGUgIT09IFwiY29tbWVudFwiKSBicmVhaztcbiAgICAgICAgICAgIHNwYWNlcyA9IHRva2Vucy5wb3AoKVsxXSArIHNwYWNlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhY2VzO1xuICAgIH07XG4gICAgLy8gRXJyb3JzXG4gICAgX3Byb3RvLnNwYWNlc0FuZENvbW1lbnRzRnJvbVN0YXJ0ID0gZnVuY3Rpb24gc3BhY2VzQW5kQ29tbWVudHNGcm9tU3RhcnQodG9rZW5zKSB7XG4gICAgICAgIHZhciBuZXh0O1xuICAgICAgICB2YXIgc3BhY2VzID0gXCJcIjtcbiAgICAgICAgd2hpbGUodG9rZW5zLmxlbmd0aCl7XG4gICAgICAgICAgICBuZXh0ID0gdG9rZW5zWzBdWzBdO1xuICAgICAgICAgICAgaWYgKG5leHQgIT09IFwic3BhY2VcIiAmJiBuZXh0ICE9PSBcImNvbW1lbnRcIikgYnJlYWs7XG4gICAgICAgICAgICBzcGFjZXMgKz0gdG9rZW5zLnNoaWZ0KClbMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYWNlcztcbiAgICB9O1xuICAgIF9wcm90by5zcGFjZXNGcm9tRW5kID0gZnVuY3Rpb24gc3BhY2VzRnJvbUVuZCh0b2tlbnMpIHtcbiAgICAgICAgdmFyIGxhc3RUb2tlblR5cGU7XG4gICAgICAgIHZhciBzcGFjZXMgPSBcIlwiO1xuICAgICAgICB3aGlsZSh0b2tlbnMubGVuZ3RoKXtcbiAgICAgICAgICAgIGxhc3RUb2tlblR5cGUgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdWzBdO1xuICAgICAgICAgICAgaWYgKGxhc3RUb2tlblR5cGUgIT09IFwic3BhY2VcIikgYnJlYWs7XG4gICAgICAgICAgICBzcGFjZXMgPSB0b2tlbnMucG9wKClbMV0gKyBzcGFjZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYWNlcztcbiAgICB9O1xuICAgIF9wcm90by5zdHJpbmdGcm9tID0gZnVuY3Rpb24gc3RyaW5nRnJvbSh0b2tlbnMsIGZyb20pIHtcbiAgICAgICAgdmFyIHJlc3VsdDIgPSBcIlwiO1xuICAgICAgICBmb3IodmFyIGkyID0gZnJvbTsgaTIgPCB0b2tlbnMubGVuZ3RoOyBpMisrKXtcbiAgICAgICAgICAgIHJlc3VsdDIgKz0gdG9rZW5zW2kyXVsxXTtcbiAgICAgICAgfVxuICAgICAgICB0b2tlbnMuc3BsaWNlKGZyb20sIHRva2Vucy5sZW5ndGggLSBmcm9tKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgfTtcbiAgICBfcHJvdG8udW5jbG9zZWRCbG9jayA9IGZ1bmN0aW9uIHVuY2xvc2VkQmxvY2soKSB7XG4gICAgICAgIHZhciBwb3MgPSB0aGlzLmN1cnJlbnQuc291cmNlLnN0YXJ0O1xuICAgICAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiVW5jbG9zZWQgYmxvY2tcIiwgcG9zLmxpbmUsIHBvcy5jb2x1bW4pO1xuICAgIH07XG4gICAgX3Byb3RvLnVuY2xvc2VkQnJhY2tldCA9IGZ1bmN0aW9uIHVuY2xvc2VkQnJhY2tldChicmFja2V0KSB7XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJVbmNsb3NlZCBicmFja2V0XCIsIHtcbiAgICAgICAgICAgIG9mZnNldDogYnJhY2tldFsyXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvZmZzZXQ6IGJyYWNrZXRbMl0gKyAxXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnVuZXhwZWN0ZWRDbG9zZSA9IGZ1bmN0aW9uIHVuZXhwZWN0ZWRDbG9zZSh0b2tlbikge1xuICAgICAgICB0aHJvdyB0aGlzLmlucHV0LmVycm9yKFwiVW5leHBlY3RlZCB9XCIsIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5bMl1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAgb2Zmc2V0OiB0b2tlblsyXSArIDFcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8udW5rbm93bldvcmQgPSBmdW5jdGlvbiB1bmtub3duV29yZCh0b2tlbnMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5pbnB1dC5lcnJvcihcIlVua25vd24gd29yZFwiLCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2Vuc1swXVsyXVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2Vuc1swXVsyXSArIHRva2Vuc1swXVsxXS5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8udW5uYW1lZEF0cnVsZSA9IGZ1bmN0aW9uIHVubmFtZWRBdHJ1bGUobm9kZTIsIHRva2VuKSB7XG4gICAgICAgIHRocm93IHRoaXMuaW5wdXQuZXJyb3IoXCJBdC1ydWxlIHdpdGhvdXQgbmFtZVwiLCB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRva2VuWzJdXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG9mZnNldDogdG9rZW5bMl0gKyB0b2tlblsxXS5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyc2VyMjtcbn0oKTtcbnZhciBwYXJzZXIgPSBQYXJzZXIkMTtcbnZhciBDb250YWluZXIkMiA9IGNvbnRhaW5lcjtcbnZhciBQYXJzZXIyMiA9IHBhcnNlcjtcbnZhciBJbnB1dCQyID0gaW5wdXQ7XG5mdW5jdGlvbiBwYXJzZSQzKGNzcywgb3B0cykge1xuICAgIHZhciBpbnB1dDIgPSBuZXcgSW5wdXQkMihjc3MsIG9wdHMpO1xuICAgIHZhciBwYXJzZXIyID0gbmV3IFBhcnNlcjIyKGlucHV0Mik7XG4gICAgdHJ5IHtcbiAgICAgICAgcGFyc2VyMi5wYXJzZSgpO1xuICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmIChlMi5uYW1lID09PSBcIkNzc1N5bnRheEVycm9yXCIgJiYgb3B0cyAmJiBvcHRzLmZyb20pIHtcbiAgICAgICAgICAgICAgICBpZiAoL1xcLnNjc3MkL2kudGVzdChvcHRzLmZyb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIGUyLm1lc3NhZ2UgKz0gXCJcXG5Zb3UgdHJpZWQgdG8gcGFyc2UgU0NTUyB3aXRoIHRoZSBzdGFuZGFyZCBDU1MgcGFyc2VyOyB0cnkgYWdhaW4gd2l0aCB0aGUgcG9zdGNzcy1zY3NzIHBhcnNlclwiO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoL1xcLnNhc3MvaS50ZXN0KG9wdHMuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZTIubWVzc2FnZSArPSBcIlxcbllvdSB0cmllZCB0byBwYXJzZSBTYXNzIHdpdGggdGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7IHRyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLXNhc3MgcGFyc2VyXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvXFwubGVzcyQvaS50ZXN0KG9wdHMuZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZTIubWVzc2FnZSArPSBcIlxcbllvdSB0cmllZCB0byBwYXJzZSBMZXNzIHdpdGggdGhlIHN0YW5kYXJkIENTUyBwYXJzZXI7IHRyeSBhZ2FpbiB3aXRoIHRoZSBwb3N0Y3NzLWxlc3MgcGFyc2VyXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGUyO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VyMi5yb290O1xufVxudmFyIHBhcnNlXzEgPSBwYXJzZSQzO1xucGFyc2UkMy5kZWZhdWx0ID0gcGFyc2UkMztcbkNvbnRhaW5lciQyLnJlZ2lzdGVyUGFyc2UocGFyc2UkMyk7XG52YXIgaXNDbGVhbiA9IHN5bWJvbHMuaXNDbGVhbiwgbXkgPSBzeW1ib2xzLm15O1xudmFyIE1hcEdlbmVyYXRvciQxID0gbWFwR2VuZXJhdG9yO1xudmFyIHN0cmluZ2lmeSQyID0gc3RyaW5naWZ5XzE7XG52YXIgQ29udGFpbmVyJDEgPSBjb250YWluZXI7XG52YXIgRG9jdW1lbnQkMiA9IGRvY3VtZW50JDEkMjtcbnZhciB3YXJuT25jZSQxID0gd2Fybk9uY2UkMjtcbnZhciBSZXN1bHQkMiA9IHJlc3VsdDtcbnZhciBwYXJzZSQyID0gcGFyc2VfMTtcbnZhciBSb290JDMgPSByb290O1xudmFyIFRZUEVfVE9fQ0xBU1NfTkFNRSA9IHtcbiAgICBhdHJ1bGU6IFwiQXRSdWxlXCIsXG4gICAgY29tbWVudDogXCJDb21tZW50XCIsXG4gICAgZGVjbDogXCJEZWNsYXJhdGlvblwiLFxuICAgIGRvY3VtZW50OiBcIkRvY3VtZW50XCIsXG4gICAgcm9vdDogXCJSb290XCIsXG4gICAgcnVsZTogXCJSdWxlXCJcbn07XG52YXIgUExVR0lOX1BST1BTID0ge1xuICAgIEF0UnVsZTogdHJ1ZSxcbiAgICBBdFJ1bGVFeGl0OiB0cnVlLFxuICAgIENvbW1lbnQ6IHRydWUsXG4gICAgQ29tbWVudEV4aXQ6IHRydWUsXG4gICAgRGVjbGFyYXRpb246IHRydWUsXG4gICAgRGVjbGFyYXRpb25FeGl0OiB0cnVlLFxuICAgIERvY3VtZW50OiB0cnVlLFxuICAgIERvY3VtZW50RXhpdDogdHJ1ZSxcbiAgICBPbmNlOiB0cnVlLFxuICAgIE9uY2VFeGl0OiB0cnVlLFxuICAgIHBvc3Rjc3NQbHVnaW46IHRydWUsXG4gICAgcHJlcGFyZTogdHJ1ZSxcbiAgICBSb290OiB0cnVlLFxuICAgIFJvb3RFeGl0OiB0cnVlLFxuICAgIFJ1bGU6IHRydWUsXG4gICAgUnVsZUV4aXQ6IHRydWVcbn07XG52YXIgTk9UX1ZJU0lUT1JTID0ge1xuICAgIE9uY2U6IHRydWUsXG4gICAgcG9zdGNzc1BsdWdpbjogdHJ1ZSxcbiAgICBwcmVwYXJlOiB0cnVlXG59O1xudmFyIENISUxEUkVOID0gMDtcbmZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2Yob2JqKSkgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iai50aGVuID09PSBcImZ1bmN0aW9uXCI7XG59XG5mdW5jdGlvbiBnZXRFdmVudHMobm9kZTIpIHtcbiAgICB2YXIga2V5ID0gZmFsc2U7XG4gICAgdmFyIHR5cGUgPSBUWVBFX1RPX0NMQVNTX05BTUVbbm9kZTIudHlwZV07XG4gICAgaWYgKG5vZGUyLnR5cGUgPT09IFwiZGVjbFwiKSB7XG4gICAgICAgIGtleSA9IG5vZGUyLnByb3AudG9Mb3dlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUyLnR5cGUgPT09IFwiYXRydWxlXCIpIHtcbiAgICAgICAga2V5ID0gbm9kZTIubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICBpZiAoa2V5ICYmIG5vZGUyLmFwcGVuZCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHR5cGUgKyBcIi1cIiArIGtleSxcbiAgICAgICAgICAgIENISUxEUkVOLFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdFwiLFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdC1cIiArIGtleVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAoa2V5KSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgdHlwZSArIFwiLVwiICsga2V5LFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdFwiLFxuICAgICAgICAgICAgdHlwZSArIFwiRXhpdC1cIiArIGtleVxuICAgICAgICBdO1xuICAgIH0gZWxzZSBpZiAobm9kZTIuYXBwZW5kKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgQ0hJTERSRU4sXG4gICAgICAgICAgICB0eXBlICsgXCJFeGl0XCJcbiAgICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIHR5cGUgKyBcIkV4aXRcIlxuICAgICAgICBdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvU3RhY2sobm9kZTIpIHtcbiAgICB2YXIgZXZlbnRzO1xuICAgIGlmIChub2RlMi50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgZXZlbnRzID0gW1xuICAgICAgICAgICAgXCJEb2N1bWVudFwiLFxuICAgICAgICAgICAgQ0hJTERSRU4sXG4gICAgICAgICAgICBcIkRvY3VtZW50RXhpdFwiXG4gICAgICAgIF07XG4gICAgfSBlbHNlIGlmIChub2RlMi50eXBlID09PSBcInJvb3RcIikge1xuICAgICAgICBldmVudHMgPSBbXG4gICAgICAgICAgICBcIlJvb3RcIixcbiAgICAgICAgICAgIENISUxEUkVOLFxuICAgICAgICAgICAgXCJSb290RXhpdFwiXG4gICAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZXZlbnRzID0gZ2V0RXZlbnRzKG5vZGUyKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZlbnRJbmRleDogMCxcbiAgICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICAgIGl0ZXJhdG9yOiAwLFxuICAgICAgICBub2RlOiBub2RlMixcbiAgICAgICAgdmlzaXRvckluZGV4OiAwLFxuICAgICAgICB2aXNpdG9yczogW11cbiAgICB9O1xufVxuZnVuY3Rpb24gY2xlYW5NYXJrcyhub2RlMikge1xuICAgIG5vZGUyW2lzQ2xlYW5dID0gZmFsc2U7XG4gICAgaWYgKG5vZGUyLm5vZGVzKSBub2RlMi5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBjbGVhbk1hcmtzKGkyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZTI7XG59XG52YXIgcG9zdGNzcyQyID0ge307XG52YXIgTGF6eVJlc3VsdCQyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBMYXp5UmVzdWx0Mihwcm9jZXNzb3IyLCBjc3MsIG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdHJpbmdpZmllZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb2Nlc3NlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgcm9vdDI7XG4gICAgICAgIGlmICgodHlwZW9mIGNzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihjc3MpKSA9PT0gXCJvYmplY3RcIiAmJiBjc3MgIT09IG51bGwgJiYgKGNzcy50eXBlID09PSBcInJvb3RcIiB8fCBjc3MudHlwZSA9PT0gXCJkb2N1bWVudFwiKSkge1xuICAgICAgICAgICAgcm9vdDIgPSBjbGVhbk1hcmtzKGNzcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YoY3NzLCBMYXp5UmVzdWx0MikgfHwgX2luc3RhbmNlb2YoY3NzLCBSZXN1bHQkMikpIHtcbiAgICAgICAgICAgIHJvb3QyID0gY2xlYW5NYXJrcyhjc3Mucm9vdCk7XG4gICAgICAgICAgICBpZiAoY3NzLm1hcCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cy5tYXAgPT09IFwidW5kZWZpbmVkXCIpIG9wdHMubWFwID0ge307XG4gICAgICAgICAgICAgICAgaWYgKCFvcHRzLm1hcC5pbmxpbmUpIG9wdHMubWFwLmlubGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG9wdHMubWFwLnByZXYgPSBjc3MubWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBhcnNlcjIgPSBwYXJzZSQyO1xuICAgICAgICAgICAgaWYgKG9wdHMuc3ludGF4KSBwYXJzZXIyID0gb3B0cy5zeW50YXgucGFyc2U7XG4gICAgICAgICAgICBpZiAob3B0cy5wYXJzZXIpIHBhcnNlcjIgPSBvcHRzLnBhcnNlcjtcbiAgICAgICAgICAgIGlmIChwYXJzZXIyLnBhcnNlKSBwYXJzZXIyID0gcGFyc2VyMi5wYXJzZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcm9vdDIgPSBwYXJzZXIyKGNzcywgb3B0cyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm9vdDIgJiYgIXJvb3QyW215XSkge1xuICAgICAgICAgICAgICAgIENvbnRhaW5lciQxLnJlYnVpbGQocm9vdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzdWx0ID0gbmV3IFJlc3VsdCQyKHByb2Nlc3NvcjIsIHJvb3QyLCBvcHRzKTtcbiAgICAgICAgdGhpcy5oZWxwZXJzID0gX2V4dGVuZHMoe30sIHBvc3Rjc3MkMiwge1xuICAgICAgICAgICAgcG9zdGNzczogcG9zdGNzcyQyLFxuICAgICAgICAgICAgcmVzdWx0OiB0aGlzLnJlc3VsdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gdGhpcy5wcm9jZXNzb3IucGx1Z2lucy5tYXAoZnVuY3Rpb24ocGx1Z2luMjIpIHtcbiAgICAgICAgICAgIGlmICgodHlwZW9mIHBsdWdpbjIyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKHBsdWdpbjIyKSkgPT09IFwib2JqZWN0XCIgJiYgcGx1Z2luMjIucHJlcGFyZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgcGx1Z2luMjIsIHBsdWdpbjIyLnByZXBhcmUoX3RoaXMucmVzdWx0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW4yMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBMYXp5UmVzdWx0Mi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmFzeW5jID0gZnVuY3Rpb24gYXN5bmMoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSByZXR1cm4gUHJvbWlzZS5yZWplY3QodGhpcy5lcnJvcik7XG4gICAgICAgIGlmICh0aGlzLnByb2Nlc3NlZCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnJlc3VsdCk7XG4gICAgICAgIGlmICghdGhpcy5wcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmcgPSB0aGlzLnJ1bkFzeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc2luZztcbiAgICB9O1xuICAgIF9wcm90by5jYXRjaCA9IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jKCkuY2F0Y2gob25SZWplY3RlZCk7XG4gICAgfTtcbiAgICBfcHJvdG8uZmluYWxseSA9IGZ1bmN0aW9uIF9maW5hbGx5KG9uRmluYWxseSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GaW5hbGx5LCBvbkZpbmFsbHkpO1xuICAgIH07XG4gICAgX3Byb3RvLmdldEFzeW5jRXJyb3IgPSBmdW5jdGlvbiBnZXRBc3luY0Vycm9yKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2UgcHJvY2Vzcyhjc3MpLnRoZW4oY2IpIHRvIHdvcmsgd2l0aCBhc3luYyBwbHVnaW5zXCIpO1xuICAgIH07XG4gICAgX3Byb3RvLmhhbmRsZUVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyb3IsIG5vZGUyKSB7XG4gICAgICAgIHZhciBwbHVnaW4yMiA9IHRoaXMucmVzdWx0Lmxhc3RQbHVnaW47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobm9kZTIpIG5vZGUyLmFkZFRvRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09IFwiQ3NzU3ludGF4RXJyb3JcIiAmJiAhZXJyb3IucGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IucGx1Z2luID0gcGx1Z2luMjIucG9zdGNzc1BsdWdpbjtcbiAgICAgICAgICAgICAgICBlcnJvci5zZXRNZXNzYWdlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBsdWdpbjIyLnBvc3Rjc3NWZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGx1Z2luTmFtZSA9IHBsdWdpbjIyLnBvc3Rjc3NQbHVnaW47XG4gICAgICAgICAgICAgICAgICAgIHZhciBwbHVnaW5WZXIgPSBwbHVnaW4yMi5wb3N0Y3NzVmVyc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bnRpbWVWZXIgPSB0aGlzLnJlc3VsdC5wcm9jZXNzb3IudmVyc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEyID0gcGx1Z2luVmVyLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBydW50aW1lVmVyLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEyWzBdICE9PSBiWzBdIHx8IHBhcnNlSW50KGEyWzFdKSA+IHBhcnNlSW50KGJbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5rbm93biBlcnJvciBmcm9tIFBvc3RDU1MgcGx1Z2luLiBZb3VyIGN1cnJlbnQgUG9zdENTUyB2ZXJzaW9uIGlzIFwiICsgcnVudGltZVZlciArIFwiLCBidXQgXCIgKyBwbHVnaW5OYW1lICsgXCIgdXNlcyBcIiArIHBsdWdpblZlciArIFwiLiBQZXJoYXBzIHRoaXMgaXMgdGhlIHNvdXJjZSBvZiB0aGUgZXJyb3IgYmVsb3cuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfTtcbiAgICBfcHJvdG8ucHJlcGFyZVZpc2l0b3JzID0gZnVuY3Rpb24gcHJlcGFyZVZpc2l0b3JzKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xuICAgICAgICB2YXIgYWRkID0gZnVuY3Rpb24ocGx1Z2luMjIsIHR5cGUsIGNiKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmxpc3RlbmVyc1t0eXBlXSkgX3RoaXMubGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICAgICAgICBfdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaChbXG4gICAgICAgICAgICAgICAgcGx1Z2luMjIsXG4gICAgICAgICAgICAgICAgY2JcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh0aGlzLnBsdWdpbnMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgcGx1Z2luMjIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmICgodHlwZW9mIHBsdWdpbjIyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKHBsdWdpbjIyKSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGV2ZW50IGluIHBsdWdpbjIyKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFQTFVHSU5fUFJPUFNbZXZlbnRdICYmIC9eW0EtWl0vLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGV2ZW50IFwiICsgZXZlbnQgKyBcIiBpbiBcIiArIHBsdWdpbjIyLnBvc3Rjc3NQbHVnaW4gKyBcIi4gVHJ5IHRvIHVwZGF0ZSBQb3N0Q1NTIChcIiArIHRoaXMucHJvY2Vzc29yLnZlcnNpb24gKyBcIiBub3cpLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIU5PVF9WSVNJVE9SU1tldmVudF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdHlwZV9vZihwbHVnaW4yMltldmVudF0pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBmaWx0ZXIgaW4gcGx1Z2luMjJbZXZlbnRdKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlciA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZChwbHVnaW4yMiwgZXZlbnQsIHBsdWdpbjIyW2V2ZW50XVtmaWx0ZXJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZChwbHVnaW4yMiwgZXZlbnQgKyBcIi1cIiArIGZpbHRlci50b0xvd2VyQ2FzZSgpLCBwbHVnaW4yMltldmVudF1bZmlsdGVyXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4yMltldmVudF0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZChwbHVnaW4yMiwgZXZlbnQsIHBsdWdpbjIyW2V2ZW50XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYXNMaXN0ZW5lciA9IE9iamVjdC5rZXlzKHRoaXMubGlzdGVuZXJzKS5sZW5ndGggPiAwO1xuICAgIH07XG4gICAgX3Byb3RvLnJ1bkFzeW5jID0gZnVuY3Rpb24gcnVuQXN5bmMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGkyLCBwbHVnaW4yMiwgcHJvbWlzZSwgZXJyb3IsIHJvb3QyLCBzdGFjaywgcHJvbWlzZTEsIGUyLCBub2RlMiwgX2xvb3AsIF9pdGVyYXRvciwgX3N0ZXA7XG4gICAgICAgICAgICByZXR1cm4gX3RzX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbihfc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2goX3N0YXRlLmxhYmVsKXtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucGx1Z2luID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGkyIDwgX3RoaXMucGx1Z2lucy5sZW5ndGgpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbjIyID0gX3RoaXMucGx1Z2luc1tpMl07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlID0gX3RoaXMucnVuT25Sb290KHBsdWdpbjIyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQcm9taXNlKHByb21pc2UpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS50cnlzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNVxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IF9zdGF0ZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGkyKys7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJlcGFyZVZpc2l0b3JzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmhhc0xpc3RlbmVyKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMThcbiAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICByb290MiA9IF90aGlzLnJlc3VsdC5yb290O1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gNztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhcm9vdDJbaXNDbGVhbl0pIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxNFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvb3QyW2lzQ2xlYW5dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RhY2socm9vdDIpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gODtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoc3RhY2subGVuZ3RoID4gMCkpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxM1xuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UxID0gX3RoaXMudmlzaXRUaWNrKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNQcm9taXNlKHByb21pc2UxKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEyXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLmxhYmVsID0gOTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnRyeXMucHVzaChbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UxXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMlxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUyID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0ubm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IF90aGlzLmhhbmRsZUVycm9yKGUyLCBub2RlMik7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA3XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9zdGVwX3ZhbHVlLCBwbHVnaW4yMiwgdmlzaXRvciwgcm9vdHMsIGUyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdHNfZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uKF9zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2goX3N0YXRlLmxhYmVsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RlcF92YWx1ZSA9IF9zdGVwLnZhbHVlLCBwbHVnaW4yMiA9IF9zdGVwX3ZhbHVlWzBdLCB2aXNpdG9yID0gX3N0ZXBfdmFsdWVbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS50cnlzLnB1c2goW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA2LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShyb290Mi50eXBlID09PSBcImRvY3VtZW50XCIpKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290cyA9IHJvb3QyLm5vZGVzLm1hcChmdW5jdGlvbihzdWJSb290KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdG9yKHN1YlJvb3QsIF90aGlzLmhlbHBlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHJvb3RzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA1XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aXNpdG9yKHJvb3QyLCBfdGhpcy5oZWxwZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfc3RhdGUubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBfdGhpcy5oYW5kbGVFcnJvcihlMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoX3RoaXMubGlzdGVuZXJzLk9uY2VFeGl0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDE1O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmUpIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxOFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdHNfdmFsdWVzKF9sb29wKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdGF0ZS5sYWJlbCA9IDE3O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE1XG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdHJpbmdpZnkoKVxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoKTtcbiAgICB9O1xuICAgIF9wcm90by5ydW5PblJvb3QgPSBmdW5jdGlvbiBydW5PblJvb3QocGx1Z2luMjIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXN1bHQubGFzdFBsdWdpbiA9IHBsdWdpbjIyO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCh0eXBlb2YgcGx1Z2luMjIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YocGx1Z2luMjIpKSA9PT0gXCJvYmplY3RcIiAmJiBwbHVnaW4yMi5PbmNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0LnJvb3QudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb290cyA9IHRoaXMucmVzdWx0LnJvb3Qubm9kZXMubWFwKGZ1bmN0aW9uKHJvb3QyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGx1Z2luMjIuT25jZShyb290MiwgX3RoaXMuaGVscGVycyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlKHJvb3RzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJvb3RzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwbHVnaW4yMi5PbmNlKHRoaXMucmVzdWx0LnJvb3QsIHRoaXMuaGVscGVycyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW4yMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsdWdpbjIyKHRoaXMucmVzdWx0LnJvb3QsIHRoaXMucmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8uc3RyaW5naWZ5ID0gZnVuY3Rpb24gc3RyaW5naWZ5KCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICAgICAgaWYgKHRoaXMuc3RyaW5naWZpZWQpIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICAgICAgdGhpcy5zdHJpbmdpZmllZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3luYygpO1xuICAgICAgICB2YXIgb3B0cyA9IHRoaXMucmVzdWx0Lm9wdHM7XG4gICAgICAgIHZhciBzdHIgPSBzdHJpbmdpZnkkMjtcbiAgICAgICAgaWYgKG9wdHMuc3ludGF4KSBzdHIgPSBvcHRzLnN5bnRheC5zdHJpbmdpZnk7XG4gICAgICAgIGlmIChvcHRzLnN0cmluZ2lmaWVyKSBzdHIgPSBvcHRzLnN0cmluZ2lmaWVyO1xuICAgICAgICBpZiAoc3RyLnN0cmluZ2lmeSkgc3RyID0gc3RyLnN0cmluZ2lmeTtcbiAgICAgICAgdmFyIG1hcCA9IG5ldyBNYXBHZW5lcmF0b3IkMShzdHIsIHRoaXMucmVzdWx0LnJvb3QsIHRoaXMucmVzdWx0Lm9wdHMpO1xuICAgICAgICB2YXIgZGF0YSA9IG1hcC5nZW5lcmF0ZSgpO1xuICAgICAgICB0aGlzLnJlc3VsdC5jc3MgPSBkYXRhWzBdO1xuICAgICAgICB0aGlzLnJlc3VsdC5tYXAgPSBkYXRhWzFdO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgfTtcbiAgICBfcHJvdG8uc3luYyA9IGZ1bmN0aW9uIHN5bmMoKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB0aHJvdyB0aGlzLmVycm9yO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzZWQpIHJldHVybiB0aGlzLnJlc3VsdDtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLmdldEFzeW5jRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh0aGlzLnBsdWdpbnMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgcGx1Z2luMjIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBwcm9taXNlID0gdGhpcy5ydW5PblJvb3QocGx1Z2luMjIpO1xuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZ2V0QXN5bmNFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlcGFyZVZpc2l0b3JzKCk7XG4gICAgICAgIGlmICh0aGlzLmhhc0xpc3RlbmVyKSB7XG4gICAgICAgICAgICB2YXIgcm9vdDIgPSB0aGlzLnJlc3VsdC5yb290O1xuICAgICAgICAgICAgd2hpbGUoIXJvb3QyW2lzQ2xlYW5dKXtcbiAgICAgICAgICAgICAgICByb290Mltpc0NsZWFuXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrU3luYyhyb290Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnMuT25jZUV4aXQpIHtcbiAgICAgICAgICAgICAgICBpZiAocm9vdDIudHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yMSA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShyb290Mi5ub2RlcyksIF9zdGVwMTsgIShfc3RlcDEgPSBfaXRlcmF0b3IxKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWJSb290ID0gX3N0ZXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdFN5bmModGhpcy5saXN0ZW5lcnMuT25jZUV4aXQsIHN1YlJvb3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdFN5bmModGhpcy5saXN0ZW5lcnMuT25jZUV4aXQsIHJvb3QyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghKFwiZnJvbVwiIGluIHRoaXMub3B0cykpIHtcbiAgICAgICAgICAgICAgICB3YXJuT25jZSQxKFwiV2l0aG91dCBgZnJvbWAgb3B0aW9uIFBvc3RDU1MgY291bGQgZ2VuZXJhdGUgd3Jvbmcgc291cmNlIG1hcCBhbmQgd2lsbCBub3QgZmluZCBCcm93c2Vyc2xpc3QgY29uZmlnLiBTZXQgaXQgdG8gQ1NTIGZpbGUgcGF0aCBvciB0byBgdW5kZWZpbmVkYCB0byBwcmV2ZW50IHRoaXMgd2FybmluZy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXN5bmMoKS50aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9O1xuICAgIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jc3M7XG4gICAgfTtcbiAgICBfcHJvdG8udmlzaXRTeW5jID0gZnVuY3Rpb24gdmlzaXRTeW5jKHZpc2l0b3JzLCBub2RlMikge1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZSh2aXNpdG9ycyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBfc3RlcF92YWx1ZSA9IF9zdGVwLnZhbHVlLCBwbHVnaW4yMiA9IF9zdGVwX3ZhbHVlWzBdLCB2aXNpdG9yID0gX3N0ZXBfdmFsdWVbMV07XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5sYXN0UGx1Z2luID0gcGx1Z2luMjI7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IHZpc2l0b3Iobm9kZTIsIHRoaXMuaGVscGVycyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuaGFuZGxlRXJyb3IoZTIsIG5vZGUyLnByb3h5T2YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUyLnR5cGUgIT09IFwicm9vdFwiICYmIG5vZGUyLnR5cGUgIT09IFwiZG9jdW1lbnRcIiAmJiAhbm9kZTIucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcm9taXNlKHByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5nZXRBc3luY0Vycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9wcm90by52aXNpdFRpY2sgPSBmdW5jdGlvbiB2aXNpdFRpY2soc3RhY2spIHtcbiAgICAgICAgdmFyIHZpc2l0MiA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbm9kZTIgPSB2aXNpdDIubm9kZSwgdmlzaXRvcnMgPSB2aXNpdDIudmlzaXRvcnM7XG4gICAgICAgIGlmIChub2RlMi50eXBlICE9PSBcInJvb3RcIiAmJiBub2RlMi50eXBlICE9PSBcImRvY3VtZW50XCIgJiYgIW5vZGUyLnBhcmVudCkge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpc2l0b3JzLmxlbmd0aCA+IDAgJiYgdmlzaXQyLnZpc2l0b3JJbmRleCA8IHZpc2l0b3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIF92aXNpdG9yc192aXNpdDJfdmlzaXRvckluZGV4ID0gdmlzaXRvcnNbdmlzaXQyLnZpc2l0b3JJbmRleF0sIHBsdWdpbjIyID0gX3Zpc2l0b3JzX3Zpc2l0Ml92aXNpdG9ySW5kZXhbMF0sIHZpc2l0b3IgPSBfdmlzaXRvcnNfdmlzaXQyX3Zpc2l0b3JJbmRleFsxXTtcbiAgICAgICAgICAgIHZpc2l0Mi52aXNpdG9ySW5kZXggKz0gMTtcbiAgICAgICAgICAgIGlmICh2aXNpdDIudmlzaXRvckluZGV4ID09PSB2aXNpdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2aXNpdDIudmlzaXRvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB2aXNpdDIudmlzaXRvckluZGV4ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzdWx0Lmxhc3RQbHVnaW4gPSBwbHVnaW4yMjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0b3Iobm9kZTIudG9Qcm94eSgpLCB0aGlzLmhlbHBlcnMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyB0aGlzLmhhbmRsZUVycm9yKGUyLCBub2RlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZpc2l0Mi5pdGVyYXRvciAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gdmlzaXQyLml0ZXJhdG9yO1xuICAgICAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICAgICAgd2hpbGUoY2hpbGQgPSBub2RlMi5ub2Rlc1tub2RlMi5pbmRleGVzW2l0ZXJhdG9yXV0pe1xuICAgICAgICAgICAgICAgIG5vZGUyLmluZGV4ZXNbaXRlcmF0b3JdICs9IDE7XG4gICAgICAgICAgICAgICAgaWYgKCFjaGlsZFtpc0NsZWFuXSkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZFtpc0NsZWFuXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2godG9TdGFjayhjaGlsZCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmlzaXQyLml0ZXJhdG9yID0gMDtcbiAgICAgICAgICAgIGRlbGV0ZSBub2RlMi5pbmRleGVzW2l0ZXJhdG9yXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRzID0gdmlzaXQyLmV2ZW50cztcbiAgICAgICAgd2hpbGUodmlzaXQyLmV2ZW50SW5kZXggPCBldmVudHMubGVuZ3RoKXtcbiAgICAgICAgICAgIHZhciBldmVudCA9IGV2ZW50c1t2aXNpdDIuZXZlbnRJbmRleF07XG4gICAgICAgICAgICB2aXNpdDIuZXZlbnRJbmRleCArPSAxO1xuICAgICAgICAgICAgaWYgKGV2ZW50ID09PSBDSElMRFJFTikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlMi5ub2RlcyAmJiBub2RlMi5ub2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTJbaXNDbGVhbl0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2aXNpdDIuaXRlcmF0b3IgPSBub2RlMi5nZXRJdGVyYXRvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgICAgICAgICAgIHZpc2l0Mi52aXNpdG9ycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgfTtcbiAgICBfcHJvdG8ud2Fsa1N5bmMgPSBmdW5jdGlvbiB3YWxrU3luYyhub2RlMikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBub2RlMltpc0NsZWFuXSA9IHRydWU7XG4gICAgICAgIHZhciBldmVudHMgPSBnZXRFdmVudHMobm9kZTIpO1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShldmVudHMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgZXZlbnQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChldmVudCA9PT0gQ0hJTERSRU4pIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZTIubm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTIuZWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZFtpc0NsZWFuXSkgX3RoaXMud2Fsa1N5bmMoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB2aXNpdG9ycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgICAgICAgICBpZiAodmlzaXRvcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmlzaXRTeW5jKHZpc2l0b3JzLCBub2RlMi50b1Byb3h5KCkpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ud2FybmluZ3MgPSBmdW5jdGlvbiB3YXJuaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3luYygpLndhcm5pbmdzKCk7XG4gICAgfTtcbiAgICBfY3JlYXRlX2NsYXNzKExhenlSZXN1bHQyLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjb250ZW50XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5jb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY3NzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmdpZnkoKS5jc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXBcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZ2lmeSgpLm1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm1lc3NhZ2VzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zeW5jKCkubWVzc2FnZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJvcHRzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQub3B0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInByb2Nlc3NvclwiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0LnByb2Nlc3NvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcInJvb3RcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN5bmMoKS5yb290O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFN5bWJvbC50b1N0cmluZ1RhZyxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkxhenlSZXN1bHRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBMYXp5UmVzdWx0Mjtcbn0oKTtcbkxhenlSZXN1bHQkMi5yZWdpc3RlclBvc3Rjc3MgPSBmdW5jdGlvbihkZXBlbmRhbnQpIHtcbiAgICBwb3N0Y3NzJDIgPSBkZXBlbmRhbnQ7XG59O1xudmFyIGxhenlSZXN1bHQgPSBMYXp5UmVzdWx0JDI7XG5MYXp5UmVzdWx0JDIuZGVmYXVsdCA9IExhenlSZXN1bHQkMjtcblJvb3QkMy5yZWdpc3RlckxhenlSZXN1bHQoTGF6eVJlc3VsdCQyKTtcbkRvY3VtZW50JDIucmVnaXN0ZXJMYXp5UmVzdWx0KExhenlSZXN1bHQkMik7XG52YXIgTWFwR2VuZXJhdG9yMjIgPSBtYXBHZW5lcmF0b3I7XG52YXIgc3RyaW5naWZ5JDEgPSBzdHJpbmdpZnlfMTtcbnZhciB3YXJuT25jZTIyID0gd2Fybk9uY2UkMjtcbnZhciBwYXJzZSQxID0gcGFyc2VfMTtcbnZhciBSZXN1bHQkMSA9IHJlc3VsdDtcbnZhciBOb1dvcmtSZXN1bHQkMSA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTm9Xb3JrUmVzdWx0Mihwcm9jZXNzb3IyLCBjc3MsIG9wdHMpIHtcbiAgICAgICAgY3NzID0gY3NzLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuc3RyaW5naWZpZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHJvY2Vzc29yID0gcHJvY2Vzc29yMjtcbiAgICAgICAgdGhpcy5fY3NzID0gY3NzO1xuICAgICAgICB0aGlzLl9vcHRzID0gb3B0cztcbiAgICAgICAgdGhpcy5fbWFwID0gdm9pZCAwO1xuICAgICAgICB2YXIgcm9vdDI7XG4gICAgICAgIHZhciBzdHIgPSBzdHJpbmdpZnkkMTtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSBuZXcgUmVzdWx0JDEodGhpcy5fcHJvY2Vzc29yLCByb290MiwgdGhpcy5fb3B0cyk7XG4gICAgICAgIHRoaXMucmVzdWx0LmNzcyA9IGNzcztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5yZXN1bHQsIFwicm9vdFwiLCB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5yb290O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1hcCA9IG5ldyBNYXBHZW5lcmF0b3IyMihzdHIsIHJvb3QyLCB0aGlzLl9vcHRzLCBjc3MpO1xuICAgICAgICBpZiAobWFwLmlzTWFwKCkpIHtcbiAgICAgICAgICAgIHZhciBfbWFwX2dlbmVyYXRlID0gbWFwLmdlbmVyYXRlKCksIGdlbmVyYXRlZENTUyA9IF9tYXBfZ2VuZXJhdGVbMF0sIGdlbmVyYXRlZE1hcCA9IF9tYXBfZ2VuZXJhdGVbMV07XG4gICAgICAgICAgICBpZiAoZ2VuZXJhdGVkQ1NTKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQuY3NzID0gZ2VuZXJhdGVkQ1NTO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZE1hcCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0Lm1hcCA9IGdlbmVyYXRlZE1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hcC5jbGVhckFubm90YXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0LmNzcyA9IG1hcC5jc3M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9wcm90byA9IE5vV29ya1Jlc3VsdDIucHJvdG90eXBlO1xuICAgIF9wcm90by5hc3luYyA9IGZ1bmN0aW9uIGFzeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcikgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuZXJyb3IpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMucmVzdWx0KTtcbiAgICB9O1xuICAgIF9wcm90by5jYXRjaCA9IGZ1bmN0aW9uIF9jYXRjaChvblJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jKCkuY2F0Y2gob25SZWplY3RlZCk7XG4gICAgfTtcbiAgICBfcHJvdG8uZmluYWxseSA9IGZ1bmN0aW9uIF9maW5hbGx5KG9uRmluYWxseSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc3luYygpLnRoZW4ob25GaW5hbGx5LCBvbkZpbmFsbHkpO1xuICAgIH07XG4gICAgX3Byb3RvLnN5bmMgPSBmdW5jdGlvbiBzeW5jKCkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcikgdGhyb3cgdGhpcy5lcnJvcjtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0O1xuICAgIH07XG4gICAgX3Byb3RvLnRoZW4gPSBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICghKFwiZnJvbVwiIGluIHRoaXMuX29wdHMpKSB7XG4gICAgICAgICAgICAgICAgd2Fybk9uY2UyMihcIldpdGhvdXQgYGZyb21gIG9wdGlvbiBQb3N0Q1NTIGNvdWxkIGdlbmVyYXRlIHdyb25nIHNvdXJjZSBtYXAgYW5kIHdpbGwgbm90IGZpbmQgQnJvd3NlcnNsaXN0IGNvbmZpZy4gU2V0IGl0IHRvIENTUyBmaWxlIHBhdGggb3IgdG8gYHVuZGVmaW5lZGAgdG8gcHJldmVudCB0aGlzIHdhcm5pbmcuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jKCkudGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgfTtcbiAgICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NzcztcbiAgICB9O1xuICAgIF9wcm90by53YXJuaW5ncyA9IGZ1bmN0aW9uIHdhcm5pbmdzKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfTtcbiAgICBfY3JlYXRlX2NsYXNzKE5vV29ya1Jlc3VsdDIsIFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNvbnRlbnRcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5jc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjc3NcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5jc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtYXBcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtZXNzYWdlc1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwib3B0c1wiLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0Lm9wdHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJwcm9jZXNzb3JcIixcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3VsdC5wcm9jZXNzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJyb290XCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcm9vdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJvb3QyO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZXIyID0gcGFyc2UkMTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByb290MiA9IHBhcnNlcjIodGhpcy5fY3NzLCB0aGlzLl9vcHRzKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHRoaXMuZXJyb3I7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHJvb3QyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm9vdDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFN5bWJvbC50b1N0cmluZ1RhZyxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIk5vV29ya1Jlc3VsdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXSk7XG4gICAgcmV0dXJuIE5vV29ya1Jlc3VsdDI7XG59KCk7XG52YXIgbm9Xb3JrUmVzdWx0ID0gTm9Xb3JrUmVzdWx0JDE7XG5Ob1dvcmtSZXN1bHQkMS5kZWZhdWx0ID0gTm9Xb3JrUmVzdWx0JDE7XG52YXIgTm9Xb3JrUmVzdWx0MjIgPSBub1dvcmtSZXN1bHQ7XG52YXIgTGF6eVJlc3VsdCQxID0gbGF6eVJlc3VsdDtcbnZhciBEb2N1bWVudCQxID0gZG9jdW1lbnQkMSQyO1xudmFyIFJvb3QkMiA9IHJvb3Q7XG52YXIgUHJvY2Vzc29yJDEgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFByb2Nlc3NvcjIocGx1Z2lucykge1xuICAgICAgICBpZiAocGx1Z2lucyA9PT0gdm9pZCAwKSBwbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IFwiOC40LjM4XCI7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHRoaXMubm9ybWFsaXplKHBsdWdpbnMpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gUHJvY2Vzc29yMi5wcm90b3R5cGU7XG4gICAgX3Byb3RvLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZShwbHVnaW5zKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkID0gW107XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHBsdWdpbnMpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgaTIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChpMi5wb3N0Y3NzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaTIgPSBpMigpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpMi5wb3N0Y3NzKSB7XG4gICAgICAgICAgICAgICAgaTIgPSBpMi5wb3N0Y3NzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0eXBlb2YgaTIgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YoaTIpKSA9PT0gXCJvYmplY3RcIiAmJiBBcnJheS5pc0FycmF5KGkyLnBsdWdpbnMpKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQuY29uY2F0KGkyLnBsdWdpbnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgodHlwZW9mIGkyID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlX29mKGkyKSkgPT09IFwib2JqZWN0XCIgJiYgaTIucG9zdGNzc1BsdWdpbikge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQucHVzaChpMik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZC5wdXNoKGkyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBpMiA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZihpMikpID09PSBcIm9iamVjdFwiICYmIChpMi5wYXJzZSB8fCBpMi5zdHJpbmdpZnkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3N0Q1NTIHN5bnRheGVzIGNhbm5vdCBiZSB1c2VkIGFzIHBsdWdpbnMuIEluc3RlYWQsIHBsZWFzZSB1c2Ugb25lIG9mIHRoZSBzeW50YXgvcGFyc2VyL3N0cmluZ2lmaWVyIG9wdGlvbnMgYXMgb3V0bGluZWQgaW4geW91ciBQb3N0Q1NTIHJ1bm5lciBkb2N1bWVudGF0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpMiArIFwiIGlzIG5vdCBhIFBvc3RDU1MgcGx1Z2luXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkO1xuICAgIH07XG4gICAgX3Byb3RvLnByb2Nlc3MgPSBmdW5jdGlvbiBwcm9jZXNzMShjc3MsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgb3B0cyA9IHt9O1xuICAgICAgICBpZiAoIXRoaXMucGx1Z2lucy5sZW5ndGggJiYgIW9wdHMucGFyc2VyICYmICFvcHRzLnN0cmluZ2lmaWVyICYmICFvcHRzLnN5bnRheCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb1dvcmtSZXN1bHQyMih0aGlzLCBjc3MsIG9wdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMYXp5UmVzdWx0JDEodGhpcywgY3NzLCBvcHRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX3Byb3RvLnVzZSA9IGZ1bmN0aW9uIHVzZShwbHVnaW4yMikge1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB0aGlzLnBsdWdpbnMuY29uY2F0KHRoaXMubm9ybWFsaXplKFtcbiAgICAgICAgICAgIHBsdWdpbjIyXG4gICAgICAgIF0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvY2Vzc29yMjtcbn0oKTtcbnZhciBwcm9jZXNzb3IgPSBQcm9jZXNzb3IkMTtcblByb2Nlc3NvciQxLmRlZmF1bHQgPSBQcm9jZXNzb3IkMTtcblJvb3QkMi5yZWdpc3RlclByb2Nlc3NvcihQcm9jZXNzb3IkMSk7XG5Eb2N1bWVudCQxLnJlZ2lzdGVyUHJvY2Vzc29yKFByb2Nlc3NvciQxKTtcbnZhciBEZWNsYXJhdGlvbiQxID0gZGVjbGFyYXRpb247XG52YXIgUHJldmlvdXNNYXAyMiA9IHByZXZpb3VzTWFwO1xudmFyIENvbW1lbnQkMSA9IGNvbW1lbnQ7XG52YXIgQXRSdWxlJDEgPSBhdFJ1bGU7XG52YXIgSW5wdXQkMSA9IGlucHV0O1xudmFyIFJvb3QkMSA9IHJvb3Q7XG52YXIgUnVsZSQxID0gcnVsZTtcbmZ1bmN0aW9uIGZyb21KU09OJDEoanNvbiwgaW5wdXRzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHJldHVybiBqc29uLm1hcChmdW5jdGlvbihuMikge1xuICAgICAgICByZXR1cm4gZnJvbUpTT04kMShuMik7XG4gICAgfSk7XG4gICAgdmFyIG93bklucHV0cyA9IGpzb24uaW5wdXRzLCBkZWZhdWx0cyA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKGpzb24sIFtcbiAgICAgICAgXCJpbnB1dHNcIlxuICAgIF0pO1xuICAgIGlmIChvd25JbnB1dHMpIHtcbiAgICAgICAgaW5wdXRzID0gW107XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKG93bklucHV0cyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgIHZhciBpbnB1dDIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgIHZhciBpbnB1dEh5ZHJhdGVkID0gX2V4dGVuZHMoe30sIGlucHV0Miwge1xuICAgICAgICAgICAgICAgIF9fcHJvdG9fXzogSW5wdXQkMS5wcm90b3R5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGlucHV0SHlkcmF0ZWQubWFwKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRIeWRyYXRlZC5tYXAgPSBfZXh0ZW5kcyh7fSwgaW5wdXRIeWRyYXRlZC5tYXAsIHtcbiAgICAgICAgICAgICAgICAgICAgX19wcm90b19fOiBQcmV2aW91c01hcDIyLnByb3RvdHlwZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5wdXRzLnB1c2goaW5wdXRIeWRyYXRlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRzLm5vZGVzKSB7XG4gICAgICAgIGRlZmF1bHRzLm5vZGVzID0ganNvbi5ub2Rlcy5tYXAoZnVuY3Rpb24objIpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tSlNPTiQxKG4yLCBpbnB1dHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRzLnNvdXJjZSkge1xuICAgICAgICB2YXIgX2RlZmF1bHRzX3NvdXJjZSA9IGRlZmF1bHRzLnNvdXJjZSwgaW5wdXRJZCA9IF9kZWZhdWx0c19zb3VyY2UuaW5wdXRJZCwgc291cmNlID0gX29iamVjdF93aXRob3V0X3Byb3BlcnRpZXNfbG9vc2UoX2RlZmF1bHRzX3NvdXJjZSwgW1xuICAgICAgICAgICAgXCJpbnB1dElkXCJcbiAgICAgICAgXSk7XG4gICAgICAgIGRlZmF1bHRzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgaWYgKGlucHV0SWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZGVmYXVsdHMuc291cmNlLmlucHV0ID0gaW5wdXRzW2lucHV0SWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkZWZhdWx0cy50eXBlID09PSBcInJvb3RcIikge1xuICAgICAgICByZXR1cm4gbmV3IFJvb3QkMShkZWZhdWx0cyk7XG4gICAgfSBlbHNlIGlmIChkZWZhdWx0cy50eXBlID09PSBcImRlY2xcIikge1xuICAgICAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uJDEoZGVmYXVsdHMpO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJydWxlXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSdWxlJDEoZGVmYXVsdHMpO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJjb21tZW50XCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21tZW50JDEoZGVmYXVsdHMpO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdHMudHlwZSA9PT0gXCJhdHJ1bGVcIikge1xuICAgICAgICByZXR1cm4gbmV3IEF0UnVsZSQxKGRlZmF1bHRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIgKyBqc29uLnR5cGUpO1xuICAgIH1cbn1cbnZhciBmcm9tSlNPTl8xID0gZnJvbUpTT04kMTtcbmZyb21KU09OJDEuZGVmYXVsdCA9IGZyb21KU09OJDE7XG52YXIgQ3NzU3ludGF4RXJyb3IyMiA9IGNzc1N5bnRheEVycm9yO1xudmFyIERlY2xhcmF0aW9uMjIgPSBkZWNsYXJhdGlvbjtcbnZhciBMYXp5UmVzdWx0MjIgPSBsYXp5UmVzdWx0O1xudmFyIENvbnRhaW5lcjIyID0gY29udGFpbmVyO1xudmFyIFByb2Nlc3NvcjIyID0gcHJvY2Vzc29yO1xudmFyIHN0cmluZ2lmeSA9IHN0cmluZ2lmeV8xO1xudmFyIGZyb21KU09OID0gZnJvbUpTT05fMTtcbnZhciBEb2N1bWVudDIyMiA9IGRvY3VtZW50JDEkMjtcbnZhciBXYXJuaW5nMjIgPSB3YXJuaW5nO1xudmFyIENvbW1lbnQyMiA9IGNvbW1lbnQ7XG52YXIgQXRSdWxlMjIgPSBhdFJ1bGU7XG52YXIgUmVzdWx0MjIgPSByZXN1bHQ7XG52YXIgSW5wdXQyMiA9IGlucHV0O1xudmFyIHBhcnNlID0gcGFyc2VfMTtcbnZhciBsaXN0ID0gbGlzdF8xO1xudmFyIFJ1bGUyMiA9IHJ1bGU7XG52YXIgUm9vdDIyID0gcm9vdDtcbnZhciBOb2RlMjIgPSBub2RlO1xuZnVuY3Rpb24gcG9zdGNzcygpIHtcbiAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIGlmIChwbHVnaW5zLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KHBsdWdpbnNbMF0pKSB7XG4gICAgICAgIHBsdWdpbnMgPSBwbHVnaW5zWzBdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb2Nlc3NvcjIyKHBsdWdpbnMpO1xufVxucG9zdGNzcy5wbHVnaW4gPSBmdW5jdGlvbiBwbHVnaW4yKG5hbWUsIGluaXRpYWxpemVyKSB7XG4gICAgdmFyIHdhcm5pbmdQcmludGVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gY3JlYXRvcigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4gJiYgIXdhcm5pbmdQcmludGVkKSB7XG4gICAgICAgICAgICB3YXJuaW5nUHJpbnRlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4obmFtZSArIFwiOiBwb3N0Y3NzLnBsdWdpbiB3YXMgZGVwcmVjYXRlZC4gTWlncmF0aW9uIGd1aWRlOlxcbmh0dHBzOi8vZXZpbG1hcnRpYW5zLmNvbS9jaHJvbmljbGVzL3Bvc3Rjc3MtOC1wbHVnaW4tbWlncmF0aW9uXCIpO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52LkxBTkcgJiYgcHJvY2Vzcy5lbnYuTEFORy5zdGFydHNXaXRoKFwiY25cIikpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4obmFtZSArIFwiOiDph4zpnaIgcG9zdGNzcy5wbHVnaW4g6KKr5byD55SoLiDov4Hnp7vmjIfljZc6XFxuaHR0cHM6Ly93d3cudzNjdGVjaC5jb20vdG9waWMvMjIyNlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSBpbml0aWFsaXplci5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIHRyYW5zZm9ybWVyLnBvc3Rjc3NQbHVnaW4gPSBuYW1lO1xuICAgICAgICB0cmFuc2Zvcm1lci5wb3N0Y3NzVmVyc2lvbiA9IG5ldyBQcm9jZXNzb3IyMigpLnZlcnNpb247XG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1lcjtcbiAgICB9XG4gICAgdmFyIGNhY2hlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdG9yLCBcInBvc3Rjc3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGUpIGNhY2hlID0gY3JlYXRvcigpO1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY3JlYXRvci5wcm9jZXNzID0gZnVuY3Rpb24oY3NzLCBwcm9jZXNzT3B0cywgcGx1Z2luT3B0cykge1xuICAgICAgICByZXR1cm4gcG9zdGNzcyhbXG4gICAgICAgICAgICBjcmVhdG9yKHBsdWdpbk9wdHMpXG4gICAgICAgIF0pLnByb2Nlc3MoY3NzLCBwcm9jZXNzT3B0cyk7XG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRvcjtcbn07XG5wb3N0Y3NzLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbnBvc3Rjc3MucGFyc2UgPSBwYXJzZTtcbnBvc3Rjc3MuZnJvbUpTT04gPSBmcm9tSlNPTjtcbnBvc3Rjc3MubGlzdCA9IGxpc3Q7XG5wb3N0Y3NzLmNvbW1lbnQgPSBmdW5jdGlvbihkZWZhdWx0cykge1xuICAgIHJldHVybiBuZXcgQ29tbWVudDIyKGRlZmF1bHRzKTtcbn07XG5wb3N0Y3NzLmF0UnVsZSA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBBdFJ1bGUyMihkZWZhdWx0cyk7XG59O1xucG9zdGNzcy5kZWNsID0gZnVuY3Rpb24oZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gbmV3IERlY2xhcmF0aW9uMjIoZGVmYXVsdHMpO1xufTtcbnBvc3Rjc3MucnVsZSA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBSdWxlMjIoZGVmYXVsdHMpO1xufTtcbnBvc3Rjc3Mucm9vdCA9IGZ1bmN0aW9uKGRlZmF1bHRzKSB7XG4gICAgcmV0dXJuIG5ldyBSb290MjIoZGVmYXVsdHMpO1xufTtcbnBvc3Rjc3MuZG9jdW1lbnQgPSBmdW5jdGlvbihkZWZhdWx0cykge1xuICAgIHJldHVybiBuZXcgRG9jdW1lbnQyMjIoZGVmYXVsdHMpO1xufTtcbnBvc3Rjc3MuQ3NzU3ludGF4RXJyb3IgPSBDc3NTeW50YXhFcnJvcjIyO1xucG9zdGNzcy5EZWNsYXJhdGlvbiA9IERlY2xhcmF0aW9uMjI7XG5wb3N0Y3NzLkNvbnRhaW5lciA9IENvbnRhaW5lcjIyO1xucG9zdGNzcy5Qcm9jZXNzb3IgPSBQcm9jZXNzb3IyMjtcbnBvc3Rjc3MuRG9jdW1lbnQgPSBEb2N1bWVudDIyMjtcbnBvc3Rjc3MuQ29tbWVudCA9IENvbW1lbnQyMjtcbnBvc3Rjc3MuV2FybmluZyA9IFdhcm5pbmcyMjtcbnBvc3Rjc3MuQXRSdWxlID0gQXRSdWxlMjI7XG5wb3N0Y3NzLlJlc3VsdCA9IFJlc3VsdDIyO1xucG9zdGNzcy5JbnB1dCA9IElucHV0MjI7XG5wb3N0Y3NzLlJ1bGUgPSBSdWxlMjI7XG5wb3N0Y3NzLlJvb3QgPSBSb290MjI7XG5wb3N0Y3NzLk5vZGUgPSBOb2RlMjI7XG5MYXp5UmVzdWx0MjIucmVnaXN0ZXJQb3N0Y3NzKHBvc3Rjc3MpO1xudmFyIHBvc3Rjc3NfMSA9IHBvc3Rjc3M7XG5wb3N0Y3NzLmRlZmF1bHQgPSBwb3N0Y3NzO1xudmFyIHBvc3Rjc3MkMSA9IC8qIEBfX1BVUkVfXyAqLyBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhwb3N0Y3NzXzEpO1xucG9zdGNzcyQxLnN0cmluZ2lmeTtcbnBvc3Rjc3MkMS5mcm9tSlNPTjtcbnBvc3Rjc3MkMS5wbHVnaW47XG5wb3N0Y3NzJDEucGFyc2U7XG5wb3N0Y3NzJDEubGlzdDtcbnBvc3Rjc3MkMS5kb2N1bWVudDtcbnBvc3Rjc3MkMS5jb21tZW50O1xucG9zdGNzcyQxLmF0UnVsZTtcbnBvc3Rjc3MkMS5ydWxlO1xucG9zdGNzcyQxLmRlY2w7XG5wb3N0Y3NzJDEucm9vdDtcbnBvc3Rjc3MkMS5Dc3NTeW50YXhFcnJvcjtcbnBvc3Rjc3MkMS5EZWNsYXJhdGlvbjtcbnBvc3Rjc3MkMS5Db250YWluZXI7XG5wb3N0Y3NzJDEuUHJvY2Vzc29yO1xucG9zdGNzcyQxLkRvY3VtZW50O1xucG9zdGNzcyQxLkNvbW1lbnQ7XG5wb3N0Y3NzJDEuV2FybmluZztcbnBvc3Rjc3MkMS5BdFJ1bGU7XG5wb3N0Y3NzJDEuUmVzdWx0O1xucG9zdGNzcyQxLklucHV0O1xucG9zdGNzcyQxLlJ1bGU7XG5wb3N0Y3NzJDEuUm9vdDtcbnBvc3Rjc3MkMS5Ob2RlO1xudmFyIEJhc2VSUk5vZGUgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIEJhc2VSUk5vZGUoKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIF9hcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBfYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcInBhcmVudEVsZW1lbnRcIiwgbnVsbCk7XG4gICAgICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwicGFyZW50Tm9kZVwiLCBudWxsKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJvd25lckRvY3VtZW50XCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcImZpcnN0Q2hpbGRcIiwgbnVsbCk7XG4gICAgICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwibGFzdENoaWxkXCIsIG51bGwpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcInByZXZpb3VzU2libGluZ1wiLCBudWxsKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJuZXh0U2libGluZ1wiLCBudWxsKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZDIodGhpcywgXCJFTEVNRU5UX05PREVcIiwgMSk7XG4gICAgICAgIF9fcHVibGljRmllbGQyKHRoaXMsIFwiVEVYVF9OT0RFXCIsIDMpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcIm5vZGVUeXBlXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcIm5vZGVOYW1lXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkMih0aGlzLCBcIlJSTm9kZVR5cGVcIik7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBCYXNlUlJOb2RlLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyhub2RlMikge1xuICAgICAgICBpZiAoIV9pbnN0YW5jZW9mKG5vZGUyLCBCYXNlUlJOb2RlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBlbHNlIGlmIChub2RlMi5vd25lckRvY3VtZW50ICE9PSB0aGlzLm93bmVyRG9jdW1lbnQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZWxzZSBpZiAobm9kZTIgPT09IHRoaXMpIHJldHVybiB0cnVlO1xuICAgICAgICB3aGlsZShub2RlMi5wYXJlbnROb2RlKXtcbiAgICAgICAgICAgIGlmIChub2RlMi5wYXJlbnROb2RlID09PSB0aGlzKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIG5vZGUyID0gbm9kZTIucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgX3Byb3RvLmFwcGVuZENoaWxkID0gZnVuY3Rpb24gYXBwZW5kQ2hpbGQoX25ld0NoaWxkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJSRG9tRXhjZXB0aW9uOiBGYWlsZWQgdG8gZXhlY3V0ZSAnYXBwZW5kQ2hpbGQnIG9uICdSUk5vZGUnOiBUaGlzIFJSTm9kZSB0eXBlIGRvZXMgbm90IHN1cHBvcnQgdGhpcyBtZXRob2QuXCIpO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIF9wcm90by5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiBpbnNlcnRCZWZvcmUoX25ld0NoaWxkLCBfcmVmQ2hpbGQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUlJEb21FeGNlcHRpb246IEZhaWxlZCB0byBleGVjdXRlICdpbnNlcnRCZWZvcmUnIG9uICdSUk5vZGUnOiBUaGlzIFJSTm9kZSB0eXBlIGRvZXMgbm90IHN1cHBvcnQgdGhpcyBtZXRob2QuXCIpO1xuICAgIH07XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIF9wcm90by5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIHJlbW92ZUNoaWxkKF9ub2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJSRG9tRXhjZXB0aW9uOiBGYWlsZWQgdG8gZXhlY3V0ZSAncmVtb3ZlQ2hpbGQnIG9uICdSUk5vZGUnOiBUaGlzIFJSTm9kZSB0eXBlIGRvZXMgbm90IHN1cHBvcnQgdGhpcyBtZXRob2QuXCIpO1xuICAgIH07XG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcIlJSTm9kZVwiO1xuICAgIH07XG4gICAgX2NyZWF0ZV9jbGFzcyhCYXNlUlJOb2RlLCBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjaGlsZE5vZGVzXCIsXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGROb2RlczIgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRJdGVyYXRvciA9IHRoaXMuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB3aGlsZShjaGlsZEl0ZXJhdG9yKXtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlczIucHVzaChjaGlsZEl0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRJdGVyYXRvciA9IGNoaWxkSXRlcmF0b3IubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZE5vZGVzMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIF0pO1xuICAgIHJldHVybiBCYXNlUlJOb2RlO1xufSgpO1xudmFyIHRlc3RhYmxlQWNjZXNzb3JzID0ge1xuICAgIE5vZGU6IFtcbiAgICAgICAgXCJjaGlsZE5vZGVzXCIsXG4gICAgICAgIFwicGFyZW50Tm9kZVwiLFxuICAgICAgICBcInBhcmVudEVsZW1lbnRcIixcbiAgICAgICAgXCJ0ZXh0Q29udGVudFwiXG4gICAgXSxcbiAgICBTaGFkb3dSb290OiBbXG4gICAgICAgIFwiaG9zdFwiLFxuICAgICAgICBcInN0eWxlU2hlZXRzXCJcbiAgICBdLFxuICAgIEVsZW1lbnQ6IFtcbiAgICAgICAgXCJzaGFkb3dSb290XCIsXG4gICAgICAgIFwicXVlcnlTZWxlY3RvclwiLFxuICAgICAgICBcInF1ZXJ5U2VsZWN0b3JBbGxcIlxuICAgIF0sXG4gICAgTXV0YXRpb25PYnNlcnZlcjogW11cbn07XG52YXIgdGVzdGFibGVNZXRob2RzID0ge1xuICAgIE5vZGU6IFtcbiAgICAgICAgXCJjb250YWluc1wiLFxuICAgICAgICBcImdldFJvb3ROb2RlXCJcbiAgICBdLFxuICAgIFNoYWRvd1Jvb3Q6IFtcbiAgICAgICAgXCJnZXRTZWxlY3Rpb25cIlxuICAgIF0sXG4gICAgRWxlbWVudDogW10sXG4gICAgTXV0YXRpb25PYnNlcnZlcjogW1xuICAgICAgICBcImNvbnN0cnVjdG9yXCJcbiAgICBdXG59O1xudmFyIHVudGFpbnRlZEJhc2VQcm90b3R5cGUgPSB7fTtcbnZhciBpc0FuZ3VsYXJab25lUHJlc2VudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIWdsb2JhbFRoaXMuWm9uZTtcbn07XG5mdW5jdGlvbiBnZXRVbnRhaW50ZWRQcm90b3R5cGUoa2V5KSB7XG4gICAgaWYgKHVudGFpbnRlZEJhc2VQcm90b3R5cGVba2V5XSkgcmV0dXJuIHVudGFpbnRlZEJhc2VQcm90b3R5cGVba2V5XTtcbiAgICB2YXIgZGVmYXVsdE9iaiA9IGdsb2JhbFRoaXNba2V5XTtcbiAgICB2YXIgZGVmYXVsdFByb3RvdHlwZSA9IGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICAgIHZhciBhY2Nlc3Nvck5hbWVzID0ga2V5IGluIHRlc3RhYmxlQWNjZXNzb3JzID8gdGVzdGFibGVBY2Nlc3NvcnNba2V5XSA6IHZvaWQgMDtcbiAgICB2YXIgaXNVbnRhaW50ZWRBY2Nlc3NvcnMgPSBCb29sZWFuKGFjY2Vzc29yTmFtZXMgJiYgLy8gQHRzLWV4cGVjdC1lcnJvciAyMzQ1XG4gICAgYWNjZXNzb3JOYW1lcy5ldmVyeShmdW5jdGlvbihhY2Nlc3Nvcikge1xuICAgICAgICB2YXIgX2EyLCBfYjtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKF9iID0gKF9hMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGVmYXVsdFByb3RvdHlwZSwgYWNjZXNzb3IpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJbbmF0aXZlIGNvZGVdXCIpKTtcbiAgICB9KSk7XG4gICAgdmFyIG1ldGhvZE5hbWVzID0ga2V5IGluIHRlc3RhYmxlTWV0aG9kcyA/IHRlc3RhYmxlTWV0aG9kc1trZXldIDogdm9pZCAwO1xuICAgIHZhciBpc1VudGFpbnRlZE1ldGhvZHMgPSBCb29sZWFuKG1ldGhvZE5hbWVzICYmIG1ldGhvZE5hbWVzLmV2ZXJ5KC8vIEB0cy1leHBlY3QtZXJyb3IgMjM0NVxuICAgIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGRlZmF1bHRQcm90b3R5cGVbbWV0aG9kXSA9PT0gXCJmdW5jdGlvblwiICYmICgoX2EyID0gZGVmYXVsdFByb3RvdHlwZVttZXRob2RdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnRvU3RyaW5nKCkuaW5jbHVkZXMoXCJbbmF0aXZlIGNvZGVdXCIpKTtcbiAgICB9KSk7XG4gICAgaWYgKGlzVW50YWludGVkQWNjZXNzb3JzICYmIGlzVW50YWludGVkTWV0aG9kcyAmJiAhaXNBbmd1bGFyWm9uZVByZXNlbnQoKSkge1xuICAgICAgICB1bnRhaW50ZWRCYXNlUHJvdG90eXBlW2tleV0gPSBkZWZhdWx0T2JqLnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRPYmoucHJvdG90eXBlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICB2YXIgaWZyYW1lRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZUVsKTtcbiAgICAgICAgdmFyIHdpbiA9IGlmcmFtZUVsLmNvbnRlbnRXaW5kb3c7XG4gICAgICAgIGlmICghd2luKSByZXR1cm4gZGVmYXVsdE9iai5wcm90b3R5cGU7XG4gICAgICAgIHZhciB1bnRhaW50ZWRPYmplY3QgPSB3aW5ba2V5XS5wcm90b3R5cGU7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lRWwpO1xuICAgICAgICBpZiAoIXVudGFpbnRlZE9iamVjdCkgcmV0dXJuIGRlZmF1bHRQcm90b3R5cGU7XG4gICAgICAgIHJldHVybiB1bnRhaW50ZWRCYXNlUHJvdG90eXBlW2tleV0gPSB1bnRhaW50ZWRPYmplY3Q7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFByb3RvdHlwZTtcbiAgICB9XG59XG52YXIgdW50YWludGVkQWNjZXNzb3JDYWNoZSA9IHt9O1xuZnVuY3Rpb24gZ2V0VW50YWludGVkQWNjZXNzb3Ioa2V5LCBpbnN0YW5jZSwgYWNjZXNzb3IpIHtcbiAgICB2YXIgX2EyO1xuICAgIHZhciBjYWNoZUtleSA9IGtleSArIFwiLlwiICsgU3RyaW5nKGFjY2Vzc29yKTtcbiAgICBpZiAodW50YWludGVkQWNjZXNzb3JDYWNoZVtjYWNoZUtleV0pIHJldHVybiB1bnRhaW50ZWRBY2Nlc3NvckNhY2hlW2NhY2hlS2V5XS5jYWxsKGluc3RhbmNlKTtcbiAgICB2YXIgdW50YWludGVkUHJvdG90eXBlID0gZ2V0VW50YWludGVkUHJvdG90eXBlKGtleSk7XG4gICAgdmFyIHVudGFpbnRlZEFjY2Vzc29yID0gKF9hMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodW50YWludGVkUHJvdG90eXBlLCBhY2Nlc3NvcikpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZ2V0O1xuICAgIGlmICghdW50YWludGVkQWNjZXNzb3IpIHJldHVybiBpbnN0YW5jZVthY2Nlc3Nvcl07XG4gICAgdW50YWludGVkQWNjZXNzb3JDYWNoZVtjYWNoZUtleV0gPSB1bnRhaW50ZWRBY2Nlc3NvcjtcbiAgICByZXR1cm4gdW50YWludGVkQWNjZXNzb3IuY2FsbChpbnN0YW5jZSk7XG59XG52YXIgdW50YWludGVkTWV0aG9kQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGdldFVudGFpbnRlZE1ldGhvZChrZXksIGluc3RhbmNlLCBtZXRob2QpIHtcbiAgICB2YXIgY2FjaGVLZXkgPSBrZXkgKyBcIi5cIiArIFN0cmluZyhtZXRob2QpO1xuICAgIGlmICh1bnRhaW50ZWRNZXRob2RDYWNoZVtjYWNoZUtleV0pIHJldHVybiB1bnRhaW50ZWRNZXRob2RDYWNoZVtjYWNoZUtleV0uYmluZChpbnN0YW5jZSk7XG4gICAgdmFyIHVudGFpbnRlZFByb3RvdHlwZSA9IGdldFVudGFpbnRlZFByb3RvdHlwZShrZXkpO1xuICAgIHZhciB1bnRhaW50ZWRNZXRob2QgPSB1bnRhaW50ZWRQcm90b3R5cGVbbWV0aG9kXTtcbiAgICBpZiAodHlwZW9mIHVudGFpbnRlZE1ldGhvZCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gaW5zdGFuY2VbbWV0aG9kXTtcbiAgICB1bnRhaW50ZWRNZXRob2RDYWNoZVtjYWNoZUtleV0gPSB1bnRhaW50ZWRNZXRob2Q7XG4gICAgcmV0dXJuIHVudGFpbnRlZE1ldGhvZC5iaW5kKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIGNoaWxkTm9kZXMobjIpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJOb2RlXCIsIG4yLCBcImNoaWxkTm9kZXNcIik7XG59XG5mdW5jdGlvbiBwYXJlbnROb2RlKG4yKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yKFwiTm9kZVwiLCBuMiwgXCJwYXJlbnROb2RlXCIpO1xufVxuZnVuY3Rpb24gcGFyZW50RWxlbWVudChuMikge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIk5vZGVcIiwgbjIsIFwicGFyZW50RWxlbWVudFwiKTtcbn1cbmZ1bmN0aW9uIHRleHRDb250ZW50KG4yKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZEFjY2Vzc29yKFwiTm9kZVwiLCBuMiwgXCJ0ZXh0Q29udGVudFwiKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zKG4yLCBvdGhlcikge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRNZXRob2QoXCJOb2RlXCIsIG4yLCBcImNvbnRhaW5zXCIpKG90aGVyKTtcbn1cbmZ1bmN0aW9uIGdldFJvb3ROb2RlKG4yKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZE1ldGhvZChcIk5vZGVcIiwgbjIsIFwiZ2V0Um9vdE5vZGVcIikoKTtcbn1cbmZ1bmN0aW9uIGhvc3QobjIpIHtcbiAgICBpZiAoIW4yIHx8ICEoXCJob3N0XCIgaW4gbjIpKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJTaGFkb3dSb290XCIsIG4yLCBcImhvc3RcIik7XG59XG5mdW5jdGlvbiBzdHlsZVNoZWV0cyhuMikge1xuICAgIHJldHVybiBuMi5zdHlsZVNoZWV0cztcbn1cbmZ1bmN0aW9uIHNoYWRvd1Jvb3QobjIpIHtcbiAgICBpZiAoIW4yIHx8ICEoXCJzaGFkb3dSb290XCIgaW4gbjIpKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJFbGVtZW50XCIsIG4yLCBcInNoYWRvd1Jvb3RcIik7XG59XG5mdW5jdGlvbiBxdWVyeVNlbGVjdG9yKG4yLCBzZWxlY3RvcnMpIHtcbiAgICByZXR1cm4gZ2V0VW50YWludGVkQWNjZXNzb3IoXCJFbGVtZW50XCIsIG4yLCBcInF1ZXJ5U2VsZWN0b3JcIikoc2VsZWN0b3JzKTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGwobjIsIHNlbGVjdG9ycykge1xuICAgIHJldHVybiBnZXRVbnRhaW50ZWRBY2Nlc3NvcihcIkVsZW1lbnRcIiwgbjIsIFwicXVlcnlTZWxlY3RvckFsbFwiKShzZWxlY3RvcnMpO1xufVxuZnVuY3Rpb24gbXV0YXRpb25PYnNlcnZlckN0b3IoKSB7XG4gICAgcmV0dXJuIGdldFVudGFpbnRlZFByb3RvdHlwZShcIk11dGF0aW9uT2JzZXJ2ZXJcIikuY29uc3RydWN0b3I7XG59XG52YXIgaW5kZXggPSB7XG4gICAgY2hpbGROb2RlczogY2hpbGROb2RlcyxcbiAgICBwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuICAgIHBhcmVudEVsZW1lbnQ6IHBhcmVudEVsZW1lbnQsXG4gICAgdGV4dENvbnRlbnQ6IHRleHRDb250ZW50LFxuICAgIGNvbnRhaW5zOiBjb250YWlucyxcbiAgICBnZXRSb290Tm9kZTogZ2V0Um9vdE5vZGUsXG4gICAgaG9zdDogaG9zdCxcbiAgICBzdHlsZVNoZWV0czogc3R5bGVTaGVldHMsXG4gICAgc2hhZG93Um9vdDogc2hhZG93Um9vdCxcbiAgICBxdWVyeVNlbGVjdG9yOiBxdWVyeVNlbGVjdG9yLFxuICAgIHF1ZXJ5U2VsZWN0b3JBbGw6IHF1ZXJ5U2VsZWN0b3JBbGwsXG4gICAgbXV0YXRpb25PYnNlcnZlcjogbXV0YXRpb25PYnNlcnZlckN0b3Jcbn07XG5mdW5jdGlvbiBvbih0eXBlLCBmbiwgdGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldCA9PT0gdm9pZCAwKSB0YXJnZXQgPSBkb2N1bWVudDtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH07XG4gICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBvcHRpb25zKTtcbiAgICB9O1xufVxudmFyIERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyA9IFwiUGxlYXNlIHN0b3AgaW1wb3J0IG1pcnJvciBkaXJlY3RseS4gSW5zdGVhZCBvZiB0aGF0LFxcclxcbm5vdyB5b3UgY2FuIHVzZSByZXBsYXllci5nZXRNaXJyb3IoKSB0byBhY2Nlc3MgdGhlIG1pcnJvciBpbnN0YW5jZSBvZiBhIHJlcGxheWVyLFxcclxcbm9yIHlvdSBjYW4gdXNlIHJlY29yZC5taXJyb3IgdG8gYWNjZXNzIHRoZSBtaXJyb3IgaW5zdGFuY2UgZHVyaW5nIHJlY29yZGluZy5cIjtcbnZhciBfbWlycm9yID0ge1xuICAgIG1hcDoge30sXG4gICAgZ2V0SWQ6IGZ1bmN0aW9uIGdldElkKCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9LFxuICAgIGdldE5vZGU6IGZ1bmN0aW9uIGdldE5vZGUoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICByZW1vdmVOb2RlRnJvbU1hcDogZnVuY3Rpb24gcmVtb3ZlTm9kZUZyb21NYXAoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcbiAgICB9LFxuICAgIGhhczogZnVuY3Rpb24gaGFzKCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIHJlc2V0OiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xuICAgIH1cbn07XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cuUHJveHkgJiYgd2luZG93LlJlZmxlY3QpIHtcbiAgICBfbWlycm9yID0gbmV3IFByb3h5KF9taXJyb3IsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgaWYgKHByb3AgPT09IFwibWFwXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91cyA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICB9XG4gICAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgICB9LCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhvb2tTZXR0ZXIodGFyZ2V0LCBrZXksIGQsIGlzUmV2b2tlZCwgd2luKSB7XG4gICAgaWYgKHdpbiA9PT0gdm9pZCAwKSB3aW4gPSB3aW5kb3c7XG4gICAgdmFyIG9yaWdpbmFsID0gd2luLk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgIHdpbi5PYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGlzUmV2b2tlZCA/IGQgOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkLnNldC5jYWxsKF90aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbCAmJiBvcmlnaW5hbC5zZXQpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbC5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBob29rU2V0dGVyKHRhcmdldCwga2V5LCBvcmlnaW5hbCB8fCB7fSwgdHJ1ZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhdGNoKHNvdXJjZSwgbmFtZSwgcmVwbGFjZW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIShuYW1lIGluIHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnaW5hbCA9IHNvdXJjZVtuYW1lXTtcbiAgICAgICAgdmFyIHdyYXBwZWQgPSByZXBsYWNlbWVudChvcmlnaW5hbCk7XG4gICAgICAgIGlmICh0eXBlb2Ygd3JhcHBlZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB3cmFwcGVkLnByb3RvdHlwZSA9IHdyYXBwZWQucHJvdG90eXBlIHx8IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod3JhcHBlZCwge1xuICAgICAgICAgICAgICAgIF9fcnJ3ZWJfb3JpZ2luYWxfXzoge1xuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9yaWdpbmFsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlW25hbWVdID0gd3JhcHBlZDtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc291cmNlW25hbWVdID0gb3JpZ2luYWw7XG4gICAgICAgIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG59XG52YXIgbm93VGltZXN0YW1wID0gRGF0ZS5ub3c7XG5pZiAoIS8qIEBfX1BVUkVfXyAqLyAvWzEtOV1bMC05XXsxMn0vLnRlc3QoRGF0ZS5ub3coKS50b1N0cmluZygpKSkge1xuICAgIG5vd1RpbWVzdGFtcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwod2luKSB7XG4gICAgdmFyIF9hMiwgX2IsIF9jLCBfZDtcbiAgICB2YXIgZG9jID0gd2luLmRvY3VtZW50O1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IGRvYy5zY3JvbGxpbmdFbGVtZW50ID8gZG9jLnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdCA6IHdpbi5wYWdlWE9mZnNldCAhPT0gdm9pZCAwID8gd2luLnBhZ2VYT2Zmc2V0IDogZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IChkb2MgPT0gbnVsbCA/IHZvaWQgMCA6IGRvYy5ib2R5KSAmJiAoKF9hMiA9IGluZGV4LnBhcmVudEVsZW1lbnQoZG9jLmJvZHkpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnNjcm9sbExlZnQpIHx8ICgoX2IgPSBkb2MgPT0gbnVsbCA/IHZvaWQgMCA6IGRvYy5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2Iuc2Nyb2xsTGVmdCkgfHwgMCxcbiAgICAgICAgdG9wOiBkb2Muc2Nyb2xsaW5nRWxlbWVudCA/IGRvYy5zY3JvbGxpbmdFbGVtZW50LnNjcm9sbFRvcCA6IHdpbi5wYWdlWU9mZnNldCAhPT0gdm9pZCAwID8gd2luLnBhZ2VZT2Zmc2V0IDogKGRvYyA9PSBudWxsID8gdm9pZCAwIDogZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApIHx8IChkb2MgPT0gbnVsbCA/IHZvaWQgMCA6IGRvYy5ib2R5KSAmJiAoKF9jID0gaW5kZXgucGFyZW50RWxlbWVudChkb2MuYm9keSkpID09IG51bGwgPyB2b2lkIDAgOiBfYy5zY3JvbGxUb3ApIHx8ICgoX2QgPSBkb2MgPT0gbnVsbCA/IHZvaWQgMCA6IGRvYy5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2Quc2Nyb2xsVG9wKSB8fCAwXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvd0hlaWdodCgpIHtcbiAgICByZXR1cm4gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IGRvY3VtZW50LmJvZHkgJiYgZG9jdW1lbnQuYm9keS5jbGllbnRIZWlnaHQ7XG59XG5mdW5jdGlvbiBnZXRXaW5kb3dXaWR0aCgpIHtcbiAgICByZXR1cm4gd2luZG93LmlubmVyV2lkdGggfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCBkb2N1bWVudC5ib2R5ICYmIGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg7XG59XG5mdW5jdGlvbiBjbG9zZXN0RWxlbWVudE9mTm9kZShub2RlMikge1xuICAgIGlmICghbm9kZTIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBlbCA9IG5vZGUyLm5vZGVUeXBlID09PSBub2RlMi5FTEVNRU5UX05PREUgPyBub2RlMiA6IGluZGV4LnBhcmVudEVsZW1lbnQobm9kZTIpO1xuICAgIHJldHVybiBlbDtcbn1cbmZ1bmN0aW9uIGlzQmxvY2tlZChub2RlMiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgY2hlY2tBbmNlc3RvcnMpIHtcbiAgICBpZiAoIW5vZGUyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGVsID0gY2xvc2VzdEVsZW1lbnRPZk5vZGUobm9kZTIpO1xuICAgIGlmICghZWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGJsb2NrQ2xhc3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoYmxvY2tDbGFzcykpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGNoZWNrQW5jZXN0b3JzICYmIGVsLmNsb3Nlc3QoXCIuXCIgKyBibG9ja0NsYXNzKSAhPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2xhc3NNYXRjaGVzUmVnZXgoZWwsIGJsb2NrQ2xhc3MsIGNoZWNrQW5jZXN0b3JzKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlMikge31cbiAgICBpZiAoYmxvY2tTZWxlY3Rvcikge1xuICAgICAgICBpZiAoZWwubWF0Y2hlcyhibG9ja1NlbGVjdG9yKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChjaGVja0FuY2VzdG9ycyAmJiBlbC5jbG9zZXN0KGJsb2NrU2VsZWN0b3IpICE9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNTZXJpYWxpemVkKG4yLCBtaXJyb3IyKSB7XG4gICAgcmV0dXJuIG1pcnJvcjIuZ2V0SWQobjIpICE9PSAtMTtcbn1cbmZ1bmN0aW9uIGlzSWdub3JlZChuMiwgbWlycm9yMiwgc2xpbURPTU9wdGlvbnMpIHtcbiAgICBpZiAobjIudGFnTmFtZSA9PT0gXCJUSVRMRVwiICYmIHNsaW1ET01PcHRpb25zLmhlYWRUaXRsZU11dGF0aW9ucykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG1pcnJvcjIuZ2V0SWQobjIpID09PSBJR05PUkVEX05PREU7XG59XG5mdW5jdGlvbiBpc0FuY2VzdG9yUmVtb3ZlZCh0YXJnZXQsIG1pcnJvcjIpIHtcbiAgICBpZiAoaXNTaGFkb3dSb290KHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgaWQgPSBtaXJyb3IyLmdldElkKHRhcmdldCk7XG4gICAgaWYgKCFtaXJyb3IyLmhhcyhpZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBwYXJlbnQgPSBpbmRleC5wYXJlbnROb2RlKHRhcmdldCk7XG4gICAgaWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IHRhcmdldC5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc0FuY2VzdG9yUmVtb3ZlZChwYXJlbnQsIG1pcnJvcjIpO1xufVxuZnVuY3Rpb24gbGVnYWN5X2lzVG91Y2hFdmVudChldmVudCkge1xuICAgIHJldHVybiBCb29sZWFuKGV2ZW50LmNoYW5nZWRUb3VjaGVzKTtcbn1cbmZ1bmN0aW9uIHBvbHlmaWxsJDEod2luKSB7XG4gICAgaWYgKHdpbiA9PT0gdm9pZCAwKSB3aW4gPSB3aW5kb3c7XG4gICAgaWYgKFwiTm9kZUxpc3RcIiBpbiB3aW4gJiYgIXdpbi5Ob2RlTGlzdC5wcm90b3R5cGUuZm9yRWFjaCkge1xuICAgICAgICB3aW4uTm9kZUxpc3QucHJvdG90eXBlLmZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbiAgICB9XG4gICAgaWYgKFwiRE9NVG9rZW5MaXN0XCIgaW4gd2luICYmICF3aW4uRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5mb3JFYWNoKSB7XG4gICAgICAgIHdpbi5ET01Ub2tlbkxpc3QucHJvdG90eXBlLmZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1NlcmlhbGl6ZWRJZnJhbWUobjIsIG1pcnJvcjIpIHtcbiAgICByZXR1cm4gQm9vbGVhbihuMi5ub2RlTmFtZSA9PT0gXCJJRlJBTUVcIiAmJiBtaXJyb3IyLmdldE1ldGEobjIpKTtcbn1cbmZ1bmN0aW9uIGlzU2VyaWFsaXplZFN0eWxlc2hlZXQobjIsIG1pcnJvcjIpIHtcbiAgICByZXR1cm4gQm9vbGVhbihuMi5ub2RlTmFtZSA9PT0gXCJMSU5LXCIgJiYgbjIubm9kZVR5cGUgPT09IG4yLkVMRU1FTlRfTk9ERSAmJiBuMi5nZXRBdHRyaWJ1dGUgJiYgbjIuZ2V0QXR0cmlidXRlKFwicmVsXCIpID09PSBcInN0eWxlc2hlZXRcIiAmJiBtaXJyb3IyLmdldE1ldGEobjIpKTtcbn1cbmZ1bmN0aW9uIGhhc1NoYWRvd1Jvb3QobjIpIHtcbiAgICBpZiAoIW4yKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKF9pbnN0YW5jZW9mKG4yLCBCYXNlUlJOb2RlKSAmJiBcInNoYWRvd1Jvb3RcIiBpbiBuMikge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihuMi5zaGFkb3dSb290KTtcbiAgICB9XG4gICAgcmV0dXJuIEJvb2xlYW4oaW5kZXguc2hhZG93Um9vdChuMikpO1xufVxudmFyIFN0eWxlU2hlZXRNaXJyb3IgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFN0eWxlU2hlZXRNaXJyb3IoKSB7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpZFwiLCAxKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0eWxlSURNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaWRTdHlsZU1hcFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXRNaXJyb3IucHJvdG90eXBlO1xuICAgIF9wcm90by5nZXRJZCA9IGZ1bmN0aW9uIGdldElkKHN0eWxlc2hlZXQpIHtcbiAgICAgICAgdmFyIF90aGlzX3N0eWxlSURNYXBfZ2V0O1xuICAgICAgICByZXR1cm4gKF90aGlzX3N0eWxlSURNYXBfZ2V0ID0gdGhpcy5zdHlsZUlETWFwLmdldChzdHlsZXNoZWV0KSkgIT0gbnVsbCA/IF90aGlzX3N0eWxlSURNYXBfZ2V0IDogLTE7XG4gICAgfTtcbiAgICBfcHJvdG8uaGFzID0gZnVuY3Rpb24gaGFzKHN0eWxlc2hlZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGVJRE1hcC5oYXMoc3R5bGVzaGVldCk7XG4gICAgfTtcbiAgICAvKipcbiAgICogQHJldHVybnMgSWYgdGhlIHN0eWxlc2hlZXQgaXMgaW4gdGhlIG1pcnJvciwgcmV0dXJucyB0aGUgaWQgb2YgdGhlIHN0eWxlc2hlZXQuIElmIG5vdCwgcmV0dXJuIHRoZSBuZXcgYXNzaWduZWQgaWQuXG4gICAqLyBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKHN0eWxlc2hlZXQsIGlkKSB7XG4gICAgICAgIGlmICh0aGlzLmhhcyhzdHlsZXNoZWV0KSkgcmV0dXJuIHRoaXMuZ2V0SWQoc3R5bGVzaGVldCk7XG4gICAgICAgIHZhciBuZXdJZDtcbiAgICAgICAgaWYgKGlkID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG5ld0lkID0gdGhpcy5pZCsrO1xuICAgICAgICB9IGVsc2UgbmV3SWQgPSBpZDtcbiAgICAgICAgdGhpcy5zdHlsZUlETWFwLnNldChzdHlsZXNoZWV0LCBuZXdJZCk7XG4gICAgICAgIHRoaXMuaWRTdHlsZU1hcC5zZXQobmV3SWQsIHN0eWxlc2hlZXQpO1xuICAgICAgICByZXR1cm4gbmV3SWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0U3R5bGUgPSBmdW5jdGlvbiBnZXRTdHlsZShpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZFN0eWxlTWFwLmdldChpZCkgfHwgbnVsbDtcbiAgICB9O1xuICAgIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnN0eWxlSURNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5pZFN0eWxlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5pZCA9IDE7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2VuZXJhdGVJZCA9IGZ1bmN0aW9uIGdlbmVyYXRlSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkKys7XG4gICAgfTtcbiAgICByZXR1cm4gU3R5bGVTaGVldE1pcnJvcjtcbn0oKTtcbmZ1bmN0aW9uIGdldFNoYWRvd0hvc3QobjIpIHtcbiAgICB2YXIgX2EyO1xuICAgIHZhciBzaGFkb3dIb3N0ID0gbnVsbDtcbiAgICBpZiAoXCJnZXRSb290Tm9kZVwiIGluIG4yICYmICgoX2EyID0gaW5kZXguZ2V0Um9vdE5vZGUobjIpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLm5vZGVUeXBlKSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICYmIGluZGV4Lmhvc3QoaW5kZXguZ2V0Um9vdE5vZGUobjIpKSkgc2hhZG93SG9zdCA9IGluZGV4Lmhvc3QoaW5kZXguZ2V0Um9vdE5vZGUobjIpKTtcbiAgICByZXR1cm4gc2hhZG93SG9zdDtcbn1cbmZ1bmN0aW9uIGdldFJvb3RTaGFkb3dIb3N0KG4yKSB7XG4gICAgdmFyIHJvb3RTaGFkb3dIb3N0ID0gbjI7XG4gICAgdmFyIHNoYWRvd0hvc3Q7XG4gICAgd2hpbGUoc2hhZG93SG9zdCA9IGdldFNoYWRvd0hvc3Qocm9vdFNoYWRvd0hvc3QpKXJvb3RTaGFkb3dIb3N0ID0gc2hhZG93SG9zdDtcbiAgICByZXR1cm4gcm9vdFNoYWRvd0hvc3Q7XG59XG5mdW5jdGlvbiBzaGFkb3dIb3N0SW5Eb20objIpIHtcbiAgICB2YXIgZG9jID0gbjIub3duZXJEb2N1bWVudDtcbiAgICBpZiAoIWRvYykgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBzaGFkb3dIb3N0ID0gZ2V0Um9vdFNoYWRvd0hvc3QobjIpO1xuICAgIHJldHVybiBpbmRleC5jb250YWlucyhkb2MsIHNoYWRvd0hvc3QpO1xufVxuZnVuY3Rpb24gaW5Eb20objIpIHtcbiAgICB2YXIgZG9jID0gbjIub3duZXJEb2N1bWVudDtcbiAgICBpZiAoIWRvYykgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBpbmRleC5jb250YWlucyhkb2MsIG4yKSB8fCBzaGFkb3dIb3N0SW5Eb20objIpO1xufVxudmFyIEV2ZW50VHlwZSA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbihFdmVudFR5cGUyKSB7XG4gICAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiRG9tQ29udGVudExvYWRlZFwiXSA9IDBdID0gXCJEb21Db250ZW50TG9hZGVkXCI7XG4gICAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiTG9hZFwiXSA9IDFdID0gXCJMb2FkXCI7XG4gICAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiRnVsbFNuYXBzaG90XCJdID0gMl0gPSBcIkZ1bGxTbmFwc2hvdFwiO1xuICAgIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkluY3JlbWVudGFsU25hcHNob3RcIl0gPSAzXSA9IFwiSW5jcmVtZW50YWxTbmFwc2hvdFwiO1xuICAgIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIk1ldGFcIl0gPSA0XSA9IFwiTWV0YVwiO1xuICAgIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkN1c3RvbVwiXSA9IDVdID0gXCJDdXN0b21cIjtcbiAgICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJQbHVnaW5cIl0gPSA2XSA9IFwiUGx1Z2luXCI7XG4gICAgcmV0dXJuIEV2ZW50VHlwZTI7XG59KEV2ZW50VHlwZSB8fCB7fSk7XG52YXIgSW5jcmVtZW50YWxTb3VyY2UgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oSW5jcmVtZW50YWxTb3VyY2UyKSB7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk11dGF0aW9uXCJdID0gMF0gPSBcIk11dGF0aW9uXCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1vdXNlTW92ZVwiXSA9IDFdID0gXCJNb3VzZU1vdmVcIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTW91c2VJbnRlcmFjdGlvblwiXSA9IDJdID0gXCJNb3VzZUludGVyYWN0aW9uXCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlNjcm9sbFwiXSA9IDNdID0gXCJTY3JvbGxcIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiVmlld3BvcnRSZXNpemVcIl0gPSA0XSA9IFwiVmlld3BvcnRSZXNpemVcIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiSW5wdXRcIl0gPSA1XSA9IFwiSW5wdXRcIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiVG91Y2hNb3ZlXCJdID0gNl0gPSBcIlRvdWNoTW92ZVwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNZWRpYUludGVyYWN0aW9uXCJdID0gN10gPSBcIk1lZGlhSW50ZXJhY3Rpb25cIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU3R5bGVTaGVldFJ1bGVcIl0gPSA4XSA9IFwiU3R5bGVTaGVldFJ1bGVcIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQ2FudmFzTXV0YXRpb25cIl0gPSA5XSA9IFwiQ2FudmFzTXV0YXRpb25cIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiRm9udFwiXSA9IDEwXSA9IFwiRm9udFwiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJMb2dcIl0gPSAxMV0gPSBcIkxvZ1wiO1xuICAgIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJEcmFnXCJdID0gMTJdID0gXCJEcmFnXCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlN0eWxlRGVjbGFyYXRpb25cIl0gPSAxM10gPSBcIlN0eWxlRGVjbGFyYXRpb25cIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU2VsZWN0aW9uXCJdID0gMTRdID0gXCJTZWxlY3Rpb25cIjtcbiAgICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQWRvcHRlZFN0eWxlU2hlZXRcIl0gPSAxNV0gPSBcIkFkb3B0ZWRTdHlsZVNoZWV0XCI7XG4gICAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkN1c3RvbUVsZW1lbnRcIl0gPSAxNl0gPSBcIkN1c3RvbUVsZW1lbnRcIjtcbiAgICByZXR1cm4gSW5jcmVtZW50YWxTb3VyY2UyO1xufShJbmNyZW1lbnRhbFNvdXJjZSB8fCB7fSk7XG52YXIgTW91c2VJbnRlcmFjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oTW91c2VJbnRlcmFjdGlvbnMyKSB7XG4gICAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIk1vdXNlVXBcIl0gPSAwXSA9IFwiTW91c2VVcFwiO1xuICAgIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJNb3VzZURvd25cIl0gPSAxXSA9IFwiTW91c2VEb3duXCI7XG4gICAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkNsaWNrXCJdID0gMl0gPSBcIkNsaWNrXCI7XG4gICAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkNvbnRleHRNZW51XCJdID0gM10gPSBcIkNvbnRleHRNZW51XCI7XG4gICAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkRibENsaWNrXCJdID0gNF0gPSBcIkRibENsaWNrXCI7XG4gICAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkZvY3VzXCJdID0gNV0gPSBcIkZvY3VzXCI7XG4gICAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkJsdXJcIl0gPSA2XSA9IFwiQmx1clwiO1xuICAgIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaFN0YXJ0XCJdID0gN10gPSBcIlRvdWNoU3RhcnRcIjtcbiAgICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiVG91Y2hNb3ZlX0RlcGFydGVkXCJdID0gOF0gPSBcIlRvdWNoTW92ZV9EZXBhcnRlZFwiO1xuICAgIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaEVuZFwiXSA9IDldID0gXCJUb3VjaEVuZFwiO1xuICAgIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJUb3VjaENhbmNlbFwiXSA9IDEwXSA9IFwiVG91Y2hDYW5jZWxcIjtcbiAgICByZXR1cm4gTW91c2VJbnRlcmFjdGlvbnMyO1xufShNb3VzZUludGVyYWN0aW9ucyB8fCB7fSk7XG52YXIgUG9pbnRlclR5cGVzID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKFBvaW50ZXJUeXBlczIpIHtcbiAgICBQb2ludGVyVHlwZXMyW1BvaW50ZXJUeXBlczJbXCJNb3VzZVwiXSA9IDBdID0gXCJNb3VzZVwiO1xuICAgIFBvaW50ZXJUeXBlczJbUG9pbnRlclR5cGVzMltcIlBlblwiXSA9IDFdID0gXCJQZW5cIjtcbiAgICBQb2ludGVyVHlwZXMyW1BvaW50ZXJUeXBlczJbXCJUb3VjaFwiXSA9IDJdID0gXCJUb3VjaFwiO1xuICAgIHJldHVybiBQb2ludGVyVHlwZXMyO1xufShQb2ludGVyVHlwZXMgfHwge30pO1xudmFyIENhbnZhc0NvbnRleHQgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oQ2FudmFzQ29udGV4dDIpIHtcbiAgICBDYW52YXNDb250ZXh0MltDYW52YXNDb250ZXh0MltcIjJEXCJdID0gMF0gPSBcIjJEXCI7XG4gICAgQ2FudmFzQ29udGV4dDJbQ2FudmFzQ29udGV4dDJbXCJXZWJHTFwiXSA9IDFdID0gXCJXZWJHTFwiO1xuICAgIENhbnZhc0NvbnRleHQyW0NhbnZhc0NvbnRleHQyW1wiV2ViR0wyXCJdID0gMl0gPSBcIldlYkdMMlwiO1xuICAgIHJldHVybiBDYW52YXNDb250ZXh0Mjtcbn0oQ2FudmFzQ29udGV4dCB8fCB7fSk7XG52YXIgTWVkaWFJbnRlcmFjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24oTWVkaWFJbnRlcmFjdGlvbnMyKSB7XG4gICAgTWVkaWFJbnRlcmFjdGlvbnMyW01lZGlhSW50ZXJhY3Rpb25zMltcIlBsYXlcIl0gPSAwXSA9IFwiUGxheVwiO1xuICAgIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJQYXVzZVwiXSA9IDFdID0gXCJQYXVzZVwiO1xuICAgIE1lZGlhSW50ZXJhY3Rpb25zMltNZWRpYUludGVyYWN0aW9uczJbXCJTZWVrZWRcIl0gPSAyXSA9IFwiU2Vla2VkXCI7XG4gICAgTWVkaWFJbnRlcmFjdGlvbnMyW01lZGlhSW50ZXJhY3Rpb25zMltcIlZvbHVtZUNoYW5nZVwiXSA9IDNdID0gXCJWb2x1bWVDaGFuZ2VcIjtcbiAgICBNZWRpYUludGVyYWN0aW9uczJbTWVkaWFJbnRlcmFjdGlvbnMyW1wiUmF0ZUNoYW5nZVwiXSA9IDRdID0gXCJSYXRlQ2hhbmdlXCI7XG4gICAgcmV0dXJuIE1lZGlhSW50ZXJhY3Rpb25zMjtcbn0oTWVkaWFJbnRlcmFjdGlvbnMgfHwge30pO1xudmFyIE5vZGVUeXBlID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKE5vZGVUeXBlMikge1xuICAgIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJEb2N1bWVudFwiXSA9IDBdID0gXCJEb2N1bWVudFwiO1xuICAgIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJEb2N1bWVudFR5cGVcIl0gPSAxXSA9IFwiRG9jdW1lbnRUeXBlXCI7XG4gICAgTm9kZVR5cGUyW05vZGVUeXBlMltcIkVsZW1lbnRcIl0gPSAyXSA9IFwiRWxlbWVudFwiO1xuICAgIE5vZGVUeXBlMltOb2RlVHlwZTJbXCJUZXh0XCJdID0gM10gPSBcIlRleHRcIjtcbiAgICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiQ0RBVEFcIl0gPSA0XSA9IFwiQ0RBVEFcIjtcbiAgICBOb2RlVHlwZTJbTm9kZVR5cGUyW1wiQ29tbWVudFwiXSA9IDVdID0gXCJDb21tZW50XCI7XG4gICAgcmV0dXJuIE5vZGVUeXBlMjtcbn0oTm9kZVR5cGUgfHwge30pO1xuZnVuY3Rpb24gaXNOb2RlSW5MaW5rZWRMaXN0KG4yKSB7XG4gICAgcmV0dXJuIFwiX19sblwiIGluIG4yO1xufVxudmFyIERvdWJsZUxpbmtlZExpc3QgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIERvdWJsZUxpbmtlZExpc3QoKSB7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsZW5ndGhcIiwgMCk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoZWFkXCIsIG51bGwpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGFpbFwiLCBudWxsKTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IERvdWJsZUxpbmtlZExpc3QucHJvdG90eXBlO1xuICAgIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQocG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3NpdGlvbiBvdXRzaWRlIG9mIGxpc3QgcmFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmhlYWQ7XG4gICAgICAgIGZvcih2YXIgaW5kZXgyID0gMDsgaW5kZXgyIDwgcG9zaXRpb247IGluZGV4MisrKXtcbiAgICAgICAgICAgIGN1cnJlbnQgPSAoY3VycmVudCA9PSBudWxsID8gdm9pZCAwIDogY3VycmVudC5uZXh0KSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH07XG4gICAgX3Byb3RvLmFkZE5vZGUgPSBmdW5jdGlvbiBhZGROb2RlKG4yKSB7XG4gICAgICAgIHZhciBub2RlMiA9IHtcbiAgICAgICAgICAgIHZhbHVlOiBuMixcbiAgICAgICAgICAgIHByZXZpb3VzOiBudWxsLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBuMi5fX2xuID0gbm9kZTI7XG4gICAgICAgIGlmIChuMi5wcmV2aW91c1NpYmxpbmcgJiYgaXNOb2RlSW5MaW5rZWRMaXN0KG4yLnByZXZpb3VzU2libGluZykpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gbjIucHJldmlvdXNTaWJsaW5nLl9fbG4ubmV4dDtcbiAgICAgICAgICAgIG5vZGUyLm5leHQgPSBjdXJyZW50O1xuICAgICAgICAgICAgbm9kZTIucHJldmlvdXMgPSBuMi5wcmV2aW91c1NpYmxpbmcuX19sbjtcbiAgICAgICAgICAgIG4yLnByZXZpb3VzU2libGluZy5fX2xuLm5leHQgPSBub2RlMjtcbiAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5wcmV2aW91cyA9IG5vZGUyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG4yLm5leHRTaWJsaW5nICYmIGlzTm9kZUluTGlua2VkTGlzdChuMi5uZXh0U2libGluZykgJiYgbjIubmV4dFNpYmxpbmcuX19sbi5wcmV2aW91cykge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnQxID0gbjIubmV4dFNpYmxpbmcuX19sbi5wcmV2aW91cztcbiAgICAgICAgICAgIG5vZGUyLnByZXZpb3VzID0gY3VycmVudDE7XG4gICAgICAgICAgICBub2RlMi5uZXh0ID0gbjIubmV4dFNpYmxpbmcuX19sbjtcbiAgICAgICAgICAgIG4yLm5leHRTaWJsaW5nLl9fbG4ucHJldmlvdXMgPSBub2RlMjtcbiAgICAgICAgICAgIGlmIChjdXJyZW50MSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQxLm5leHQgPSBub2RlMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhlYWQucHJldmlvdXMgPSBub2RlMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUyLm5leHQgPSB0aGlzLmhlYWQ7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBub2RlMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZTIubmV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50YWlsID0gbm9kZTI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9O1xuICAgIF9wcm90by5yZW1vdmVOb2RlID0gZnVuY3Rpb24gcmVtb3ZlTm9kZShuMikge1xuICAgICAgICB2YXIgY3VycmVudCA9IG4yLl9fbG47XG4gICAgICAgIGlmICghdGhpcy5oZWFkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdXJyZW50LnByZXZpb3VzKSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWFkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkLnByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnQucHJldmlvdXMubmV4dCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm5leHQucHJldmlvdXMgPSBjdXJyZW50LnByZXZpb3VzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhaWwgPSBjdXJyZW50LnByZXZpb3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuMi5fX2xuKSB7XG4gICAgICAgICAgICBkZWxldGUgbjIuX19sbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgIH07XG4gICAgcmV0dXJuIERvdWJsZUxpbmtlZExpc3Q7XG59KCk7XG52YXIgbW92ZUtleSA9IGZ1bmN0aW9uKGlkLCBwYXJlbnRJZCkge1xuICAgIHJldHVybiBpZCArIFwiQFwiICsgcGFyZW50SWQ7XG59O1xudmFyIE11dGF0aW9uQnVmZmVyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBNdXRhdGlvbkJ1ZmZlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZyb3plblwiLCBmYWxzZSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsb2NrZWRcIiwgZmFsc2UpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidGV4dHNcIiwgW10pO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYXR0cmlidXRlc1wiLCBbXSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJhdHRyaWJ1dGVNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicmVtb3Zlc1wiLCBbXSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtYXBSZW1vdmVzXCIsIFtdKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1vdmVkTWFwXCIsIHt9KTtcbiAgICAgICAgLyoqXG4gICAgICogdGhlIGJyb3dzZXIgTXV0YXRpb25PYnNlcnZlciBlbWl0cyBtdWx0aXBsZSBtdXRhdGlvbnMgYWZ0ZXJcbiAgICAgKiBhIGRlbGF5IGZvciBwZXJmb3JtYW5jZSByZWFzb25zLCBtYWtpbmcgdHJhY2luZyBhZGRlZCBub2RlcyBoYXJkXG4gICAgICogaW4gb3VyIGBwcm9jZXNzTXV0YXRpb25zYCBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgd2UgYXBwZW5kIGFuIGVsZW1lbnQgZWxfMSBpbnRvIGJvZHksIGFuZCB0aGVuIGFwcGVuZFxuICAgICAqIGFub3RoZXIgZWxlbWVudCBlbF8yIGludG8gZWxfMSwgdGhlc2UgdHdvIG11dGF0aW9ucyBtYXkgYmUgcGFzc2VkIHRvIHRoZVxuICAgICAqIGNhbGxiYWNrIGZ1bmN0aW9uIHRvZ2V0aGVyIHdoZW4gdGhlIHR3byBvcGVyYXRpb25zIHdlcmUgZG9uZS5cbiAgICAgKiBHZW5lcmFsbHkgd2UgbmVlZCB0byB0cmFjZSBjaGlsZCBub2RlcyBvZiBuZXdseSBhZGRlZCBub2RlcywgYnV0IGluIHRoaXNcbiAgICAgKiBjYXNlIGlmIHdlIGNvdW50IGVsXzIgYXMgZWxfMSdzIGNoaWxkIG5vZGUgaW4gdGhlIGZpcnN0IG11dGF0aW9uIHJlY29yZCxcbiAgICAgKiB0aGVuIHdlIHdpbGwgY291bnQgZWxfMiBhZ2FpbiBpbiB0aGUgc2Vjb25kIG11dGF0aW9uIHJlY29yZCB3aGljaCB3YXNcbiAgICAgKiBkdXBsaWNhdGVkLlxuICAgICAqIFRvIGF2b2lkIG9mIGR1cGxpY2F0ZSBjb3VudGluZyBhZGRlZCBub2Rlcywgd2UgdXNlIGEgU2V0IHRvIHN0b3JlXG4gICAgICogYWRkZWQgbm9kZXMgYW5kIGl0cyBjaGlsZCBub2RlcyBkdXJpbmcgaXRlcmF0ZSBtdXRhdGlvbiByZWNvcmRzLiBUaGVuXG4gICAgICogY29sbGVjdCBhZGRlZCBub2RlcyBmcm9tIHRoZSBTZXQgd2hpY2ggaGF2ZSBubyBkdXBsaWNhdGUgY29weS4gQnV0XG4gICAgICogdGhpcyBhbHNvIGNhdXNlcyBuZXdseSBhZGRlZCBub2RlcyB3aWxsIG5vdCBiZSBzZXJpYWxpemVkIHdpdGggaWQgQVNBUCxcbiAgICAgKiB3aGljaCBtZWFucyBhbGwgdGhlIGlkIHJlbGF0ZWQgY2FsY3VsYXRpb24gc2hvdWxkIGJlIGxhenkgdG9vLlxuICAgICAqLyBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYWRkZWRTZXRcIiwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtb3ZlZFNldFwiLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImRyb3BwZWRTZXRcIiwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZW1vdmVzU3ViVHJlZUNhY2hlXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibXV0YXRpb25DYlwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImJsb2NrQ2xhc3NcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJibG9ja1NlbGVjdG9yXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWFza1RleHRDbGFzc1wiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1hc2tUZXh0U2VsZWN0b3JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpbmxpbmVTdHlsZXNoZWV0XCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWFza0lucHV0T3B0aW9uc1wiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1hc2tUZXh0Rm5cIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtYXNrSW5wdXRGblwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImtlZXBJZnJhbWVTcmNGblwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJlY29yZENhbnZhc1wiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlubGluZUltYWdlc1wiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInNsaW1ET01PcHRpb25zXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiZGF0YVVSTE9wdGlvbnNcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJkb2NcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtaXJyb3JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpZnJhbWVNYW5hZ2VyXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3R5bGVzaGVldE1hbmFnZXJcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzaGFkb3dEb21NYW5hZ2VyXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY2FudmFzTWFuYWdlclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByb2Nlc3NlZE5vZGVNYW5hZ2VyXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwidW5hdHRhY2hlZERvY1wiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByb2Nlc3NNdXRhdGlvbnNcIiwgZnVuY3Rpb24obXV0YXRpb25zKSB7XG4gICAgICAgICAgICBtdXRhdGlvbnMuZm9yRWFjaChfdGhpcy5wcm9jZXNzTXV0YXRpb24pO1xuICAgICAgICAgICAgX3RoaXMuZW1pdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImVtaXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuZnJvemVuIHx8IF90aGlzLmxvY2tlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhZGRzID0gW107XG4gICAgICAgICAgICB2YXIgYWRkZWRJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgICAgdmFyIGFkZExpc3QgPSBuZXcgRG91YmxlTGlua2VkTGlzdCgpO1xuICAgICAgICAgICAgdmFyIGdldE5leHRJZCA9IGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5zID0gbjI7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRJZCA9IElHTk9SRURfTk9ERTtcbiAgICAgICAgICAgICAgICB3aGlsZShuZXh0SWQgPT09IElHTk9SRURfTk9ERSl7XG4gICAgICAgICAgICAgICAgICAgIG5zID0gbnMgJiYgbnMubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIG5leHRJZCA9IG5zICYmIF90aGlzLm1pcnJvci5nZXRJZChucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0SWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHB1c2hBZGQgPSBmdW5jdGlvbihuMikge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBpbmRleC5wYXJlbnROb2RlKG4yKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcmVudCB8fCAhaW5Eb20objIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNzc0NhcHR1cmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKG4yLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50LnRhZ05hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRUYWcgPT09IFwiVEVYVEFSRUFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudFRhZyA9PT0gXCJTVFlMRVwiICYmIF90aGlzLmFkZGVkU2V0LmhhcyhwYXJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjc3NDYXB0dXJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudElkID0gaXNTaGFkb3dSb290KHBhcmVudCkgPyBfdGhpcy5taXJyb3IuZ2V0SWQoZ2V0U2hhZG93SG9zdChuMikpIDogX3RoaXMubWlycm9yLmdldElkKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRJZCA9IGdldE5leHRJZChuMik7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudElkID09PSAtMSB8fCBuZXh0SWQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRMaXN0LmFkZE5vZGUobjIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc24gPSBzZXJpYWxpemVOb2RlV2l0aElkKG4yLCB7XG4gICAgICAgICAgICAgICAgICAgIGRvYzogX3RoaXMuZG9jLFxuICAgICAgICAgICAgICAgICAgICBtaXJyb3I6IF90aGlzLm1pcnJvcixcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tDbGFzczogX3RoaXMuYmxvY2tDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tTZWxlY3RvcjogX3RoaXMuYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRDbGFzczogX3RoaXMubWFza1RleHRDbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcjogX3RoaXMubWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgICAgICAgICAgc2tpcENoaWxkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBuZXdseUFkZGVkRWxlbWVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldDogX3RoaXMuaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogX3RoaXMubWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRGbjogX3RoaXMubWFza1RleHRGbixcbiAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0Rm46IF90aGlzLm1hc2tJbnB1dEZuLFxuICAgICAgICAgICAgICAgICAgICBzbGltRE9NT3B0aW9uczogX3RoaXMuc2xpbURPTU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zOiBfdGhpcy5kYXRhVVJMT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzOiBfdGhpcy5yZWNvcmRDYW52YXMsXG4gICAgICAgICAgICAgICAgICAgIGlubGluZUltYWdlczogX3RoaXMuaW5saW5lSW1hZ2VzLFxuICAgICAgICAgICAgICAgICAgICBvblNlcmlhbGl6ZTogZnVuY3Rpb24oY3VycmVudE4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRJZnJhbWUoY3VycmVudE4sIF90aGlzLm1pcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5pZnJhbWVNYW5hZ2VyLmFkZElmcmFtZShjdXJyZW50Tik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkU3R5bGVzaGVldChjdXJyZW50TiwgX3RoaXMubWlycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLnRyYWNrTGlua0VsZW1lbnQoY3VycmVudE4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1NoYWRvd1Jvb3QobjIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2hhZG93RG9tTWFuYWdlci5hZGRTaGFkb3dSb290KGluZGV4LnNoYWRvd1Jvb3QobjIpLCBfdGhpcy5kb2MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbklmcmFtZUxvYWQ6IGZ1bmN0aW9uKGlmcmFtZSwgY2hpbGRTbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaWZyYW1lTWFuYWdlci5hdHRhY2hJZnJhbWUoaWZyYW1lLCBjaGlsZFNuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNoYWRvd0RvbU1hbmFnZXIub2JzZXJ2ZUF0dGFjaFNoYWRvdyhpZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkOiBmdW5jdGlvbihsaW5rLCBjaGlsZFNuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdHlsZXNoZWV0TWFuYWdlci5hdHRhY2hMaW5rRWxlbWVudChsaW5rLCBjaGlsZFNuKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY3NzQ2FwdHVyZWQ6IGNzc0NhcHR1cmVkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNuKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogcGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0SWQ6IG5leHRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IHNuXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhZGRlZElkcy5hZGQoc24uaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aGlsZShfdGhpcy5tYXBSZW1vdmVzLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgX3RoaXMubWlycm9yLnJlbW92ZU5vZGVGcm9tTWFwKF90aGlzLm1hcFJlbW92ZXMuc2hpZnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShfdGhpcy5tb3ZlZFNldCksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICB2YXIgbjIgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQYXJlbnRSZW1vdmVkKF90aGlzLnJlbW92ZXNTdWJUcmVlQ2FjaGUsIG4yLCBfdGhpcy5taXJyb3IpICYmICFfdGhpcy5tb3ZlZFNldC5oYXMoaW5kZXgucGFyZW50Tm9kZShuMikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwdXNoQWRkKG4yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yMSA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShfdGhpcy5hZGRlZFNldCksIF9zdGVwMTsgIShfc3RlcDEgPSBfaXRlcmF0b3IxKCkpLmRvbmU7KXtcbiAgICAgICAgICAgICAgICB2YXIgbjIxID0gX3N0ZXAxLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICghaXNBbmNlc3RvckluU2V0KF90aGlzLmRyb3BwZWRTZXQsIG4yMSkgJiYgIWlzUGFyZW50UmVtb3ZlZChfdGhpcy5yZW1vdmVzU3ViVHJlZUNhY2hlLCBuMjEsIF90aGlzLm1pcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcHVzaEFkZChuMjEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBbmNlc3RvckluU2V0KF90aGlzLm1vdmVkU2V0LCBuMjEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHB1c2hBZGQobjIxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kcm9wcGVkU2V0LmFkZChuMjEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGUgPSBudWxsO1xuICAgICAgICAgICAgd2hpbGUoYWRkTGlzdC5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIHZhciBub2RlMiA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50SWQgPSBfdGhpcy5taXJyb3IuZ2V0SWQoaW5kZXgucGFyZW50Tm9kZShjYW5kaWRhdGUudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRJZCA9IGdldE5leHRJZChjYW5kaWRhdGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50SWQgIT09IC0xICYmIG5leHRJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUyID0gY2FuZGlkYXRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbm9kZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRhaWxOb2RlID0gYWRkTGlzdC50YWlsO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSh0YWlsTm9kZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX25vZGUgPSB0YWlsTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhaWxOb2RlID0gdGFpbE5vZGUucHJldmlvdXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX25vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50SWQxID0gX3RoaXMubWlycm9yLmdldElkKGluZGV4LnBhcmVudE5vZGUoX25vZGUudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dElkMSA9IGdldE5leHRJZChfbm9kZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRJZDEgPT09IC0xKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJlbnRJZDEgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUyID0gX25vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1bmhhbmRsZWROb2RlID0gX25vZGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBpbmRleC5wYXJlbnROb2RlKHVuaGFuZGxlZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hhZG93SG9zdCA9IGluZGV4Lmhvc3QocGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJZDIgPSBfdGhpcy5taXJyb3IuZ2V0SWQoc2hhZG93SG9zdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50SWQyICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUyID0gX25vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlMikge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZShhZGRMaXN0LmhlYWQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkTGlzdC5yZW1vdmVOb2RlKGFkZExpc3QuaGVhZC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZSA9IG5vZGUyLnByZXZpb3VzO1xuICAgICAgICAgICAgICAgIGFkZExpc3QucmVtb3ZlTm9kZShub2RlMi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcHVzaEFkZChub2RlMi52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0czogX3RoaXMudGV4dHMubWFwKGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG4yID0gdGV4dC5ub2RlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gaW5kZXgucGFyZW50Tm9kZShuMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZ2VuVGV4dEFyZWFWYWx1ZU11dGF0aW9uKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBfdGhpcy5taXJyb3IuZ2V0SWQobjIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRleHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWFkZGVkSWRzLmhhcyh0ZXh0LmlkKTtcbiAgICAgICAgICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24odGV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubWlycm9yLmhhcyh0ZXh0LmlkKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBfdGhpcy5hdHRyaWJ1dGVzLm1hcChmdW5jdGlvbihhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGUuYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLnN0eWxlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlmZkFzU3RyID0gSlNPTi5zdHJpbmdpZnkoYXR0cmlidXRlLnN0eWxlRGlmZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdW5jaGFuZ2VkQXNTdHIgPSBKU09OLnN0cmluZ2lmeShhdHRyaWJ1dGUuX3VuY2hhbmdlZFN0eWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZkFzU3RyLmxlbmd0aCA8IGF0dHJpYnV0ZXMuc3R5bGUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChkaWZmQXNTdHIgKyB1bmNoYW5nZWRBc1N0cikuc3BsaXQoXCJ2YXIoXCIpLmxlbmd0aCA9PT0gYXR0cmlidXRlcy5zdHlsZS5zcGxpdChcInZhcihcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuc3R5bGUgPSBhdHRyaWJ1dGUuc3R5bGVEaWZmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IF90aGlzLm1pcnJvci5nZXRJZChhdHRyaWJ1dGUubm9kZSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWFkZGVkSWRzLmhhcyhhdHRyaWJ1dGUuaWQpO1xuICAgICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbihhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm1pcnJvci5oYXMoYXR0cmlidXRlLmlkKTtcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICByZW1vdmVzOiBfdGhpcy5yZW1vdmVzLFxuICAgICAgICAgICAgICAgIGFkZHM6IGFkZHNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXBheWxvYWQudGV4dHMubGVuZ3RoICYmICFwYXlsb2FkLmF0dHJpYnV0ZXMubGVuZ3RoICYmICFwYXlsb2FkLnJlbW92ZXMubGVuZ3RoICYmICFwYXlsb2FkLmFkZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMudGV4dHMgPSBbXTtcbiAgICAgICAgICAgIF90aGlzLmF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgICAgICAgIF90aGlzLmF0dHJpYnV0ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgICAgICAgX3RoaXMucmVtb3ZlcyA9IFtdO1xuICAgICAgICAgICAgX3RoaXMuYWRkZWRTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgICAgX3RoaXMubW92ZWRTZXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICAgICAgX3RoaXMuZHJvcHBlZFNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgICAgICBfdGhpcy5yZW1vdmVzU3ViVHJlZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgICAgIF90aGlzLm1vdmVkTWFwID0ge307XG4gICAgICAgICAgICBfdGhpcy5tdXRhdGlvbkNiKHBheWxvYWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImdlblRleHRBcmVhVmFsdWVNdXRhdGlvblwiLCBmdW5jdGlvbih0ZXh0YXJlYSkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBfdGhpcy5hdHRyaWJ1dGVNYXAuZ2V0KHRleHRhcmVhKTtcbiAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IHRleHRhcmVhLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVEaWZmOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgX3VuY2hhbmdlZFN0eWxlczoge31cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIF90aGlzLmF0dHJpYnV0ZXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hdHRyaWJ1dGVNYXAuc2V0KHRleHRhcmVhLCBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0uYXR0cmlidXRlcy52YWx1ZSA9IEFycmF5LmZyb20oaW5kZXguY2hpbGROb2Rlcyh0ZXh0YXJlYSksIGZ1bmN0aW9uKGNuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4LnRleHRDb250ZW50KGNuKSB8fCBcIlwiO1xuICAgICAgICAgICAgfSkuam9pbihcIlwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJwcm9jZXNzTXV0YXRpb25cIiwgZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgaWYgKGlzSWdub3JlZChtLnRhcmdldCwgX3RoaXMubWlycm9yLCBfdGhpcy5zbGltRE9NT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzd2l0Y2gobS50eXBlKXtcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2hhcmFjdGVyRGF0YVwiOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBpbmRleC50ZXh0Q29udGVudChtLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQmxvY2tlZChtLnRhcmdldCwgX3RoaXMuYmxvY2tDbGFzcywgX3RoaXMuYmxvY2tTZWxlY3RvciwgZmFsc2UpICYmIHZhbHVlICE9PSBtLm9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudGV4dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZWVkTWFza2luZ1RleHQobS50YXJnZXQsIF90aGlzLm1hc2tUZXh0Q2xhc3MsIF90aGlzLm1hc2tUZXh0U2VsZWN0b3IsIHRydWUpICYmIHZhbHVlID8gX3RoaXMubWFza1RleHRGbiA/IF90aGlzLm1hc2tUZXh0Rm4odmFsdWUsIGNsb3Nlc3RFbGVtZW50T2ZOb2RlKG0udGFyZ2V0KSkgOiB2YWx1ZS5yZXBsYWNlKC9bXFxTXS9nLCBcIipcIikgOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogbS50YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImF0dHJpYnV0ZXNcIjpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IG0udGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBtLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUxID0gbS50YXJnZXQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09IFwidmFsdWVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZ2V0SW5wdXRUeXBlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUxID0gbWFza0lucHV0VmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IF90aGlzLm1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ05hbWU6IHRhcmdldC50YWdOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogX3RoaXMubWFza0lucHV0Rm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0Jsb2NrZWQobS50YXJnZXQsIF90aGlzLmJsb2NrQ2xhc3MsIF90aGlzLmJsb2NrU2VsZWN0b3IsIGZhbHNlKSB8fCB2YWx1ZTEgPT09IG0ub2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF90aGlzLmF0dHJpYnV0ZU1hcC5nZXQobS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC50YWdOYW1lID09PSBcIklGUkFNRVwiICYmIGF0dHJpYnV0ZU5hbWUgPT09IFwic3JjXCIgJiYgIV90aGlzLmtlZXBJZnJhbWVTcmNGbih2YWx1ZTEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQuY29udGVudERvY3VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPSBcInJyX3NyY1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBtLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlRGlmZjoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF91bmNoYW5nZWRTdHlsZXM6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5hdHRyaWJ1dGVzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYXR0cmlidXRlTWFwLnNldChtLnRhcmdldCwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gXCJ0eXBlXCIgJiYgdGFyZ2V0LnRhZ05hbWUgPT09IFwiSU5QVVRcIiAmJiAobS5vbGRWYWx1ZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpID09PSBcInBhc3N3b3JkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwiZGF0YS1yci1pcy1wYXNzd29yZFwiLCBcInRydWVcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlnbm9yZUF0dHJpYnV0ZSh0YXJnZXQudGFnTmFtZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSB0cmFuc2Zvcm1BdHRyaWJ1dGUoX3RoaXMuZG9jLCB0b0xvd2VyQ2FzZSh0YXJnZXQudGFnTmFtZSksIHRvTG93ZXJDYXNlKGF0dHJpYnV0ZU5hbWUpLCB2YWx1ZTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSBcInN0eWxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy51bmF0dGFjaGVkRG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnVuYXR0YWNoZWREb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudW5hdHRhY2hlZERvYyA9IF90aGlzLmRvYztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkID0gX3RoaXMudW5hdHRhY2hlZERvYy5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0ub2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZC5zZXRBdHRyaWJ1dGUoXCJzdHlsZVwiLCBtLm9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShBcnJheS5mcm9tKHRhcmdldC5zdHlsZSkpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG5hbWUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdQcmlvcml0eSA9IHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KHBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkLnN0eWxlLmdldFByb3BlcnR5VmFsdWUocG5hbWUpIHx8IG5ld1ByaW9yaXR5ICE9PSBvbGQuc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eShwbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3UHJpb3JpdHkgPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdHlsZURpZmZbcG5hbWVdID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdHlsZURpZmZbcG5hbWVdID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdQcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5fdW5jaGFuZ2VkU3R5bGVzW3BuYW1lXSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ByaW9yaXR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIF9pdGVyYXRvcjEgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UoQXJyYXkuZnJvbShvbGQuc3R5bGUpKSwgX3N0ZXAxOyAhKF9zdGVwMSA9IF9pdGVyYXRvcjEoKSkuZG9uZTspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBuYW1lMSA9IF9zdGVwMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwbmFtZTEpID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdHlsZURpZmZbcG5hbWUxXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRyaWJ1dGVOYW1lID09PSBcIm9wZW5cIiAmJiB0YXJnZXQudGFnTmFtZSA9PT0gXCJESUFMT0dcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Lm1hdGNoZXMoXCJkaWFsb2c6bW9kYWxcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYXR0cmlidXRlc1tcInJyX29wZW5fbW9kZVwiXSA9IFwibW9kYWxcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYXR0cmlidXRlc1tcInJyX29wZW5fbW9kZVwiXSA9IFwibm9uLW1vZGFsXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJjaGlsZExpc3RcIjpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmxvY2tlZChtLnRhcmdldCwgX3RoaXMuYmxvY2tDbGFzcywgX3RoaXMuYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtLnRhcmdldC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZW5UZXh0QXJlYVZhbHVlTXV0YXRpb24obS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG0uYWRkZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdlbkFkZHMobjIsIG0udGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbS5yZW1vdmVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbihuMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlSWQgPSBfdGhpcy5taXJyb3IuZ2V0SWQobjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJZCA9IGlzU2hhZG93Um9vdChtLnRhcmdldCkgPyBfdGhpcy5taXJyb3IuZ2V0SWQoaW5kZXguaG9zdChtLnRhcmdldCkpIDogX3RoaXMubWlycm9yLmdldElkKG0udGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNCbG9ja2VkKG0udGFyZ2V0LCBfdGhpcy5ibG9ja0NsYXNzLCBfdGhpcy5ibG9ja1NlbGVjdG9yLCBmYWxzZSkgfHwgaXNJZ25vcmVkKG4yLCBfdGhpcy5taXJyb3IsIF90aGlzLnNsaW1ET01PcHRpb25zKSB8fCAhaXNTZXJpYWxpemVkKG4yLCBfdGhpcy5taXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmFkZGVkU2V0LmhhcyhuMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVlcERlbGV0ZShfdGhpcy5hZGRlZFNldCwgbjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5kcm9wcGVkU2V0LmFkZChuMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfdGhpcy5hZGRlZFNldC5oYXMobS50YXJnZXQpICYmIG5vZGVJZCA9PT0gLTEpIDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FuY2VzdG9yUmVtb3ZlZChtLnRhcmdldCwgX3RoaXMubWlycm9yKSkgO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLm1vdmVkU2V0LmhhcyhuMikgJiYgX3RoaXMubW92ZWRNYXBbbW92ZUtleShub2RlSWQsIHBhcmVudElkKV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVlcERlbGV0ZShfdGhpcy5tb3ZlZFNldCwgbjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogcGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNTaGFkb3c6IGlzU2hhZG93Um9vdChtLnRhcmdldCkgJiYgaXNOYXRpdmVTaGFkb3dEb20obS50YXJnZXQpID8gdHJ1ZSA6IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc1JlbW92ZXMobjIsIF90aGlzLnJlbW92ZXNTdWJUcmVlQ2FjaGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tYXBSZW1vdmVzLnB1c2gobjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICogTWFrZSBzdXJlIHlvdSBjaGVjayBpZiBgbmAncyBwYXJlbnQgaXMgYmxvY2tlZCBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uXG4gICAgICogKi8gX19wdWJsaWNGaWVsZCh0aGlzLCBcImdlbkFkZHNcIiwgZnVuY3Rpb24objIsIHRhcmdldCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb2Nlc3NlZE5vZGVNYW5hZ2VyLmluT3RoZXJCdWZmZXIobjIsIF90aGlzKSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKF90aGlzLmFkZGVkU2V0LmhhcyhuMikgfHwgX3RoaXMubW92ZWRTZXQuaGFzKG4yKSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKF90aGlzLm1pcnJvci5oYXNOb2RlKG4yKSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0lnbm9yZWQobjIsIF90aGlzLm1pcnJvciwgX3RoaXMuc2xpbURPTU9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMubW92ZWRTZXQuYWRkKG4yKTtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0SWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgJiYgX3RoaXMubWlycm9yLmhhc05vZGUodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRJZCA9IF90aGlzLm1pcnJvci5nZXRJZCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0SWQgJiYgdGFyZ2V0SWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1vdmVkTWFwW21vdmVLZXkoX3RoaXMubWlycm9yLmdldElkKG4yKSwgdGFyZ2V0SWQpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRlZFNldC5hZGQobjIpO1xuICAgICAgICAgICAgICAgIF90aGlzLmRyb3BwZWRTZXQuZGVsZXRlKG4yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNCbG9ja2VkKG4yLCBfdGhpcy5ibG9ja0NsYXNzLCBfdGhpcy5ibG9ja1NlbGVjdG9yLCBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleC5jaGlsZE5vZGVzKG4yKS5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkTikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZ2VuQWRkcyhjaGlsZE4pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChoYXNTaGFkb3dSb290KG4yKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleC5jaGlsZE5vZGVzKGluZGV4LnNoYWRvd1Jvb3QobjIpKS5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvY2Vzc2VkTm9kZU1hbmFnZXIuYWRkKGNoaWxkTiwgX3RoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZ2VuQWRkcyhjaGlsZE4sIG4yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IE11dGF0aW9uQnVmZmVyLnByb3RvdHlwZTtcbiAgICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQob3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBbXG4gICAgICAgICAgICBcIm11dGF0aW9uQ2JcIixcbiAgICAgICAgICAgIFwiYmxvY2tDbGFzc1wiLFxuICAgICAgICAgICAgXCJibG9ja1NlbGVjdG9yXCIsXG4gICAgICAgICAgICBcIm1hc2tUZXh0Q2xhc3NcIixcbiAgICAgICAgICAgIFwibWFza1RleHRTZWxlY3RvclwiLFxuICAgICAgICAgICAgXCJpbmxpbmVTdHlsZXNoZWV0XCIsXG4gICAgICAgICAgICBcIm1hc2tJbnB1dE9wdGlvbnNcIixcbiAgICAgICAgICAgIFwibWFza1RleHRGblwiLFxuICAgICAgICAgICAgXCJtYXNrSW5wdXRGblwiLFxuICAgICAgICAgICAgXCJrZWVwSWZyYW1lU3JjRm5cIixcbiAgICAgICAgICAgIFwicmVjb3JkQ2FudmFzXCIsXG4gICAgICAgICAgICBcImlubGluZUltYWdlc1wiLFxuICAgICAgICAgICAgXCJzbGltRE9NT3B0aW9uc1wiLFxuICAgICAgICAgICAgXCJkYXRhVVJMT3B0aW9uc1wiLFxuICAgICAgICAgICAgXCJkb2NcIixcbiAgICAgICAgICAgIFwibWlycm9yXCIsXG4gICAgICAgICAgICBcImlmcmFtZU1hbmFnZXJcIixcbiAgICAgICAgICAgIFwic3R5bGVzaGVldE1hbmFnZXJcIixcbiAgICAgICAgICAgIFwic2hhZG93RG9tTWFuYWdlclwiLFxuICAgICAgICAgICAgXCJjYW52YXNNYW5hZ2VyXCIsXG4gICAgICAgICAgICBcInByb2Nlc3NlZE5vZGVNYW5hZ2VyXCJcbiAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgX3RoaXNba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZnJlZXplID0gZnVuY3Rpb24gZnJlZXplKCkge1xuICAgICAgICB0aGlzLmZyb3plbiA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5mcmVlemUoKTtcbiAgICB9O1xuICAgIF9wcm90by51bmZyZWV6ZSA9IGZ1bmN0aW9uIHVuZnJlZXplKCkge1xuICAgICAgICB0aGlzLmZyb3plbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbnZhc01hbmFnZXIudW5mcmVlemUoKTtcbiAgICAgICAgdGhpcy5lbWl0KCk7XG4gICAgfTtcbiAgICBfcHJvdG8uaXNGcm96ZW4gPSBmdW5jdGlvbiBpc0Zyb3plbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvemVuO1xuICAgIH07XG4gICAgX3Byb3RvLmxvY2sgPSBmdW5jdGlvbiBsb2NrKCkge1xuICAgICAgICB0aGlzLmxvY2tlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5sb2NrKCk7XG4gICAgfTtcbiAgICBfcHJvdG8udW5sb2NrID0gZnVuY3Rpb24gdW5sb2NrKCkge1xuICAgICAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbnZhc01hbmFnZXIudW5sb2NrKCk7XG4gICAgICAgIHRoaXMuZW1pdCgpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuc2hhZG93RG9tTWFuYWdlci5yZXNldCgpO1xuICAgICAgICB0aGlzLmNhbnZhc01hbmFnZXIucmVzZXQoKTtcbiAgICB9O1xuICAgIHJldHVybiBNdXRhdGlvbkJ1ZmZlcjtcbn0oKTtcbmZ1bmN0aW9uIGRlZXBEZWxldGUoYWRkc1NldCwgbjIpIHtcbiAgICBhZGRzU2V0LmRlbGV0ZShuMik7XG4gICAgaW5kZXguY2hpbGROb2RlcyhuMikuZm9yRWFjaChmdW5jdGlvbihjaGlsZE4pIHtcbiAgICAgICAgcmV0dXJuIGRlZXBEZWxldGUoYWRkc1NldCwgY2hpbGROKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NSZW1vdmVzKG4yLCBjYWNoZSkge1xuICAgIHZhciBxdWV1ZSA9IFtcbiAgICAgICAgbjJcbiAgICBdO1xuICAgIHdoaWxlKHF1ZXVlLmxlbmd0aCl7XG4gICAgICAgIHZhciBuZXh0ID0gcXVldWUucG9wKCk7XG4gICAgICAgIGlmIChjYWNoZS5oYXMobmV4dCkpIGNvbnRpbnVlO1xuICAgICAgICBjYWNoZS5hZGQobmV4dCk7XG4gICAgICAgIGluZGV4LmNoaWxkTm9kZXMobmV4dCkuZm9yRWFjaChmdW5jdGlvbihuMjIpIHtcbiAgICAgICAgICAgIHJldHVybiBxdWV1ZS5wdXNoKG4yMik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm47XG59XG5mdW5jdGlvbiBpc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgbjIsIG1pcnJvcjIpIHtcbiAgICBpZiAocmVtb3Zlcy5zaXplID09PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIF9pc1BhcmVudFJlbW92ZWQocmVtb3ZlcywgbjIpO1xufVxuZnVuY3Rpb24gX2lzUGFyZW50UmVtb3ZlZChyZW1vdmVzLCBuMiwgX21pcnJvcjIpIHtcbiAgICB2YXIgbm9kZTIgPSBpbmRleC5wYXJlbnROb2RlKG4yKTtcbiAgICBpZiAoIW5vZGUyKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHJlbW92ZXMuaGFzKG5vZGUyKTtcbn1cbmZ1bmN0aW9uIGlzQW5jZXN0b3JJblNldChzZXQsIG4yKSB7XG4gICAgaWYgKHNldC5zaXplID09PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIF9pc0FuY2VzdG9ySW5TZXQoc2V0LCBuMik7XG59XG5mdW5jdGlvbiBfaXNBbmNlc3RvckluU2V0KHNldCwgbjIpIHtcbiAgICB2YXIgcGFyZW50ID0gaW5kZXgucGFyZW50Tm9kZShuMik7XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc2V0LmhhcyhwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gX2lzQW5jZXN0b3JJblNldChzZXQsIHBhcmVudCk7XG59XG52YXIgZXJyb3JIYW5kbGVyO1xuZnVuY3Rpb24gcmVnaXN0ZXJFcnJvckhhbmRsZXIoaGFuZGxlcikge1xuICAgIGVycm9ySGFuZGxlciA9IGhhbmRsZXI7XG59XG5mdW5jdGlvbiB1bnJlZ2lzdGVyRXJyb3JIYW5kbGVyKCkge1xuICAgIGVycm9ySGFuZGxlciA9IHZvaWQgMDtcbn1cbnZhciBjYWxsYmFja1dyYXBwZXIgPSBmdW5jdGlvbihjYikge1xuICAgIGlmICghZXJyb3JIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiBjYjtcbiAgICB9XG4gICAgdmFyIHJyd2ViV3JhcHBlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCByZXN0ID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICByZXN0W19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gY2IuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQocmVzdCkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9ySGFuZGxlciAmJiBlcnJvckhhbmRsZXIoZXJyb3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBycndlYldyYXBwZWQ7XG59O1xudmFyIG11dGF0aW9uQnVmZmVycyA9IFtdO1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoXCJjb21wb3NlZFBhdGhcIiBpbiBldmVudCkge1xuICAgICAgICAgICAgdmFyIHBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKFwicGF0aFwiIGluIGV2ZW50ICYmIGV2ZW50LnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQucGF0aFswXTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcmV0dXJuIGV2ZW50ICYmIGV2ZW50LnRhcmdldDtcbn1cbmZ1bmN0aW9uIGluaXRNdXRhdGlvbk9ic2VydmVyKG9wdGlvbnMsIHJvb3RFbCkge1xuICAgIHZhciBtdXRhdGlvbkJ1ZmZlciA9IG5ldyBNdXRhdGlvbkJ1ZmZlcigpO1xuICAgIG11dGF0aW9uQnVmZmVycy5wdXNoKG11dGF0aW9uQnVmZmVyKTtcbiAgICBtdXRhdGlvbkJ1ZmZlci5pbml0KG9wdGlvbnMpO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyAobXV0YXRpb25PYnNlcnZlckN0b3IoKSkoY2FsbGJhY2tXcmFwcGVyKG11dGF0aW9uQnVmZmVyLnByb2Nlc3NNdXRhdGlvbnMuYmluZChtdXRhdGlvbkJ1ZmZlcikpKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKHJvb3RFbCwge1xuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSxcbiAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICAgICAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlLFxuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5mdW5jdGlvbiBpbml0TW92ZU9ic2VydmVyKHBhcmFtKSB7XG4gICAgdmFyIG1vdXNlbW92ZUNiID0gcGFyYW0ubW91c2Vtb3ZlQ2IsIHNhbXBsaW5nID0gcGFyYW0uc2FtcGxpbmcsIGRvYyA9IHBhcmFtLmRvYywgbWlycm9yMiA9IHBhcmFtLm1pcnJvcjtcbiAgICBpZiAoc2FtcGxpbmcubW91c2Vtb3ZlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gICAgdmFyIHRocmVzaG9sZCA9IHR5cGVvZiBzYW1wbGluZy5tb3VzZW1vdmUgPT09IFwibnVtYmVyXCIgPyBzYW1wbGluZy5tb3VzZW1vdmUgOiA1MDtcbiAgICB2YXIgY2FsbGJhY2tUaHJlc2hvbGQgPSB0eXBlb2Ygc2FtcGxpbmcubW91c2Vtb3ZlQ2FsbGJhY2sgPT09IFwibnVtYmVyXCIgPyBzYW1wbGluZy5tb3VzZW1vdmVDYWxsYmFjayA6IDUwMDtcbiAgICB2YXIgcG9zaXRpb25zID0gW107XG4gICAgdmFyIHRpbWVCYXNlbGluZTtcbiAgICB2YXIgd3JhcHBlZENiID0gdGhyb3R0bGUoY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICB2YXIgdG90YWxPZmZzZXQgPSBEYXRlLm5vdygpIC0gdGltZUJhc2VsaW5lO1xuICAgICAgICBtb3VzZW1vdmVDYihwb3NpdGlvbnMubWFwKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgIHAudGltZU9mZnNldCAtPSB0b3RhbE9mZnNldDtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9KSwgc291cmNlKTtcbiAgICAgICAgcG9zaXRpb25zID0gW107XG4gICAgICAgIHRpbWVCYXNlbGluZSA9IG51bGw7XG4gICAgfSksIGNhbGxiYWNrVGhyZXNob2xkKTtcbiAgICB2YXIgdXBkYXRlUG9zaXRpb24gPSBjYWxsYmFja1dyYXBwZXIodGhyb3R0bGUoY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZ0KTtcbiAgICAgICAgdmFyIF9yZWYgPSBsZWdhY3lfaXNUb3VjaEV2ZW50KGV2dCkgPyBldnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldnQsIGNsaWVudFggPSBfcmVmLmNsaWVudFgsIGNsaWVudFkgPSBfcmVmLmNsaWVudFk7XG4gICAgICAgIGlmICghdGltZUJhc2VsaW5lKSB7XG4gICAgICAgICAgICB0aW1lQmFzZWxpbmUgPSBub3dUaW1lc3RhbXAoKTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB4OiBjbGllbnRYLFxuICAgICAgICAgICAgeTogY2xpZW50WSxcbiAgICAgICAgICAgIGlkOiBtaXJyb3IyLmdldElkKHRhcmdldCksXG4gICAgICAgICAgICB0aW1lT2Zmc2V0OiBub3dUaW1lc3RhbXAoKSAtIHRpbWVCYXNlbGluZVxuICAgICAgICB9KTtcbiAgICAgICAgd3JhcHBlZENiKHR5cGVvZiBEcmFnRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgX2luc3RhbmNlb2YoZXZ0LCBEcmFnRXZlbnQpID8gSW5jcmVtZW50YWxTb3VyY2UuRHJhZyA6IF9pbnN0YW5jZW9mKGV2dCwgTW91c2VFdmVudCkgPyBJbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZU1vdmUgOiBJbmNyZW1lbnRhbFNvdXJjZS5Ub3VjaE1vdmUpO1xuICAgIH0pLCB0aHJlc2hvbGQsIHtcbiAgICAgICAgdHJhaWxpbmc6IGZhbHNlXG4gICAgfSkpO1xuICAgIHZhciBoYW5kbGVycyA9IFtcbiAgICAgICAgb24oXCJtb3VzZW1vdmVcIiwgdXBkYXRlUG9zaXRpb24sIGRvYyksXG4gICAgICAgIG9uKFwidG91Y2htb3ZlXCIsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpLFxuICAgICAgICBvbihcImRyYWdcIiwgdXBkYXRlUG9zaXRpb24sIGRvYylcbiAgICBdO1xuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgcmV0dXJuIGgoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbml0TW91c2VJbnRlcmFjdGlvbk9ic2VydmVyKHBhcmFtKSB7XG4gICAgdmFyIG1vdXNlSW50ZXJhY3Rpb25DYiA9IHBhcmFtLm1vdXNlSW50ZXJhY3Rpb25DYiwgZG9jID0gcGFyYW0uZG9jLCBtaXJyb3IyID0gcGFyYW0ubWlycm9yLCBibG9ja0NsYXNzID0gcGFyYW0uYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciA9IHBhcmFtLmJsb2NrU2VsZWN0b3IsIHNhbXBsaW5nID0gcGFyYW0uc2FtcGxpbmc7XG4gICAgaWYgKHNhbXBsaW5nLm1vdXNlSW50ZXJhY3Rpb24gPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgICB2YXIgZGlzYWJsZU1hcCA9IHNhbXBsaW5nLm1vdXNlSW50ZXJhY3Rpb24gPT09IHRydWUgfHwgc2FtcGxpbmcubW91c2VJbnRlcmFjdGlvbiA9PT0gdm9pZCAwID8ge30gOiBzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uO1xuICAgIHZhciBoYW5kbGVycyA9IFtdO1xuICAgIHZhciBjdXJyZW50UG9pbnRlclR5cGUgPSBudWxsO1xuICAgIHZhciBnZXRIYW5kbGVyID0gZnVuY3Rpb24oZXZlbnRLZXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBvaW50ZXJUeXBlID0gbnVsbDtcbiAgICAgICAgICAgIHZhciB0aGlzRXZlbnRLZXkgPSBldmVudEtleTtcbiAgICAgICAgICAgIGlmIChcInBvaW50ZXJUeXBlXCIgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2goZXZlbnQucG9pbnRlclR5cGUpe1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwibW91c2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gUG9pbnRlclR5cGVzLk1vdXNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b3VjaFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuVG91Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBlblwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuUGVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb2ludGVyVHlwZSA9PT0gUG9pbnRlclR5cGVzLlRvdWNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0gPT09IE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlRG93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpc0V2ZW50S2V5ID0gXCJUb3VjaFN0YXJ0XCI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTW91c2VJbnRlcmFjdGlvbnNbZXZlbnRLZXldID09PSBNb3VzZUludGVyYWN0aW9ucy5Nb3VzZVVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzRXZlbnRLZXkgPSBcIlRvdWNoRW5kXCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBvaW50ZXJUeXBlID09PSBQb2ludGVyVHlwZXMuUGVuKSA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxlZ2FjeV9pc1RvdWNoRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuVG91Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9pbnRlclR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnRlclR5cGUgPSBwb2ludGVyVHlwZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpc0V2ZW50S2V5LnN0YXJ0c1dpdGgoXCJUb3VjaFwiKSAmJiBwb2ludGVyVHlwZSA9PT0gUG9pbnRlclR5cGVzLlRvdWNoIHx8IHRoaXNFdmVudEtleS5zdGFydHNXaXRoKFwiTW91c2VcIikgJiYgcG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5Nb3VzZSkge1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0gPT09IE1vdXNlSW50ZXJhY3Rpb25zLkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBjdXJyZW50UG9pbnRlclR5cGU7XG4gICAgICAgICAgICAgICAgY3VycmVudFBvaW50ZXJUeXBlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlMiA9IGxlZ2FjeV9pc1RvdWNoRXZlbnQoZXZlbnQpID8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudDtcbiAgICAgICAgICAgIGlmICghZTIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaWQgPSBtaXJyb3IyLmdldElkKHRhcmdldCk7XG4gICAgICAgICAgICB2YXIgY2xpZW50WCA9IGUyLmNsaWVudFgsIGNsaWVudFkgPSBlMi5jbGllbnRZO1xuICAgICAgICAgICAgY2FsbGJhY2tXcmFwcGVyKG1vdXNlSW50ZXJhY3Rpb25DYikoX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIHR5cGU6IE1vdXNlSW50ZXJhY3Rpb25zW3RoaXNFdmVudEtleV0sXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHg6IGNsaWVudFgsXG4gICAgICAgICAgICAgICAgeTogY2xpZW50WVxuICAgICAgICAgICAgfSwgcG9pbnRlclR5cGUgIT09IG51bGwgJiYge1xuICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgT2JqZWN0LmtleXMoTW91c2VJbnRlcmFjdGlvbnMpLmZpbHRlcihmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlci5pc05hTihOdW1iZXIoa2V5KSkgJiYgIWtleS5lbmRzV2l0aChcIl9EZXBhcnRlZFwiKSAmJiBkaXNhYmxlTWFwW2tleV0gIT09IGZhbHNlO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24oZXZlbnRLZXkpIHtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IHRvTG93ZXJDYXNlKGV2ZW50S2V5KTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBnZXRIYW5kbGVyKGV2ZW50S2V5KTtcbiAgICAgICAgaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcbiAgICAgICAgICAgIHN3aXRjaChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0pe1xuICAgICAgICAgICAgICAgIGNhc2UgTW91c2VJbnRlcmFjdGlvbnMuTW91c2VEb3duOlxuICAgICAgICAgICAgICAgIGNhc2UgTW91c2VJbnRlcmFjdGlvbnMuTW91c2VVcDpcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnJlcGxhY2UoXCJtb3VzZVwiLCBcInBvaW50ZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgTW91c2VJbnRlcmFjdGlvbnMuVG91Y2hTdGFydDpcbiAgICAgICAgICAgICAgICBjYXNlIE1vdXNlSW50ZXJhY3Rpb25zLlRvdWNoRW5kOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlcnMucHVzaChvbihldmVudE5hbWUsIGhhbmRsZXIsIGRvYykpO1xuICAgIH0pO1xuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIGhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgcmV0dXJuIGgoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBpbml0U2Nyb2xsT2JzZXJ2ZXIocGFyYW0pIHtcbiAgICB2YXIgc2Nyb2xsQ2IgPSBwYXJhbS5zY3JvbGxDYiwgZG9jID0gcGFyYW0uZG9jLCBtaXJyb3IyID0gcGFyYW0ubWlycm9yLCBibG9ja0NsYXNzID0gcGFyYW0uYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciA9IHBhcmFtLmJsb2NrU2VsZWN0b3IsIHNhbXBsaW5nID0gcGFyYW0uc2FtcGxpbmc7XG4gICAgdmFyIHVwZGF0ZVBvc2l0aW9uID0gY2FsbGJhY2tXcmFwcGVyKHRocm90dGxlKGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2dCk7XG4gICAgICAgIGlmICghdGFyZ2V0IHx8IGlzQmxvY2tlZCh0YXJnZXQsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkID0gbWlycm9yMi5nZXRJZCh0YXJnZXQpO1xuICAgICAgICBpZiAodGFyZ2V0ID09PSBkb2MgJiYgZG9jLmRlZmF1bHRWaWV3KSB7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsTGVmdFRvcCA9IGdldFdpbmRvd1Njcm9sbChkb2MuZGVmYXVsdFZpZXcpO1xuICAgICAgICAgICAgc2Nyb2xsQ2Ioe1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB4OiBzY3JvbGxMZWZ0VG9wLmxlZnQsXG4gICAgICAgICAgICAgICAgeTogc2Nyb2xsTGVmdFRvcC50b3BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2Nyb2xsQ2Ioe1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB4OiB0YXJnZXQuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgICAgICB5OiB0YXJnZXQuc2Nyb2xsVG9wXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pLCBzYW1wbGluZy5zY3JvbGwgfHwgMTAwKSk7XG4gICAgcmV0dXJuIG9uKFwic2Nyb2xsXCIsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpO1xufVxuZnVuY3Rpb24gaW5pdFZpZXdwb3J0UmVzaXplT2JzZXJ2ZXIocGFyYW0sIHBhcmFtMSkge1xuICAgIHZhciB2aWV3cG9ydFJlc2l6ZUNiID0gcGFyYW0udmlld3BvcnRSZXNpemVDYjtcbiAgICB2YXIgd2luID0gcGFyYW0xLndpbjtcbiAgICB2YXIgbGFzdEggPSAtMTtcbiAgICB2YXIgbGFzdFcgPSAtMTtcbiAgICB2YXIgdXBkYXRlRGltZW5zaW9uID0gY2FsbGJhY2tXcmFwcGVyKHRocm90dGxlKGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IGdldFdpbmRvd0hlaWdodCgpO1xuICAgICAgICB2YXIgd2lkdGggPSBnZXRXaW5kb3dXaWR0aCgpO1xuICAgICAgICBpZiAobGFzdEggIT09IGhlaWdodCB8fCBsYXN0VyAhPT0gd2lkdGgpIHtcbiAgICAgICAgICAgIHZpZXdwb3J0UmVzaXplQ2Ioe1xuICAgICAgICAgICAgICAgIHdpZHRoOiBOdW1iZXIod2lkdGgpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogTnVtYmVyKGhlaWdodClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGFzdEggPSBoZWlnaHQ7XG4gICAgICAgICAgICBsYXN0VyA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgfSksIDIwMCkpO1xuICAgIHJldHVybiBvbihcInJlc2l6ZVwiLCB1cGRhdGVEaW1lbnNpb24sIHdpbik7XG59XG52YXIgSU5QVVRfVEFHUyA9IFtcbiAgICBcIklOUFVUXCIsXG4gICAgXCJURVhUQVJFQVwiLFxuICAgIFwiU0VMRUNUXCJcbl07XG52YXIgbGFzdElucHV0VmFsdWVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGluaXRJbnB1dE9ic2VydmVyKHBhcmFtKSB7XG4gICAgdmFyIGlucHV0Q2IgPSBwYXJhbS5pbnB1dENiLCBkb2MgPSBwYXJhbS5kb2MsIG1pcnJvcjIgPSBwYXJhbS5taXJyb3IsIGJsb2NrQ2xhc3MgPSBwYXJhbS5ibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yID0gcGFyYW0uYmxvY2tTZWxlY3RvciwgaWdub3JlQ2xhc3MgPSBwYXJhbS5pZ25vcmVDbGFzcywgaWdub3JlU2VsZWN0b3IgPSBwYXJhbS5pZ25vcmVTZWxlY3RvciwgbWFza0lucHV0T3B0aW9ucyA9IHBhcmFtLm1hc2tJbnB1dE9wdGlvbnMsIG1hc2tJbnB1dEZuID0gcGFyYW0ubWFza0lucHV0Rm4sIHNhbXBsaW5nID0gcGFyYW0uc2FtcGxpbmcsIHVzZXJUcmlnZ2VyZWRPbklucHV0ID0gcGFyYW0udXNlclRyaWdnZXJlZE9uSW5wdXQ7XG4gICAgZnVuY3Rpb24gZXZlbnRIYW5kbGVyKGV2ZW50KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgICAgIHZhciB1c2VyVHJpZ2dlcmVkID0gZXZlbnQuaXNUcnVzdGVkO1xuICAgICAgICB2YXIgdGFnTmFtZSA9IHRhcmdldCAmJiB0YXJnZXQudGFnTmFtZTtcbiAgICAgICAgaWYgKHRhcmdldCAmJiB0YWdOYW1lID09PSBcIk9QVElPTlwiKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBpbmRleC5wYXJlbnRFbGVtZW50KHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0YXJnZXQgfHwgIXRhZ05hbWUgfHwgSU5QVVRfVEFHUy5pbmRleE9mKHRhZ05hbWUpIDwgMCB8fCBpc0Jsb2NrZWQodGFyZ2V0LCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGlnbm9yZUNsYXNzKSB8fCBpZ25vcmVTZWxlY3RvciAmJiB0YXJnZXQubWF0Y2hlcyhpZ25vcmVTZWxlY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4dCA9IHRhcmdldC52YWx1ZTtcbiAgICAgICAgdmFyIGlzQ2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgdHlwZSA9IGdldElucHV0VHlwZSh0YXJnZXQpIHx8IFwiXCI7XG4gICAgICAgIGlmICh0eXBlID09PSBcInJhZGlvXCIgfHwgdHlwZSA9PT0gXCJjaGVja2JveFwiKSB7XG4gICAgICAgICAgICBpc0NoZWNrZWQgPSB0YXJnZXQuY2hlY2tlZDtcbiAgICAgICAgfSBlbHNlIGlmIChtYXNrSW5wdXRPcHRpb25zW3RhZ05hbWUudG9Mb3dlckNhc2UoKV0gfHwgbWFza0lucHV0T3B0aW9uc1t0eXBlXSkge1xuICAgICAgICAgICAgdGV4dCA9IG1hc2tJbnB1dFZhbHVlKHtcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB0YXJnZXQsXG4gICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9uczogbWFza0lucHV0T3B0aW9ucyxcbiAgICAgICAgICAgICAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRleHQsXG4gICAgICAgICAgICAgICAgbWFza0lucHV0Rm46IG1hc2tJbnB1dEZuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYldpdGhEZWR1cCh0YXJnZXQsIHVzZXJUcmlnZ2VyZWRPbklucHV0ID8ge1xuICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgIGlzQ2hlY2tlZDogaXNDaGVja2VkLFxuICAgICAgICAgICAgdXNlclRyaWdnZXJlZDogdXNlclRyaWdnZXJlZFxuICAgICAgICB9IDoge1xuICAgICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICAgIGlzQ2hlY2tlZDogaXNDaGVja2VkXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbmFtZSA9IHRhcmdldC5uYW1lO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJyYWRpb1wiICYmIG5hbWUgJiYgaXNDaGVja2VkKSB7XG4gICAgICAgICAgICBkb2MucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cInJhZGlvXCJdW25hbWU9XCInICsgbmFtZSArICdcIl0nKS5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQyID0gZWwudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGNiV2l0aERlZHVwKGVsLCB1c2VyVHJpZ2dlcmVkT25JbnB1dCA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNDaGVja2VkOiAhaXNDaGVja2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlclRyaWdnZXJlZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNDaGVja2VkOiAhaXNDaGVja2VkXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNiV2l0aERlZHVwKHRhcmdldCwgdjIpIHtcbiAgICAgICAgdmFyIGxhc3RJbnB1dFZhbHVlID0gbGFzdElucHV0VmFsdWVNYXAuZ2V0KHRhcmdldCk7XG4gICAgICAgIGlmICghbGFzdElucHV0VmFsdWUgfHwgbGFzdElucHV0VmFsdWUudGV4dCAhPT0gdjIudGV4dCB8fCBsYXN0SW5wdXRWYWx1ZS5pc0NoZWNrZWQgIT09IHYyLmlzQ2hlY2tlZCkge1xuICAgICAgICAgICAgbGFzdElucHV0VmFsdWVNYXAuc2V0KHRhcmdldCwgdjIpO1xuICAgICAgICAgICAgdmFyIGlkID0gbWlycm9yMi5nZXRJZCh0YXJnZXQpO1xuICAgICAgICAgICAgY2FsbGJhY2tXcmFwcGVyKGlucHV0Q2IpKF9leHRlbmRzKHt9LCB2Miwge1xuICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBldmVudHMgPSBzYW1wbGluZy5pbnB1dCA9PT0gXCJsYXN0XCIgPyBbXG4gICAgICAgIFwiY2hhbmdlXCJcbiAgICBdIDogW1xuICAgICAgICBcImlucHV0XCIsXG4gICAgICAgIFwiY2hhbmdlXCJcbiAgICBdO1xuICAgIHZhciBoYW5kbGVycyA9IGV2ZW50cy5tYXAoZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICAgIHJldHVybiBvbihldmVudE5hbWUsIGNhbGxiYWNrV3JhcHBlcihldmVudEhhbmRsZXIpLCBkb2MpO1xuICAgIH0pO1xuICAgIHZhciBjdXJyZW50V2luZG93ID0gZG9jLmRlZmF1bHRWaWV3O1xuICAgIGlmICghY3VycmVudFdpbmRvdykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBwcm9wZXJ0eURlc2NyaXB0b3IgPSBjdXJyZW50V2luZG93Lk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY3VycmVudFdpbmRvdy5IVE1MSW5wdXRFbGVtZW50LnByb3RvdHlwZSwgXCJ2YWx1ZVwiKTtcbiAgICB2YXIgaG9va1Byb3BlcnRpZXMgPSBbXG4gICAgICAgIFtcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3cuSFRNTElucHV0RWxlbWVudC5wcm90b3R5cGUsXG4gICAgICAgICAgICBcInZhbHVlXCJcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgY3VycmVudFdpbmRvdy5IVE1MSW5wdXRFbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgICAgIFwiY2hlY2tlZFwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3cuSFRNTFNlbGVjdEVsZW1lbnQucHJvdG90eXBlLFxuICAgICAgICAgICAgXCJ2YWx1ZVwiXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3cuSFRNTFRleHRBcmVhRWxlbWVudC5wcm90b3R5cGUsXG4gICAgICAgICAgICBcInZhbHVlXCJcbiAgICAgICAgXSxcbiAgICAgICAgLy8gU29tZSBVSSBsaWJyYXJ5IHVzZSBzZWxlY3RlZEluZGV4IHRvIHNldCBzZWxlY3QgdmFsdWVcbiAgICAgICAgW1xuICAgICAgICAgICAgY3VycmVudFdpbmRvdy5IVE1MU2VsZWN0RWxlbWVudC5wcm90b3R5cGUsXG4gICAgICAgICAgICBcInNlbGVjdGVkSW5kZXhcIlxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICBjdXJyZW50V2luZG93LkhUTUxPcHRpb25FbGVtZW50LnByb3RvdHlwZSxcbiAgICAgICAgICAgIFwic2VsZWN0ZWRcIlxuICAgICAgICBdXG4gICAgXTtcbiAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yICYmIHByb3BlcnR5RGVzY3JpcHRvci5zZXQpIHtcbiAgICAgICAgdmFyIF9oYW5kbGVycztcbiAgICAgICAgKF9oYW5kbGVycyA9IGhhbmRsZXJzKS5wdXNoLmFwcGx5KF9oYW5kbGVycywgW10uY29uY2F0KGhvb2tQcm9wZXJ0aWVzLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9va1NldHRlcihwWzBdLCBwWzFdLCB7XG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrV3JhcHBlcihldmVudEhhbmRsZXIpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVHJ1c3RlZDogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZmFsc2UsIGN1cnJlbnRXaW5kb3cpO1xuICAgICAgICB9KSkpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyhydWxlMikge1xuICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcbiAgICBmdW5jdGlvbiByZWN1cnNlKGNoaWxkUnVsZSwgcG9zKSB7XG4gICAgICAgIGlmIChoYXNOZXN0ZWRDU1NSdWxlKFwiQ1NTR3JvdXBpbmdSdWxlXCIpICYmIF9pbnN0YW5jZW9mKGNoaWxkUnVsZS5wYXJlbnRSdWxlLCBDU1NHcm91cGluZ1J1bGUpIHx8IGhhc05lc3RlZENTU1J1bGUoXCJDU1NNZWRpYVJ1bGVcIikgJiYgX2luc3RhbmNlb2YoY2hpbGRSdWxlLnBhcmVudFJ1bGUsIENTU01lZGlhUnVsZSkgfHwgaGFzTmVzdGVkQ1NTUnVsZShcIkNTU1N1cHBvcnRzUnVsZVwiKSAmJiBfaW5zdGFuY2VvZihjaGlsZFJ1bGUucGFyZW50UnVsZSwgQ1NTU3VwcG9ydHNSdWxlKSB8fCBoYXNOZXN0ZWRDU1NSdWxlKFwiQ1NTQ29uZGl0aW9uUnVsZVwiKSAmJiBfaW5zdGFuY2VvZihjaGlsZFJ1bGUucGFyZW50UnVsZSwgQ1NTQ29uZGl0aW9uUnVsZSkpIHtcbiAgICAgICAgICAgIHZhciBydWxlczIgPSBBcnJheS5mcm9tKGNoaWxkUnVsZS5wYXJlbnRSdWxlLmNzc1J1bGVzKTtcbiAgICAgICAgICAgIHZhciBpbmRleDIgPSBydWxlczIuaW5kZXhPZihjaGlsZFJ1bGUpO1xuICAgICAgICAgICAgcG9zLnVuc2hpZnQoaW5kZXgyKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGlsZFJ1bGUucGFyZW50U3R5bGVTaGVldCkge1xuICAgICAgICAgICAgdmFyIHJ1bGVzMjEgPSBBcnJheS5mcm9tKGNoaWxkUnVsZS5wYXJlbnRTdHlsZVNoZWV0LmNzc1J1bGVzKTtcbiAgICAgICAgICAgIHZhciBpbmRleDIxID0gcnVsZXMyMS5pbmRleE9mKGNoaWxkUnVsZSk7XG4gICAgICAgICAgICBwb3MudW5zaGlmdChpbmRleDIxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICByZXR1cm4gcmVjdXJzZShydWxlMiwgcG9zaXRpb25zKTtcbn1cbmZ1bmN0aW9uIGdldElkQW5kU3R5bGVJZChzaGVldCwgbWlycm9yMiwgc3R5bGVNaXJyb3IpIHtcbiAgICB2YXIgaWQsIHN0eWxlSWQ7XG4gICAgaWYgKCFzaGVldCkgcmV0dXJuIHt9O1xuICAgIGlmIChzaGVldC5vd25lck5vZGUpIGlkID0gbWlycm9yMi5nZXRJZChzaGVldC5vd25lck5vZGUpO1xuICAgIGVsc2Ugc3R5bGVJZCA9IHN0eWxlTWlycm9yLmdldElkKHNoZWV0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHlsZUlkOiBzdHlsZUlkLFxuICAgICAgICBpZDogaWRcbiAgICB9O1xufVxuZnVuY3Rpb24gaW5pdFN0eWxlU2hlZXRPYnNlcnZlcihwYXJhbSwgcGFyYW0xKSB7XG4gICAgdmFyIHN0eWxlU2hlZXRSdWxlQ2IgPSBwYXJhbS5zdHlsZVNoZWV0UnVsZUNiLCBtaXJyb3IyID0gcGFyYW0ubWlycm9yLCBzdHlsZXNoZWV0TWFuYWdlciA9IHBhcmFtLnN0eWxlc2hlZXRNYW5hZ2VyO1xuICAgIHZhciB3aW4gPSBwYXJhbTEud2luO1xuICAgIGlmICghd2luLkNTU1N0eWxlU2hlZXQgfHwgIXdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gICAgdmFyIGluc2VydFJ1bGUgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZTtcbiAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IG5ldyBQcm94eShpbnNlcnRSdWxlLCB7XG4gICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSB7XG4gICAgICAgICAgICB2YXIgcnVsZTIgPSBhcmd1bWVudHNMaXN0WzBdLCBpbmRleDIgPSBhcmd1bWVudHNMaXN0WzFdO1xuICAgICAgICAgICAgdmFyIF9nZXRJZEFuZFN0eWxlSWQgPSBnZXRJZEFuZFN0eWxlSWQodGhpc0FyZywgbWlycm9yMiwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpLCBpZCA9IF9nZXRJZEFuZFN0eWxlSWQuaWQsIHN0eWxlSWQgPSBfZ2V0SWRBbmRTdHlsZUlkLnN0eWxlSWQ7XG4gICAgICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZUlkOiBzdHlsZUlkLFxuICAgICAgICAgICAgICAgICAgICBhZGRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogcnVsZTIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4MlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICB9KVxuICAgIH0pO1xuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5hZGRSdWxlID0gZnVuY3Rpb24oc2VsZWN0b3IsIHN0eWxlQmxvY2ssIGluZGV4Mikge1xuICAgICAgICBpZiAoaW5kZXgyID09PSB2b2lkIDApIGluZGV4MiA9IHRoaXMuY3NzUnVsZXMubGVuZ3RoO1xuICAgICAgICB2YXIgcnVsZTIgPSBzZWxlY3RvciArIFwiIHsgXCIgKyBzdHlsZUJsb2NrICsgXCIgfVwiO1xuICAgICAgICByZXR1cm4gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmluc2VydFJ1bGUuYXBwbHkodGhpcywgW1xuICAgICAgICAgICAgcnVsZTIsXG4gICAgICAgICAgICBpbmRleDJcbiAgICAgICAgXSk7XG4gICAgfTtcbiAgICB2YXIgZGVsZXRlUnVsZSA9IHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5kZWxldGVSdWxlO1xuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5kZWxldGVSdWxlID0gbmV3IFByb3h5KGRlbGV0ZVJ1bGUsIHtcbiAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICAgICAgICAgIHZhciBpbmRleDIgPSBhcmd1bWVudHNMaXN0WzBdO1xuICAgICAgICAgICAgdmFyIF9nZXRJZEFuZFN0eWxlSWQgPSBnZXRJZEFuZFN0eWxlSWQodGhpc0FyZywgbWlycm9yMiwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpLCBpZCA9IF9nZXRJZEFuZFN0eWxlSWQuaWQsIHN0eWxlSWQgPSBfZ2V0SWRBbmRTdHlsZUlkLnN0eWxlSWQ7XG4gICAgICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZUlkOiBzdHlsZUlkLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4MlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICB9KVxuICAgIH0pO1xuICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZW1vdmVSdWxlID0gZnVuY3Rpb24oaW5kZXgyKSB7XG4gICAgICAgIHJldHVybiB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZS5hcHBseSh0aGlzLCBbXG4gICAgICAgICAgICBpbmRleDJcbiAgICAgICAgXSk7XG4gICAgfTtcbiAgICB2YXIgcmVwbGFjZTtcbiAgICBpZiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2UpIHtcbiAgICAgICAgcmVwbGFjZSA9IHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlO1xuICAgICAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZSA9IG5ldyBQcm94eShyZXBsYWNlLCB7XG4gICAgICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gYXJndW1lbnRzTGlzdFswXTtcbiAgICAgICAgICAgICAgICB2YXIgX2dldElkQW5kU3R5bGVJZCA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLCBtaXJyb3IyLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvciksIGlkID0gX2dldElkQW5kU3R5bGVJZC5pZCwgc3R5bGVJZCA9IF9nZXRJZEFuZFN0eWxlSWQuc3R5bGVJZDtcbiAgICAgICAgICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUlkOiBzdHlsZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZTogdGV4dFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgcmVwbGFjZVN5bmM7XG4gICAgaWYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYykge1xuICAgICAgICByZXBsYWNlU3luYyA9IHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlU3luYztcbiAgICAgICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jID0gbmV3IFByb3h5KHJlcGxhY2VTeW5jLCB7XG4gICAgICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gYXJndW1lbnRzTGlzdFswXTtcbiAgICAgICAgICAgICAgICB2YXIgX2dldElkQW5kU3R5bGVJZCA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLCBtaXJyb3IyLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvciksIGlkID0gX2dldElkQW5kU3R5bGVJZC5pZCwgc3R5bGVJZCA9IF9nZXRJZEFuZFN0eWxlSWQuc3R5bGVJZDtcbiAgICAgICAgICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUlkOiBzdHlsZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwbGFjZVN5bmM6IHRleHRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcyA9IHt9O1xuICAgIGlmIChjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUoXCJDU1NHcm91cGluZ1J1bGVcIikpIHtcbiAgICAgICAgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzLkNTU0dyb3VwaW5nUnVsZSA9IHdpbi5DU1NHcm91cGluZ1J1bGU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZShcIkNTU01lZGlhUnVsZVwiKSkge1xuICAgICAgICAgICAgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzLkNTU01lZGlhUnVsZSA9IHdpbi5DU1NNZWRpYVJ1bGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZShcIkNTU0NvbmRpdGlvblJ1bGVcIikpIHtcbiAgICAgICAgICAgIHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcy5DU1NDb25kaXRpb25SdWxlID0gd2luLkNTU0NvbmRpdGlvblJ1bGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZShcIkNTU1N1cHBvcnRzUnVsZVwiKSkge1xuICAgICAgICAgICAgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzLkNTU1N1cHBvcnRzUnVsZSA9IHdpbi5DU1NTdXBwb3J0c1J1bGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHVubW9kaWZpZWRGdW5jdGlvbnMgPSB7fTtcbiAgICBPYmplY3QuZW50cmllcyhzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMpLmZvckVhY2goZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgdmFyIHR5cGVLZXkgPSBwYXJhbVswXSwgdHlwZSA9IHBhcmFtWzFdO1xuICAgICAgICB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldID0ge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICAgICAgaW5zZXJ0UnVsZTogdHlwZS5wcm90b3R5cGUuaW5zZXJ0UnVsZSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgICAgICAgIGRlbGV0ZVJ1bGU6IHR5cGUucHJvdG90eXBlLmRlbGV0ZVJ1bGVcbiAgICAgICAgfTtcbiAgICAgICAgdHlwZS5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IG5ldyBQcm94eSh1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmluc2VydFJ1bGUsIHtcbiAgICAgICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJ1bGUyID0gYXJndW1lbnRzTGlzdFswXSwgaW5kZXgyID0gYXJndW1lbnRzTGlzdFsxXTtcbiAgICAgICAgICAgICAgICB2YXIgX2dldElkQW5kU3R5bGVJZCA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLnBhcmVudFN0eWxlU2hlZXQsIG1pcnJvcjIsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKSwgaWQgPSBfZ2V0SWRBbmRTdHlsZUlkLmlkLCBzdHlsZUlkID0gX2dldElkQW5kU3R5bGVJZC5zdHlsZUlkO1xuICAgICAgICAgICAgICAgIGlmIChpZCAmJiBpZCAhPT0gLTEgfHwgc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBydWxlMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IFtdLmNvbmNhdChnZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcpLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDIgfHwgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgICAgdHlwZS5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IG5ldyBQcm94eSh1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmRlbGV0ZVJ1bGUsIHtcbiAgICAgICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24odGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4MiA9IGFyZ3VtZW50c0xpc3RbMF07XG4gICAgICAgICAgICAgICAgdmFyIF9nZXRJZEFuZFN0eWxlSWQgPSBnZXRJZEFuZFN0eWxlSWQodGhpc0FyZy5wYXJlbnRTdHlsZVNoZWV0LCBtaXJyb3IyLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvciksIGlkID0gX2dldElkQW5kU3R5bGVJZC5pZCwgc3R5bGVJZCA9IF9nZXRJZEFuZFN0eWxlSWQuc3R5bGVJZDtcbiAgICAgICAgICAgICAgICBpZiAoaWQgJiYgaWQgIT09IC0xIHx8IHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUlkOiBzdHlsZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IFtdLmNvbmNhdChnZXROZXN0ZWRDU1NSdWxlUG9zaXRpb25zKHRoaXNBcmcpLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmluc2VydFJ1bGUgPSBpbnNlcnRSdWxlO1xuICAgICAgICB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IGRlbGV0ZVJ1bGU7XG4gICAgICAgIHJlcGxhY2UgJiYgKHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5yZXBsYWNlID0gcmVwbGFjZSk7XG4gICAgICAgIHJlcGxhY2VTeW5jICYmICh3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZVN5bmMgPSByZXBsYWNlU3luYyk7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcykuZm9yRWFjaChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICAgICAgdmFyIHR5cGVLZXkgPSBwYXJhbVswXSwgdHlwZSA9IHBhcmFtWzFdO1xuICAgICAgICAgICAgdHlwZS5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uaW5zZXJ0UnVsZTtcbiAgICAgICAgICAgIHR5cGUucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSB1bm1vZGlmaWVkRnVuY3Rpb25zW3R5cGVLZXldLmRlbGV0ZVJ1bGU7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaW5pdEFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIocGFyYW0sIGhvc3QyKSB7XG4gICAgdmFyIG1pcnJvcjIgPSBwYXJhbS5taXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyID0gcGFyYW0uc3R5bGVzaGVldE1hbmFnZXI7XG4gICAgdmFyIF9hMiwgX2IsIF9jO1xuICAgIHZhciBob3N0SWQgPSBudWxsO1xuICAgIGlmIChob3N0Mi5ub2RlTmFtZSA9PT0gXCIjZG9jdW1lbnRcIikgaG9zdElkID0gbWlycm9yMi5nZXRJZChob3N0Mik7XG4gICAgZWxzZSBob3N0SWQgPSBtaXJyb3IyLmdldElkKGluZGV4Lmhvc3QoaG9zdDIpKTtcbiAgICB2YXIgcGF0Y2hUYXJnZXQgPSBob3N0Mi5ub2RlTmFtZSA9PT0gXCIjZG9jdW1lbnRcIiA/IChfYTIgPSBob3N0Mi5kZWZhdWx0VmlldykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5Eb2N1bWVudCA6IChfYyA9IChfYiA9IGhvc3QyLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYi5kZWZhdWx0VmlldykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLlNoYWRvd1Jvb3Q7XG4gICAgdmFyIG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yID0gKHBhdGNoVGFyZ2V0ID09IG51bGwgPyB2b2lkIDAgOiBwYXRjaFRhcmdldC5wcm90b3R5cGUpID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXRjaFRhcmdldCA9PSBudWxsID8gdm9pZCAwIDogcGF0Y2hUYXJnZXQucHJvdG90eXBlLCBcImFkb3B0ZWRTdHlsZVNoZWV0c1wiKSA6IHZvaWQgMDtcbiAgICBpZiAoaG9zdElkID09PSBudWxsIHx8IGhvc3RJZCA9PT0gLTEgfHwgIXBhdGNoVGFyZ2V0IHx8ICFvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvcikgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3QyLCBcImFkb3B0ZWRTdHlsZVNoZWV0c1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxuICAgICAgICBlbnVtZXJhYmxlOiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHZhciBfYTM7XG4gICAgICAgICAgICByZXR1cm4gKF9hMyA9IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMy5jYWxsKHRoaXMpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzaGVldHMpIHtcbiAgICAgICAgICAgIHZhciBfYTM7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MiA9IChfYTMgPSBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5zZXQpID09IG51bGwgPyB2b2lkIDAgOiBfYTMuY2FsbCh0aGlzLCBzaGVldHMpO1xuICAgICAgICAgICAgaWYgKGhvc3RJZCAhPT0gbnVsbCAmJiBob3N0SWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIuYWRvcHRTdHlsZVNoZWV0cyhzaGVldHMsIGhvc3RJZCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZTIpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShob3N0MiwgXCJhZG9wdGVkU3R5bGVTaGVldHNcIiwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgICAgICAgZ2V0OiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5nZXQsXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICAgICAgICBzZXQ6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLnNldFxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRTdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIocGFyYW0sIHBhcmFtMSkge1xuICAgIHZhciBzdHlsZURlY2xhcmF0aW9uQ2IgPSBwYXJhbS5zdHlsZURlY2xhcmF0aW9uQ2IsIG1pcnJvcjIgPSBwYXJhbS5taXJyb3IsIGlnbm9yZUNTU0F0dHJpYnV0ZXMgPSBwYXJhbS5pZ25vcmVDU1NBdHRyaWJ1dGVzLCBzdHlsZXNoZWV0TWFuYWdlciA9IHBhcmFtLnN0eWxlc2hlZXRNYW5hZ2VyO1xuICAgIHZhciB3aW4gPSBwYXJhbTEud2luO1xuICAgIHZhciBzZXRQcm9wZXJ0eSA9IHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5zZXRQcm9wZXJ0eTtcbiAgICB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBuZXcgUHJveHkoc2V0UHJvcGVydHksIHtcbiAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBhcmd1bWVudHNMaXN0WzBdLCB2YWx1ZSA9IGFyZ3VtZW50c0xpc3RbMV0sIHByaW9yaXR5ID0gYXJndW1lbnRzTGlzdFsyXTtcbiAgICAgICAgICAgIGlmIChpZ25vcmVDU1NBdHRyaWJ1dGVzLmhhcyhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0UHJvcGVydHkuYXBwbHkodGhpc0FyZywgW1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHByaW9yaXR5XG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2dldElkQW5kU3R5bGVJZCA9IGdldElkQW5kU3R5bGVJZCgoX2EyID0gdGhpc0FyZy5wYXJlbnRSdWxlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnBhcmVudFN0eWxlU2hlZXQsIG1pcnJvcjIsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKSwgaWQgPSBfZ2V0SWRBbmRTdHlsZUlkLmlkLCBzdHlsZUlkID0gX2dldElkQW5kU3R5bGVJZC5zdHlsZUlkO1xuICAgICAgICAgICAgaWYgKGlkICYmIGlkICE9PSAtMSB8fCBzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVEZWNsYXJhdGlvbkNiKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZUlkOiBzdHlsZUlkLFxuICAgICAgICAgICAgICAgICAgICBzZXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5OiBwcmlvcml0eVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICBpbmRleDogZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyh0aGlzQXJnLnBhcmVudFJ1bGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICB9KVxuICAgIH0pO1xuICAgIHZhciByZW1vdmVQcm9wZXJ0eSA9IHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5yZW1vdmVQcm9wZXJ0eTtcbiAgICB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUucmVtb3ZlUHJvcGVydHkgPSBuZXcgUHJveHkocmVtb3ZlUHJvcGVydHksIHtcbiAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbih0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpIHtcbiAgICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBhcmd1bWVudHNMaXN0WzBdO1xuICAgICAgICAgICAgaWYgKGlnbm9yZUNTU0F0dHJpYnV0ZXMuaGFzKHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVQcm9wZXJ0eS5hcHBseSh0aGlzQXJnLCBbXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2dldElkQW5kU3R5bGVJZCA9IGdldElkQW5kU3R5bGVJZCgoX2EyID0gdGhpc0FyZy5wYXJlbnRSdWxlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnBhcmVudFN0eWxlU2hlZXQsIG1pcnJvcjIsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKSwgaWQgPSBfZ2V0SWRBbmRTdHlsZUlkLmlkLCBzdHlsZUlkID0gX2dldElkQW5kU3R5bGVJZC5zdHlsZUlkO1xuICAgICAgICAgICAgaWYgKGlkICYmIGlkICE9PSAtMSB8fCBzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVEZWNsYXJhdGlvbkNiKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZUlkOiBzdHlsZUlkLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICBpbmRleDogZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyh0aGlzQXJnLnBhcmVudFJ1bGUpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xuICAgICAgICB9KVxuICAgIH0pO1xuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IHNldFByb3BlcnR5O1xuICAgICAgICB3aW4uQ1NTU3R5bGVEZWNsYXJhdGlvbi5wcm90b3R5cGUucmVtb3ZlUHJvcGVydHkgPSByZW1vdmVQcm9wZXJ0eTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRNZWRpYUludGVyYWN0aW9uT2JzZXJ2ZXIocGFyYW0pIHtcbiAgICB2YXIgbWVkaWFJbnRlcmFjdGlvbkNiID0gcGFyYW0ubWVkaWFJbnRlcmFjdGlvbkNiLCBibG9ja0NsYXNzID0gcGFyYW0uYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciA9IHBhcmFtLmJsb2NrU2VsZWN0b3IsIG1pcnJvcjIgPSBwYXJhbS5taXJyb3IsIHNhbXBsaW5nID0gcGFyYW0uc2FtcGxpbmcsIGRvYyA9IHBhcmFtLmRvYztcbiAgICB2YXIgaGFuZGxlciA9IGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aHJvdHRsZShjYWxsYmFja1dyYXBwZXIoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgICAgICAgICBpZiAoIXRhcmdldCB8fCBpc0Jsb2NrZWQodGFyZ2V0LCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IHRhcmdldC5jdXJyZW50VGltZSwgdm9sdW1lID0gdGFyZ2V0LnZvbHVtZSwgbXV0ZWQgPSB0YXJnZXQubXV0ZWQsIHBsYXliYWNrUmF0ZSA9IHRhcmdldC5wbGF5YmFja1JhdGUsIGxvb3AgPSB0YXJnZXQubG9vcDtcbiAgICAgICAgICAgIG1lZGlhSW50ZXJhY3Rpb25DYih7XG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBpZDogbWlycm9yMi5nZXRJZCh0YXJnZXQpLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRUaW1lOiBjdXJyZW50VGltZSxcbiAgICAgICAgICAgICAgICB2b2x1bWU6IHZvbHVtZSxcbiAgICAgICAgICAgICAgICBtdXRlZDogbXV0ZWQsXG4gICAgICAgICAgICAgICAgcGxheWJhY2tSYXRlOiBwbGF5YmFja1JhdGUsXG4gICAgICAgICAgICAgICAgbG9vcDogbG9vcFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLCBzYW1wbGluZy5tZWRpYSB8fCA1MDApO1xuICAgIH0pO1xuICAgIHZhciBoYW5kbGVycyA9IFtcbiAgICAgICAgb24oXCJwbGF5XCIsIGhhbmRsZXIoTWVkaWFJbnRlcmFjdGlvbnMuUGxheSksIGRvYyksXG4gICAgICAgIG9uKFwicGF1c2VcIiwgaGFuZGxlcihNZWRpYUludGVyYWN0aW9ucy5QYXVzZSksIGRvYyksXG4gICAgICAgIG9uKFwic2Vla2VkXCIsIGhhbmRsZXIoTWVkaWFJbnRlcmFjdGlvbnMuU2Vla2VkKSwgZG9jKSxcbiAgICAgICAgb24oXCJ2b2x1bWVjaGFuZ2VcIiwgaGFuZGxlcihNZWRpYUludGVyYWN0aW9ucy5Wb2x1bWVDaGFuZ2UpLCBkb2MpLFxuICAgICAgICBvbihcInJhdGVjaGFuZ2VcIiwgaGFuZGxlcihNZWRpYUludGVyYWN0aW9ucy5SYXRlQ2hhbmdlKSwgZG9jKVxuICAgIF07XG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRGb250T2JzZXJ2ZXIocGFyYW0pIHtcbiAgICB2YXIgZm9udENiID0gcGFyYW0uZm9udENiLCBkb2MgPSBwYXJhbS5kb2M7XG4gICAgdmFyIHdpbiA9IGRvYy5kZWZhdWx0VmlldztcbiAgICBpZiAoIXdpbikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgdmFyIGZvbnRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICB2YXIgb3JpZ2luYWxGb250RmFjZSA9IHdpbi5Gb250RmFjZTtcbiAgICB3aW4uRm9udEZhY2UgPSBmdW5jdGlvbiBGb250RmFjZTIoZmFtaWx5LCBzb3VyY2UsIGRlc2NyaXB0b3JzKSB7XG4gICAgICAgIHZhciBmb250RmFjZSA9IG5ldyBvcmlnaW5hbEZvbnRGYWNlKGZhbWlseSwgc291cmNlLCBkZXNjcmlwdG9ycyk7XG4gICAgICAgIGZvbnRNYXAuc2V0KGZvbnRGYWNlLCB7XG4gICAgICAgICAgICBmYW1pbHk6IGZhbWlseSxcbiAgICAgICAgICAgIGJ1ZmZlcjogdHlwZW9mIHNvdXJjZSAhPT0gXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGRlc2NyaXB0b3JzOiBkZXNjcmlwdG9ycyxcbiAgICAgICAgICAgIGZvbnRTb3VyY2U6IHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCIgPyBzb3VyY2UgOiBKU09OLnN0cmluZ2lmeShBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KHNvdXJjZSkpKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvbnRGYWNlO1xuICAgIH07XG4gICAgdmFyIHJlc3RvcmVIYW5kbGVyID0gcGF0Y2goZG9jLmZvbnRzLCBcImFkZFwiLCBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZm9udEZhY2UpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gZm9udE1hcC5nZXQoZm9udEZhY2UpO1xuICAgICAgICAgICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnRDYihwKTtcbiAgICAgICAgICAgICAgICAgICAgZm9udE1hcC5kZWxldGUoZm9udEZhY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbXG4gICAgICAgICAgICAgICAgZm9udEZhY2VcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIGhhbmRsZXJzLnB1c2goZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbi5Gb250RmFjZSA9IG9yaWdpbmFsRm9udEZhY2U7XG4gICAgfSk7XG4gICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcihmdW5jdGlvbigpIHtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRTZWxlY3Rpb25PYnNlcnZlcihwYXJhbSkge1xuICAgIHZhciBkb2MgPSBwYXJhbS5kb2MsIG1pcnJvcjIgPSBwYXJhbS5taXJyb3IsIGJsb2NrQ2xhc3MgPSBwYXJhbS5ibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yID0gcGFyYW0uYmxvY2tTZWxlY3Rvciwgc2VsZWN0aW9uQ2IgPSBwYXJhbS5zZWxlY3Rpb25DYjtcbiAgICB2YXIgY29sbGFwc2VkID0gdHJ1ZTtcbiAgICB2YXIgdXBkYXRlU2VsZWN0aW9uID0gY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gZG9jLmdldFNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbiB8fCBjb2xsYXBzZWQgJiYgKHNlbGVjdGlvbiA9PSBudWxsID8gdm9pZCAwIDogc2VsZWN0aW9uLmlzQ29sbGFwc2VkKSkgcmV0dXJuO1xuICAgICAgICBjb2xsYXBzZWQgPSBzZWxlY3Rpb24uaXNDb2xsYXBzZWQgfHwgZmFsc2U7XG4gICAgICAgIHZhciByYW5nZXMgPSBbXTtcbiAgICAgICAgdmFyIGNvdW50ID0gc2VsZWN0aW9uLnJhbmdlQ291bnQgfHwgMDtcbiAgICAgICAgZm9yKHZhciBpMiA9IDA7IGkyIDwgY291bnQ7IGkyKyspe1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoaTIpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0Q29udGFpbmVyID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0ID0gcmFuZ2Uuc3RhcnRPZmZzZXQsIGVuZENvbnRhaW5lciA9IHJhbmdlLmVuZENvbnRhaW5lciwgZW5kT2Zmc2V0ID0gcmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICAgICAgdmFyIGJsb2NrZWQgPSBpc0Jsb2NrZWQoc3RhcnRDb250YWluZXIsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpIHx8IGlzQmxvY2tlZChlbmRDb250YWluZXIsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGJsb2NrZWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBtaXJyb3IyLmdldElkKHN0YXJ0Q29udGFpbmVyKSxcbiAgICAgICAgICAgICAgICBzdGFydE9mZnNldDogc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgZW5kOiBtaXJyb3IyLmdldElkKGVuZENvbnRhaW5lciksXG4gICAgICAgICAgICAgICAgZW5kT2Zmc2V0OiBlbmRPZmZzZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbkNiKHtcbiAgICAgICAgICAgIHJhbmdlczogcmFuZ2VzXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHVwZGF0ZVNlbGVjdGlvbigpO1xuICAgIHJldHVybiBvbihcInNlbGVjdGlvbmNoYW5nZVwiLCB1cGRhdGVTZWxlY3Rpb24pO1xufVxuZnVuY3Rpb24gaW5pdEN1c3RvbUVsZW1lbnRPYnNlcnZlcihwYXJhbSkge1xuICAgIHZhciBkb2MgPSBwYXJhbS5kb2MsIGN1c3RvbUVsZW1lbnRDYiA9IHBhcmFtLmN1c3RvbUVsZW1lbnRDYjtcbiAgICB2YXIgd2luID0gZG9jLmRlZmF1bHRWaWV3O1xuICAgIGlmICghd2luIHx8ICF3aW4uY3VzdG9tRWxlbWVudHMpIHJldHVybiBmdW5jdGlvbigpIHt9O1xuICAgIHZhciByZXN0b3JlSGFuZGxlciA9IHBhdGNoKHdpbi5jdXN0b21FbGVtZW50cywgXCJkZWZpbmVcIiwgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5hbWUsIGNvbnN0cnVjdG9yLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGN1c3RvbUVsZW1lbnRDYih7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkN1c3RvbSBlbGVtZW50IGNhbGxiYWNrIGZhaWxlZCBmb3IgXCIgKyBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcixcbiAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdG9yZUhhbmRsZXI7XG59XG5mdW5jdGlvbiBtZXJnZUhvb2tzKG8yLCBob29rcykge1xuICAgIHZhciBtdXRhdGlvbkNiID0gbzIubXV0YXRpb25DYiwgbW91c2Vtb3ZlQ2IgPSBvMi5tb3VzZW1vdmVDYiwgbW91c2VJbnRlcmFjdGlvbkNiID0gbzIubW91c2VJbnRlcmFjdGlvbkNiLCBzY3JvbGxDYiA9IG8yLnNjcm9sbENiLCB2aWV3cG9ydFJlc2l6ZUNiID0gbzIudmlld3BvcnRSZXNpemVDYiwgaW5wdXRDYiA9IG8yLmlucHV0Q2IsIG1lZGlhSW50ZXJhY3Rpb25DYiA9IG8yLm1lZGlhSW50ZXJhY3Rpb25DYiwgc3R5bGVTaGVldFJ1bGVDYiA9IG8yLnN0eWxlU2hlZXRSdWxlQ2IsIHN0eWxlRGVjbGFyYXRpb25DYiA9IG8yLnN0eWxlRGVjbGFyYXRpb25DYiwgY2FudmFzTXV0YXRpb25DYiA9IG8yLmNhbnZhc011dGF0aW9uQ2IsIGZvbnRDYiA9IG8yLmZvbnRDYiwgc2VsZWN0aW9uQ2IgPSBvMi5zZWxlY3Rpb25DYiwgY3VzdG9tRWxlbWVudENiID0gbzIuY3VzdG9tRWxlbWVudENiO1xuICAgIG8yLm11dGF0aW9uQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MubXV0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBfaG9va3M7XG4gICAgICAgICAgICAoX2hvb2tzID0gaG9va3MpLm11dGF0aW9uLmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICBtdXRhdGlvbkNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLm1vdXNlbW92ZUNiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHAgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIHBbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvb2tzLm1vdXNlbW92ZSkge1xuICAgICAgICAgICAgdmFyIF9ob29rcztcbiAgICAgICAgICAgIChfaG9va3MgPSBob29rcykubW91c2Vtb3ZlLmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICBtb3VzZW1vdmVDYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChwKSk7XG4gICAgfTtcbiAgICBvMi5tb3VzZUludGVyYWN0aW9uQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MubW91c2VJbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgdmFyIF9ob29rcztcbiAgICAgICAgICAgIChfaG9va3MgPSBob29rcykubW91c2VJbnRlcmFjdGlvbi5hcHBseShfaG9va3MsIFtdLmNvbmNhdChwKSk7XG4gICAgICAgIH1cbiAgICAgICAgbW91c2VJbnRlcmFjdGlvbkNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLnNjcm9sbENiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHAgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIHBbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvb2tzLnNjcm9sbCkge1xuICAgICAgICAgICAgdmFyIF9ob29rcztcbiAgICAgICAgICAgIChfaG9va3MgPSBob29rcykuc2Nyb2xsLmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICBzY3JvbGxDYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChwKSk7XG4gICAgfTtcbiAgICBvMi52aWV3cG9ydFJlc2l6ZUNiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHAgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIHBbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvb2tzLnZpZXdwb3J0UmVzaXplKSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS52aWV3cG9ydFJlc2l6ZS5hcHBseShfaG9va3MsIFtdLmNvbmNhdChwKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmlld3BvcnRSZXNpemVDYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChwKSk7XG4gICAgfTtcbiAgICBvMi5pbnB1dENiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHAgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIHBbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvb2tzLmlucHV0KSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS5pbnB1dC5hcHBseShfaG9va3MsIFtdLmNvbmNhdChwKSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRDYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChwKSk7XG4gICAgfTtcbiAgICBvMi5tZWRpYUludGVyYWN0aW9uQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MubWVkaWFJbnRlYWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS5tZWRpYUludGVhY3Rpb24uYXBwbHkoX2hvb2tzLCBbXS5jb25jYXQocCkpO1xuICAgICAgICB9XG4gICAgICAgIG1lZGlhSW50ZXJhY3Rpb25DYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChwKSk7XG4gICAgfTtcbiAgICBvMi5zdHlsZVNoZWV0UnVsZUNiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHAgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgIHBbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvb2tzLnN0eWxlU2hlZXRSdWxlKSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS5zdHlsZVNoZWV0UnVsZS5hcHBseShfaG9va3MsIFtdLmNvbmNhdChwKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGVTaGVldFJ1bGVDYi5hcHBseSh2b2lkIDAsIFtdLmNvbmNhdChwKSk7XG4gICAgfTtcbiAgICBvMi5zdHlsZURlY2xhcmF0aW9uQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3Muc3R5bGVEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIF9ob29rcztcbiAgICAgICAgICAgIChfaG9va3MgPSBob29rcykuc3R5bGVEZWNsYXJhdGlvbi5hcHBseShfaG9va3MsIFtdLmNvbmNhdChwKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGVEZWNsYXJhdGlvbkNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLmNhbnZhc011dGF0aW9uQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3MuY2FudmFzTXV0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBfaG9va3M7XG4gICAgICAgICAgICAoX2hvb2tzID0gaG9va3MpLmNhbnZhc011dGF0aW9uLmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXNNdXRhdGlvbkNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLmZvbnRDYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKyl7XG4gICAgICAgICAgICBwW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob29rcy5mb250KSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS5mb250LmFwcGx5KF9ob29rcywgW10uY29uY2F0KHApKTtcbiAgICAgICAgfVxuICAgICAgICBmb250Q2IuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQocCkpO1xuICAgIH07XG4gICAgbzIuc2VsZWN0aW9uQ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgcCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgcFtfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaG9va3Muc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX2hvb2tzO1xuICAgICAgICAgICAgKF9ob29rcyA9IGhvb2tzKS5zZWxlY3Rpb24uYXBwbHkoX2hvb2tzLCBbXS5jb25jYXQocCkpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbkNiLmFwcGx5KHZvaWQgMCwgW10uY29uY2F0KHApKTtcbiAgICB9O1xuICAgIG8yLmN1c3RvbUVsZW1lbnRDYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBjMiA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgYzJbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvb2tzLmN1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBfaG9va3M7XG4gICAgICAgICAgICAoX2hvb2tzID0gaG9va3MpLmN1c3RvbUVsZW1lbnQuYXBwbHkoX2hvb2tzLCBbXS5jb25jYXQoYzIpKTtcbiAgICAgICAgfVxuICAgICAgICBjdXN0b21FbGVtZW50Q2IuYXBwbHkodm9pZCAwLCBbXS5jb25jYXQoYzIpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaW5pdE9ic2VydmVycyhvMiwgaG9va3MpIHtcbiAgICBpZiAoaG9va3MgPT09IHZvaWQgMCkgaG9va3MgPSB7fTtcbiAgICB2YXIgY3VycmVudFdpbmRvdyA9IG8yLmRvYy5kZWZhdWx0VmlldztcbiAgICBpZiAoIWN1cnJlbnRXaW5kb3cpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgfVxuICAgIG1lcmdlSG9va3MobzIsIGhvb2tzKTtcbiAgICB2YXIgbXV0YXRpb25PYnNlcnZlcjtcbiAgICBpZiAobzIucmVjb3JkRE9NKSB7XG4gICAgICAgIG11dGF0aW9uT2JzZXJ2ZXIgPSBpbml0TXV0YXRpb25PYnNlcnZlcihvMiwgbzIuZG9jKTtcbiAgICB9XG4gICAgdmFyIG1vdXNlbW92ZUhhbmRsZXIgPSBpbml0TW92ZU9ic2VydmVyKG8yKTtcbiAgICB2YXIgbW91c2VJbnRlcmFjdGlvbkhhbmRsZXIgPSBpbml0TW91c2VJbnRlcmFjdGlvbk9ic2VydmVyKG8yKTtcbiAgICB2YXIgc2Nyb2xsSGFuZGxlciA9IGluaXRTY3JvbGxPYnNlcnZlcihvMik7XG4gICAgdmFyIHZpZXdwb3J0UmVzaXplSGFuZGxlciA9IGluaXRWaWV3cG9ydFJlc2l6ZU9ic2VydmVyKG8yLCB7XG4gICAgICAgIHdpbjogY3VycmVudFdpbmRvd1xuICAgIH0pO1xuICAgIHZhciBpbnB1dEhhbmRsZXIgPSBpbml0SW5wdXRPYnNlcnZlcihvMik7XG4gICAgdmFyIG1lZGlhSW50ZXJhY3Rpb25IYW5kbGVyID0gaW5pdE1lZGlhSW50ZXJhY3Rpb25PYnNlcnZlcihvMik7XG4gICAgdmFyIHN0eWxlU2hlZXRPYnNlcnZlciA9IGZ1bmN0aW9uKCkge307XG4gICAgdmFyIGFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciBzdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciBmb250T2JzZXJ2ZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIGlmIChvMi5yZWNvcmRET00pIHtcbiAgICAgICAgc3R5bGVTaGVldE9ic2VydmVyID0gaW5pdFN0eWxlU2hlZXRPYnNlcnZlcihvMiwge1xuICAgICAgICAgICAgd2luOiBjdXJyZW50V2luZG93XG4gICAgICAgIH0pO1xuICAgICAgICBhZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyID0gaW5pdEFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIobzIsIG8yLmRvYyk7XG4gICAgICAgIHN0eWxlRGVjbGFyYXRpb25PYnNlcnZlciA9IGluaXRTdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIobzIsIHtcbiAgICAgICAgICAgIHdpbjogY3VycmVudFdpbmRvd1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG8yLmNvbGxlY3RGb250cykge1xuICAgICAgICAgICAgZm9udE9ic2VydmVyID0gaW5pdEZvbnRPYnNlcnZlcihvMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNlbGVjdGlvbk9ic2VydmVyID0gaW5pdFNlbGVjdGlvbk9ic2VydmVyKG8yKTtcbiAgICB2YXIgY3VzdG9tRWxlbWVudE9ic2VydmVyID0gaW5pdEN1c3RvbUVsZW1lbnRPYnNlcnZlcihvMik7XG4gICAgdmFyIHBsdWdpbkhhbmRsZXJzID0gW107XG4gICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UobzIucGx1Z2lucyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgdmFyIHBsdWdpbjMgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgcGx1Z2luSGFuZGxlcnMucHVzaChwbHVnaW4zLm9ic2VydmVyKHBsdWdpbjMuY2FsbGJhY2ssIGN1cnJlbnRXaW5kb3csIHBsdWdpbjMub3B0aW9ucykpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKGZ1bmN0aW9uKCkge1xuICAgICAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5yZXNldCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgbXV0YXRpb25PYnNlcnZlciA9PSBudWxsID8gdm9pZCAwIDogbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIG1vdXNlbW92ZUhhbmRsZXIoKTtcbiAgICAgICAgbW91c2VJbnRlcmFjdGlvbkhhbmRsZXIoKTtcbiAgICAgICAgc2Nyb2xsSGFuZGxlcigpO1xuICAgICAgICB2aWV3cG9ydFJlc2l6ZUhhbmRsZXIoKTtcbiAgICAgICAgaW5wdXRIYW5kbGVyKCk7XG4gICAgICAgIG1lZGlhSW50ZXJhY3Rpb25IYW5kbGVyKCk7XG4gICAgICAgIHN0eWxlU2hlZXRPYnNlcnZlcigpO1xuICAgICAgICBhZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyKCk7XG4gICAgICAgIHN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcigpO1xuICAgICAgICBmb250T2JzZXJ2ZXIoKTtcbiAgICAgICAgc2VsZWN0aW9uT2JzZXJ2ZXIoKTtcbiAgICAgICAgY3VzdG9tRWxlbWVudE9ic2VydmVyKCk7XG4gICAgICAgIHBsdWdpbkhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaCkge1xuICAgICAgICAgICAgcmV0dXJuIGgoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYXNOZXN0ZWRDU1NSdWxlKHByb3ApIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvd1twcm9wXSAhPT0gXCJ1bmRlZmluZWRcIjtcbn1cbmZ1bmN0aW9uIGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZShwcm9wKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odHlwZW9mIHdpbmRvd1twcm9wXSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAvLyBOb3RlOiBHZW5lcmFsbHksIHRoaXMgY2hlY2sgX3Nob3VsZG4ndF8gYmUgbmVjZXNzYXJ5XG4gICAgLy8gSG93ZXZlciwgaW4gc29tZSBzY2VuYXJpb3MgKGUuZy4ganNkb20pIHRoaXMgY2FuIHNvbWV0aW1lcyBmYWlsLCBzbyB3ZSBjaGVjayBmb3IgaXQgaGVyZVxuICAgIHdpbmRvd1twcm9wXS5wcm90b3R5cGUgJiYgXCJpbnNlcnRSdWxlXCIgaW4gd2luZG93W3Byb3BdLnByb3RvdHlwZSAmJiBcImRlbGV0ZVJ1bGVcIiBpbiB3aW5kb3dbcHJvcF0ucHJvdG90eXBlKTtcbn1cbnZhciBDcm9zc09yaWdpbklmcmFtZU1pcnJvciA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gQ3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IoZ2VuZXJhdGVJZEZuKSB7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJpZnJhbWVJZFRvUmVtb3RlSWRNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaWZyYW1lUmVtb3RlSWRUb0lkTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZUlkRm4gPSBnZW5lcmF0ZUlkRm47XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBDcm9zc09yaWdpbklmcmFtZU1pcnJvci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmdldElkID0gZnVuY3Rpb24gZ2V0SWQoaWZyYW1lLCByZW1vdGVJZCwgaWRUb1JlbW90ZU1hcCwgcmVtb3RlVG9JZE1hcCkge1xuICAgICAgICB2YXIgaWRUb1JlbW90ZUlkTWFwID0gaWRUb1JlbW90ZU1hcCB8fCB0aGlzLmdldElkVG9SZW1vdGVJZE1hcChpZnJhbWUpO1xuICAgICAgICB2YXIgcmVtb3RlSWRUb0lkTWFwID0gcmVtb3RlVG9JZE1hcCB8fCB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xuICAgICAgICB2YXIgaWQgPSBpZFRvUmVtb3RlSWRNYXAuZ2V0KHJlbW90ZUlkKTtcbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgaWQgPSB0aGlzLmdlbmVyYXRlSWRGbigpO1xuICAgICAgICAgICAgaWRUb1JlbW90ZUlkTWFwLnNldChyZW1vdGVJZCwgaWQpO1xuICAgICAgICAgICAgcmVtb3RlSWRUb0lkTWFwLnNldChpZCwgcmVtb3RlSWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuICAgIF9wcm90by5nZXRJZHMgPSBmdW5jdGlvbiBnZXRJZHMoaWZyYW1lLCByZW1vdGVJZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaWRUb1JlbW90ZUlkTWFwID0gdGhpcy5nZXRJZFRvUmVtb3RlSWRNYXAoaWZyYW1lKTtcbiAgICAgICAgdmFyIHJlbW90ZUlkVG9JZE1hcCA9IHRoaXMuZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSk7XG4gICAgICAgIHJldHVybiByZW1vdGVJZC5tYXAoZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRJZChpZnJhbWUsIGlkLCBpZFRvUmVtb3RlSWRNYXAsIHJlbW90ZUlkVG9JZE1hcCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFJlbW90ZUlkID0gZnVuY3Rpb24gZ2V0UmVtb3RlSWQoaWZyYW1lLCBpZCwgbWFwKSB7XG4gICAgICAgIHZhciByZW1vdGVJZFRvSWRNYXAgPSBtYXAgfHwgdGhpcy5nZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKTtcbiAgICAgICAgaWYgKHR5cGVvZiBpZCAhPT0gXCJudW1iZXJcIikgcmV0dXJuIGlkO1xuICAgICAgICB2YXIgcmVtb3RlSWQgPSByZW1vdGVJZFRvSWRNYXAuZ2V0KGlkKTtcbiAgICAgICAgaWYgKCFyZW1vdGVJZCkgcmV0dXJuIC0xO1xuICAgICAgICByZXR1cm4gcmVtb3RlSWQ7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0UmVtb3RlSWRzID0gZnVuY3Rpb24gZ2V0UmVtb3RlSWRzKGlmcmFtZSwgaWRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZW1vdGVJZFRvSWRNYXAgPSB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xuICAgICAgICByZXR1cm4gaWRzLm1hcChmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldFJlbW90ZUlkKGlmcmFtZSwgaWQsIHJlbW90ZUlkVG9JZE1hcCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoaWZyYW1lKSB7XG4gICAgICAgIGlmICghaWZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICAgICAgICAgICAgdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcC5kZWxldGUoaWZyYW1lKTtcbiAgICAgICAgdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAuZGVsZXRlKGlmcmFtZSk7XG4gICAgfTtcbiAgICBfcHJvdG8uZ2V0SWRUb1JlbW90ZUlkTWFwID0gZnVuY3Rpb24gZ2V0SWRUb1JlbW90ZUlkTWFwKGlmcmFtZSkge1xuICAgICAgICB2YXIgaWRUb1JlbW90ZUlkTWFwID0gdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAuZ2V0KGlmcmFtZSk7XG4gICAgICAgIGlmICghaWRUb1JlbW90ZUlkTWFwKSB7XG4gICAgICAgICAgICBpZFRvUmVtb3RlSWRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5pZnJhbWVJZFRvUmVtb3RlSWRNYXAuc2V0KGlmcmFtZSwgaWRUb1JlbW90ZUlkTWFwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWRUb1JlbW90ZUlkTWFwO1xuICAgIH07XG4gICAgX3Byb3RvLmdldFJlbW90ZUlkVG9JZE1hcCA9IGZ1bmN0aW9uIGdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpIHtcbiAgICAgICAgdmFyIHJlbW90ZUlkVG9JZE1hcCA9IHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwLmdldChpZnJhbWUpO1xuICAgICAgICBpZiAoIXJlbW90ZUlkVG9JZE1hcCkge1xuICAgICAgICAgICAgcmVtb3RlSWRUb0lkTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwLnNldChpZnJhbWUsIHJlbW90ZUlkVG9JZE1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlbW90ZUlkVG9JZE1hcDtcbiAgICB9O1xuICAgIHJldHVybiBDcm9zc09yaWdpbklmcmFtZU1pcnJvcjtcbn0oKTtcbnZhciBJZnJhbWVNYW5hZ2VyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBJZnJhbWVNYW5hZ2VyKG9wdGlvbnMpIHtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImlmcmFtZXNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY3Jvc3NPcmlnaW5JZnJhbWVNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3JcIiwgbmV3IENyb3NzT3JpZ2luSWZyYW1lTWlycm9yKGdlbklkKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY3Jvc3NPcmlnaW5JZnJhbWVSb290SWRNYXBcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibWlycm9yXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibXV0YXRpb25DYlwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIndyYXBwZWRFbWl0XCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibG9hZExpc3RlbmVyXCIpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3R5bGVzaGVldE1hbmFnZXJcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZWNvcmRDcm9zc09yaWdpbklmcmFtZXNcIik7XG4gICAgICAgIHRoaXMubXV0YXRpb25DYiA9IG9wdGlvbnMubXV0YXRpb25DYjtcbiAgICAgICAgdGhpcy53cmFwcGVkRW1pdCA9IG9wdGlvbnMud3JhcHBlZEVtaXQ7XG4gICAgICAgIHRoaXMuc3R5bGVzaGVldE1hbmFnZXIgPSBvcHRpb25zLnN0eWxlc2hlZXRNYW5hZ2VyO1xuICAgICAgICB0aGlzLnJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyA9IG9wdGlvbnMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzO1xuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3IgPSBuZXcgQ3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IodGhpcy5zdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvci5nZW5lcmF0ZUlkLmJpbmQodGhpcy5zdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvcikpO1xuICAgICAgICB0aGlzLm1pcnJvciA9IG9wdGlvbnMubWlycm9yO1xuICAgICAgICBpZiAodGhpcy5yZWNvcmRDcm9zc09yaWdpbklmcmFtZXMpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLmhhbmRsZU1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9wcm90byA9IElmcmFtZU1hbmFnZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5hZGRJZnJhbWUgPSBmdW5jdGlvbiBhZGRJZnJhbWUoaWZyYW1lRWwpIHtcbiAgICAgICAgdGhpcy5pZnJhbWVzLnNldChpZnJhbWVFbCwgdHJ1ZSk7XG4gICAgICAgIGlmIChpZnJhbWVFbC5jb250ZW50V2luZG93KSB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWFwLnNldChpZnJhbWVFbC5jb250ZW50V2luZG93LCBpZnJhbWVFbCk7XG4gICAgfTtcbiAgICBfcHJvdG8uYWRkTG9hZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTG9hZExpc3RlbmVyKGNiKSB7XG4gICAgICAgIHRoaXMubG9hZExpc3RlbmVyID0gY2I7XG4gICAgfTtcbiAgICBfcHJvdG8uYXR0YWNoSWZyYW1lID0gZnVuY3Rpb24gYXR0YWNoSWZyYW1lKGlmcmFtZUVsLCBjaGlsZFNuKSB7XG4gICAgICAgIHZhciBfYTIsIF9iO1xuICAgICAgICB0aGlzLm11dGF0aW9uQ2Ioe1xuICAgICAgICAgICAgYWRkczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IHRoaXMubWlycm9yLmdldElkKGlmcmFtZUVsKSxcbiAgICAgICAgICAgICAgICAgICAgbmV4dElkOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBub2RlOiBjaGlsZFNuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHJlbW92ZXM6IFtdLFxuICAgICAgICAgICAgdGV4dHM6IFtdLFxuICAgICAgICAgICAgYXR0cmlidXRlczogW10sXG4gICAgICAgICAgICBpc0F0dGFjaElmcmFtZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzKSAoX2EyID0gaWZyYW1lRWwuY29udGVudFdpbmRvdykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLmhhbmRsZU1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgIChfYiA9IHRoaXMubG9hZExpc3RlbmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY2FsbCh0aGlzLCBpZnJhbWVFbCk7XG4gICAgICAgIGlmIChpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQgJiYgaWZyYW1lRWwuY29udGVudERvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cyAmJiBpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzLmxlbmd0aCA+IDApIHRoaXMuc3R5bGVzaGVldE1hbmFnZXIuYWRvcHRTdHlsZVNoZWV0cyhpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzLCB0aGlzLm1pcnJvci5nZXRJZChpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQpKTtcbiAgICB9O1xuICAgIF9wcm90by5oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHZhciBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudCA9IG1lc3NhZ2U7XG4gICAgICAgIGlmIChjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5kYXRhLnR5cGUgIT09IFwicnJ3ZWJcIiB8fCAvLyBUbyBmaWx0ZXIgb3V0IHRoZSBycndlYiBtZXNzYWdlcyB3aGljaCBhcmUgZm9yd2FyZGVkIGJ5IHNvbWUgc2l0ZXMuXG4gICAgICAgIGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50Lm9yaWdpbiAhPT0gY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQuZGF0YS5vcmlnaW4pIHJldHVybjtcbiAgICAgICAgdmFyIGlmcmFtZVNvdXJjZVdpbmRvdyA9IG1lc3NhZ2Uuc291cmNlO1xuICAgICAgICBpZiAoIWlmcmFtZVNvdXJjZVdpbmRvdykgcmV0dXJuO1xuICAgICAgICB2YXIgaWZyYW1lRWwgPSB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWFwLmdldChtZXNzYWdlLnNvdXJjZSk7XG4gICAgICAgIGlmICghaWZyYW1lRWwpIHJldHVybjtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkRXZlbnQgPSB0aGlzLnRyYW5zZm9ybUNyb3NzT3JpZ2luRXZlbnQoaWZyYW1lRWwsIGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEuZXZlbnQpO1xuICAgICAgICBpZiAodHJhbnNmb3JtZWRFdmVudCkgdGhpcy53cmFwcGVkRW1pdCh0cmFuc2Zvcm1lZEV2ZW50LCBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5kYXRhLmlzQ2hlY2tvdXQpO1xuICAgIH07XG4gICAgX3Byb3RvLnRyYW5zZm9ybUNyb3NzT3JpZ2luRXZlbnQgPSBmdW5jdGlvbiB0cmFuc2Zvcm1Dcm9zc09yaWdpbkV2ZW50KGlmcmFtZUVsLCBlMikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICBzd2l0Y2goZTIudHlwZSl7XG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZS5GdWxsU25hcHNob3Q6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyb3NzT3JpZ2luSWZyYW1lTWlycm9yLnJlc2V0KGlmcmFtZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yLnJlc2V0KGlmcmFtZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRPbk5vZGUoZTIuZGF0YS5ub2RlLCBpZnJhbWVFbCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb290SWQgPSBlMi5kYXRhLm5vZGUuaWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVSb290SWRNYXAuc2V0KGlmcmFtZUVsLCByb290SWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdGNoUm9vdElkT25Ob2RlKGUyLmRhdGEubm9kZSwgcm9vdElkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogZTIudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5NdXRhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiB0aGlzLm1pcnJvci5nZXRJZChpZnJhbWVFbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0SWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBlMi5kYXRhLm5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQXR0YWNoSWZyYW1lOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUuTWV0YTpcbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlLkxvYWQ6XG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZS5Eb21Db250ZW50TG9hZGVkOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlLlBsdWdpbjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZS5DdXN0b206XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMoZTIuZGF0YS5wYXlsb2FkLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJwYXJlbnRJZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJwcmV2aW91c0lkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm5leHRJZFwiXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChlMi5kYXRhLnNvdXJjZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLk11dGF0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTIuZGF0YS5hZGRzLmZvckVhY2goZnVuY3Rpb24objIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcGxhY2VJZHMobjIsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwYXJlbnRJZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibmV4dElkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwcmV2aW91c0lkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVwbGFjZUlkT25Ob2RlKG4yLm5vZGUsIGlmcmFtZUVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb290SWQgPSBfdGhpcy5jcm9zc09yaWdpbklmcmFtZVJvb3RJZE1hcC5nZXQoaWZyYW1lRWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdElkICYmIF90aGlzLnBhdGNoUm9vdElkT25Ob2RlKG4yLm5vZGUsIHJvb3RJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMi5kYXRhLnJlbW92ZXMuZm9yRWFjaChmdW5jdGlvbihuMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVwbGFjZUlkcyhuMiwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBhcmVudElkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUyLmRhdGEuYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXBsYWNlSWRzKG4yLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMi5kYXRhLnRleHRzLmZvckVhY2goZnVuY3Rpb24objIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlcGxhY2VJZHMobjIsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLkRyYWc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlRvdWNoTW92ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuTW91c2VNb3ZlOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTIuZGF0YS5wb3NpdGlvbnMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXBsYWNlSWRzKHAsIGlmcmFtZUVsLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlZpZXdwb3J0UmVzaXplOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuTWVkaWFJbnRlcmFjdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuTW91c2VJbnRlcmFjdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuU2Nyb2xsOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5DYW52YXNNdXRhdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuSW5wdXQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMoZTIuZGF0YSwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuU3R5bGVTaGVldFJ1bGU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlLlN0eWxlRGVjbGFyYXRpb246XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMoZTIuZGF0YSwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlU3R5bGVJZHMoZTIuZGF0YSwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3R5bGVJZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5Gb250OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGUyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UuU2VsZWN0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZTIuZGF0YS5yYW5nZXMuZm9yRWFjaChmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVwbGFjZUlkcyhyYW5nZSwgaWZyYW1lRWwsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJlbmRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZS5BZG9wdGVkU3R5bGVTaGVldDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VTdHlsZUlkcyhlMi5kYXRhLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzdHlsZUlkc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2EyID0gZTIuZGF0YS5zdHlsZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIuZm9yRWFjaChmdW5jdGlvbihzdHlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVwbGFjZVN0eWxlSWRzKHN0eWxlLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3R5bGVJZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKGlmcmFtZU1pcnJvciwgb2JqLCBpZnJhbWVFbCwga2V5cykge1xuICAgICAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShrZXlzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspe1xuICAgICAgICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9ialtrZXldKSAmJiB0eXBlb2Ygb2JqW2tleV0gIT09IFwibnVtYmVyXCIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgb2JqW2tleV0gPSBpZnJhbWVNaXJyb3IuZ2V0SWRzKGlmcmFtZUVsLCBvYmpba2V5XSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gaWZyYW1lTWlycm9yLmdldElkKGlmcmFtZUVsLCBvYmpba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIF9wcm90by5yZXBsYWNlSWRzID0gZnVuY3Rpb24gcmVwbGFjZUlkcyhvYmosIGlmcmFtZUVsLCBrZXlzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UodGhpcy5jcm9zc09yaWdpbklmcmFtZU1pcnJvciwgb2JqLCBpZnJhbWVFbCwga2V5cyk7XG4gICAgfTtcbiAgICBfcHJvdG8ucmVwbGFjZVN0eWxlSWRzID0gZnVuY3Rpb24gcmVwbGFjZVN0eWxlSWRzKG9iaiwgaWZyYW1lRWwsIGtleXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSh0aGlzLmNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3IsIG9iaiwgaWZyYW1lRWwsIGtleXMpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlcGxhY2VJZE9uTm9kZSA9IGZ1bmN0aW9uIHJlcGxhY2VJZE9uTm9kZShub2RlMiwgaWZyYW1lRWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXBsYWNlSWRzKG5vZGUyLCBpZnJhbWVFbCwgW1xuICAgICAgICAgICAgXCJpZFwiLFxuICAgICAgICAgICAgXCJyb290SWRcIlxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKFwiY2hpbGROb2Rlc1wiIGluIG5vZGUyKSB7XG4gICAgICAgICAgICBub2RlMi5jaGlsZE5vZGVzLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXBsYWNlSWRPbk5vZGUoY2hpbGQsIGlmcmFtZUVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfcHJvdG8ucGF0Y2hSb290SWRPbk5vZGUgPSBmdW5jdGlvbiBwYXRjaFJvb3RJZE9uTm9kZShub2RlMiwgcm9vdElkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChub2RlMi50eXBlICE9PSBOb2RlVHlwZS5Eb2N1bWVudCAmJiAhbm9kZTIucm9vdElkKSBub2RlMi5yb290SWQgPSByb290SWQ7XG4gICAgICAgIGlmIChcImNoaWxkTm9kZXNcIiBpbiBub2RlMikge1xuICAgICAgICAgICAgbm9kZTIuY2hpbGROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucGF0Y2hSb290SWRPbk5vZGUoY2hpbGQsIHJvb3RJZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIElmcmFtZU1hbmFnZXI7XG59KCk7XG52YXIgU2hhZG93RG9tTWFuYWdlciA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gU2hhZG93RG9tTWFuYWdlcihvcHRpb25zKSB7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzaGFkb3dEb21zXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm11dGF0aW9uQ2JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzY3JvbGxDYlwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImJ5cGFzc09wdGlvbnNcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJtaXJyb3JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXN0b3JlSGFuZGxlcnNcIiwgW10pO1xuICAgICAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ2IgPSBvcHRpb25zLnNjcm9sbENiO1xuICAgICAgICB0aGlzLmJ5cGFzc09wdGlvbnMgPSBvcHRpb25zLmJ5cGFzc09wdGlvbnM7XG4gICAgICAgIHRoaXMubWlycm9yID0gb3B0aW9ucy5taXJyb3I7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICB2YXIgX3Byb3RvID0gU2hhZG93RG9tTWFuYWdlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMucGF0Y2hBdHRhY2hTaGFkb3coRWxlbWVudCwgZG9jdW1lbnQpO1xuICAgIH07XG4gICAgX3Byb3RvLmFkZFNoYWRvd1Jvb3QgPSBmdW5jdGlvbiBhZGRTaGFkb3dSb290KHNoYWRvd1Jvb3QyLCBkb2MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFpc05hdGl2ZVNoYWRvd0RvbShzaGFkb3dSb290MikpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93RG9tcy5oYXMoc2hhZG93Um9vdDIpKSByZXR1cm47XG4gICAgICAgIHRoaXMuc2hhZG93RG9tcy5hZGQoc2hhZG93Um9vdDIpO1xuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBpbml0TXV0YXRpb25PYnNlcnZlcihfZXh0ZW5kcyh7fSwgdGhpcy5ieXBhc3NPcHRpb25zLCB7XG4gICAgICAgICAgICBkb2M6IGRvYyxcbiAgICAgICAgICAgIG11dGF0aW9uQ2I6IHRoaXMubXV0YXRpb25DYixcbiAgICAgICAgICAgIG1pcnJvcjogdGhpcy5taXJyb3IsXG4gICAgICAgICAgICBzaGFkb3dEb21NYW5hZ2VyOiB0aGlzXG4gICAgICAgIH0pLCBzaGFkb3dSb290Mik7XG4gICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaChpbml0U2Nyb2xsT2JzZXJ2ZXIoX2V4dGVuZHMoe30sIHRoaXMuYnlwYXNzT3B0aW9ucywge1xuICAgICAgICAgICAgc2Nyb2xsQ2I6IHRoaXMuc2Nyb2xsQ2IsXG4gICAgICAgICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wcmF2ZWVucHVnbGlhLzA4MzJkYTY4N2VkNWE1ZDdhMDkwNzA0NmM5ZWYxODEzXG4gICAgICAgICAgICAvLyBzY3JvbGwgaXMgbm90IGFsbG93ZWQgdG8gcGFzcyB0aGUgYm91bmRhcnksIHNvIHdlIG5lZWQgdG8gbGlzdGVuIHRoZSBzaGFkb3cgZG9jdW1lbnRcbiAgICAgICAgICAgIGRvYzogc2hhZG93Um9vdDIsXG4gICAgICAgICAgICBtaXJyb3I6IHRoaXMubWlycm9yXG4gICAgICAgIH0pKSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoc2hhZG93Um9vdDIuYWRvcHRlZFN0eWxlU2hlZXRzICYmIHNoYWRvd1Jvb3QyLmFkb3B0ZWRTdHlsZVNoZWV0cy5sZW5ndGggPiAwKSBfdGhpcy5ieXBhc3NPcHRpb25zLnN0eWxlc2hlZXRNYW5hZ2VyLmFkb3B0U3R5bGVTaGVldHMoc2hhZG93Um9vdDIuYWRvcHRlZFN0eWxlU2hlZXRzLCBfdGhpcy5taXJyb3IuZ2V0SWQoaW5kZXguaG9zdChzaGFkb3dSb290MikpKTtcbiAgICAgICAgICAgIF90aGlzLnJlc3RvcmVIYW5kbGVycy5wdXNoKGluaXRBZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyKHtcbiAgICAgICAgICAgICAgICBtaXJyb3I6IF90aGlzLm1pcnJvcixcbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlcjogX3RoaXMuYnlwYXNzT3B0aW9ucy5zdHlsZXNoZWV0TWFuYWdlclxuICAgICAgICAgICAgfSwgc2hhZG93Um9vdDIpKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfTtcbiAgICAvKipcbiAgICogTW9ua2V5IHBhdGNoICdhdHRhY2hTaGFkb3cnIG9mIGFuIElGcmFtZUVsZW1lbnQgdG8gb2JzZXJ2ZSBuZXdseSBhZGRlZCBzaGFkb3cgZG9tcy5cbiAgICovIF9wcm90by5vYnNlcnZlQXR0YWNoU2hhZG93ID0gZnVuY3Rpb24gb2JzZXJ2ZUF0dGFjaFNoYWRvdyhpZnJhbWVFbGVtZW50KSB7XG4gICAgICAgIGlmICghaWZyYW1lRWxlbWVudC5jb250ZW50V2luZG93IHx8ICFpZnJhbWVFbGVtZW50LmNvbnRlbnREb2N1bWVudCkgcmV0dXJuO1xuICAgICAgICB0aGlzLnBhdGNoQXR0YWNoU2hhZG93KGlmcmFtZUVsZW1lbnQuY29udGVudFdpbmRvdy5FbGVtZW50LCBpZnJhbWVFbGVtZW50LmNvbnRlbnREb2N1bWVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICogUGF0Y2ggJ2F0dGFjaFNoYWRvdycgdG8gb2JzZXJ2ZSBuZXdseSBhZGRlZCBzaGFkb3cgZG9tcy5cbiAgICovIF9wcm90by5wYXRjaEF0dGFjaFNoYWRvdyA9IGZ1bmN0aW9uIHBhdGNoQXR0YWNoU2hhZG93KGVsZW1lbnQsIGRvYykge1xuICAgICAgICB2YXIgbWFuYWdlciA9IHRoaXM7XG4gICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLnB1c2gocGF0Y2goZWxlbWVudC5wcm90b3R5cGUsIFwiYXR0YWNoU2hhZG93XCIsIGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNSb290ID0gb3JpZ2luYWwuY2FsbCh0aGlzLCBvcHRpb24pO1xuICAgICAgICAgICAgICAgIHZhciBzaGFkb3dSb290RWwgPSBpbmRleC5zaGFkb3dSb290KHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmIChzaGFkb3dSb290RWwgJiYgaW5Eb20odGhpcykpIG1hbmFnZXIuYWRkU2hhZG93Um9vdChzaGFkb3dSb290RWwsIGRvYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNSb290O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24oaGFuZGxlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlMikge31cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVzdG9yZUhhbmRsZXJzID0gW107XG4gICAgICAgIHRoaXMuc2hhZG93RG9tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNoYWRvd0RvbU1hbmFnZXI7XG59KCk7XG52YXIgY2hhcnMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbnZhciBsb29rdXAgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIiA/IFtdIDogbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbmZvcih2YXIgaSQxID0gMDsgaSQxIDwgY2hhcnMubGVuZ3RoOyBpJDErKyl7XG4gICAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSQxKV0gPSBpJDE7XG59XG52YXIgZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGFycmF5YnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLCBpMiwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuICAgIGZvcihpMiA9IDA7IGkyIDwgbGVuOyBpMiArPSAzKXtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kyXSA+PiAyXTtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMl0gJiAzKSA8PCA0IHwgYnl0ZXNbaTIgKyAxXSA+PiA0XTtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzWyhieXRlc1tpMiArIDFdICYgMTUpIDw8IDIgfCBieXRlc1tpMiArIDJdID4+IDZdO1xuICAgICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaTIgKyAyXSAmIDYzXTtcbiAgICB9XG4gICAgaWYgKGxlbiAlIDMgPT09IDIpIHtcbiAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgICB9IGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyBcIj09XCI7XG4gICAgfVxuICAgIHJldHVybiBiYXNlNjQ7XG59O1xudmFyIGNhbnZhc1Zhck1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiB2YXJpYWJsZUxpc3RGb3IkMShjdHgsIGN0b3IpIHtcbiAgICB2YXIgY29udGV4dE1hcCA9IGNhbnZhc1Zhck1hcC5nZXQoY3R4KTtcbiAgICBpZiAoIWNvbnRleHRNYXApIHtcbiAgICAgICAgY29udGV4dE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGNhbnZhc1Zhck1hcC5zZXQoY3R4LCBjb250ZXh0TWFwKTtcbiAgICB9XG4gICAgaWYgKCFjb250ZXh0TWFwLmhhcyhjdG9yKSkge1xuICAgICAgICBjb250ZXh0TWFwLnNldChjdG9yLCBbXSk7XG4gICAgfVxuICAgIHJldHVybiBjb250ZXh0TWFwLmdldChjdG9yKTtcbn1cbnZhciBzYXZlV2ViR0xWYXIgPSBmdW5jdGlvbih2YWx1ZSwgd2luLCBjdHgpIHtcbiAgICBpZiAoIXZhbHVlIHx8ICEoaXNJbnN0YW5jZU9mV2ViR0xPYmplY3QodmFsdWUsIHdpbikgfHwgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZV9vZih2YWx1ZSkpID09PSBcIm9iamVjdFwiKSkgcmV0dXJuO1xuICAgIHZhciBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICB2YXIgbGlzdDIgPSB2YXJpYWJsZUxpc3RGb3IkMShjdHgsIG5hbWUpO1xuICAgIHZhciBpbmRleDIgPSBsaXN0Mi5pbmRleE9mKHZhbHVlKTtcbiAgICBpZiAoaW5kZXgyID09PSAtMSkge1xuICAgICAgICBpbmRleDIgPSBsaXN0Mi5sZW5ndGg7XG4gICAgICAgIGxpc3QyLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXgyO1xufTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZUFyZyh2YWx1ZSwgd2luLCBjdHgpIHtcbiAgICBpZiAoX2luc3RhbmNlb2YodmFsdWUsIEFycmF5KSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUFyZyhhcmcsIHdpbiwgY3R4KTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZih2YWx1ZSwgRmxvYXQzMkFycmF5KSB8fCBfaW5zdGFuY2VvZih2YWx1ZSwgRmxvYXQ2NEFycmF5KSB8fCBfaW5zdGFuY2VvZih2YWx1ZSwgSW50MzJBcnJheSkgfHwgX2luc3RhbmNlb2YodmFsdWUsIFVpbnQzMkFycmF5KSB8fCBfaW5zdGFuY2VvZih2YWx1ZSwgVWludDhBcnJheSkgfHwgX2luc3RhbmNlb2YodmFsdWUsIFVpbnQxNkFycmF5KSB8fCBfaW5zdGFuY2VvZih2YWx1ZSwgSW50MTZBcnJheSkgfHwgX2luc3RhbmNlb2YodmFsdWUsIEludDhBcnJheSkgfHwgX2luc3RhbmNlb2YodmFsdWUsIFVpbnQ4Q2xhbXBlZEFycmF5KSkge1xuICAgICAgICB2YXIgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBycl90eXBlOiBuYW1lLFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIE9iamVjdC52YWx1ZXModmFsdWUpXG4gICAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICgvLyBTaGFyZWRBcnJheUJ1ZmZlciBkaXNhYmxlZCBvbiBtb3N0IGJyb3dzZXJzIGR1ZSB0byBzcGVjdHJlLlxuICAgIC8vIE1vcmUgaW5mbzogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU2hhcmVkQXJyYXlCdWZmZXIvU2hhcmVkQXJyYXlCdWZmZXJcbiAgICAvLyB2YWx1ZSBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyIHx8XG4gICAgX2luc3RhbmNlb2YodmFsdWUsIEFycmF5QnVmZmVyKSkge1xuICAgICAgICB2YXIgbmFtZTEgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB2YXIgYmFzZTY0ID0gZW5jb2RlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUxLFxuICAgICAgICAgICAgYmFzZTY0OiBiYXNlNjRcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHZhbHVlLCBEYXRhVmlldykpIHtcbiAgICAgICAgdmFyIG5hbWUyID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUyLFxuICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUFyZyh2YWx1ZS5idWZmZXIsIHdpbiwgY3R4KSxcbiAgICAgICAgICAgICAgICB2YWx1ZS5ieXRlT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHZhbHVlLmJ5dGVMZW5ndGhcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHZhbHVlLCBIVE1MSW1hZ2VFbGVtZW50KSkge1xuICAgICAgICB2YXIgbmFtZTMgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB2YXIgc3JjID0gdmFsdWUuc3JjO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcnJfdHlwZTogbmFtZTMsXG4gICAgICAgICAgICBzcmM6IHNyY1xuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YodmFsdWUsIEhUTUxDYW52YXNFbGVtZW50KSkge1xuICAgICAgICB2YXIgbmFtZTQgPSBcIkhUTUxJbWFnZUVsZW1lbnRcIjtcbiAgICAgICAgdmFyIHNyYzEgPSB2YWx1ZS50b0RhdGFVUkwoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWU0LFxuICAgICAgICAgICAgc3JjOiBzcmMxXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZih2YWx1ZSwgSW1hZ2VEYXRhKSkge1xuICAgICAgICB2YXIgbmFtZTUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcnJfdHlwZTogbmFtZTUsXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplQXJnKHZhbHVlLmRhdGEsIHdpbiwgY3R4KSxcbiAgICAgICAgICAgICAgICB2YWx1ZS53aWR0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZS5oZWlnaHRcbiAgICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGlzSW5zdGFuY2VPZldlYkdMT2JqZWN0KHZhbHVlLCB3aW4pIHx8ICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVfb2YodmFsdWUpKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgbmFtZTYgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB2YXIgaW5kZXgyID0gc2F2ZVdlYkdMVmFyKHZhbHVlLCB3aW4sIGN0eCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBycl90eXBlOiBuYW1lNixcbiAgICAgICAgICAgIGluZGV4OiBpbmRleDJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxudmFyIHNlcmlhbGl6ZUFyZ3MgPSBmdW5jdGlvbihhcmdzLCB3aW4sIGN0eCkge1xuICAgIHJldHVybiBhcmdzLm1hcChmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUFyZyhhcmcsIHdpbiwgY3R4KTtcbiAgICB9KTtcbn07XG52YXIgaXNJbnN0YW5jZU9mV2ViR0xPYmplY3QgPSBmdW5jdGlvbih2YWx1ZSwgd2luKSB7XG4gICAgdmFyIHdlYkdMQ29uc3RydWN0b3JOYW1lcyA9IFtcbiAgICAgICAgXCJXZWJHTEFjdGl2ZUluZm9cIixcbiAgICAgICAgXCJXZWJHTEJ1ZmZlclwiLFxuICAgICAgICBcIldlYkdMRnJhbWVidWZmZXJcIixcbiAgICAgICAgXCJXZWJHTFByb2dyYW1cIixcbiAgICAgICAgXCJXZWJHTFJlbmRlcmJ1ZmZlclwiLFxuICAgICAgICBcIldlYkdMU2hhZGVyXCIsXG4gICAgICAgIFwiV2ViR0xTaGFkZXJQcmVjaXNpb25Gb3JtYXRcIixcbiAgICAgICAgXCJXZWJHTFRleHR1cmVcIixcbiAgICAgICAgXCJXZWJHTFVuaWZvcm1Mb2NhdGlvblwiLFxuICAgICAgICBcIldlYkdMVmVydGV4QXJyYXlPYmplY3RcIixcbiAgICAgICAgLy8gSW4gb2xkIENocm9tZSB2ZXJzaW9ucywgdmFsdWUgd29uJ3QgYmUgYW4gaW5zdGFuY2VvZiBXZWJHTFZlcnRleEFycmF5T2JqZWN0LlxuICAgICAgICBcIldlYkdMVmVydGV4QXJyYXlPYmplY3RPRVNcIlxuICAgIF07XG4gICAgdmFyIHN1cHBvcnRlZFdlYkdMQ29uc3RydWN0b3JOYW1lcyA9IHdlYkdMQ29uc3RydWN0b3JOYW1lcy5maWx0ZXIoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHdpbltuYW1lXSA9PT0gXCJmdW5jdGlvblwiO1xuICAgIH0pO1xuICAgIHJldHVybiBCb29sZWFuKHN1cHBvcnRlZFdlYkdMQ29uc3RydWN0b3JOYW1lcy5maW5kKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9pbnN0YW5jZW9mKHZhbHVlLCB3aW5bbmFtZV0pO1xuICAgIH0pKTtcbn07XG5mdW5jdGlvbiBpbml0Q2FudmFzMkRNdXRhdGlvbk9ic2VydmVyKGNiLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpIHtcbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb3AgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGVbcHJvcF0gIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaCh3aW4uQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZSwgcHJvcCwgZnVuY3Rpb24ob3JpZ2luYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Jsb2NrZWQodGhpcy5jYW52YXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWNvcmRBcmdzID0gc2VyaWFsaXplQXJncyhhcmdzLCB3aW4sIF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYihfdGhpcy5jYW52YXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2FudmFzQ29udGV4dFtcIjJEXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogcmVjb3JkQXJnc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB2YXIgaG9va0hhbmRsZXIgPSBob29rU2V0dGVyKHdpbi5DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQucHJvdG90eXBlLCBwcm9wLCB7XG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodjIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IodGhpcy5jYW52YXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IENhbnZhc0NvbnRleHRbXCIyRFwiXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChob29rSGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBoYW5kbGVycyA9IFtdO1xuICAgIHZhciBwcm9wczJEID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUpO1xuICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHByb3BzMkQpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOylfbG9vcCgpO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZENvbnRleHROYW1lKGNvbnRleHRUeXBlKSB7XG4gICAgcmV0dXJuIGNvbnRleHRUeXBlID09PSBcImV4cGVyaW1lbnRhbC13ZWJnbFwiID8gXCJ3ZWJnbFwiIDogY29udGV4dFR5cGU7XG59XG5mdW5jdGlvbiBpbml0Q2FudmFzQ29udGV4dE9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgc2V0UHJlc2VydmVEcmF3aW5nQnVmZmVyVG9UcnVlKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHJlc3RvcmVIYW5kbGVyID0gcGF0Y2god2luLkhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZSwgXCJnZXRDb250ZXh0XCIsIGZ1bmN0aW9uKG9yaWdpbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oY29udGV4dFR5cGUpIHtcbiAgICAgICAgICAgICAgICBmb3IodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Jsb2NrZWQodGhpcywgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN0eE5hbWUgPSBnZXROb3JtYWxpemVkQ29udGV4dE5hbWUoY29udGV4dFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShcIl9fY29udGV4dFwiIGluIHRoaXMpKSB0aGlzLl9fY29udGV4dCA9IGN0eE5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXRQcmVzZXJ2ZURyYXdpbmdCdWZmZXJUb1RydWUgJiYgW1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3ZWJnbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3ZWJnbDJcIlxuICAgICAgICAgICAgICAgICAgICBdLmluY2x1ZGVzKGN0eE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnc1swXSAmJiBfdHlwZV9vZihhcmdzWzBdKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0QXR0cmlidXRlcyA9IGFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250ZXh0QXR0cmlidXRlcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dEF0dHJpYnV0ZXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3Muc3BsaWNlKDAsIDEsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtdLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRUeXBlXG4gICAgICAgICAgICAgICAgXSwgYXJncykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcImZhaWxlZCB0byBwYXRjaCBIVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUuZ2V0Q29udGV4dFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBwYXRjaEdMUHJvdG90eXBlKHByb3RvdHlwZSwgdHlwZSwgY2IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHdpbikge1xuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvcCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICBpZiAoLy9wcm9wLnN0YXJ0c1dpdGgoJ2dldCcpIHx8ICAvLyBlLmcuIGdldFByb2dyYW1QYXJhbWV0ZXIsIGJ1dCB0b28gcmlza3lcbiAgICAgICAgW1xuICAgICAgICAgICAgXCJpc0NvbnRleHRMb3N0XCIsXG4gICAgICAgICAgICBcImNhbnZhc1wiLFxuICAgICAgICAgICAgXCJkcmF3aW5nQnVmZmVyV2lkdGhcIixcbiAgICAgICAgICAgIFwiZHJhd2luZ0J1ZmZlckhlaWdodFwiXG4gICAgICAgIF0uaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlW3Byb3BdICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3RvcmVIYW5kbGVyID0gcGF0Y2gocHJvdG90eXBlLCBwcm9wLCBmdW5jdGlvbihvcmlnaW5hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5Kyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBzYXZlV2ViR0xWYXIocmVzdWx0Miwgd2luLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwidGFnTmFtZVwiIGluIHRoaXMuY2FudmFzICYmICFpc0Jsb2NrZWQodGhpcy5jYW52YXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVjb3JkQXJncyA9IHNlcmlhbGl6ZUFyZ3MoYXJncywgd2luLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdXRhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IHJlY29yZEFyZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYih0aGlzLmNhbnZhcywgbXV0YXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gocmVzdG9yZUhhbmRsZXIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB2YXIgaG9va0hhbmRsZXIgPSBob29rU2V0dGVyKHByb3RvdHlwZSwgcHJvcCwge1xuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHYyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKHRoaXMuY2FudmFzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdjJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXR0ZXI6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKGhvb2tIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGhhbmRsZXJzID0gW107XG4gICAgdmFyIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvdG90eXBlKTtcbiAgICBmb3IodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVfZm9yX29mX2l0ZXJhdG9yX2hlbHBlcl9sb29zZShwcm9wcyksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KV9sb29wKCk7XG4gICAgcmV0dXJuIGhhbmRsZXJzO1xufVxuZnVuY3Rpb24gaW5pdENhbnZhc1dlYkdMTXV0YXRpb25PYnNlcnZlcihjYiwgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKSB7XG4gICAgdmFyIF9oYW5kbGVycztcbiAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICAoX2hhbmRsZXJzID0gaGFuZGxlcnMpLnB1c2guYXBwbHkoX2hhbmRsZXJzLCBbXS5jb25jYXQocGF0Y2hHTFByb3RvdHlwZSh3aW4uV2ViR0xSZW5kZXJpbmdDb250ZXh0LnByb3RvdHlwZSwgQ2FudmFzQ29udGV4dC5XZWJHTCwgY2IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHdpbikpKTtcbiAgICBpZiAodHlwZW9mIHdpbi5XZWJHTDJSZW5kZXJpbmdDb250ZXh0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhciBfaGFuZGxlcnMxO1xuICAgICAgICAoX2hhbmRsZXJzMSA9IGhhbmRsZXJzKS5wdXNoLmFwcGx5KF9oYW5kbGVyczEsIFtdLmNvbmNhdChwYXRjaEdMUHJvdG90eXBlKHdpbi5XZWJHTDJSZW5kZXJpbmdDb250ZXh0LnByb3RvdHlwZSwgQ2FudmFzQ29udGV4dC5XZWJHTDIsIGNiLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB3aW4pKSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihoKSB7XG4gICAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxudmFyIGVuY29kZWRKcyA9IFwiS0daMWJtTjBhVzl1S0NrZ2V3b2dJQ0oxYzJVZ2MzUnlhV04wSWpzS0lDQjJZWElnWTJoaGNuTWdQU0FpUVVKRFJFVkdSMGhKU2t0TVRVNVBVRkZTVTFSVlZsZFlXVnBoWW1Oa1pXWm5hR2xxYTJ4dGJtOXdjWEp6ZEhWMmQzaDVlakF4TWpNME5UWTNPRGtyTHlJN0NpQWdkbUZ5SUd4dmIydDFjQ0E5SUhSNWNHVnZaaUJWYVc1ME9FRnljbUY1SUQwOVBTQWlkVzVrWldacGJtVmtJaUEvSUZ0ZElEb2dibVYzSUZWcGJuUTRRWEp5WVhrb01qVTJLVHNLSUNCbWIzSWdLSFpoY2lCcElEMGdNRHNnYVNBOElHTm9ZWEp6TG14bGJtZDBhRHNnYVNzcktTQjdDaUFnSUNCc2IyOXJkWEJiWTJoaGNuTXVZMmhoY2tOdlpHVkJkQ2hwS1YwZ1BTQnBPd29nSUgwS0lDQjJZWElnWlc1amIyUmxJRDBnWm5WdVkzUnBiMjRvWVhKeVlYbGlkV1ptWlhJcElIc0tJQ0FnSUhaaGNpQmllWFJsY3lBOUlHNWxkeUJWYVc1ME9FRnljbUY1S0dGeWNtRjVZblZtWm1WeUtTd2dhVElzSUd4bGJpQTlJR0o1ZEdWekxteGxibWQwYUN3Z1ltRnpaVFkwSUQwZ0lpSTdDaUFnSUNCbWIzSWdLR2t5SUQwZ01Ec2dhVElnUENCc1pXNDdJR2t5SUNzOUlETXBJSHNLSUNBZ0lDQWdZbUZ6WlRZMElDczlJR05vWVhKelcySjVkR1Z6VzJreVhTQStQaUF5WFRzS0lDQWdJQ0FnWW1GelpUWTBJQ3M5SUdOb1lYSnpXeWhpZVhSbGMxdHBNbDBnSmlBektTQThQQ0EwSUh3Z1lubDBaWE5iYVRJZ0t5QXhYU0ErUGlBMFhUc0tJQ0FnSUNBZ1ltRnpaVFkwSUNzOUlHTm9ZWEp6V3loaWVYUmxjMXRwTWlBcklERmRJQ1lnTVRVcElEdzhJRElnZkNCaWVYUmxjMXRwTWlBcklESmRJRDQrSURaZE93b2dJQ0FnSUNCaVlYTmxOalFnS3owZ1kyaGhjbk5iWW5sMFpYTmJhVElnS3lBeVhTQW1JRFl6WFRzS0lDQWdJSDBLSUNBZ0lHbG1JQ2hzWlc0Z0pTQXpJRDA5UFNBeUtTQjdDaUFnSUNBZ0lHSmhjMlUyTkNBOUlHSmhjMlUyTkM1emRXSnpkSEpwYm1jb01Dd2dZbUZ6WlRZMExteGxibWQwYUNBdElERXBJQ3NnSWowaU93b2dJQ0FnZlNCbGJITmxJR2xtSUNoc1pXNGdKU0F6SUQwOVBTQXhLU0I3Q2lBZ0lDQWdJR0poYzJVMk5DQTlJR0poYzJVMk5DNXpkV0p6ZEhKcGJtY29NQ3dnWW1GelpUWTBMbXhsYm1kMGFDQXRJRElwSUNzZ0lqMDlJanNLSUNBZ0lIMEtJQ0FnSUhKbGRIVnliaUJpWVhObE5qUTdDaUFnZlRzS0lDQmpiMjV6ZENCc1lYTjBRbXh2WWsxaGNDQTlJQzhxSUVCZlgxQlZVa1ZmWHlBcUx5QnVaWGNnVFdGd0tDazdDaUFnWTI5dWMzUWdkSEpoYm5Od1lYSmxiblJDYkc5aVRXRndJRDBnTHlvZ1FGOWZVRlZTUlY5ZklDb3ZJRzVsZHlCTllYQW9LVHNLSUNCaGMzbHVZeUJtZFc1amRHbHZiaUJuWlhSVWNtRnVjM0JoY21WdWRFSnNiMkpHYjNJb2QybGtkR2dzSUdobGFXZG9kQ3dnWkdGMFlWVlNURTl3ZEdsdmJuTXBJSHNLSUNBZ0lHTnZibk4wSUdsa0lEMGdZQ1I3ZDJsa2RHaDlMU1I3YUdWcFoyaDBmV0E3Q2lBZ0lDQnBaaUFvSWs5bVpuTmpjbVZsYmtOaGJuWmhjeUlnYVc0Z1oyeHZZbUZzVkdocGN5a2dld29nSUNBZ0lDQnBaaUFvZEhKaGJuTndZWEpsYm5SQ2JHOWlUV0Z3TG1oaGN5aHBaQ2twSUhKbGRIVnliaUIwY21GdWMzQmhjbVZ1ZEVKc2IySk5ZWEF1WjJWMEtHbGtLVHNLSUNBZ0lDQWdZMjl1YzNRZ2IyWm1jMk55WldWdUlEMGdibVYzSUU5bVpuTmpjbVZsYmtOaGJuWmhjeWgzYVdSMGFDd2dhR1ZwWjJoMEtUc0tJQ0FnSUNBZ2IyWm1jMk55WldWdUxtZGxkRU52Ym5SbGVIUW9JakprSWlrN0NpQWdJQ0FnSUdOdmJuTjBJR0pzYjJJZ1BTQmhkMkZwZENCdlptWnpZM0psWlc0dVkyOXVkbVZ5ZEZSdlFteHZZaWhrWVhSaFZWSk1UM0IwYVc5dWN5azdDaUFnSUNBZ0lHTnZibk4wSUdGeWNtRjVRblZtWm1WeUlEMGdZWGRoYVhRZ1lteHZZaTVoY25KaGVVSjFabVpsY2lncE93b2dJQ0FnSUNCamIyNXpkQ0JpWVhObE5qUWdQU0JsYm1OdlpHVW9ZWEp5WVhsQ2RXWm1aWElwT3dvZ0lDQWdJQ0IwY21GdWMzQmhjbVZ1ZEVKc2IySk5ZWEF1YzJWMEtHbGtMQ0JpWVhObE5qUXBPd29nSUNBZ0lDQnlaWFIxY200Z1ltRnpaVFkwT3dvZ0lDQWdmU0JsYkhObElIc0tJQ0FnSUNBZ2NtVjBkWEp1SUNJaU93b2dJQ0FnZlFvZ0lIMEtJQ0JqYjI1emRDQjNiM0pyWlhJZ1BTQnpaV3htT3dvZ0lIZHZjbXRsY2k1dmJtMWxjM05oWjJVZ1BTQmhjM2x1WXlCbWRXNWpkR2x2YmlobEtTQjdDaUFnSUNCcFppQW9JazltWm5OamNtVmxia05oYm5aaGN5SWdhVzRnWjJ4dlltRnNWR2hwY3lrZ2V3b2dJQ0FnSUNCamIyNXpkQ0I3SUdsa0xDQmlhWFJ0WVhBc0lIZHBaSFJvTENCb1pXbG5hSFFzSUdSaGRHRlZVa3hQY0hScGIyNXpJSDBnUFNCbExtUmhkR0U3Q2lBZ0lDQWdJR052Ym5OMElIUnlZVzV6Y0dGeVpXNTBRbUZ6WlRZMElEMGdaMlYwVkhKaGJuTndZWEpsYm5SQ2JHOWlSbTl5S0FvZ0lDQWdJQ0FnSUhkcFpIUm9MQW9nSUNBZ0lDQWdJR2hsYVdkb2RDd0tJQ0FnSUNBZ0lDQmtZWFJoVlZKTVQzQjBhVzl1Y3dvZ0lDQWdJQ0FwT3dvZ0lDQWdJQ0JqYjI1emRDQnZabVp6WTNKbFpXNGdQU0J1WlhjZ1QyWm1jMk55WldWdVEyRnVkbUZ6S0hkcFpIUm9MQ0JvWldsbmFIUXBPd29nSUNBZ0lDQmpiMjV6ZENCamRIZ2dQU0J2Wm1aelkzSmxaVzR1WjJWMFEyOXVkR1Y0ZENnaU1tUWlLVHNLSUNBZ0lDQWdZM1I0TG1SeVlYZEpiV0ZuWlNoaWFYUnRZWEFzSURBc0lEQXBPd29nSUNBZ0lDQmlhWFJ0WVhBdVkyeHZjMlVvS1RzS0lDQWdJQ0FnWTI5dWMzUWdZbXh2WWlBOUlHRjNZV2wwSUc5bVpuTmpjbVZsYmk1amIyNTJaWEowVkc5Q2JHOWlLR1JoZEdGVlVreFBjSFJwYjI1ektUc0tJQ0FnSUNBZ1kyOXVjM1FnZEhsd1pTQTlJR0pzYjJJdWRIbHdaVHNLSUNBZ0lDQWdZMjl1YzNRZ1lYSnlZWGxDZFdabVpYSWdQU0JoZDJGcGRDQmliRzlpTG1GeWNtRjVRblZtWm1WeUtDazdDaUFnSUNBZ0lHTnZibk4wSUdKaGMyVTJOQ0E5SUdWdVkyOWtaU2hoY25KaGVVSjFabVpsY2lrN0NpQWdJQ0FnSUdsbUlDZ2hiR0Z6ZEVKc2IySk5ZWEF1YUdGektHbGtLU0FtSmlCaGQyRnBkQ0IwY21GdWMzQmhjbVZ1ZEVKaGMyVTJOQ0E5UFQwZ1ltRnpaVFkwS1NCN0NpQWdJQ0FnSUNBZ2JHRnpkRUpzYjJKTllYQXVjMlYwS0dsa0xDQmlZWE5sTmpRcE93b2dJQ0FnSUNBZ0lISmxkSFZ5YmlCM2IzSnJaWEl1Y0c5emRFMWxjM05oWjJVb2V5QnBaQ0I5S1RzS0lDQWdJQ0FnZlFvZ0lDQWdJQ0JwWmlBb2JHRnpkRUpzYjJKTllYQXVaMlYwS0dsa0tTQTlQVDBnWW1GelpUWTBLU0J5WlhSMWNtNGdkMjl5YTJWeUxuQnZjM1JOWlhOellXZGxLSHNnYVdRZ2ZTazdDaUFnSUNBZ0lIZHZjbXRsY2k1d2IzTjBUV1Z6YzJGblpTaDdDaUFnSUNBZ0lDQWdhV1FzQ2lBZ0lDQWdJQ0FnZEhsd1pTd0tJQ0FnSUNBZ0lDQmlZWE5sTmpRc0NpQWdJQ0FnSUNBZ2QybGtkR2dzQ2lBZ0lDQWdJQ0FnYUdWcFoyaDBDaUFnSUNBZ0lIMHBPd29nSUNBZ0lDQnNZWE4wUW14dllrMWhjQzV6WlhRb2FXUXNJR0poYzJVMk5DazdDaUFnSUNCOUlHVnNjMlVnZXdvZ0lDQWdJQ0J5WlhSMWNtNGdkMjl5YTJWeUxuQnZjM1JOWlhOellXZGxLSHNnYVdRNklHVXVaR0YwWVM1cFpDQjlLVHNLSUNBZ0lIMEtJQ0I5T3dwOUtTZ3BPd292THlNZ2MyOTFjbU5sVFdGd2NHbHVaMVZTVEQxcGJXRm5aUzFpYVhSdFlYQXRaR0YwWVMxMWNtd3RkMjl5YTJWeUxVbEtjRU0zWjE5aUxtcHpMbTFoY0FvPVwiO1xudmFyIGRlY29kZUJhc2U2NCA9IGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYXRvYihiYXNlNjQpLCBmdW5jdGlvbihjMikge1xuICAgICAgICByZXR1cm4gYzIuY2hhckNvZGVBdCgwKTtcbiAgICB9KTtcbn07XG52YXIgYmxvYiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LkJsb2IgJiYgbmV3IEJsb2IoW1xuICAgIGRlY29kZUJhc2U2NChlbmNvZGVkSnMpXG5dLCB7XG4gICAgdHlwZTogXCJ0ZXh0L2phdmFzY3JpcHQ7Y2hhcnNldD11dGYtOFwiXG59KTtcbmZ1bmN0aW9uIFdvcmtlcldyYXBwZXIob3B0aW9ucykge1xuICAgIHZhciBvYmpVUkw7XG4gICAgdHJ5IHtcbiAgICAgICAgb2JqVVJMID0gYmxvYiAmJiAod2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMKS5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIGlmICghb2JqVVJMKSB0aHJvdyBcIlwiO1xuICAgICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcihvYmpVUkwsIHtcbiAgICAgICAgICAgIG5hbWU6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMubmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwpLnJldm9rZU9iamVjdFVSTChvYmpVUkwpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICB9IGNhdGNoIChlMikge1xuICAgICAgICByZXR1cm4gbmV3IFdvcmtlcihcImRhdGE6dGV4dC9qYXZhc2NyaXB0O2Jhc2U2NCxcIiArIGVuY29kZWRKcywge1xuICAgICAgICAgICAgbmFtZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5uYW1lXG4gICAgICAgIH0pO1xuICAgIH0gZmluYWxseXtcbiAgICAgICAgb2JqVVJMICYmICh3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkwpLnJldm9rZU9iamVjdFVSTChvYmpVUkwpO1xuICAgIH1cbn1cbnZhciBDYW52YXNNYW5hZ2VyID0gLyojX19QVVJFX18qLyBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBDYW52YXNNYW5hZ2VyKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInBlbmRpbmdDYW52YXNNdXRhdGlvbnNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyYWZTdGFtcHNcIiwge1xuICAgICAgICAgICAgbGF0ZXN0SWQ6IDAsXG4gICAgICAgICAgICBpbnZva2VJZDogbnVsbFxuICAgICAgICB9KTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm1pcnJvclwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm11dGF0aW9uQ2JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJyZXNldE9ic2VydmVyc1wiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImZyb3plblwiLCBmYWxzZSk7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsb2NrZWRcIiwgZmFsc2UpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwicHJvY2Vzc011dGF0aW9uXCIsIGZ1bmN0aW9uKHRhcmdldCwgbXV0YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBuZXdGcmFtZSA9IF90aGlzLnJhZlN0YW1wcy5pbnZva2VJZCAmJiBfdGhpcy5yYWZTdGFtcHMubGF0ZXN0SWQgIT09IF90aGlzLnJhZlN0YW1wcy5pbnZva2VJZDtcbiAgICAgICAgICAgIGlmIChuZXdGcmFtZSB8fCAhX3RoaXMucmFmU3RhbXBzLmludm9rZUlkKSBfdGhpcy5yYWZTdGFtcHMuaW52b2tlSWQgPSBfdGhpcy5yYWZTdGFtcHMubGF0ZXN0SWQ7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuaGFzKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLnNldCh0YXJnZXQsIFtdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZ2V0KHRhcmdldCkucHVzaChtdXRhdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgX29wdGlvbnNfc2FtcGxpbmcgPSBvcHRpb25zLnNhbXBsaW5nLCBzYW1wbGluZyA9IF9vcHRpb25zX3NhbXBsaW5nID09PSB2b2lkIDAgPyBcImFsbFwiIDogX29wdGlvbnNfc2FtcGxpbmcsIHdpbiA9IG9wdGlvbnMud2luLCBibG9ja0NsYXNzID0gb3B0aW9ucy5ibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yID0gb3B0aW9ucy5ibG9ja1NlbGVjdG9yLCByZWNvcmRDYW52YXMgPSBvcHRpb25zLnJlY29yZENhbnZhcywgZGF0YVVSTE9wdGlvbnMgPSBvcHRpb25zLmRhdGFVUkxPcHRpb25zO1xuICAgICAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XG4gICAgICAgIHRoaXMubWlycm9yID0gb3B0aW9ucy5taXJyb3I7XG4gICAgICAgIGlmIChyZWNvcmRDYW52YXMgJiYgc2FtcGxpbmcgPT09IFwiYWxsXCIpIHRoaXMuaW5pdENhbnZhc011dGF0aW9uT2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKTtcbiAgICAgICAgaWYgKHJlY29yZENhbnZhcyAmJiB0eXBlb2Ygc2FtcGxpbmcgPT09IFwibnVtYmVyXCIpIHRoaXMuaW5pdENhbnZhc0ZQU09ic2VydmVyKHNhbXBsaW5nLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHtcbiAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zOiBkYXRhVVJMT3B0aW9uc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIF9wcm90byA9IENhbnZhc01hbmFnZXIucHJvdG90eXBlO1xuICAgIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5yZXNldE9ic2VydmVycyAmJiB0aGlzLnJlc2V0T2JzZXJ2ZXJzKCk7XG4gICAgfTtcbiAgICBfcHJvdG8uZnJlZXplID0gZnVuY3Rpb24gZnJlZXplKCkge1xuICAgICAgICB0aGlzLmZyb3plbiA9IHRydWU7XG4gICAgfTtcbiAgICBfcHJvdG8udW5mcmVlemUgPSBmdW5jdGlvbiB1bmZyZWV6ZSgpIHtcbiAgICAgICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5sb2NrID0gZnVuY3Rpb24gbG9jaygpIHtcbiAgICAgICAgdGhpcy5sb2NrZWQgPSB0cnVlO1xuICAgIH07XG4gICAgX3Byb3RvLnVubG9jayA9IGZ1bmN0aW9uIHVubG9jaygpIHtcbiAgICAgICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIF9wcm90by5pbml0Q2FudmFzRlBTT2JzZXJ2ZXIgPSBmdW5jdGlvbiBpbml0Q2FudmFzRlBTT2JzZXJ2ZXIoZnBzLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNhbnZhc0NvbnRleHRSZXNldCA9IGluaXRDYW52YXNDb250ZXh0T2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKTtcbiAgICAgICAgdmFyIHNuYXBzaG90SW5Qcm9ncmVzc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyV3JhcHBlcigpO1xuICAgICAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IGUyLmRhdGEuaWQ7XG4gICAgICAgICAgICBzbmFwc2hvdEluUHJvZ3Jlc3NNYXAuc2V0KGlkLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoIShcImJhc2U2NFwiIGluIGUyLmRhdGEpKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgX2UyX2RhdGEgPSBlMi5kYXRhLCBiYXNlNjQgPSBfZTJfZGF0YS5iYXNlNjQsIHR5cGUgPSBfZTJfZGF0YS50eXBlLCB3aWR0aCA9IF9lMl9kYXRhLndpZHRoLCBoZWlnaHQgPSBfZTJfZGF0YS5oZWlnaHQ7XG4gICAgICAgICAgICBfdGhpcy5tdXRhdGlvbkNiKHtcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgdHlwZTogQ2FudmFzQ29udGV4dFtcIjJEXCJdLFxuICAgICAgICAgICAgICAgIGNvbW1hbmRzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBcImNsZWFyUmVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lwZSBjYW52YXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBcImRyYXdJbWFnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZHJhd3MgKHNlbWktdHJhbnNwYXJlbnQpIGltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBycl90eXBlOiBcIkltYWdlQml0bWFwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBycl90eXBlOiBcIkJsb2JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJyX3R5cGU6IFwiQXJyYXlCdWZmZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U2NDogYmFzZTY0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRpbWVCZXR3ZWVuU25hcHNob3RzID0gMWUzIC8gZnBzO1xuICAgICAgICB2YXIgbGFzdFNuYXBzaG90VGltZSA9IDA7XG4gICAgICAgIHZhciByYWZJZDtcbiAgICAgICAgdmFyIGdldENhbnZhcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoZWRDYW52YXMgPSBbXTtcbiAgICAgICAgICAgIHdpbi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiY2FudmFzXCIpLmZvckVhY2goZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0Jsb2NrZWQoY2FudmFzLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkQ2FudmFzLnB1c2goY2FudmFzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVkQ2FudmFzO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGFrZUNhbnZhc1NuYXBzaG90cyA9IGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgaWYgKGxhc3RTbmFwc2hvdFRpbWUgJiYgdGltZXN0YW1wIC0gbGFzdFNuYXBzaG90VGltZSA8IHRpbWVCZXR3ZWVuU25hcHNob3RzKSB7XG4gICAgICAgICAgICAgICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGFrZUNhbnZhc1NuYXBzaG90cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdFNuYXBzaG90VGltZSA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgIHZhciBfdGhpczEgPSBfdGhpcztcbiAgICAgICAgICAgIGdldENhbnZhcygpLmZvckVhY2goLyojX19QVVJFX18qLyBfYXN5bmNfdG9fZ2VuZXJhdG9yKGZ1bmN0aW9uKGNhbnZhcykge1xuICAgICAgICAgICAgICAgIHZhciBfYTIsIGlkLCBjb250ZXh0LCBiaXRtYXA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90c19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24oX3N0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaChfc3RhdGUubGFiZWwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gX3RoaXMxLm1pcnJvci5nZXRJZChjYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzbmFwc2hvdEluUHJvZ3Jlc3NNYXAuZ2V0KGlkKSkgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbnZhcy53aWR0aCA9PT0gMCB8fCBjYW52YXMuaGVpZ2h0ID09PSAwKSByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbmFwc2hvdEluUHJvZ3Jlc3NNYXAuc2V0KGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndlYmdsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwid2ViZ2wyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLmluY2x1ZGVzKGNhbnZhcy5fX2NvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChjYW52YXMuX19jb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCgoX2EyID0gY29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogY29udGV4dC5nZXRDb250ZXh0QXR0cmlidXRlcygpKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLnByZXNlcnZlRHJhd2luZ0J1ZmZlcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmNsZWFyKGNvbnRleHQuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlSW1hZ2VCaXRtYXAoY2FudmFzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYml0bWFwID0gX3N0YXRlLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpdG1hcDogYml0bWFwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zOiBvcHRpb25zLmRhdGFVUkxPcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaXRtYXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGFrZUNhbnZhc1NuYXBzaG90cyk7XG4gICAgICAgIH07XG4gICAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRha2VDYW52YXNTbmFwc2hvdHMpO1xuICAgICAgICB0aGlzLnJlc2V0T2JzZXJ2ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjYW52YXNDb250ZXh0UmVzZXQoKTtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5pbml0Q2FudmFzTXV0YXRpb25PYnNlcnZlciA9IGZ1bmN0aW9uIGluaXRDYW52YXNNdXRhdGlvbk9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcikge1xuICAgICAgICB0aGlzLnN0YXJ0UkFGVGltZXN0YW1waW5nKCk7XG4gICAgICAgIHRoaXMuc3RhcnRQZW5kaW5nQ2FudmFzTXV0YXRpb25GbHVzaGVyKCk7XG4gICAgICAgIHZhciBjYW52YXNDb250ZXh0UmVzZXQgPSBpbml0Q2FudmFzQ29udGV4dE9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgZmFsc2UpO1xuICAgICAgICB2YXIgY2FudmFzMkRSZXNldCA9IGluaXRDYW52YXMyRE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5wcm9jZXNzTXV0YXRpb24uYmluZCh0aGlzKSwgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKTtcbiAgICAgICAgdmFyIGNhbnZhc1dlYkdMMWFuZDJSZXNldCA9IGluaXRDYW52YXNXZWJHTE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5wcm9jZXNzTXV0YXRpb24uYmluZCh0aGlzKSwgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yKTtcbiAgICAgICAgdGhpcy5yZXNldE9ic2VydmVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2FudmFzQ29udGV4dFJlc2V0KCk7XG4gICAgICAgICAgICBjYW52YXMyRFJlc2V0KCk7XG4gICAgICAgICAgICBjYW52YXNXZWJHTDFhbmQyUmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIF9wcm90by5zdGFydFBlbmRpbmdDYW52YXNNdXRhdGlvbkZsdXNoZXIgPSBmdW5jdGlvbiBzdGFydFBlbmRpbmdDYW52YXNNdXRhdGlvbkZsdXNoZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5mbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbnMoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBfcHJvdG8uc3RhcnRSQUZUaW1lc3RhbXBpbmcgPSBmdW5jdGlvbiBzdGFydFJBRlRpbWVzdGFtcGluZygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNldExhdGVzdFJBRlRpbWVzdGFtcCA9IGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgX3RoaXMucmFmU3RhbXBzLmxhdGVzdElkID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNldExhdGVzdFJBRlRpbWVzdGFtcCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzZXRMYXRlc3RSQUZUaW1lc3RhbXApO1xuICAgIH07XG4gICAgX3Byb3RvLmZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9ucyA9IGZ1bmN0aW9uIGZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9ucygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmZvckVhY2goZnVuY3Rpb24oX3ZhbHVlcywgY2FudmFzKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBfdGhpcy5taXJyb3IuZ2V0SWQoY2FudmFzKTtcbiAgICAgICAgICAgIF90aGlzLmZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9uRm9yKGNhbnZhcywgaWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9ucygpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIF9wcm90by5mbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbkZvciA9IGZ1bmN0aW9uIGZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9uRm9yKGNhbnZhcywgaWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZnJvemVuIHx8IHRoaXMubG9ja2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlc1dpdGhUeXBlID0gdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmdldChjYW52YXMpO1xuICAgICAgICBpZiAoIXZhbHVlc1dpdGhUeXBlIHx8IGlkID09PSAtMSkgcmV0dXJuO1xuICAgICAgICB2YXIgdmFsdWVzID0gdmFsdWVzV2l0aFR5cGUubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZS50eXBlOyB2YXIgcmVzdCA9IF9vYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzX2xvb3NlKHZhbHVlLCBbXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCJcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdHlwZSA9IHZhbHVlc1dpdGhUeXBlWzBdLnR5cGU7XG4gICAgICAgIHRoaXMubXV0YXRpb25DYih7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgY29tbWFuZHM6IHZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmRlbGV0ZShjYW52YXMpO1xuICAgIH07XG4gICAgcmV0dXJuIENhbnZhc01hbmFnZXI7XG59KCk7XG52YXIgU3R5bGVzaGVldE1hbmFnZXIgPSAvKiNfX1BVUkVfXyovIGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFN0eWxlc2hlZXRNYW5hZ2VyKG9wdGlvbnMpIHtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInRyYWNrZWRMaW5rRWxlbWVudHNcIiwgLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCkpO1xuICAgICAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwibXV0YXRpb25DYlwiKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFkb3B0ZWRTdHlsZVNoZWV0Q2JcIik7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJzdHlsZU1pcnJvclwiLCBuZXcgU3R5bGVTaGVldE1pcnJvcigpKTtcbiAgICAgICAgdGhpcy5tdXRhdGlvbkNiID0gb3B0aW9ucy5tdXRhdGlvbkNiO1xuICAgICAgICB0aGlzLmFkb3B0ZWRTdHlsZVNoZWV0Q2IgPSBvcHRpb25zLmFkb3B0ZWRTdHlsZVNoZWV0Q2I7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBTdHlsZXNoZWV0TWFuYWdlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmF0dGFjaExpbmtFbGVtZW50ID0gZnVuY3Rpb24gYXR0YWNoTGlua0VsZW1lbnQobGlua0VsLCBjaGlsZFNuKSB7XG4gICAgICAgIGlmIChcIl9jc3NUZXh0XCIgaW4gY2hpbGRTbi5hdHRyaWJ1dGVzKSB0aGlzLm11dGF0aW9uQ2Ioe1xuICAgICAgICAgICAgYWRkczogW10sXG4gICAgICAgICAgICByZW1vdmVzOiBbXSxcbiAgICAgICAgICAgIHRleHRzOiBbXSxcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBjaGlsZFNuLmlkLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBjaGlsZFNuLmF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYWNrTGlua0VsZW1lbnQobGlua0VsKTtcbiAgICB9O1xuICAgIF9wcm90by50cmFja0xpbmtFbGVtZW50ID0gZnVuY3Rpb24gdHJhY2tMaW5rRWxlbWVudChsaW5rRWwpIHtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tlZExpbmtFbGVtZW50cy5oYXMobGlua0VsKSkgcmV0dXJuO1xuICAgICAgICB0aGlzLnRyYWNrZWRMaW5rRWxlbWVudHMuYWRkKGxpbmtFbCk7XG4gICAgICAgIHRoaXMudHJhY2tTdHlsZXNoZWV0SW5MaW5rRWxlbWVudChsaW5rRWwpO1xuICAgIH07XG4gICAgX3Byb3RvLmFkb3B0U3R5bGVTaGVldHMgPSBmdW5jdGlvbiBhZG9wdFN0eWxlU2hlZXRzKHNoZWV0cywgaG9zdElkKSB7XG4gICAgICAgIHZhciBfdGhpcywgX2xvb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzaGVldCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHN0eWxlSWQgPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnN0eWxlTWlycm9yLmhhcyhzaGVldCkpIHtcbiAgICAgICAgICAgICAgICBzdHlsZUlkID0gX3RoaXMuc3R5bGVNaXJyb3IuYWRkKHNoZWV0KTtcbiAgICAgICAgICAgICAgICBzdHlsZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlSWQ6IHN0eWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzOiBBcnJheS5mcm9tKHNoZWV0LnJ1bGVzIHx8IENTU1J1bGUsIGZ1bmN0aW9uKHIyLCBpbmRleDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogc3RyaW5naWZ5UnVsZShyMiwgc2hlZXQuaHJlZiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4MlxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBzdHlsZUlkID0gX3RoaXMuc3R5bGVNaXJyb3IuZ2V0SWQoc2hlZXQpO1xuICAgICAgICAgICAgYWRvcHRlZFN0eWxlU2hlZXREYXRhLnN0eWxlSWRzLnB1c2goc3R5bGVJZCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzaGVldHMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIHZhciBhZG9wdGVkU3R5bGVTaGVldERhdGEgPSB7XG4gICAgICAgICAgICBpZDogaG9zdElkLFxuICAgICAgICAgICAgc3R5bGVJZHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdHlsZXMgPSBbXTtcbiAgICAgICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2Uoc2hlZXRzKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspX3RoaXMgPSB0aGlzLCBfbG9vcCgpO1xuICAgICAgICBpZiAoc3R5bGVzLmxlbmd0aCA+IDApIGFkb3B0ZWRTdHlsZVNoZWV0RGF0YS5zdHlsZXMgPSBzdHlsZXM7XG4gICAgICAgIHRoaXMuYWRvcHRlZFN0eWxlU2hlZXRDYihhZG9wdGVkU3R5bGVTaGVldERhdGEpO1xuICAgIH07XG4gICAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuc3R5bGVNaXJyb3IucmVzZXQoKTtcbiAgICAgICAgdGhpcy50cmFja2VkTGlua0VsZW1lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgfTtcbiAgICAvLyBUT0RPOiB0YWtlIHNuYXBzaG90IG9uIHN0eWxlc2hlZXQgcmVsb2FkIGJ5IGFwcGx5aW5nIGV2ZW50IGxpc3RlbmVyXG4gICAgX3Byb3RvLnRyYWNrU3R5bGVzaGVldEluTGlua0VsZW1lbnQgPSBmdW5jdGlvbiB0cmFja1N0eWxlc2hlZXRJbkxpbmtFbGVtZW50KF9saW5rRWwpIHt9O1xuICAgIHJldHVybiBTdHlsZXNoZWV0TWFuYWdlcjtcbn0oKTtcbnZhciBQcm9jZXNzZWROb2RlTWFuYWdlciA9IC8qI19fUFVSRV9fKi8gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gUHJvY2Vzc2VkTm9kZU1hbmFnZXIoKSB7XG4gICAgICAgIF9fcHVibGljRmllbGQodGhpcywgXCJub2RlTWFwXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpKTtcbiAgICAgICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImFjdGl2ZVwiLCBmYWxzZSk7XG4gICAgfVxuICAgIHZhciBfcHJvdG8gPSBQcm9jZXNzZWROb2RlTWFuYWdlci5wcm90b3R5cGU7XG4gICAgX3Byb3RvLmluT3RoZXJCdWZmZXIgPSBmdW5jdGlvbiBpbk90aGVyQnVmZmVyKG5vZGUyLCB0aGlzQnVmZmVyKSB7XG4gICAgICAgIHZhciBidWZmZXJzID0gdGhpcy5ub2RlTWFwLmdldChub2RlMik7XG4gICAgICAgIHJldHVybiBidWZmZXJzICYmIEFycmF5LmZyb20oYnVmZmVycykuc29tZShmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXIgIT09IHRoaXNCdWZmZXI7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChub2RlMiwgYnVmZmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5ub2RlTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVNYXAuc2V0KG5vZGUyLCAodGhpcy5ub2RlTWFwLmdldChub2RlMikgfHwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkuYWRkKGJ1ZmZlcikpO1xuICAgIH07XG4gICAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge307XG4gICAgcmV0dXJuIFByb2Nlc3NlZE5vZGVNYW5hZ2VyO1xufSgpO1xudmFyIHdyYXBwZWRFbWl0O1xudmFyIHRha2VGdWxsU25hcHNob3QkMTtcbnZhciBjYW52YXNNYW5hZ2VyO1xudmFyIHJlY29yZGluZyA9IGZhbHNlO1xudHJ5IHtcbiAgICBpZiAoQXJyYXkuZnJvbShbXG4gICAgICAgIDFcbiAgICBdLCBmdW5jdGlvbih4Mikge1xuICAgICAgICByZXR1cm4geDIgKiAyO1xuICAgIH0pWzBdICE9PSAyKSB7XG4gICAgICAgIHZhciBjbGVhbkZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjbGVhbkZyYW1lKTtcbiAgICAgICAgQXJyYXkuZnJvbSA9ICgoX2EgPSBjbGVhbkZyYW1lLmNvbnRlbnRXaW5kb3cpID09IG51bGwgPyB2b2lkIDAgOiBfYS5BcnJheS5mcm9tKSB8fCBBcnJheS5mcm9tO1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNsZWFuRnJhbWUpO1xuICAgIH1cbn0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZGVidWcoXCJVbmFibGUgdG8gb3ZlcnJpZGUgQXJyYXkuZnJvbVwiLCBlcnIpO1xufVxudmFyIG1pcnJvciA9IGNyZWF0ZU1pcnJvciQyKCk7XG5mdW5jdGlvbiByZWNvcmQob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgZW1pdCA9IG9wdGlvbnMuZW1pdCwgY2hlY2tvdXRFdmVyeU5tcyA9IG9wdGlvbnMuY2hlY2tvdXRFdmVyeU5tcywgY2hlY2tvdXRFdmVyeU50aCA9IG9wdGlvbnMuY2hlY2tvdXRFdmVyeU50aCwgX29wdGlvbnNfYmxvY2tDbGFzcyA9IG9wdGlvbnMuYmxvY2tDbGFzcywgYmxvY2tDbGFzcyA9IF9vcHRpb25zX2Jsb2NrQ2xhc3MgPT09IHZvaWQgMCA/IFwicnItYmxvY2tcIiA6IF9vcHRpb25zX2Jsb2NrQ2xhc3MsIF9vcHRpb25zX2Jsb2NrU2VsZWN0b3IgPSBvcHRpb25zLmJsb2NrU2VsZWN0b3IsIGJsb2NrU2VsZWN0b3IgPSBfb3B0aW9uc19ibG9ja1NlbGVjdG9yID09PSB2b2lkIDAgPyBudWxsIDogX29wdGlvbnNfYmxvY2tTZWxlY3RvciwgX29wdGlvbnNfaWdub3JlQ2xhc3MgPSBvcHRpb25zLmlnbm9yZUNsYXNzLCBpZ25vcmVDbGFzcyA9IF9vcHRpb25zX2lnbm9yZUNsYXNzID09PSB2b2lkIDAgPyBcInJyLWlnbm9yZVwiIDogX29wdGlvbnNfaWdub3JlQ2xhc3MsIF9vcHRpb25zX2lnbm9yZVNlbGVjdG9yID0gb3B0aW9ucy5pZ25vcmVTZWxlY3RvciwgaWdub3JlU2VsZWN0b3IgPSBfb3B0aW9uc19pZ25vcmVTZWxlY3RvciA9PT0gdm9pZCAwID8gbnVsbCA6IF9vcHRpb25zX2lnbm9yZVNlbGVjdG9yLCBfb3B0aW9uc19tYXNrVGV4dENsYXNzID0gb3B0aW9ucy5tYXNrVGV4dENsYXNzLCBtYXNrVGV4dENsYXNzID0gX29wdGlvbnNfbWFza1RleHRDbGFzcyA9PT0gdm9pZCAwID8gXCJyci1tYXNrXCIgOiBfb3B0aW9uc19tYXNrVGV4dENsYXNzLCBfb3B0aW9uc19tYXNrVGV4dFNlbGVjdG9yID0gb3B0aW9ucy5tYXNrVGV4dFNlbGVjdG9yLCBtYXNrVGV4dFNlbGVjdG9yID0gX29wdGlvbnNfbWFza1RleHRTZWxlY3RvciA9PT0gdm9pZCAwID8gbnVsbCA6IF9vcHRpb25zX21hc2tUZXh0U2VsZWN0b3IsIF9vcHRpb25zX2lubGluZVN0eWxlc2hlZXQgPSBvcHRpb25zLmlubGluZVN0eWxlc2hlZXQsIGlubGluZVN0eWxlc2hlZXQgPSBfb3B0aW9uc19pbmxpbmVTdHlsZXNoZWV0ID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnNfaW5saW5lU3R5bGVzaGVldCwgbWFza0FsbElucHV0cyA9IG9wdGlvbnMubWFza0FsbElucHV0cywgX21hc2tJbnB1dE9wdGlvbnMgPSBvcHRpb25zLm1hc2tJbnB1dE9wdGlvbnMsIF9zbGltRE9NT3B0aW9ucyA9IG9wdGlvbnMuc2xpbURPTU9wdGlvbnMsIG1hc2tJbnB1dEZuID0gb3B0aW9ucy5tYXNrSW5wdXRGbiwgbWFza1RleHRGbiA9IG9wdGlvbnMubWFza1RleHRGbiwgaG9va3MgPSBvcHRpb25zLmhvb2tzLCBwYWNrRm4gPSBvcHRpb25zLnBhY2tGbiwgX29wdGlvbnNfc2FtcGxpbmcgPSBvcHRpb25zLnNhbXBsaW5nLCBzYW1wbGluZyA9IF9vcHRpb25zX3NhbXBsaW5nID09PSB2b2lkIDAgPyB7fSA6IF9vcHRpb25zX3NhbXBsaW5nLCBfb3B0aW9uc19kYXRhVVJMT3B0aW9ucyA9IG9wdGlvbnMuZGF0YVVSTE9wdGlvbnMsIGRhdGFVUkxPcHRpb25zID0gX29wdGlvbnNfZGF0YVVSTE9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX29wdGlvbnNfZGF0YVVSTE9wdGlvbnMsIG1vdXNlbW92ZVdhaXQgPSBvcHRpb25zLm1vdXNlbW92ZVdhaXQsIF9vcHRpb25zX3JlY29yZERPTSA9IG9wdGlvbnMucmVjb3JkRE9NLCByZWNvcmRET00gPSBfb3B0aW9uc19yZWNvcmRET00gPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9uc19yZWNvcmRET00sIF9vcHRpb25zX3JlY29yZENhbnZhcyA9IG9wdGlvbnMucmVjb3JkQ2FudmFzLCByZWNvcmRDYW52YXMgPSBfb3B0aW9uc19yZWNvcmRDYW52YXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfcmVjb3JkQ2FudmFzLCBfb3B0aW9uc19yZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPSBvcHRpb25zLnJlY29yZENyb3NzT3JpZ2luSWZyYW1lcywgcmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzID0gX29wdGlvbnNfcmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zX3JlY29yZENyb3NzT3JpZ2luSWZyYW1lcywgX29wdGlvbnNfcmVjb3JkQWZ0ZXIgPSBvcHRpb25zLnJlY29yZEFmdGVyLCByZWNvcmRBZnRlciA9IF9vcHRpb25zX3JlY29yZEFmdGVyID09PSB2b2lkIDAgPyBvcHRpb25zLnJlY29yZEFmdGVyID09PSBcIkRPTUNvbnRlbnRMb2FkZWRcIiA/IG9wdGlvbnMucmVjb3JkQWZ0ZXIgOiBcImxvYWRcIiA6IF9vcHRpb25zX3JlY29yZEFmdGVyLCBfb3B0aW9uc191c2VyVHJpZ2dlcmVkT25JbnB1dCA9IG9wdGlvbnMudXNlclRyaWdnZXJlZE9uSW5wdXQsIHVzZXJUcmlnZ2VyZWRPbklucHV0ID0gX29wdGlvbnNfdXNlclRyaWdnZXJlZE9uSW5wdXQgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfdXNlclRyaWdnZXJlZE9uSW5wdXQsIF9vcHRpb25zX2NvbGxlY3RGb250cyA9IG9wdGlvbnMuY29sbGVjdEZvbnRzLCBjb2xsZWN0Rm9udHMgPSBfb3B0aW9uc19jb2xsZWN0Rm9udHMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnNfY29sbGVjdEZvbnRzLCBfb3B0aW9uc19pbmxpbmVJbWFnZXMgPSBvcHRpb25zLmlubGluZUltYWdlcywgaW5saW5lSW1hZ2VzID0gX29wdGlvbnNfaW5saW5lSW1hZ2VzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zX2lubGluZUltYWdlcywgcGx1Z2lucyA9IG9wdGlvbnMucGx1Z2lucywgX29wdGlvbnNfa2VlcElmcmFtZVNyY0ZuID0gb3B0aW9ucy5rZWVwSWZyYW1lU3JjRm4sIGtlZXBJZnJhbWVTcmNGbiA9IF9vcHRpb25zX2tlZXBJZnJhbWVTcmNGbiA9PT0gdm9pZCAwID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IDogX29wdGlvbnNfa2VlcElmcmFtZVNyY0ZuLCBfb3B0aW9uc19pZ25vcmVDU1NBdHRyaWJ1dGVzID0gb3B0aW9ucy5pZ25vcmVDU1NBdHRyaWJ1dGVzLCBpZ25vcmVDU1NBdHRyaWJ1dGVzID0gX29wdGlvbnNfaWdub3JlQ1NTQXR0cmlidXRlcyA9PT0gdm9pZCAwID8gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW10pIDogX29wdGlvbnNfaWdub3JlQ1NTQXR0cmlidXRlcywgZXJyb3JIYW5kbGVyMiA9IG9wdGlvbnMuZXJyb3JIYW5kbGVyO1xuICAgIHJlZ2lzdGVyRXJyb3JIYW5kbGVyKGVycm9ySGFuZGxlcjIpO1xuICAgIHZhciBpbkVtaXR0aW5nRnJhbWUgPSByZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPyB3aW5kb3cucGFyZW50ID09PSB3aW5kb3cgOiB0cnVlO1xuICAgIHZhciBwYXNzRW1pdHNUb1BhcmVudCA9IGZhbHNlO1xuICAgIGlmICghaW5FbWl0dGluZ0ZyYW1lKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAod2luZG93LnBhcmVudC5kb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHBhc3NFbWl0c1RvUGFyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgICAgICBwYXNzRW1pdHNUb1BhcmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluRW1pdHRpbmdGcmFtZSAmJiAhZW1pdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbWl0IGZ1bmN0aW9uIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBpZiAoIWluRW1pdHRpbmdGcmFtZSAmJiAhcGFzc0VtaXRzVG9QYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgfVxuICAgIGlmIChtb3VzZW1vdmVXYWl0ICE9PSB2b2lkIDAgJiYgc2FtcGxpbmcubW91c2Vtb3ZlID09PSB2b2lkIDApIHtcbiAgICAgICAgc2FtcGxpbmcubW91c2Vtb3ZlID0gbW91c2Vtb3ZlV2FpdDtcbiAgICB9XG4gICAgbWlycm9yLnJlc2V0KCk7XG4gICAgdmFyIG1hc2tJbnB1dE9wdGlvbnMgPSBtYXNrQWxsSW5wdXRzID09PSB0cnVlID8ge1xuICAgICAgICBjb2xvcjogdHJ1ZSxcbiAgICAgICAgZGF0ZTogdHJ1ZSxcbiAgICAgICAgXCJkYXRldGltZS1sb2NhbFwiOiB0cnVlLFxuICAgICAgICBlbWFpbDogdHJ1ZSxcbiAgICAgICAgbW9udGg6IHRydWUsXG4gICAgICAgIG51bWJlcjogdHJ1ZSxcbiAgICAgICAgcmFuZ2U6IHRydWUsXG4gICAgICAgIHNlYXJjaDogdHJ1ZSxcbiAgICAgICAgdGVsOiB0cnVlLFxuICAgICAgICB0ZXh0OiB0cnVlLFxuICAgICAgICB0aW1lOiB0cnVlLFxuICAgICAgICB1cmw6IHRydWUsXG4gICAgICAgIHdlZWs6IHRydWUsXG4gICAgICAgIHRleHRhcmVhOiB0cnVlLFxuICAgICAgICBzZWxlY3Q6IHRydWUsXG4gICAgICAgIHBhc3N3b3JkOiB0cnVlXG4gICAgfSA6IF9tYXNrSW5wdXRPcHRpb25zICE9PSB2b2lkIDAgPyBfbWFza0lucHV0T3B0aW9ucyA6IHtcbiAgICAgICAgcGFzc3dvcmQ6IHRydWVcbiAgICB9O1xuICAgIHZhciBzbGltRE9NT3B0aW9ucyA9IF9zbGltRE9NT3B0aW9ucyA9PT0gdHJ1ZSB8fCBfc2xpbURPTU9wdGlvbnMgPT09IFwiYWxsXCIgPyB7XG4gICAgICAgIHNjcmlwdDogdHJ1ZSxcbiAgICAgICAgY29tbWVudDogdHJ1ZSxcbiAgICAgICAgaGVhZEZhdmljb246IHRydWUsXG4gICAgICAgIGhlYWRXaGl0ZXNwYWNlOiB0cnVlLFxuICAgICAgICBoZWFkTWV0YVNvY2lhbDogdHJ1ZSxcbiAgICAgICAgaGVhZE1ldGFSb2JvdHM6IHRydWUsXG4gICAgICAgIGhlYWRNZXRhSHR0cEVxdWl2OiB0cnVlLFxuICAgICAgICBoZWFkTWV0YVZlcmlmaWNhdGlvbjogdHJ1ZSxcbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgb2ZmIGZvciBzbGltRE9NT3B0aW9ucyA9PT0gdHJ1ZSxcbiAgICAgICAgLy8gYXMgdGhleSBkZXN0cm95IHNvbWUgKGhpZGRlbikgaW5mbzpcbiAgICAgICAgaGVhZE1ldGFBdXRob3JzaGlwOiBfc2xpbURPTU9wdGlvbnMgPT09IFwiYWxsXCIsXG4gICAgICAgIGhlYWRNZXRhRGVzY0tleXdvcmRzOiBfc2xpbURPTU9wdGlvbnMgPT09IFwiYWxsXCIsXG4gICAgICAgIGhlYWRUaXRsZU11dGF0aW9uczogX3NsaW1ET01PcHRpb25zID09PSBcImFsbFwiXG4gICAgfSA6IF9zbGltRE9NT3B0aW9ucyA/IF9zbGltRE9NT3B0aW9ucyA6IHt9O1xuICAgIHBvbHlmaWxsJDEoKTtcbiAgICB2YXIgbGFzdEZ1bGxTbmFwc2hvdEV2ZW50O1xuICAgIHZhciBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPSAwO1xuICAgIHZhciBldmVudFByb2Nlc3NvciA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgIGZvcih2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZV9mb3Jfb2ZfaXRlcmF0b3JfaGVscGVyX2xvb3NlKHBsdWdpbnMgfHwgW10pLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOyl7XG4gICAgICAgICAgICB2YXIgcGx1Z2luMyA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHBsdWdpbjMuZXZlbnRQcm9jZXNzb3IpIHtcbiAgICAgICAgICAgICAgICBlMiA9IHBsdWdpbjMuZXZlbnRQcm9jZXNzb3IoZTIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYWNrRm4gJiYgLy8gRGlzYWJsZSBwYWNraW5nIGV2ZW50cyB3aGljaCB3aWxsIGJlIGVtaXR0ZWQgdG8gcGFyZW50IGZyYW1lcy5cbiAgICAgICAgIXBhc3NFbWl0c1RvUGFyZW50KSB7XG4gICAgICAgICAgICBlMiA9IHBhY2tGbihlMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGUyO1xuICAgIH07XG4gICAgd3JhcHBlZEVtaXQgPSBmdW5jdGlvbihyMiwgaXNDaGVja291dCkge1xuICAgICAgICB2YXIgX2EyO1xuICAgICAgICB2YXIgZTIgPSByMjtcbiAgICAgICAgZTIudGltZXN0YW1wID0gbm93VGltZXN0YW1wKCk7XG4gICAgICAgIGlmICgoKF9hMiA9IG11dGF0aW9uQnVmZmVyc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5pc0Zyb3plbigpKSAmJiBlMi50eXBlICE9PSBFdmVudFR5cGUuRnVsbFNuYXBzaG90ICYmICEoZTIudHlwZSA9PT0gRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QgJiYgZTIuZGF0YS5zb3VyY2UgPT09IEluY3JlbWVudGFsU291cmNlLk11dGF0aW9uKSkge1xuICAgICAgICAgICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1Zi51bmZyZWV6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluRW1pdHRpbmdGcmFtZSkge1xuICAgICAgICAgICAgZW1pdCA9PSBudWxsID8gdm9pZCAwIDogZW1pdChldmVudFByb2Nlc3NvcihlMiksIGlzQ2hlY2tvdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhc3NFbWl0c1RvUGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJyd2ViXCIsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50UHJvY2Vzc29yKGUyKSxcbiAgICAgICAgICAgICAgICBvcmlnaW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICAgICAgICAgICAgaXNDaGVja291dDogaXNDaGVja291dFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHdpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UobWVzc2FnZSwgXCIqXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlMi50eXBlID09PSBFdmVudFR5cGUuRnVsbFNuYXBzaG90KSB7XG4gICAgICAgICAgICBsYXN0RnVsbFNuYXBzaG90RXZlbnQgPSBlMjtcbiAgICAgICAgICAgIGluY3JlbWVudGFsU25hcHNob3RDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZTIudHlwZSA9PT0gRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QpIHtcbiAgICAgICAgICAgIGlmIChlMi5kYXRhLnNvdXJjZSA9PT0gSW5jcmVtZW50YWxTb3VyY2UuTXV0YXRpb24gJiYgZTIuZGF0YS5pc0F0dGFjaElmcmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluY3JlbWVudGFsU25hcHNob3RDb3VudCsrO1xuICAgICAgICAgICAgdmFyIGV4Y2VlZENvdW50ID0gY2hlY2tvdXRFdmVyeU50aCAmJiBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPj0gY2hlY2tvdXRFdmVyeU50aDtcbiAgICAgICAgICAgIHZhciBleGNlZWRUaW1lID0gY2hlY2tvdXRFdmVyeU5tcyAmJiBlMi50aW1lc3RhbXAgLSBsYXN0RnVsbFNuYXBzaG90RXZlbnQudGltZXN0YW1wID4gY2hlY2tvdXRFdmVyeU5tcztcbiAgICAgICAgICAgIGlmIChleGNlZWRDb3VudCB8fCBleGNlZWRUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGFrZUZ1bGxTbmFwc2hvdCQxKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgd3JhcHBlZE11dGF0aW9uRW1pdCA9IGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5NdXRhdGlvblxuICAgICAgICAgICAgfSwgbSlcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgd3JhcHBlZFNjcm9sbEVtaXQgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgIGRhdGE6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLlNjcm9sbFxuICAgICAgICAgICAgfSwgcClcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB2YXIgd3JhcHBlZENhbnZhc011dGF0aW9uRW1pdCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuQ2FudmFzTXV0YXRpb25cbiAgICAgICAgICAgIH0sIHApXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIHdyYXBwZWRBZG9wdGVkU3R5bGVTaGVldEVtaXQgPSBmdW5jdGlvbihhMikge1xuICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICBkYXRhOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5BZG9wdGVkU3R5bGVTaGVldFxuICAgICAgICAgICAgfSwgYTIpXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdmFyIHN0eWxlc2hlZXRNYW5hZ2VyID0gbmV3IFN0eWxlc2hlZXRNYW5hZ2VyKHtcbiAgICAgICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcbiAgICAgICAgYWRvcHRlZFN0eWxlU2hlZXRDYjogd3JhcHBlZEFkb3B0ZWRTdHlsZVNoZWV0RW1pdFxuICAgIH0pO1xuICAgIHZhciBpZnJhbWVNYW5hZ2VyID0gbmV3IElmcmFtZU1hbmFnZXIoe1xuICAgICAgICBtaXJyb3I6IG1pcnJvcixcbiAgICAgICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcbiAgICAgICAgc3R5bGVzaGVldE1hbmFnZXI6IHN0eWxlc2hlZXRNYW5hZ2VyLFxuICAgICAgICByZWNvcmRDcm9zc09yaWdpbklmcmFtZXM6IHJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyxcbiAgICAgICAgd3JhcHBlZEVtaXQ6IHdyYXBwZWRFbWl0XG4gICAgfSk7XG4gICAgZm9yKHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlX2Zvcl9vZl9pdGVyYXRvcl9oZWxwZXJfbG9vc2UocGx1Z2lucyB8fCBbXSksIF9zdGVwOyAhKF9zdGVwID0gX2l0ZXJhdG9yKCkpLmRvbmU7KXtcbiAgICAgICAgdmFyIHBsdWdpbjMgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgaWYgKHBsdWdpbjMuZ2V0TWlycm9yKSBwbHVnaW4zLmdldE1pcnJvcih7XG4gICAgICAgICAgICBub2RlTWlycm9yOiBtaXJyb3IsXG4gICAgICAgICAgICBjcm9zc09yaWdpbklmcmFtZU1pcnJvcjogaWZyYW1lTWFuYWdlci5jcm9zc09yaWdpbklmcmFtZU1pcnJvcixcbiAgICAgICAgICAgIGNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3I6IGlmcmFtZU1hbmFnZXIuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHByb2Nlc3NlZE5vZGVNYW5hZ2VyID0gbmV3IFByb2Nlc3NlZE5vZGVNYW5hZ2VyKCk7XG4gICAgY2FudmFzTWFuYWdlciA9IG5ldyBDYW52YXNNYW5hZ2VyKHtcbiAgICAgICAgcmVjb3JkQ2FudmFzOiByZWNvcmRDYW52YXMsXG4gICAgICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRDYW52YXNNdXRhdGlvbkVtaXQsXG4gICAgICAgIHdpbjogd2luZG93LFxuICAgICAgICBibG9ja0NsYXNzOiBibG9ja0NsYXNzLFxuICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxuICAgICAgICBtaXJyb3I6IG1pcnJvcixcbiAgICAgICAgc2FtcGxpbmc6IHNhbXBsaW5nLmNhbnZhcyxcbiAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zXG4gICAgfSk7XG4gICAgdmFyIHNoYWRvd0RvbU1hbmFnZXIgPSBuZXcgU2hhZG93RG9tTWFuYWdlcih7XG4gICAgICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXG4gICAgICAgIHNjcm9sbENiOiB3cmFwcGVkU2Nyb2xsRW1pdCxcbiAgICAgICAgYnlwYXNzT3B0aW9uczoge1xuICAgICAgICAgICAgYmxvY2tDbGFzczogYmxvY2tDbGFzcyxcbiAgICAgICAgICAgIGJsb2NrU2VsZWN0b3I6IGJsb2NrU2VsZWN0b3IsXG4gICAgICAgICAgICBtYXNrVGV4dENsYXNzOiBtYXNrVGV4dENsYXNzLFxuICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcjogbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IGlubGluZVN0eWxlc2hlZXQsXG4gICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IGRhdGFVUkxPcHRpb25zLFxuICAgICAgICAgICAgbWFza1RleHRGbjogbWFza1RleHRGbixcbiAgICAgICAgICAgIG1hc2tJbnB1dEZuOiBtYXNrSW5wdXRGbixcbiAgICAgICAgICAgIHJlY29yZENhbnZhczogcmVjb3JkQ2FudmFzLFxuICAgICAgICAgICAgaW5saW5lSW1hZ2VzOiBpbmxpbmVJbWFnZXMsXG4gICAgICAgICAgICBzYW1wbGluZzogc2FtcGxpbmcsXG4gICAgICAgICAgICBzbGltRE9NT3B0aW9uczogc2xpbURPTU9wdGlvbnMsXG4gICAgICAgICAgICBpZnJhbWVNYW5hZ2VyOiBpZnJhbWVNYW5hZ2VyLFxuICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXI6IHN0eWxlc2hlZXRNYW5hZ2VyLFxuICAgICAgICAgICAgY2FudmFzTWFuYWdlcjogY2FudmFzTWFuYWdlcixcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbjoga2VlcElmcmFtZVNyY0ZuLFxuICAgICAgICAgICAgcHJvY2Vzc2VkTm9kZU1hbmFnZXI6IHByb2Nlc3NlZE5vZGVNYW5hZ2VyXG4gICAgICAgIH0sXG4gICAgICAgIG1pcnJvcjogbWlycm9yXG4gICAgfSk7XG4gICAgdGFrZUZ1bGxTbmFwc2hvdCQxID0gZnVuY3Rpb24oaXNDaGVja291dCkge1xuICAgICAgICBpZiAoaXNDaGVja291dCA9PT0gdm9pZCAwKSBpc0NoZWNrb3V0ID0gZmFsc2U7XG4gICAgICAgIGlmICghcmVjb3JkRE9NKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLk1ldGEsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgaHJlZjogd2luZG93LmxvY2F0aW9uLmhyZWYsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGdldFdpbmRvd1dpZHRoKCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBnZXRXaW5kb3dIZWlnaHQoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBpc0NoZWNrb3V0KTtcbiAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIucmVzZXQoKTtcbiAgICAgICAgc2hhZG93RG9tTWFuYWdlci5pbml0KCk7XG4gICAgICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1Zikge1xuICAgICAgICAgICAgcmV0dXJuIGJ1Zi5sb2NrKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbm9kZTIgPSBzbmFwc2hvdChkb2N1bWVudCwge1xuICAgICAgICAgICAgbWlycm9yOiBtaXJyb3IsXG4gICAgICAgICAgICBibG9ja0NsYXNzOiBibG9ja0NsYXNzLFxuICAgICAgICAgICAgYmxvY2tTZWxlY3RvcjogYmxvY2tTZWxlY3RvcixcbiAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3M6IG1hc2tUZXh0Q2xhc3MsXG4gICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yOiBtYXNrVGV4dFNlbGVjdG9yLFxuICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldDogaW5saW5lU3R5bGVzaGVldCxcbiAgICAgICAgICAgIG1hc2tBbGxJbnB1dHM6IG1hc2tJbnB1dE9wdGlvbnMsXG4gICAgICAgICAgICBtYXNrVGV4dEZuOiBtYXNrVGV4dEZuLFxuICAgICAgICAgICAgbWFza0lucHV0Rm46IG1hc2tJbnB1dEZuLFxuICAgICAgICAgICAgc2xpbURPTTogc2xpbURPTU9wdGlvbnMsXG4gICAgICAgICAgICBkYXRhVVJMT3B0aW9uczogZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgICByZWNvcmRDYW52YXM6IHJlY29yZENhbnZhcyxcbiAgICAgICAgICAgIGlubGluZUltYWdlczogaW5saW5lSW1hZ2VzLFxuICAgICAgICAgICAgb25TZXJpYWxpemU6IGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZElmcmFtZShuMiwgbWlycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICBpZnJhbWVNYW5hZ2VyLmFkZElmcmFtZShuMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRTdHlsZXNoZWV0KG4yLCBtaXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLnRyYWNrTGlua0VsZW1lbnQobjIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdChuMikpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93RG9tTWFuYWdlci5hZGRTaGFkb3dSb290KGluZGV4LnNoYWRvd1Jvb3QobjIpLCBkb2N1bWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uSWZyYW1lTG9hZDogZnVuY3Rpb24oaWZyYW1lLCBjaGlsZFNuKSB7XG4gICAgICAgICAgICAgICAgaWZyYW1lTWFuYWdlci5hdHRhY2hJZnJhbWUoaWZyYW1lLCBjaGlsZFNuKTtcbiAgICAgICAgICAgICAgICBzaGFkb3dEb21NYW5hZ2VyLm9ic2VydmVBdHRhY2hTaGFkb3coaWZyYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkOiBmdW5jdGlvbihsaW5rRWwsIGNoaWxkU24pIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5hdHRhY2hMaW5rRWxlbWVudChsaW5rRWwsIGNoaWxkU24pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbjoga2VlcElmcmFtZVNyY0ZuXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIW5vZGUyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKFwiRmFpbGVkIHRvIHNuYXBzaG90IHRoZSBkb2N1bWVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuRnVsbFNuYXBzaG90LFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG5vZGU6IG5vZGUyLFxuICAgICAgICAgICAgICAgIGluaXRpYWxPZmZzZXQ6IGdldFdpbmRvd1Njcm9sbCh3aW5kb3cpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGlzQ2hlY2tvdXQpO1xuICAgICAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWYpIHtcbiAgICAgICAgICAgIHJldHVybiBidWYudW5sb2NrKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzICYmIGRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cy5sZW5ndGggPiAwKSBzdHlsZXNoZWV0TWFuYWdlci5hZG9wdFN0eWxlU2hlZXRzKGRvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cywgbWlycm9yLmdldElkKGRvY3VtZW50KSk7XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdmFyIG9ic2VydmUgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICAgIHZhciBfYTI7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKGluaXRPYnNlcnZlcnMpKHtcbiAgICAgICAgICAgICAgICBtdXRhdGlvbkNiOiB3cmFwcGVkTXV0YXRpb25FbWl0LFxuICAgICAgICAgICAgICAgIG1vdXNlbW92ZUNiOiBmdW5jdGlvbihwb3NpdGlvbnMsIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zOiBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb3VzZUludGVyYWN0aW9uQ2I6IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuTW91c2VJbnRlcmFjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzY3JvbGxDYjogd3JhcHBlZFNjcm9sbEVtaXQsXG4gICAgICAgICAgICAgICAgdmlld3BvcnRSZXNpemVDYjogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5WaWV3cG9ydFJlc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnB1dENiOiBmdW5jdGlvbih2Mikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkluY3JlbWVudGFsU25hcHNob3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZS5JbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdjIpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWVkaWFJbnRlcmFjdGlvbkNiOiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLk1lZGlhSW50ZXJhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHApXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYjogZnVuY3Rpb24ocjIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuU3R5bGVTaGVldFJ1bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHIyKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYjogZnVuY3Rpb24ocjIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuU3R5bGVEZWNsYXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcjIpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2FudmFzTXV0YXRpb25DYjogd3JhcHBlZENhbnZhc011dGF0aW9uRW1pdCxcbiAgICAgICAgICAgICAgICBmb250Q2I6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuRm9udFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25DYjogZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlLlNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjdXN0b21FbGVtZW50Q2I6IGZ1bmN0aW9uKGMyKSB7XG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogX2V4dGVuZHMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UuQ3VzdG9tRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgYzIpXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmxvY2tDbGFzczogYmxvY2tDbGFzcyxcbiAgICAgICAgICAgICAgICBpZ25vcmVDbGFzczogaWdub3JlQ2xhc3MsXG4gICAgICAgICAgICAgICAgaWdub3JlU2VsZWN0b3I6IGlnbm9yZVNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3M6IG1hc2tUZXh0Q2xhc3MsXG4gICAgICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcjogbWFza1RleHRTZWxlY3RvcixcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiBtYXNrSW5wdXRPcHRpb25zLFxuICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQ6IGlubGluZVN0eWxlc2hlZXQsXG4gICAgICAgICAgICAgICAgc2FtcGxpbmc6IHNhbXBsaW5nLFxuICAgICAgICAgICAgICAgIHJlY29yZERPTTogcmVjb3JkRE9NLFxuICAgICAgICAgICAgICAgIHJlY29yZENhbnZhczogcmVjb3JkQ2FudmFzLFxuICAgICAgICAgICAgICAgIGlubGluZUltYWdlczogaW5saW5lSW1hZ2VzLFxuICAgICAgICAgICAgICAgIHVzZXJUcmlnZ2VyZWRPbklucHV0OiB1c2VyVHJpZ2dlcmVkT25JbnB1dCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0Rm9udHM6IGNvbGxlY3RGb250cyxcbiAgICAgICAgICAgICAgICBkb2M6IGRvYyxcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRGbjogbWFza0lucHV0Rm4sXG4gICAgICAgICAgICAgICAgbWFza1RleHRGbjogbWFza1RleHRGbixcbiAgICAgICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm46IGtlZXBJZnJhbWVTcmNGbixcbiAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yOiBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgICAgIHNsaW1ET01PcHRpb25zOiBzbGltRE9NT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBkYXRhVVJMT3B0aW9uczogZGF0YVVSTE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgbWlycm9yOiBtaXJyb3IsXG4gICAgICAgICAgICAgICAgaWZyYW1lTWFuYWdlcjogaWZyYW1lTWFuYWdlcixcbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlcjogc3R5bGVzaGVldE1hbmFnZXIsXG4gICAgICAgICAgICAgICAgc2hhZG93RG9tTWFuYWdlcjogc2hhZG93RG9tTWFuYWdlcixcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWROb2RlTWFuYWdlcjogcHJvY2Vzc2VkTm9kZU1hbmFnZXIsXG4gICAgICAgICAgICAgICAgY2FudmFzTWFuYWdlcjogY2FudmFzTWFuYWdlcixcbiAgICAgICAgICAgICAgICBpZ25vcmVDU1NBdHRyaWJ1dGVzOiBpZ25vcmVDU1NBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIHBsdWdpbnM6ICgoX2EyID0gcGx1Z2lucyA9PSBudWxsID8gdm9pZCAwIDogcGx1Z2lucy5maWx0ZXIoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcC5vYnNlcnZlcjtcbiAgICAgICAgICAgICAgICB9KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5tYXAoZnVuY3Rpb24ocCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXI6IHAub2JzZXJ2ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiBwLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24ocGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVkRW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZS5QbHVnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbjogcC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogcGF5bG9hZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkpIHx8IFtdXG4gICAgICAgICAgICB9LCBob29rcyk7XG4gICAgICAgIH07XG4gICAgICAgIGlmcmFtZU1hbmFnZXIuYWRkTG9hZExpc3RlbmVyKGZ1bmN0aW9uKGlmcmFtZUVsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gob2JzZXJ2ZShpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQpKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0YWtlRnVsbFNuYXBzaG90JDEoKTtcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gob2JzZXJ2ZShkb2N1bWVudCkpO1xuICAgICAgICAgICAgcmVjb3JkaW5nID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiaW50ZXJhY3RpdmVcIiB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgIGluaXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2gob24oXCJET01Db250ZW50TG9hZGVkXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHdyYXBwZWRFbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlLkRvbUNvbnRlbnRMb2FkZWQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZEFmdGVyID09PSBcIkRPTUNvbnRlbnRMb2FkZWRcIikgaW5pdCgpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChvbihcImxvYWRcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUuTG9hZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkQWZ0ZXIgPT09IFwibG9hZFwiKSBpbml0KCk7XG4gICAgICAgICAgICB9LCB3aW5kb3cpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcm9jZXNzZWROb2RlTWFuYWdlci5kZXN0cm95KCk7XG4gICAgICAgICAgICByZWNvcmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJFcnJvckhhbmRsZXIoKTtcbiAgICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xuICAgIH1cbn1cbnJlY29yZC5hZGRDdXN0b21FdmVudCA9IGZ1bmN0aW9uKHRhZywgcGF5bG9hZCkge1xuICAgIGlmICghcmVjb3JkaW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBsZWFzZSBhZGQgY3VzdG9tIGV2ZW50IGFmdGVyIHN0YXJ0IHJlY29yZGluZ1wiKTtcbiAgICB9XG4gICAgd3JhcHBlZEVtaXQoe1xuICAgICAgICB0eXBlOiBFdmVudFR5cGUuQ3VzdG9tLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbnJlY29yZC5mcmVlemVQYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmKSB7XG4gICAgICAgIHJldHVybiBidWYuZnJlZXplKCk7XG4gICAgfSk7XG59O1xucmVjb3JkLnRha2VGdWxsU25hcHNob3QgPSBmdW5jdGlvbihpc0NoZWNrb3V0KSB7XG4gICAgaWYgKCFyZWNvcmRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGxlYXNlIHRha2UgZnVsbCBzbmFwc2hvdCBhZnRlciBzdGFydCByZWNvcmRpbmdcIik7XG4gICAgfVxuICAgIHRha2VGdWxsU25hcHNob3QkMShpc0NoZWNrb3V0KTtcbn07XG5yZWNvcmQubWlycm9yID0gbWlycm9yO1xudmFyIG47XG4hZnVuY3Rpb24odDIpIHtcbiAgICB0Mlt0Mi5Ob3RTdGFydGVkID0gMF0gPSBcIk5vdFN0YXJ0ZWRcIiwgdDJbdDIuUnVubmluZyA9IDFdID0gXCJSdW5uaW5nXCIsIHQyW3QyLlN0b3BwZWQgPSAyXSA9IFwiU3RvcHBlZFwiO1xufShuIHx8IChuID0ge30pKTtcbnJlY29yZC5hZGRDdXN0b21FdmVudDtcbnJlY29yZC5mcmVlemVQYWdlO1xucmVjb3JkLnRha2VGdWxsU25hcHNob3Q7XG5cbnZhciBzZXRJbW1lZGlhdGUgPSB3aW5bJ3NldEltbWVkaWF0ZSddO1xudmFyIGJ1aWx0SW5Qcm9wLCBjeWNsZSwgc2NoZWR1bGluZ1F1ZXVlLFxuICAgIFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyxcbiAgICB0aW1lciA9ICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJykgP1xuICAgICAgICBmdW5jdGlvbiB0aW1lcihmbikgeyByZXR1cm4gc2V0SW1tZWRpYXRlKGZuKTsgfSA6XG4gICAgICAgIHNldFRpbWVvdXQ7XG5cbi8vIGRhbW1pdCwgSUU4LlxudHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sJ3gnLHt9KTtcbiAgICBidWlsdEluUHJvcCA9IGZ1bmN0aW9uIGJ1aWx0SW5Qcm9wKG9iaixuYW1lLHZhbCxjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosbmFtZSx7XG4gICAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGNvbmZpZyAhPT0gZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmNhdGNoIChlcnIpIHtcbiAgICBidWlsdEluUHJvcCA9IGZ1bmN0aW9uIGJ1aWx0SW5Qcm9wKG9iaixuYW1lLHZhbCkge1xuICAgICAgICBvYmpbbmFtZV0gPSB2YWw7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbn1cblxuLy8gTm90ZTogdXNpbmcgYSBxdWV1ZSBpbnN0ZWFkIG9mIGFycmF5IGZvciBlZmZpY2llbmN5XG5zY2hlZHVsaW5nUXVldWUgPSAoZnVuY3Rpb24gUXVldWUoKSB7XG4gICAgdmFyIGZpcnN0LCBsYXN0LCBpdGVtO1xuXG4gICAgZnVuY3Rpb24gSXRlbShmbixzZWxmKSB7XG4gICAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgICAgdGhpcy5zZWxmID0gc2VsZjtcbiAgICAgICAgdGhpcy5uZXh0ID0gdm9pZCAwO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZDogZnVuY3Rpb24gYWRkKGZuLHNlbGYpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBuZXcgSXRlbShmbixzZWxmKTtcbiAgICAgICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgICAgICAgbGFzdC5uZXh0ID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpcnN0ID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3QgPSBpdGVtO1xuICAgICAgICAgICAgaXRlbSA9IHZvaWQgMDtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhaW46IGZ1bmN0aW9uIGRyYWluKCkge1xuICAgICAgICAgICAgdmFyIGYgPSBmaXJzdDtcbiAgICAgICAgICAgIGZpcnN0ID0gbGFzdCA9IGN5Y2xlID0gdm9pZCAwO1xuXG4gICAgICAgICAgICB3aGlsZSAoZikge1xuICAgICAgICAgICAgICAgIGYuZm4uY2FsbChmLnNlbGYpO1xuICAgICAgICAgICAgICAgIGYgPSBmLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuZnVuY3Rpb24gc2NoZWR1bGUoZm4sc2VsZikge1xuICAgIHNjaGVkdWxpbmdRdWV1ZS5hZGQoZm4sc2VsZik7XG4gICAgaWYgKCFjeWNsZSkge1xuICAgICAgICBjeWNsZSA9IHRpbWVyKHNjaGVkdWxpbmdRdWV1ZS5kcmFpbik7XG4gICAgfVxufVxuXG4vLyBwcm9taXNlIGR1Y2sgdHlwaW5nXG5mdW5jdGlvbiBpc1RoZW5hYmxlKG8pIHtcbiAgICB2YXIgX3RoZW4sIG9UeXBlID0gdHlwZW9mIG87XG5cbiAgICBpZiAobyAhPT0gbnVsbCAmJiAob1R5cGUgPT09ICdvYmplY3QnIHx8IG9UeXBlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICBfdGhlbiA9IG8udGhlbjtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBfdGhlbiA9PT0gJ2Z1bmN0aW9uJyA/IF90aGVuIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG5vdGlmeSgpIHtcbiAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5jaGFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBub3RpZnlJc29sYXRlZChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSA9PT0gMSkgPyB0aGlzLmNoYWluW2ldLnN1Y2Nlc3MgOiB0aGlzLmNoYWluW2ldLmZhaWx1cmUsXG4gICAgICAgICAgICB0aGlzLmNoYWluW2ldXG4gICAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuY2hhaW4ubGVuZ3RoID0gMDtcbn1cblxuLy8gTk9URTogVGhpcyBpcyBhIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGlzb2xhdGVcbi8vIHRoZSBgdHJ5Li5jYXRjaGAgc28gdGhhdCBvdGhlciBjb2RlIGNhbiBiZVxuLy8gb3B0aW1pemVkIGJldHRlclxuZnVuY3Rpb24gbm90aWZ5SXNvbGF0ZWQoc2VsZixjYixjaGFpbikge1xuICAgIHZhciByZXQsIF90aGVuO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChjYiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNoYWluLnJlamVjdChzZWxmLm1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBzZWxmLm1zZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldCA9IGNiLmNhbGwodm9pZCAwLHNlbGYubXNnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJldCA9PT0gY2hhaW4ucHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGNoYWluLnJlamVjdChUeXBlRXJyb3IoJ1Byb21pc2UtY2hhaW4gY3ljbGUnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGVuID0gaXNUaGVuYWJsZShyZXQpKSB7XG4gICAgICAgICAgICAgICAgX3RoZW4uY2FsbChyZXQsY2hhaW4ucmVzb2x2ZSxjaGFpbi5yZWplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhaW4ucmVzb2x2ZShyZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY2hhaW4ucmVqZWN0KGVycik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlKG1zZykge1xuICAgIHZhciBfdGhlbiwgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBhbHJlYWR5IHRyaWdnZXJlZD9cbiAgICBpZiAoc2VsZi50cmlnZ2VyZWQpIHsgcmV0dXJuOyB9XG5cbiAgICBzZWxmLnRyaWdnZXJlZCA9IHRydWU7XG5cbiAgICAvLyB1bndyYXBcbiAgICBpZiAoc2VsZi5kZWYpIHtcbiAgICAgICAgc2VsZiA9IHNlbGYuZGVmO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICBpZiAoX3RoZW4gPSBpc1RoZW5hYmxlKG1zZykpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdmFyIGRlZldyYXBwZXIgPSBuZXcgTWFrZURlZldyYXBwZXIoc2VsZik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgX3RoZW4uY2FsbChtc2csXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAkcmVzb2x2ZSQoKXsgcmVzb2x2ZS5hcHBseShkZWZXcmFwcGVyLGFyZ3VtZW50cyk7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAkcmVqZWN0JCgpeyByZWplY3QuYXBwbHkoZGVmV3JhcHBlcixhcmd1bWVudHMpOyB9XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0LmNhbGwoZGVmV3JhcHBlcixlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5tc2cgPSBtc2c7XG4gICAgICAgICAgICBzZWxmLnN0YXRlID0gMTtcbiAgICAgICAgICAgIGlmIChzZWxmLmNoYWluLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBzY2hlZHVsZShub3RpZnksc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QuY2FsbChuZXcgTWFrZURlZldyYXBwZXIoc2VsZiksZXJyKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlamVjdChtc2cpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBhbHJlYWR5IHRyaWdnZXJlZD9cbiAgICBpZiAoc2VsZi50cmlnZ2VyZWQpIHsgcmV0dXJuOyB9XG5cbiAgICBzZWxmLnRyaWdnZXJlZCA9IHRydWU7XG5cbiAgICAvLyB1bndyYXBcbiAgICBpZiAoc2VsZi5kZWYpIHtcbiAgICAgICAgc2VsZiA9IHNlbGYuZGVmO1xuICAgIH1cblxuICAgIHNlbGYubXNnID0gbXNnO1xuICAgIHNlbGYuc3RhdGUgPSAyO1xuICAgIGlmIChzZWxmLmNoYWluLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc2NoZWR1bGUobm90aWZ5LHNlbGYpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixyZXNvbHZlcixyZWplY3Rlcikge1xuICAgIGZvciAodmFyIGlkeD0wOyBpZHg8YXJyLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgKGZ1bmN0aW9uIElJRkUoaWR4KXtcbiAgICAgICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoYXJyW2lkeF0pXG4gICAgICAgICAgICAgICAgLnRoZW4oXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uICRyZXNvbHZlciQobXNnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyKGlkeCxtc2cpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICByZWplY3RlclxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgIH0pKGlkeCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBNYWtlRGVmV3JhcHBlcihzZWxmKSB7XG4gICAgdGhpcy5kZWYgPSBzZWxmO1xuICAgIHRoaXMudHJpZ2dlcmVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIE1ha2VEZWYoc2VsZikge1xuICAgIHRoaXMucHJvbWlzZSA9IHNlbGY7XG4gICAgdGhpcy5zdGF0ZSA9IDA7XG4gICAgdGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNoYWluID0gW107XG4gICAgdGhpcy5tc2cgPSB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIE5wb1Byb21pc2UoZXhlY3V0b3IpIHtcbiAgICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1snX19OUE9fXyddICE9PSAwKSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgcHJvbWlzZScpO1xuICAgIH1cblxuICAgIC8vIGluc3RhbmNlIHNoYWRvd2luZyB0aGUgaW5oZXJpdGVkIFwiYnJhbmRcIlxuICAgIC8vIHRvIHNpZ25hbCBhbiBhbHJlYWR5IFwiaW5pdGlhbGl6ZWRcIiBwcm9taXNlXG4gICAgdGhpc1snX19OUE9fXyddID0gMTtcblxuICAgIHZhciBkZWYgPSBuZXcgTWFrZURlZih0aGlzKTtcblxuICAgIHRoaXNbJ3RoZW4nXSA9IGZ1bmN0aW9uIHRoZW4oc3VjY2VzcyxmYWlsdXJlKSB7XG4gICAgICAgIHZhciBvID0ge1xuICAgICAgICAgICAgc3VjY2VzczogdHlwZW9mIHN1Y2Nlc3MgPT09ICdmdW5jdGlvbicgPyBzdWNjZXNzIDogdHJ1ZSxcbiAgICAgICAgICAgIGZhaWx1cmU6IHR5cGVvZiBmYWlsdXJlID09PSAnZnVuY3Rpb24nID8gZmFpbHVyZSA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgICAgICAvLyBOb3RlOiBgdGhlbiguLilgIGl0c2VsZiBjYW4gYmUgYm9ycm93ZWQgdG8gYmUgdXNlZCBhZ2FpbnN0XG4gICAgICAgICAgICAvLyBhIGRpZmZlcmVudCBwcm9taXNlIGNvbnN0cnVjdG9yIGZvciBtYWtpbmcgdGhlIGNoYWluZWQgcHJvbWlzZSxcbiAgICAgICAgICAgIC8vIGJ5IHN1YnN0aXR1dGluZyBhIGRpZmZlcmVudCBgdGhpc2AgYmluZGluZy5cbiAgICAgICAgby5wcm9taXNlID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZnVuY3Rpb24gZXh0cmFjdENoYWluKHJlc29sdmUscmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgby5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIG8ucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgZGVmLmNoYWluLnB1c2gobyk7XG5cbiAgICAgICAgaWYgKGRlZi5zdGF0ZSAhPT0gMCkge1xuICAgICAgICAgICAgc2NoZWR1bGUobm90aWZ5LGRlZik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gby5wcm9taXNlO1xuICAgIH07XG4gICAgdGhpc1snY2F0Y2gnXSA9IGZ1bmN0aW9uICRjYXRjaCQoZmFpbHVyZSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aGVuKHZvaWQgMCxmYWlsdXJlKTtcbiAgICB9O1xuXG4gICAgdHJ5IHtcbiAgICAgICAgZXhlY3V0b3IuY2FsbChcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHB1YmxpY1Jlc29sdmUobXNnKXtcbiAgICAgICAgICAgICAgICByZXNvbHZlLmNhbGwoZGVmLG1zZyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnVuY3Rpb24gcHVibGljUmVqZWN0KG1zZykge1xuICAgICAgICAgICAgICAgIHJlamVjdC5jYWxsKGRlZixtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdC5jYWxsKGRlZixlcnIpO1xuICAgIH1cbn1cblxudmFyIFByb21pc2VQcm90b3R5cGUgPSBidWlsdEluUHJvcCh7fSwnY29uc3RydWN0b3InLE5wb1Byb21pc2UsXG4gICAgLypjb25maWd1cmFibGU9Ki9mYWxzZVxuKTtcblxuICAgIC8vIE5vdGU6IEFuZHJvaWQgNCBjYW5ub3QgdXNlIGBPYmplY3QuZGVmaW5lUHJvcGVydHkoLi4pYCBoZXJlXG5OcG9Qcm9taXNlLnByb3RvdHlwZSA9IFByb21pc2VQcm90b3R5cGU7XG5cbi8vIGJ1aWx0LWluIFwiYnJhbmRcIiB0byBzaWduYWwgYW4gXCJ1bmluaXRpYWxpemVkXCIgcHJvbWlzZVxuYnVpbHRJblByb3AoUHJvbWlzZVByb3RvdHlwZSwnX19OUE9fXycsMCxcbiAgICAvKmNvbmZpZ3VyYWJsZT0qL2ZhbHNlXG4pO1xuXG5idWlsdEluUHJvcChOcG9Qcm9taXNlLCdyZXNvbHZlJyxmdW5jdGlvbiBQcm9taXNlJHJlc29sdmUobXNnKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgIC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG4gICAgLy8gbm90ZTogYmVzdCBcImlzUHJvbWlzZVwiIGNoZWNrIHRoYXQncyBwcmFjdGljYWwgZm9yIG5vd1xuICAgIGlmIChtc2cgJiYgdHlwZW9mIG1zZyA9PT0gJ29iamVjdCcgJiYgbXNnWydfX05QT19fJ10gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiByZWplY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUobXNnKTtcbiAgICB9KTtcbn0pO1xuXG5idWlsdEluUHJvcChOcG9Qcm9taXNlLCdyZWplY3QnLGZ1bmN0aW9uIFByb21pc2UkcmVqZWN0KG1zZykge1xuICAgIHJldHVybiBuZXcgdGhpcyhmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcmVqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZWplY3QobXNnKTtcbiAgICB9KTtcbn0pO1xuXG5idWlsdEluUHJvcChOcG9Qcm9taXNlLCdhbGwnLGZ1bmN0aW9uIFByb21pc2UkYWxsKGFycikge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuICAgIGlmIChUb1N0cmluZy5jYWxsKGFycikgIT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLnJlamVjdChUeXBlRXJyb3IoJ05vdCBhbiBhcnJheScpKTtcbiAgICB9XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yLnJlc29sdmUoW10pO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGgsIG1zZ3MgPSBBcnJheShsZW4pLCBjb3VudCA9IDA7XG5cbiAgICAgICAgaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixmdW5jdGlvbiByZXNvbHZlcihpZHgsbXNnKSB7XG4gICAgICAgICAgICBtc2dzW2lkeF0gPSBtc2c7XG4gICAgICAgICAgICBpZiAoKytjb3VudCA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShtc2dzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxyZWplY3QpO1xuICAgIH0pO1xufSk7XG5cbmJ1aWx0SW5Qcm9wKE5wb1Byb21pc2UsJ3JhY2UnLGZ1bmN0aW9uIFByb21pc2UkcmFjZShhcnIpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgLy8gc3BlYyBtYW5kYXRlZCBjaGVja3NcbiAgICBpZiAoVG9TdHJpbmcuY2FsbChhcnIpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3Rvci5yZWplY3QoVHlwZUVycm9yKCdOb3QgYW4gYXJyYXknKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcmVqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVyYXRlUHJvbWlzZXMoQ29uc3RydWN0b3IsYXJyLGZ1bmN0aW9uIHJlc29sdmVyKGlkeCxtc2cpe1xuICAgICAgICAgICAgcmVzb2x2ZShtc2cpO1xuICAgICAgICB9LHJlamVjdCk7XG4gICAgfSk7XG59KTtcblxudmFyIFByb21pc2VQb2x5ZmlsbDtcbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgUHJvbWlzZS50b1N0cmluZygpLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSAhPT0gLTEpIHtcbiAgICBQcm9taXNlUG9seWZpbGwgPSBQcm9taXNlO1xufSBlbHNlIHtcbiAgICBQcm9taXNlUG9seWZpbGwgPSBOcG9Qcm9taXNlO1xufVxuXG52YXIgQ29uZmlnID0ge1xuICAgIERFQlVHOiBmYWxzZSxcbiAgICBMSUJfVkVSU0lPTjogJzIuNjUuMCdcbn07XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIsIGVxZXFlcTogXCJvZmZcIiAqL1xuXG4vLyBNYXhpbXVtIGFsbG93ZWQgc2Vzc2lvbiByZWNvcmRpbmcgbGVuZ3RoXG52YXIgTUFYX1JFQ09SRElOR19NUyA9IDI0ICogNjAgKiA2MCAqIDEwMDA7IC8vIDI0IGhvdXJzXG4vLyBNYXhpbXVtIGFsbG93ZWQgdmFsdWUgZm9yIG1pbmltdW0gc2Vzc2lvbiByZWNvcmRpbmcgbGVuZ3RoXG52YXIgTUFYX1ZBTFVFX0ZPUl9NSU5fUkVDT1JESU5HX01TID0gOCAqIDEwMDA7IC8vIDggc2Vjb25kc1xuXG4vKlxuICogU2F2ZWQgcmVmZXJlbmNlcyB0byBsb25nIHZhcmlhYmxlIG5hbWVzLCBzbyB0aGF0IGNsb3N1cmUgY29tcGlsZXIgY2FuXG4gKiBtaW5pbWl6ZSBmaWxlIHNpemUuXG4gKi9cblxudmFyIEFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgRnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIE9ialByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICBzbGljZSA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICBoYXNPd25Qcm9wZXJ0eSA9IE9ialByb3RvLmhhc093blByb3BlcnR5LFxuICAgIHdpbmRvd0NvbnNvbGUgPSB3aW4uY29uc29sZSxcbiAgICBuYXZpZ2F0b3IgPSB3aW4ubmF2aWdhdG9yLFxuICAgIGRvY3VtZW50JDEgPSB3aW4uZG9jdW1lbnQsXG4gICAgd2luZG93T3BlcmEgPSB3aW4ub3BlcmEsXG4gICAgc2NyZWVuID0gd2luLnNjcmVlbixcbiAgICB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXG52YXIgbmF0aXZlQmluZCA9IEZ1bmNQcm90by5iaW5kLFxuICAgIG5hdGl2ZUZvckVhY2ggPSBBcnJheVByb3RvLmZvckVhY2gsXG4gICAgbmF0aXZlSW5kZXhPZiA9IEFycmF5UHJvdG8uaW5kZXhPZixcbiAgICBuYXRpdmVNYXAgPSBBcnJheVByb3RvLm1hcCxcbiAgICBuYXRpdmVJc0FycmF5ID0gQXJyYXkuaXNBcnJheSxcbiAgICBicmVha2VyID0ge307XG5cbnZhciBfID0ge1xuICAgIHRyaW06IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvVHJpbSNQb2x5ZmlsbFxuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJyk7XG4gICAgfVxufTtcblxuLy8gQ29uc29sZSBvdmVycmlkZVxudmFyIGNvbnNvbGUkMSA9IHtcbiAgICAvKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopfSAqL1xuICAgIGxvZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChDb25maWcuREVCVUcgJiYgIV8uaXNVbmRlZmluZWQod2luZG93Q29uc29sZSkgJiYgd2luZG93Q29uc29sZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmxvZy5hcHBseSh3aW5kb3dDb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGFyZ3VtZW50cywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUubG9nKGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKil9ICovXG4gICAgd2FybjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChDb25maWcuREVCVUcgJiYgIV8uaXNVbmRlZmluZWQod2luZG93Q29uc29sZSkgJiYgd2luZG93Q29uc29sZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbJ01peHBhbmVsIHdhcm5pbmc6J10uY29uY2F0KF8udG9BcnJheShhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS53YXJuLmFwcGx5KHdpbmRvd0NvbnNvbGUsIGFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGFyZ3MsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLndhcm4oYXJnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKX0gKi9cbiAgICBlcnJvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChDb25maWcuREVCVUcgJiYgIV8uaXNVbmRlZmluZWQod2luZG93Q29uc29sZSkgJiYgd2luZG93Q29uc29sZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbJ01peHBhbmVsIGVycm9yOiddLmNvbmNhdChfLnRvQXJyYXkoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUuZXJyb3IuYXBwbHkod2luZG93Q29uc29sZSwgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goYXJncywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUuZXJyb3IoYXJnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKX0gKi9cbiAgICBjcml0aWNhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZCh3aW5kb3dDb25zb2xlKSAmJiB3aW5kb3dDb25zb2xlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFsnTWl4cGFuZWwgZXJyb3I6J10uY29uY2F0KF8udG9BcnJheShhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5lcnJvci5hcHBseSh3aW5kb3dDb25zb2xlLCBhcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF8uZWFjaChhcmdzLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5lcnJvcihhcmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGxvZ19mdW5jX3dpdGhfcHJlZml4ID0gZnVuY3Rpb24oZnVuYywgcHJlZml4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBhcmd1bWVudHNbMF0gPSAnWycgKyBwcmVmaXggKyAnXSAnICsgYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseShjb25zb2xlJDEsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn07XG52YXIgY29uc29sZV93aXRoX3ByZWZpeCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxvZzogbG9nX2Z1bmNfd2l0aF9wcmVmaXgoY29uc29sZSQxLmxvZywgcHJlZml4KSxcbiAgICAgICAgZXJyb3I6IGxvZ19mdW5jX3dpdGhfcHJlZml4KGNvbnNvbGUkMS5lcnJvciwgcHJlZml4KSxcbiAgICAgICAgY3JpdGljYWw6IGxvZ19mdW5jX3dpdGhfcHJlZml4KGNvbnNvbGUkMS5jcml0aWNhbCwgcHJlZml4KVxuICAgIH07XG59O1xuXG5cbnZhciBzYWZld3JhcCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlJDEuY3JpdGljYWwoJ0ltcGxlbWVudGF0aW9uIGVycm9yLiBQbGVhc2UgdHVybiBvbiBkZWJ1ZyBhbmQgY29udGFjdCBzdXBwb3J0QG1peHBhbmVsLmNvbS4nKTtcbiAgICAgICAgICAgIGlmIChDb25maWcuREVCVUcpe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUkMS5jcml0aWNhbChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuXG52YXIgc2FmZXdyYXBDbGFzcyA9IGZ1bmN0aW9uKGtsYXNzKSB7XG4gICAgdmFyIHByb3RvID0ga2xhc3MucHJvdG90eXBlO1xuICAgIGZvciAodmFyIGZ1bmMgaW4gcHJvdG8pIHtcbiAgICAgICAgaWYgKHR5cGVvZihwcm90b1tmdW5jXSkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHByb3RvW2Z1bmNdID0gc2FmZXdyYXAocHJvdG9bZnVuY10pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG4vLyBVTkRFUlNDT1JFXG4vLyBFbWJlZCBwYXJ0IG9mIHRoZSBVbmRlcnNjb3JlIExpYnJhcnlcbl8uYmluZCA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQpIHtcbiAgICB2YXIgYXJncywgYm91bmQ7XG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVCaW5kLmFwcGx5KGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgfVxuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9XG4gICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgYm91bmQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3RvciA9IHt9O1xuICAgICAgICBjdG9yLnByb3RvdHlwZSA9IGZ1bmMucHJvdG90eXBlO1xuICAgICAgICB2YXIgc2VsZiA9IG5ldyBjdG9yKCk7XG4gICAgICAgIGN0b3IucHJvdG90eXBlID0gbnVsbDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkoc2VsZiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xufTtcblxuLyoqXG4gKiBAcGFyYW0geyo9fSBvYmpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uKik9fSBpdGVyYXRvclxuICogQHBhcmFtIHtPYmplY3Q9fSBjb250ZXh0XG4gKi9cbl8uZWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAob2JqID09PSBudWxsIHx8IG9iaiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5hdGl2ZUZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IG5hdGl2ZUZvckVhY2gpIHtcbiAgICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBvYmogJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGJyZWFrZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpba2V5XSwga2V5LCBvYmopID09PSBicmVha2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5fLmV4dGVuZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIF8uZWFjaChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZVtwcm9wXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbl8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8vIGZyb20gYSBjb21tZW50IG9uIGh0dHA6Ly9kYmoub3JnL2Riai8/cD0yODZcbi8vIGZhaWxzIG9uIG9ubHkgb25lIHZlcnkgcmFyZSBhbmQgZGVsaWJlcmF0ZSBjdXN0b20gb2JqZWN0OlxuLy8gdmFyIGJvbWIgPSB7IHRvU3RyaW5nIDogdW5kZWZpbmVkLCB2YWx1ZU9mOiBmdW5jdGlvbihvKSB7IHJldHVybiBcImZ1bmN0aW9uIEJPTUJBIVwiOyB9fTtcbl8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKGYpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gL15cXHMqXFxiZnVuY3Rpb25cXGIvLnRlc3QoZik7XG4gICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmosICdjYWxsZWUnKSk7XG59O1xuXG5fLnRvQXJyYXkgPSBmdW5jdGlvbihpdGVyYWJsZSkge1xuICAgIGlmICghaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoaXRlcmFibGUudG9BcnJheSkge1xuICAgICAgICByZXR1cm4gaXRlcmFibGUudG9BcnJheSgpO1xuICAgIH1cbiAgICBpZiAoXy5pc0FycmF5KGl0ZXJhYmxlKSkge1xuICAgICAgICByZXR1cm4gc2xpY2UuY2FsbChpdGVyYWJsZSk7XG4gICAgfVxuICAgIGlmIChfLmlzQXJndW1lbnRzKGl0ZXJhYmxlKSkge1xuICAgICAgICByZXR1cm4gc2xpY2UuY2FsbChpdGVyYWJsZSk7XG4gICAgfVxuICAgIHJldHVybiBfLnZhbHVlcyhpdGVyYWJsZSk7XG59O1xuXG5fLm1hcCA9IGZ1bmN0aW9uKGFyciwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBpZiAobmF0aXZlTWFwICYmIGFyci5tYXAgPT09IG5hdGl2ZU1hcCkge1xuICAgICAgICByZXR1cm4gYXJyLm1hcChjYWxsYmFjaywgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgXy5lYWNoKGFyciwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGNhbGxiYWNrLmNhbGwoY29udGV4dCwgaXRlbSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxufTtcblxuXy5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0ga2V5O1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xufTtcblxuXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5fLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIHRhcmdldCkge1xuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICBpZiAobmF0aXZlSW5kZXhPZiAmJiBvYmouaW5kZXhPZiA9PT0gbmF0aXZlSW5kZXhPZikge1xuICAgICAgICByZXR1cm4gb2JqLmluZGV4T2YodGFyZ2V0KSAhPSAtMTtcbiAgICB9XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKGZvdW5kIHx8IChmb3VuZCA9ICh2YWx1ZSA9PT0gdGFyZ2V0KSkpIHtcbiAgICAgICAgICAgIHJldHVybiBicmVha2VyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvdW5kO1xufTtcblxuXy5pbmNsdWRlcyA9IGZ1bmN0aW9uKHN0ciwgbmVlZGxlKSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xufTtcblxuLy8gVW5kZXJzY29yZSBBZGRvbnNcbl8uaW5oZXJpdCA9IGZ1bmN0aW9uKHN1YmNsYXNzLCBzdXBlcmNsYXNzKSB7XG4gICAgc3ViY2xhc3MucHJvdG90eXBlID0gbmV3IHN1cGVyY2xhc3MoKTtcbiAgICBzdWJjbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJjbGFzcztcbiAgICBzdWJjbGFzcy5zdXBlcmNsYXNzID0gc3VwZXJjbGFzcy5wcm90b3R5cGU7XG4gICAgcmV0dXJuIHN1YmNsYXNzO1xufTtcblxuXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAob2JqID09PSBPYmplY3Qob2JqKSAmJiAhXy5pc0FycmF5KG9iaikpO1xufTtcblxuXy5pc0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKF8uaXNPYmplY3Qob2JqKSkge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbl8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG59O1xuXG5fLmlzU3RyaW5nID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBTdHJpbmddJztcbn07XG5cbl8uaXNEYXRlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBEYXRlXSc7XG59O1xuXG5fLmlzTnVtYmVyID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBOdW1iZXJdJztcbn07XG5cbl8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xufTtcblxuXy5lbmNvZGVEYXRlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgaWYgKF8uaXNEYXRlKHYpKSB7XG4gICAgICAgICAgICBvYmpba10gPSBfLmZvcm1hdERhdGUodik7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdCh2KSkge1xuICAgICAgICAgICAgb2JqW2tdID0gXy5lbmNvZGVEYXRlcyh2KTsgLy8gcmVjdXJzZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbn07XG5cbl8udGltZXN0YW1wID0gZnVuY3Rpb24oKSB7XG4gICAgRGF0ZS5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICtuZXcgRGF0ZTtcbiAgICB9O1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xufTtcblxuXy5mb3JtYXREYXRlID0gZnVuY3Rpb24oZCkge1xuICAgIC8vIFlZWVktTU0tRERUSEg6TU06U1MgaW4gVVRDXG4gICAgZnVuY3Rpb24gcGFkKG4pIHtcbiAgICAgICAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4gOiBuO1xuICAgIH1cbiAgICByZXR1cm4gZC5nZXRVVENGdWxsWWVhcigpICsgJy0nICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDTW9udGgoKSArIDEpICsgJy0nICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDRGF0ZSgpKSArICdUJyArXG4gICAgICAgIHBhZChkLmdldFVUQ0hvdXJzKCkpICsgJzonICtcbiAgICAgICAgcGFkKGQuZ2V0VVRDTWludXRlcygpKSArICc6JyArXG4gICAgICAgIHBhZChkLmdldFVUQ1NlY29uZHMoKSk7XG59O1xuXG5fLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMgPSBmdW5jdGlvbihwKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIF8uZWFjaChwLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgIGlmIChfLmlzU3RyaW5nKHYpICYmIHYubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0W2tdID0gdjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG59O1xuXG4vKlxuICogdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgY29weSBvZiBvYmplY3QgYWZ0ZXIgdHJ1bmNhdGluZyBpdC4gIElmXG4gKiBwYXNzZWQgYW4gQXJyYXkgb3IgT2JqZWN0IGl0IHdpbGwgaXRlcmF0ZSB0aHJvdWdoIG9iaiBhbmRcbiAqIHRydW5jYXRlIGFsbCB0aGUgdmFsdWVzIHJlY3Vyc2l2ZWx5LlxuICovXG5fLnRydW5jYXRlID0gZnVuY3Rpb24ob2JqLCBsZW5ndGgpIHtcbiAgICB2YXIgcmV0O1xuXG4gICAgaWYgKHR5cGVvZihvYmopID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXQgPSBvYmouc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKF8uaXNBcnJheShvYmopKSB7XG4gICAgICAgIHJldCA9IFtdO1xuICAgICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHJldC5wdXNoKF8udHJ1bmNhdGUodmFsLCBsZW5ndGgpKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgcmV0ID0ge307XG4gICAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICAgICAgICByZXRba2V5XSA9IF8udHJ1bmNhdGUodmFsLCBsZW5ndGgpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBvYmo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldDtcbn07XG5cbl8uSlNPTkVuY29kZSA9IChmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24obWl4ZWRfdmFsKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG1peGVkX3ZhbDtcbiAgICAgICAgdmFyIHF1b3RlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgZXNjYXBhYmxlID0gL1tcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceDlmXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2c7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgICAgICAgICAgdmFyIG1ldGEgPSB7IC8vIHRhYmxlIG9mIGNoYXJhY3RlciBzdWJzdGl0dXRpb25zXG4gICAgICAgICAgICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAgICAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICAgICAgICAgJ1xcbic6ICdcXFxcbicsXG4gICAgICAgICAgICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAgICAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICAgICAgICAgJ1wiJzogJ1xcXFxcIicsXG4gICAgICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIHJldHVybiBlc2NhcGFibGUudGVzdChzdHJpbmcpID9cbiAgICAgICAgICAgICAgICAnXCInICsgc3RyaW5nLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gbWV0YVthXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyA/IGMgOlxuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICAgICAgICAgICAgfSkgKyAnXCInIDpcbiAgICAgICAgICAgICAgICAnXCInICsgc3RyaW5nICsgJ1wiJztcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc3RyID0gZnVuY3Rpb24oa2V5LCBob2xkZXIpIHtcbiAgICAgICAgICAgIHZhciBnYXAgPSAnJztcbiAgICAgICAgICAgIHZhciBpbmRlbnQgPSAnICAgICc7XG4gICAgICAgICAgICB2YXIgaSA9IDA7IC8vIFRoZSBsb29wIGNvdW50ZXIuXG4gICAgICAgICAgICB2YXIgayA9ICcnOyAvLyBUaGUgbWVtYmVyIGtleS5cbiAgICAgICAgICAgIHZhciB2ID0gJyc7IC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHZhciBtaW5kID0gZ2FwO1xuICAgICAgICAgICAgdmFyIHBhcnRpYWwgPSBbXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGhvbGRlcltrZXldO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaGFzIGEgdG9KU09OIG1ldGhvZCwgY2FsbCBpdCB0byBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdoYXQgaGFwcGVucyBuZXh0IGRlcGVuZHMgb24gdGhlIHZhbHVlJ3MgdHlwZS5cbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHF1b3RlKHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gRW5jb2RlIG5vbi1maW5pdGUgbnVtYmVycyBhcyBudWxsLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6ICdudWxsJztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuIG9yIG51bGwsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuIE5vdGU6XG4gICAgICAgICAgICAgICAgICAgIC8vIHR5cGVvZiBudWxsIGRvZXMgbm90IHByb2R1Y2UgJ251bGwnLiBUaGUgY2FzZSBpcyBpbmNsdWRlZCBoZXJlIGluXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdHlwZSBpcyAnb2JqZWN0Jywgd2UgbWlnaHQgYmUgZGVhbGluZyB3aXRoIGFuIG9iamVjdCBvciBhbiBhcnJheSBvclxuICAgICAgICAgICAgICAgICAgICAvLyBudWxsLlxuICAgICAgICAgICAgICAgICAgICAvLyBEdWUgdG8gYSBzcGVjaWZpY2F0aW9uIGJsdW5kZXIgaW4gRUNNQVNjcmlwdCwgdHlwZW9mIG51bGwgaXMgJ29iamVjdCcsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHdhdGNoIG91dCBmb3IgdGhhdCBjYXNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBhbiBhcnJheSB0byBob2xkIHRoZSBwYXJ0aWFsIHJlc3VsdHMgb2Ygc3RyaW5naWZ5aW5nIHRoaXMgb2JqZWN0IHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICBnYXAgKz0gaW5kZW50O1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSXMgdGhlIHZhbHVlIGFuIGFycmF5P1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdmFsdWUgaXMgYW4gYXJyYXkuIFN0cmluZ2lmeSBldmVyeSBlbGVtZW50LiBVc2UgbnVsbCBhcyBhIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3Igbm9uLUpTT04gdmFsdWVzLlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsW2ldID0gc3RyKGksIHZhbHVlKSB8fCAnbnVsbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBlbGVtZW50cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLCBhbmQgd3JhcCB0aGVtIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBicmFja2V0cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICdbXScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhcCA/ICdbXFxuJyArIGdhcCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluZCArICddJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdbJyArIHBhcnRpYWwuam9pbignLCcpICsgJ10nO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUga2V5cyBpbiB0aGUgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBtZW1iZXIgdGV4dHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcyxcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHdyYXAgdGhlbSBpbiBicmFjZXMuXG4gICAgICAgICAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICd7fScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FwID8gJ3snICsgcGFydGlhbC5qb2luKCcsJykgKyAnJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5kICsgJ30nIDogJ3snICsgcGFydGlhbC5qb2luKCcsJykgKyAnfSc7XG4gICAgICAgICAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgJycuXG4gICAgICAgIC8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG4gICAgICAgIHJldHVybiBzdHIoJycsIHtcbiAgICAgICAgICAgICcnOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9kb3VnbGFzY3JvY2tmb3JkL0pTT04tanMvYmxvYi9tYXN0ZXIvanNvbl9wYXJzZS5qc1xuICogU2xpZ2h0bHkgbW9kaWZpZWQgdG8gdGhyb3cgYSByZWFsIEVycm9yIHJhdGhlciB0aGFuIGEgUE9KT1xuICovXG5fLkpTT05EZWNvZGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGF0LCAvLyBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgICAgIGNoLCAvLyBUaGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICAgICAgZXNjYXBlZSA9IHtcbiAgICAgICAgICAgICdcIic6ICdcIicsXG4gICAgICAgICAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAgICAgICAgICcvJzogJy8nLFxuICAgICAgICAgICAgJ2InOiAnXFxiJyxcbiAgICAgICAgICAgICdmJzogJ1xcZicsXG4gICAgICAgICAgICAnbic6ICdcXG4nLFxuICAgICAgICAgICAgJ3InOiAnXFxyJyxcbiAgICAgICAgICAgICd0JzogJ1xcdCdcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dCxcbiAgICAgICAgZXJyb3IgPSBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICB2YXIgZSA9IG5ldyBTeW50YXhFcnJvcihtKTtcbiAgICAgICAgICAgIGUuYXQgPSBhdDtcbiAgICAgICAgICAgIGUudGV4dCA9IHRleHQ7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0ID0gZnVuY3Rpb24oYykge1xuICAgICAgICAgICAgLy8gSWYgYSBjIHBhcmFtZXRlciBpcyBwcm92aWRlZCwgdmVyaWZ5IHRoYXQgaXQgbWF0Y2hlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICBpZiAoYyAmJiBjICE9PSBjaCkge1xuICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCBcXCcnICsgYyArICdcXCcgaW5zdGVhZCBvZiBcXCcnICsgY2ggKyAnXFwnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIG5leHQgY2hhcmFjdGVyLiBXaGVuIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMsXG4gICAgICAgICAgICAvLyByZXR1cm4gdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICAgIGNoID0gdGV4dC5jaGFyQXQoYXQpO1xuICAgICAgICAgICAgYXQgKz0gMTtcbiAgICAgICAgICAgIHJldHVybiBjaDtcbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBhIG51bWJlciB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBudW1iZXIsXG4gICAgICAgICAgICAgICAgc3RyaW5nID0gJyc7XG5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gJy0nO1xuICAgICAgICAgICAgICAgIG5leHQoJy0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9ICcuJztcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCgpICYmIGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG51bWJlciA9ICtzdHJpbmc7XG4gICAgICAgICAgICBpZiAoIWlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignQmFkIG51bWJlcicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUGFyc2UgYSBzdHJpbmcgdmFsdWUuXG4gICAgICAgICAgICB2YXIgaGV4LFxuICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgc3RyaW5nID0gJycsXG4gICAgICAgICAgICAgICAgdWZmZmY7XG4gICAgICAgICAgICAvLyBXaGVuIHBhcnNpbmcgZm9yIHN0cmluZyB2YWx1ZXMsIHdlIG11c3QgbG9vayBmb3IgXCIgYW5kIFxcIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZXggPSBwYXJzZUludChuZXh0KCksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShoZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IHVmZmZmICogMTYgKyBoZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVmZmZmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVzY2FwZWVbY2hdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBlc2NhcGVlW2NoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcignQmFkIHN0cmluZycpO1xuICAgICAgICB9LFxuICAgICAgICB3aGl0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgd2hpbGUgKGNoICYmIGNoIDw9ICcgJykge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgd29yZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gdHJ1ZSwgZmFsc2UsIG9yIG51bGwuXG4gICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ3QnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgncicpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2YnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnYScpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ3MnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnZScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ24nKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcignVW5leHBlY3RlZCBcIicgKyBjaCArICdcIicpO1xuICAgICAgICB9LFxuICAgICAgICB2YWx1ZSwgLy8gUGxhY2Vob2xkZXIgZm9yIHRoZSB2YWx1ZSBmdW5jdGlvbi5cbiAgICAgICAgYXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGFuIGFycmF5IHZhbHVlLlxuICAgICAgICAgICAgdmFyIGFycmF5ID0gW107XG5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgnWycpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnXScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7IC8vIGVtcHR5IGFycmF5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHZhbHVlKCkpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgnXScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlcnJvcignQmFkIGFycmF5Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9iamVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUGFyc2UgYW4gb2JqZWN0IHZhbHVlLlxuICAgICAgICAgICAgdmFyIGtleSxcbiAgICAgICAgICAgICAgICBvYmplY3QgPSB7fTtcblxuICAgICAgICAgICAgaWYgKGNoID09PSAneycpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCd7Jyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7IC8vIGVtcHR5IG9iamVjdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ0R1cGxpY2F0ZSBrZXkgXCInICsga2V5ICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoJ0JhZCBvYmplY3QnKTtcbiAgICAgICAgfTtcblxuICAgIHZhbHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFBhcnNlIGEgSlNPTiB2YWx1ZS4gSXQgY291bGQgYmUgYW4gb2JqZWN0LCBhbiBhcnJheSwgYSBzdHJpbmcsXG4gICAgICAgIC8vIGEgbnVtYmVyLCBvciBhIHdvcmQuXG4gICAgICAgIHdoaXRlKCk7XG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3QoKTtcbiAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheSgpO1xuICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmcoKTtcbiAgICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXIoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoID49ICcwJyAmJiBjaCA8PSAnOScgPyBudW1iZXIoKSA6IHdvcmQoKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBSZXR1cm4gdGhlIGpzb25fcGFyc2UgZnVuY3Rpb24uIEl0IHdpbGwgaGF2ZSBhY2Nlc3MgdG8gYWxsIG9mIHRoZVxuICAgIC8vIGFib3ZlIGZ1bmN0aW9ucyBhbmQgdmFyaWFibGVzLlxuICAgIHJldHVybiBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICB0ZXh0ID0gc291cmNlO1xuICAgICAgICBhdCA9IDA7XG4gICAgICAgIGNoID0gJyAnO1xuICAgICAgICByZXN1bHQgPSB2YWx1ZSgpO1xuICAgICAgICB3aGl0ZSgpO1xuICAgICAgICBpZiAoY2gpIHtcbiAgICAgICAgICAgIGVycm9yKCdTeW50YXggZXJyb3InKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn0pKCk7XG5cbl8uYmFzZTY0RW5jb2RlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBiNjQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuICAgIHZhciBvMSwgbzIsIG8zLCBoMSwgaDIsIGgzLCBoNCwgYml0cywgaSA9IDAsXG4gICAgICAgIGFjID0gMCxcbiAgICAgICAgZW5jID0gJycsXG4gICAgICAgIHRtcF9hcnIgPSBbXTtcblxuICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhID0gXy51dGY4RW5jb2RlKGRhdGEpO1xuXG4gICAgZG8geyAvLyBwYWNrIHRocmVlIG9jdGV0cyBpbnRvIGZvdXIgaGV4ZXRzXG4gICAgICAgIG8xID0gZGF0YS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIG8yID0gZGF0YS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIG8zID0gZGF0YS5jaGFyQ29kZUF0KGkrKyk7XG5cbiAgICAgICAgYml0cyA9IG8xIDw8IDE2IHwgbzIgPDwgOCB8IG8zO1xuXG4gICAgICAgIGgxID0gYml0cyA+PiAxOCAmIDB4M2Y7XG4gICAgICAgIGgyID0gYml0cyA+PiAxMiAmIDB4M2Y7XG4gICAgICAgIGgzID0gYml0cyA+PiA2ICYgMHgzZjtcbiAgICAgICAgaDQgPSBiaXRzICYgMHgzZjtcblxuICAgICAgICAvLyB1c2UgaGV4ZXRzIHRvIGluZGV4IGludG8gYjY0LCBhbmQgYXBwZW5kIHJlc3VsdCB0byBlbmNvZGVkIHN0cmluZ1xuICAgICAgICB0bXBfYXJyW2FjKytdID0gYjY0LmNoYXJBdChoMSkgKyBiNjQuY2hhckF0KGgyKSArIGI2NC5jaGFyQXQoaDMpICsgYjY0LmNoYXJBdChoNCk7XG4gICAgfSB3aGlsZSAoaSA8IGRhdGEubGVuZ3RoKTtcblxuICAgIGVuYyA9IHRtcF9hcnIuam9pbignJyk7XG5cbiAgICBzd2l0Y2ggKGRhdGEubGVuZ3RoICUgMykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBlbmMgPSBlbmMuc2xpY2UoMCwgLTIpICsgJz09JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBlbmMgPSBlbmMuc2xpY2UoMCwgLTEpICsgJz0nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuYztcbn07XG5cbl8udXRmOEVuY29kZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHN0cmluZyA9IChzdHJpbmcgKyAnJykucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKS5yZXBsYWNlKC9cXHIvZywgJ1xcbicpO1xuXG4gICAgdmFyIHV0ZnRleHQgPSAnJyxcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZDtcbiAgICB2YXIgc3RyaW5nbCA9IDAsXG4gICAgICAgIG47XG5cbiAgICBzdGFydCA9IGVuZCA9IDA7XG4gICAgc3RyaW5nbCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICBmb3IgKG4gPSAwOyBuIDwgc3RyaW5nbDsgbisrKSB7XG4gICAgICAgIHZhciBjMSA9IHN0cmluZy5jaGFyQ29kZUF0KG4pO1xuICAgICAgICB2YXIgZW5jID0gbnVsbDtcblxuICAgICAgICBpZiAoYzEgPCAxMjgpIHtcbiAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICB9IGVsc2UgaWYgKChjMSA+IDEyNykgJiYgKGMxIDwgMjA0OCkpIHtcbiAgICAgICAgICAgIGVuYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMxID4+IDYpIHwgMTkyLCAoYzEgJiA2MykgfCAxMjgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW5jID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoYzEgPj4gMTIpIHwgMjI0LCAoKGMxID4+IDYpICYgNjMpIHwgMTI4LCAoYzEgJiA2MykgfCAxMjgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChlbmQgPiBzdGFydCkge1xuICAgICAgICAgICAgICAgIHV0ZnRleHQgKz0gc3RyaW5nLnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0ZnRleHQgKz0gZW5jO1xuICAgICAgICAgICAgc3RhcnQgPSBlbmQgPSBuICsgMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbmQgPiBzdGFydCkge1xuICAgICAgICB1dGZ0ZXh0ICs9IHN0cmluZy5zdWJzdHJpbmcoc3RhcnQsIHN0cmluZy5sZW5ndGgpO1xuICAgIH1cblxuICAgIHJldHVybiB1dGZ0ZXh0O1xufTtcblxuXy5VVUlEID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gdXNlIG5hdGl2ZSBDcnlwdG8gQVBJIHdoZW4gYXZhaWxhYmxlXG4gICAgICAgIHJldHVybiB3aW5bJ2NyeXB0byddWydyYW5kb21VVUlEJ10oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIGdlbmVyYXRpbmcgb3VyIG93biBVVUlEXG4gICAgICAgIC8vIGJhc2VkIG9uIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3Njd29vZC8zYmZmNDJjYzAwNWNjMjBhYjdlYzk4ZjBkOGUxZDU5ZFxuICAgICAgICB2YXIgdXVpZCA9IG5ldyBBcnJheSgzNik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzY7IGkrKykge1xuICAgICAgICAgICAgdXVpZFtpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE2KTtcbiAgICAgICAgfVxuICAgICAgICB1dWlkWzE0XSA9IDQ7IC8vIHNldCBiaXRzIDEyLTE1IG9mIHRpbWUtaGlnaC1hbmQtdmVyc2lvbiB0byAwMTAwXG4gICAgICAgIHV1aWRbMTldID0gdXVpZFsxOV0gJj0gLTU7IC8vIHNldCBiaXQgNiBvZiBjbG9jay1zZXEtYW5kLXJlc2VydmVkIHRvIHplcm9cbiAgICAgICAgdXVpZFsxOV0gPSB1dWlkWzE5XSB8PSAoMSA8PCAzKTsgLy8gc2V0IGJpdCA3IG9mIGNsb2NrLXNlcS1hbmQtcmVzZXJ2ZWQgdG8gb25lXG4gICAgICAgIHV1aWRbOF0gPSB1dWlkWzEzXSA9IHV1aWRbMThdID0gdXVpZFsyM10gPSAnLSc7XG5cbiAgICAgICAgcmV0dXJuIF8ubWFwKHV1aWQsIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4LnRvU3RyaW5nKDE2KTtcbiAgICAgICAgfSkuam9pbignJyk7XG4gICAgfVxufTtcblxuLy8gXy5pc0Jsb2NrZWRVQSgpXG4vLyBUaGlzIGlzIHRvIGJsb2NrIHZhcmlvdXMgd2ViIHNwaWRlcnMgZnJvbSBleGVjdXRpbmcgb3VyIEpTIGFuZFxuLy8gc2VuZGluZyBmYWxzZSB0cmFja2luZyBkYXRhXG52YXIgQkxPQ0tFRF9VQV9TVFJTID0gW1xuICAgICdhaHJlZnNib3QnLFxuICAgICdhaHJlZnNzaXRlYXVkaXQnLFxuICAgICdhbWF6b25ib3QnLFxuICAgICdiYWlkdXNwaWRlcicsXG4gICAgJ2Jpbmdib3QnLFxuICAgICdiaW5ncHJldmlldycsXG4gICAgJ2Nocm9tZS1saWdodGhvdXNlJyxcbiAgICAnZmFjZWJvb2tleHRlcm5hbCcsXG4gICAgJ3BldGFsYm90JyxcbiAgICAncGludGVyZXN0JyxcbiAgICAnc2NyZWFtaW5nIGZyb2cnLFxuICAgICd5YWhvbyEgc2x1cnAnLFxuICAgICd5YW5kZXgnLFxuXG4gICAgLy8gYSB3aG9sZSBidW5jaCBvZiBnb29nLXNwZWNpZmljIGNyYXdsZXJzXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vc2VhcmNoL2RvY3MvYWR2YW5jZWQvY3Jhd2xpbmcvb3ZlcnZpZXctZ29vZ2xlLWNyYXdsZXJzXG4gICAgJ2Fkc2JvdC1nb29nbGUnLFxuICAgICdhcGlzLWdvb2dsZScsXG4gICAgJ2R1cGxleHdlYi1nb29nbGUnLFxuICAgICdmZWVkZmV0Y2hlci1nb29nbGUnLFxuICAgICdnb29nbGUgZmF2aWNvbicsXG4gICAgJ2dvb2dsZSB3ZWIgcHJldmlldycsXG4gICAgJ2dvb2dsZS1yZWFkLWFsb3VkJyxcbiAgICAnZ29vZ2xlYm90JyxcbiAgICAnZ29vZ2xld2VibGlnaHQnLFxuICAgICdtZWRpYXBhcnRuZXJzLWdvb2dsZScsXG4gICAgJ3N0b3JlYm90LWdvb2dsZSdcbl07XG5fLmlzQmxvY2tlZFVBID0gZnVuY3Rpb24odWEpIHtcbiAgICB2YXIgaTtcbiAgICB1YSA9IHVhLnRvTG93ZXJDYXNlKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IEJMT0NLRURfVUFfU1RSUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodWEuaW5kZXhPZihCTE9DS0VEX1VBX1NUUlNbaV0pICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdD19IGZvcm1kYXRhXG4gKiBAcGFyYW0ge3N0cmluZz19IGFyZ19zZXBhcmF0b3JcbiAqL1xuXy5IVFRQQnVpbGRRdWVyeSA9IGZ1bmN0aW9uKGZvcm1kYXRhLCBhcmdfc2VwYXJhdG9yKSB7XG4gICAgdmFyIHVzZV92YWwsIHVzZV9rZXksIHRtcF9hcnIgPSBbXTtcblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKGFyZ19zZXBhcmF0b3IpKSB7XG4gICAgICAgIGFyZ19zZXBhcmF0b3IgPSAnJic7XG4gICAgfVxuXG4gICAgXy5lYWNoKGZvcm1kYXRhLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgICB1c2VfdmFsID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbC50b1N0cmluZygpKTtcbiAgICAgICAgdXNlX2tleSA9IGVuY29kZVVSSUNvbXBvbmVudChrZXkpO1xuICAgICAgICB0bXBfYXJyW3RtcF9hcnIubGVuZ3RoXSA9IHVzZV9rZXkgKyAnPScgKyB1c2VfdmFsO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRtcF9hcnIuam9pbihhcmdfc2VwYXJhdG9yKTtcbn07XG5cbl8uZ2V0UXVlcnlQYXJhbSA9IGZ1bmN0aW9uKHVybCwgcGFyYW0pIHtcbiAgICAvLyBFeHBlY3RzIGEgcmF3IFVSTFxuXG4gICAgcGFyYW0gPSBwYXJhbS5yZXBsYWNlKC9bW10vZywgJ1xcXFxbJykucmVwbGFjZSgvW1xcXV0vZywgJ1xcXFxdJyk7XG4gICAgdmFyIHJlZ2V4UyA9ICdbXFxcXD8mXScgKyBwYXJhbSArICc9KFteJiNdKiknLFxuICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAocmVnZXhTKSxcbiAgICAgICAgcmVzdWx0cyA9IHJlZ2V4LmV4ZWModXJsKTtcbiAgICBpZiAocmVzdWx0cyA9PT0gbnVsbCB8fCAocmVzdWx0cyAmJiB0eXBlb2YocmVzdWx0c1sxXSkgIT09ICdzdHJpbmcnICYmIHJlc3VsdHNbMV0ubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdHNbMV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBkZWNvZGVVUklDb21wb25lbnQocmVzdWx0KTtcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcignU2tpcHBpbmcgZGVjb2RpbmcgZm9yIG1hbGZvcm1lZCBxdWVyeSBwYXJhbTogJyArIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICB9XG59O1xuXG5cbi8vIF8uY29va2llXG4vLyBNZXRob2RzIHBhcnRpYWxseSBib3Jyb3dlZCBmcm9tIHF1aXJrc21vZGUub3JnL2pzL2Nvb2tpZXMuaHRtbFxuXy5jb29raWUgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBuYW1lRVEgPSBuYW1lICsgJz0nO1xuICAgICAgICB2YXIgY2EgPSBkb2N1bWVudCQxLmNvb2tpZS5zcGxpdCgnOycpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYyA9IGNhW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09ICcgJykge1xuICAgICAgICAgICAgICAgIGMgPSBjLnN1YnN0cmluZygxLCBjLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYy5pbmRleE9mKG5hbWVFUSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGMuc3Vic3RyaW5nKG5hbWVFUS5sZW5ndGgsIGMubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIHBhcnNlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBjb29raWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb29raWUgPSBfLkpTT05EZWNvZGUoXy5jb29raWUuZ2V0KG5hbWUpKSB8fCB7fTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBub29wXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvb2tpZTtcbiAgICB9LFxuXG4gICAgc2V0X3NlY29uZHM6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBzZWNvbmRzLCBpc19jcm9zc19zdWJkb21haW4sIGlzX3NlY3VyZSwgaXNfY3Jvc3Nfc2l0ZSwgZG9tYWluX292ZXJyaWRlKSB7XG4gICAgICAgIHZhciBjZG9tYWluID0gJycsXG4gICAgICAgICAgICBleHBpcmVzID0gJycsXG4gICAgICAgICAgICBzZWN1cmUgPSAnJztcblxuICAgICAgICBpZiAoZG9tYWluX292ZXJyaWRlKSB7XG4gICAgICAgICAgICBjZG9tYWluID0gJzsgZG9tYWluPScgKyBkb21haW5fb3ZlcnJpZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNfY3Jvc3Nfc3ViZG9tYWluKSB7XG4gICAgICAgICAgICB2YXIgZG9tYWluID0gZXh0cmFjdF9kb21haW4oZG9jdW1lbnQkMS5sb2NhdGlvbi5ob3N0bmFtZSk7XG4gICAgICAgICAgICBjZG9tYWluID0gZG9tYWluID8gJzsgZG9tYWluPS4nICsgZG9tYWluIDogJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2Vjb25kcykge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgKHNlY29uZHMgKiAxMDAwKSk7XG4gICAgICAgICAgICBleHBpcmVzID0gJzsgZXhwaXJlcz0nICsgZGF0ZS50b0dNVFN0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzX2Nyb3NzX3NpdGUpIHtcbiAgICAgICAgICAgIGlzX3NlY3VyZSA9IHRydWU7XG4gICAgICAgICAgICBzZWN1cmUgPSAnOyBTYW1lU2l0ZT1Ob25lJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfc2VjdXJlKSB7XG4gICAgICAgICAgICBzZWN1cmUgKz0gJzsgc2VjdXJlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50JDEuY29va2llID0gbmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkgKyBleHBpcmVzICsgJzsgcGF0aD0vJyArIGNkb21haW4gKyBzZWN1cmU7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24obmFtZSwgdmFsdWUsIGRheXMsIGlzX2Nyb3NzX3N1YmRvbWFpbiwgaXNfc2VjdXJlLCBpc19jcm9zc19zaXRlLCBkb21haW5fb3ZlcnJpZGUpIHtcbiAgICAgICAgdmFyIGNkb21haW4gPSAnJywgZXhwaXJlcyA9ICcnLCBzZWN1cmUgPSAnJztcblxuICAgICAgICBpZiAoZG9tYWluX292ZXJyaWRlKSB7XG4gICAgICAgICAgICBjZG9tYWluID0gJzsgZG9tYWluPScgKyBkb21haW5fb3ZlcnJpZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNfY3Jvc3Nfc3ViZG9tYWluKSB7XG4gICAgICAgICAgICB2YXIgZG9tYWluID0gZXh0cmFjdF9kb21haW4oZG9jdW1lbnQkMS5sb2NhdGlvbi5ob3N0bmFtZSk7XG4gICAgICAgICAgICBjZG9tYWluID0gZG9tYWluID8gJzsgZG9tYWluPS4nICsgZG9tYWluIDogJyc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgKGRheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XG4gICAgICAgICAgICBleHBpcmVzID0gJzsgZXhwaXJlcz0nICsgZGF0ZS50b0dNVFN0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzX2Nyb3NzX3NpdGUpIHtcbiAgICAgICAgICAgIGlzX3NlY3VyZSA9IHRydWU7XG4gICAgICAgICAgICBzZWN1cmUgPSAnOyBTYW1lU2l0ZT1Ob25lJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfc2VjdXJlKSB7XG4gICAgICAgICAgICBzZWN1cmUgKz0gJzsgc2VjdXJlJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdfY29va2llX3ZhbCA9IG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpICsgZXhwaXJlcyArICc7IHBhdGg9LycgKyBjZG9tYWluICsgc2VjdXJlO1xuICAgICAgICBkb2N1bWVudCQxLmNvb2tpZSA9IG5ld19jb29raWVfdmFsO1xuICAgICAgICByZXR1cm4gbmV3X2Nvb2tpZV92YWw7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24obmFtZSwgaXNfY3Jvc3Nfc3ViZG9tYWluLCBkb21haW5fb3ZlcnJpZGUpIHtcbiAgICAgICAgXy5jb29raWUuc2V0KG5hbWUsICcnLCAtMSwgaXNfY3Jvc3Nfc3ViZG9tYWluLCBmYWxzZSwgZmFsc2UsIGRvbWFpbl9vdmVycmlkZSk7XG4gICAgfVxufTtcblxudmFyIF90ZXN0U3RvcmFnZVN1cHBvcnRlZCA9IGZ1bmN0aW9uIChzdG9yYWdlKSB7XG4gICAgdmFyIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIGtleSA9ICdfX21wbHNzXycgKyBjaGVhcF9ndWlkKDgpLFxuICAgICAgICAgICAgdmFsID0gJ3h5eic7XG4gICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbCk7XG4gICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5KSAhPT0gdmFsKSB7XG4gICAgICAgICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBzdXBwb3J0ZWQ7XG59O1xuXG52YXIgX2xvY2FsU3RvcmFnZVN1cHBvcnRlZCA9IG51bGw7XG52YXIgbG9jYWxTdG9yYWdlU3VwcG9ydGVkID0gZnVuY3Rpb24oc3RvcmFnZSwgZm9yY2VDaGVjaykge1xuICAgIGlmIChfbG9jYWxTdG9yYWdlU3VwcG9ydGVkICE9PSBudWxsICYmICFmb3JjZUNoZWNrKSB7XG4gICAgICAgIHJldHVybiBfbG9jYWxTdG9yYWdlU3VwcG9ydGVkO1xuICAgIH1cbiAgICByZXR1cm4gX2xvY2FsU3RvcmFnZVN1cHBvcnRlZCA9IF90ZXN0U3RvcmFnZVN1cHBvcnRlZChzdG9yYWdlIHx8IHdpbi5sb2NhbFN0b3JhZ2UpO1xufTtcblxudmFyIF9zZXNzaW9uU3RvcmFnZVN1cHBvcnRlZCA9IG51bGw7XG52YXIgc2Vzc2lvblN0b3JhZ2VTdXBwb3J0ZWQgPSBmdW5jdGlvbihzdG9yYWdlLCBmb3JjZUNoZWNrKSB7XG4gICAgaWYgKF9zZXNzaW9uU3RvcmFnZVN1cHBvcnRlZCAhPT0gbnVsbCAmJiAhZm9yY2VDaGVjaykge1xuICAgICAgICByZXR1cm4gX3Nlc3Npb25TdG9yYWdlU3VwcG9ydGVkO1xuICAgIH1cbiAgICByZXR1cm4gX3Nlc3Npb25TdG9yYWdlU3VwcG9ydGVkID0gX3Rlc3RTdG9yYWdlU3VwcG9ydGVkKHN0b3JhZ2UgfHwgd2luLnNlc3Npb25TdG9yYWdlKTtcbn07XG5cbmZ1bmN0aW9uIF9zdG9yYWdlV3JhcHBlcihzdG9yYWdlLCBuYW1lLCBpc19zdXBwb3J0ZWRfZm4pIHtcbiAgICB2YXIgbG9nX2Vycm9yID0gZnVuY3Rpb24obXNnKSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcihuYW1lICsgJyBlcnJvcjogJyArIG1zZyk7XG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGlzX3N1cHBvcnRlZDogZnVuY3Rpb24oZm9yY2VDaGVjaykge1xuICAgICAgICAgICAgdmFyIHN1cHBvcnRlZCA9IGlzX3N1cHBvcnRlZF9mbihzdG9yYWdlLCBmb3JjZUNoZWNrKTtcbiAgICAgICAgICAgIGlmICghc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKG5hbWUgKyAnIHVuc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3VwcG9ydGVkO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogbG9nX2Vycm9yLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dfZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBwYXJzZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfLkpTT05EZWNvZGUoc3RvcmFnZS5nZXRJdGVtKGtleSkpIHx8IHt9O1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dfZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dfZXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5cbl8ubG9jYWxTdG9yYWdlID0gX3N0b3JhZ2VXcmFwcGVyKHdpbi5sb2NhbFN0b3JhZ2UsICdsb2NhbFN0b3JhZ2UnLCBsb2NhbFN0b3JhZ2VTdXBwb3J0ZWQpO1xuXy5zZXNzaW9uU3RvcmFnZSA9IF9zdG9yYWdlV3JhcHBlcih3aW4uc2Vzc2lvblN0b3JhZ2UsICdzZXNzaW9uU3RvcmFnZScsIHNlc3Npb25TdG9yYWdlU3VwcG9ydGVkKTtcblxuXy5yZWdpc3Rlcl9ldmVudCA9IChmdW5jdGlvbigpIHtcbiAgICAvLyB3cml0dGVuIGJ5IERlYW4gRWR3YXJkcywgMjAwNVxuICAgIC8vIHdpdGggaW5wdXQgZnJvbSBUaW5vIFppamRlbCAtIGNyaXNwQHhzNGFsbC5ubFxuICAgIC8vIHdpdGggaW5wdXQgZnJvbSBDYXJsIFN2ZXJyZSAtIG1haWxAY2FybHN2ZXJyZS5jb21cbiAgICAvLyB3aXRoIGlucHV0IGZyb20gTWl4cGFuZWxcbiAgICAvLyBodHRwOi8vZGVhbi5lZHdhcmRzLm5hbWUvd2VibG9nLzIwMDUvMTAvYWRkLWV2ZW50L1xuICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzE5MzA0NDBcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLiopfSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gb2xkU2Nob29sXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdXNlQ2FwdHVyZVxuICAgICAqL1xuICAgIHZhciByZWdpc3Rlcl9ldmVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIG9sZFNjaG9vbCwgdXNlQ2FwdHVyZSkge1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcignTm8gdmFsaWQgZWxlbWVudCBwcm92aWRlZCB0byByZWdpc3Rlcl9ldmVudCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciAmJiAhb2xkU2Nob29sKSB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgISF1c2VDYXB0dXJlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvbnR5cGUgPSAnb24nICsgdHlwZTtcbiAgICAgICAgICAgIHZhciBvbGRfaGFuZGxlciA9IGVsZW1lbnRbb250eXBlXTsgLy8gY2FuIGJlIHVuZGVmaW5lZFxuICAgICAgICAgICAgZWxlbWVudFtvbnR5cGVdID0gbWFrZUhhbmRsZXIoZWxlbWVudCwgaGFuZGxlciwgb2xkX2hhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VIYW5kbGVyKGVsZW1lbnQsIG5ld19oYW5kbGVyLCBvbGRfaGFuZGxlcnMpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgZXZlbnQgPSBldmVudCB8fCBmaXhFdmVudCh3aW4uZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyB0aGlzIGJhc2ljYWxseSBoYXBwZW5zIGluIGZpcmVmb3ggd2hlbmV2ZXIgYW5vdGhlciBzY3JpcHRcbiAgICAgICAgICAgIC8vIG92ZXJ3cml0ZXMgdGhlIG9ubG9hZCBjYWxsYmFjayBhbmQgZG9lc24ndCBwYXNzIHRoZSBldmVudFxuICAgICAgICAgICAgLy8gb2JqZWN0IHRvIHByZXZpb3VzbHkgZGVmaW5lZCBjYWxsYmFja3MuICBBbGwgdGhlIGJyb3dzZXJzXG4gICAgICAgICAgICAvLyB0aGF0IGRvbid0IGRlZmluZSB3aW5kb3cuZXZlbnQgaW1wbGVtZW50IGFkZEV2ZW50TGlzdGVuZXJcbiAgICAgICAgICAgIC8vIHNvIHRoZSBkb21fbG9hZGVkIGhhbmRsZXIgd2lsbCBzdGlsbCBiZSBmaXJlZCBhcyB1c3VhbC5cbiAgICAgICAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRfcmVzdWx0LCBuZXdfcmVzdWx0O1xuXG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9sZF9oYW5kbGVycykpIHtcbiAgICAgICAgICAgICAgICBvbGRfcmVzdWx0ID0gb2xkX2hhbmRsZXJzKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld19yZXN1bHQgPSBuZXdfaGFuZGxlci5jYWxsKGVsZW1lbnQsIGV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKChmYWxzZSA9PT0gb2xkX3Jlc3VsdCkgfHwgKGZhbHNlID09PSBuZXdfcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpeEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQgPSBmaXhFdmVudC5wcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGZpeEV2ZW50LnN0b3BQcm9wYWdhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICAgIGZpeEV2ZW50LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9O1xuICAgIGZpeEV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfTtcblxuICAgIHJldHVybiByZWdpc3Rlcl9ldmVudDtcbn0pKCk7XG5cblxudmFyIFRPS0VOX01BVENIX1JFR0VYID0gbmV3IFJlZ0V4cCgnXihcXFxcdyopXFxcXFsoXFxcXHcrKShbPX5cXFxcfFxcXFxeXFxcXCRcXFxcKl0/KT0/XCI/KFteXFxcXF1cIl0qKVwiP1xcXFxdJCcpO1xuXG5fLmRvbV9xdWVyeSA9IChmdW5jdGlvbigpIHtcbiAgICAvKiBkb2N1bWVudC5nZXRFbGVtZW50c0J5U2VsZWN0b3Ioc2VsZWN0b3IpXG4gICAgLSByZXR1cm5zIGFuIGFycmF5IG9mIGVsZW1lbnQgb2JqZWN0cyBmcm9tIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gICAgbWF0Y2hpbmcgdGhlIENTUyBzZWxlY3Rvci4gU2VsZWN0b3JzIGNhbiBjb250YWluIGVsZW1lbnQgbmFtZXMsXG4gICAgY2xhc3MgbmFtZXMgYW5kIGlkcyBhbmQgY2FuIGJlIG5lc3RlZC4gRm9yIGV4YW1wbGU6XG5cbiAgICBlbGVtZW50cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlTZWxlY3RvcignZGl2I21haW4gcCBhLmV4dGVybmFsJylcblxuICAgIFdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIGFsbCAnYScgZWxlbWVudHMgd2l0aCAnZXh0ZXJuYWwnIGluIHRoZWlyXG4gICAgY2xhc3MgYXR0cmlidXRlIHRoYXQgYXJlIGNvbnRhaW5lZCBpbnNpZGUgJ3AnIGVsZW1lbnRzIHRoYXQgYXJlXG4gICAgY29udGFpbmVkIGluc2lkZSB0aGUgJ2RpdicgZWxlbWVudCB3aGljaCBoYXMgaWQ9XCJtYWluXCJcblxuICAgIE5ldyBpbiB2ZXJzaW9uIDAuNDogU3VwcG9ydCBmb3IgQ1NTMiBhbmQgQ1NTMyBhdHRyaWJ1dGUgc2VsZWN0b3JzOlxuICAgIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXG4gICAgVmVyc2lvbiAwLjQgLSBTaW1vbiBXaWxsaXNvbiwgTWFyY2ggMjV0aCAyMDAzXG4gICAgLS0gV29ya3MgaW4gUGhvZW5peCAwLjUsIE1vemlsbGEgMS4zLCBPcGVyYSA3LCBJbnRlcm5ldCBFeHBsb3JlciA2LCBJbnRlcm5ldCBFeHBsb3JlciA1IG9uIFdpbmRvd3NcbiAgICAtLSBPcGVyYSA3IGZhaWxzXG5cbiAgICBWZXJzaW9uIDAuNSAtIENhcmwgU3ZlcnJlLCBKYW4gN3RoIDIwMTNcbiAgICAtLSBOb3cgdXNlcyBqUXVlcnktZXNxdWUgYGhhc0NsYXNzYCBmb3IgdGVzdGluZyBjbGFzcyBuYW1lXG4gICAgZXF1YWxpdHkuICBUaGlzIGZpeGVzIGEgYnVnIHJlbGF0ZWQgdG8gJy0nIGNoYXJhY3RlcnMgYmVpbmdcbiAgICBjb25zaWRlcmVkIG5vdCBwYXJ0IG9mIGEgJ3dvcmQnIGluIHJlZ2V4LlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBnZXRBbGxDaGlsZHJlbihlKSB7XG4gICAgICAgIC8vIFJldHVybnMgYWxsIGNoaWxkcmVuIG9mIGVsZW1lbnQuIFdvcmthcm91bmQgcmVxdWlyZWQgZm9yIElFNS9XaW5kb3dzLiBVZ2guXG4gICAgICAgIHJldHVybiBlLmFsbCA/IGUuYWxsIDogZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpO1xuICAgIH1cblxuICAgIHZhciBiYWRfd2hpdGVzcGFjZSA9IC9bXFx0XFxyXFxuXS9nO1xuXG4gICAgZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbSwgc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICcgJyArIHNlbGVjdG9yICsgJyAnO1xuICAgICAgICByZXR1cm4gKCgnICcgKyBlbGVtLmNsYXNzTmFtZSArICcgJykucmVwbGFjZShiYWRfd2hpdGVzcGFjZSwgJyAnKS5pbmRleE9mKGNsYXNzTmFtZSkgPj0gMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RWxlbWVudHNCeVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gZmFpbCBncmFjZWZ1bGx5IGluIGxlc3NlciBicm93c2Vyc1xuICAgICAgICBpZiAoIWRvY3VtZW50JDEuZ2V0RWxlbWVudHNCeVRhZ05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGxpdCBzZWxlY3RvciBpbiB0byB0b2tlbnNcbiAgICAgICAgdmFyIHRva2VucyA9IHNlbGVjdG9yLnNwbGl0KCcgJyk7XG4gICAgICAgIHZhciB0b2tlbiwgYml0cywgdGFnTmFtZSwgZm91bmQsIGZvdW5kQ291bnQsIGksIGosIGssIGVsZW1lbnRzLCBjdXJyZW50Q29udGV4dEluZGV4O1xuICAgICAgICB2YXIgY3VycmVudENvbnRleHQgPSBbZG9jdW1lbnQkMV07XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgICAgICAgICAgaWYgKHRva2VuLmluZGV4T2YoJyMnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9rZW4gaXMgYW4gSUQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBiaXRzID0gdG9rZW4uc3BsaXQoJyMnKTtcbiAgICAgICAgICAgICAgICB0YWdOYW1lID0gYml0c1swXTtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBiaXRzWzFdO1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQkMS5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50IHx8ICh0YWdOYW1lICYmIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPSB0YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IG5vdCBmb3VuZCBvciB0YWcgd2l0aCB0aGF0IElEIG5vdCBmb3VuZCwgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2V0IGN1cnJlbnRDb250ZXh0IHRvIGNvbnRhaW4ganVzdCB0aGlzIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IFtlbGVtZW50XTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcCB0byBuZXh0IHRva2VuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4uaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBUb2tlbiBjb250YWlucyBhIGNsYXNzIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgYml0cyA9IHRva2VuLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgdGFnTmFtZSA9IGJpdHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGJpdHNbMV07XG4gICAgICAgICAgICAgICAgaWYgKCF0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWUgPSAnKic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdldCBlbGVtZW50cyBtYXRjaGluZyB0YWcsIGZpbHRlciB0aGVtIGZvciBjbGFzcyBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGZvdW5kID0gW107XG4gICAgICAgICAgICAgICAgZm91bmRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGN1cnJlbnRDb250ZXh0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBnZXRBbGxDaGlsZHJlbihjdXJyZW50Q29udGV4dFtqXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGN1cnJlbnRDb250ZXh0W2pdLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBlbGVtZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRbZm91bmRDb3VudCsrXSA9IGVsZW1lbnRzW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gW107XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGZvdW5kLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZFtqXS5jbGFzc05hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNTdHJpbmcoZm91bmRbal0uY2xhc3NOYW1lKSAmJiAvLyBzb21lIFNWRyBlbGVtZW50cyBoYXZlIGNsYXNzTmFtZXMgd2hpY2ggYXJlIG5vdCBzdHJpbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDbGFzcyhmb3VuZFtqXSwgY2xhc3NOYW1lKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0W2N1cnJlbnRDb250ZXh0SW5kZXgrK10gPSBmb3VuZFtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcCB0byBuZXh0IHRva2VuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb2RlIHRvIGRlYWwgd2l0aCBhdHRyaWJ1dGUgc2VsZWN0b3JzXG4gICAgICAgICAgICB2YXIgdG9rZW5fbWF0Y2ggPSB0b2tlbi5tYXRjaChUT0tFTl9NQVRDSF9SRUdFWCk7XG4gICAgICAgICAgICBpZiAodG9rZW5fbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB0YWdOYW1lID0gdG9rZW5fbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gdG9rZW5fbWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJPcGVyYXRvciA9IHRva2VuX21hdGNoWzNdO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSB0b2tlbl9tYXRjaFs0XTtcbiAgICAgICAgICAgICAgICBpZiAoIXRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnTmFtZSA9ICcqJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gR3JhYiBhbGwgb2YgdGhlIHRhZ05hbWUgZWxlbWVudHMgd2l0aGluIGN1cnJlbnQgY29udGV4dFxuICAgICAgICAgICAgICAgIGZvdW5kID0gW107XG4gICAgICAgICAgICAgICAgZm91bmRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGN1cnJlbnRDb250ZXh0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBnZXRBbGxDaGlsZHJlbihjdXJyZW50Q29udGV4dFtqXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGN1cnJlbnRDb250ZXh0W2pdLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBlbGVtZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRbZm91bmRDb3VudCsrXSA9IGVsZW1lbnRzW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gW107XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNoZWNrRnVuY3Rpb247IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIHRvIGZpbHRlciB0aGUgZWxlbWVudHNcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF0dHJPcGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICc9JzogLy8gRXF1YWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkgPT0gYXR0clZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnfic6IC8vIE1hdGNoIG9uZSBvZiBzcGFjZSBzZXBlcmF0ZWQgd29yZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkubWF0Y2gobmV3IFJlZ0V4cCgnXFxcXGInICsgYXR0clZhbHVlICsgJ1xcXFxiJykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnfCc6IC8vIE1hdGNoIHN0YXJ0IHdpdGggdmFsdWUgZm9sbG93ZWQgYnkgb3B0aW9uYWwgaHlwaGVuXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLm1hdGNoKG5ldyBSZWdFeHAoJ14nICsgYXR0clZhbHVlICsgJy0/JykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXic6IC8vIE1hdGNoIHN0YXJ0cyB3aXRoIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLmluZGV4T2YoYXR0clZhbHVlKSA9PT0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyQnOiAvLyBNYXRjaCBlbmRzIHdpdGggdmFsdWUgLSBmYWlscyB3aXRoIFwiV2FybmluZ1wiIGluIE9wZXJhIDdcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkubGFzdEluZGV4T2YoYXR0clZhbHVlKSA9PSBlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkubGVuZ3RoIC0gYXR0clZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyonOiAvLyBNYXRjaCBlbmRzIHdpdGggdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkuaW5kZXhPZihhdHRyVmFsdWUpID4gLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCB0ZXN0IGZvciBleGlzdGVuY2Ugb2YgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IFtdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBmb3VuZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tGdW5jdGlvbihmb3VuZFtqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0W2N1cnJlbnRDb250ZXh0SW5kZXgrK10gPSBmb3VuZFtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhbGVydCgnQXR0cmlidXRlIFNlbGVjdG9yOiAnK3RhZ05hbWUrJyAnK2F0dHJOYW1lKycgJythdHRyT3BlcmF0b3IrJyAnK2F0dHJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIFNraXAgdG8gbmV4dCB0b2tlblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHRva2VuIGlzIEpVU1QgYW4gZWxlbWVudCAobm90IGEgY2xhc3Mgb3IgSUQgc2VsZWN0b3IpXG4gICAgICAgICAgICB0YWdOYW1lID0gdG9rZW47XG4gICAgICAgICAgICBmb3VuZCA9IFtdO1xuICAgICAgICAgICAgZm91bmRDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY3VycmVudENvbnRleHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGN1cnJlbnRDb250ZXh0W2pdLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBlbGVtZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZFtmb3VuZENvdW50KytdID0gZWxlbWVudHNba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudENvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgIGlmIChfLmlzRWxlbWVudChxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbcXVlcnldO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QocXVlcnkpICYmICFfLmlzVW5kZWZpbmVkKHF1ZXJ5Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFbGVtZW50c0J5U2VsZWN0b3IuY2FsbCh0aGlzLCBxdWVyeSk7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxudmFyIENBTVBBSUdOX0tFWVdPUkRTID0gWyd1dG1fc291cmNlJywgJ3V0bV9tZWRpdW0nLCAndXRtX2NhbXBhaWduJywgJ3V0bV9jb250ZW50JywgJ3V0bV90ZXJtJywgJ3V0bV9pZCcsICd1dG1fc291cmNlX3BsYXRmb3JtJywndXRtX2NhbXBhaWduX2lkJywgJ3V0bV9jcmVhdGl2ZV9mb3JtYXQnLCAndXRtX21hcmtldGluZ190YWN0aWMnXTtcbnZhciBDTElDS19JRFMgPSBbJ2RjbGlkJywgJ2ZiY2xpZCcsICdnY2xpZCcsICdrb19jbGlja19pZCcsICdsaV9mYXRfaWQnLCAnbXNjbGtpZCcsICdzY2NpZCcsICd0dGNsaWQnLCAndHdjbGlkJywgJ3dicmFpZCddO1xuXG5fLmluZm8gPSB7XG4gICAgY2FtcGFpZ25QYXJhbXM6IGZ1bmN0aW9uKGRlZmF1bHRfdmFsdWUpIHtcbiAgICAgICAgdmFyIGt3ID0gJycsXG4gICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgXy5lYWNoKENBTVBBSUdOX0tFWVdPUkRTLCBmdW5jdGlvbihrd2tleSkge1xuICAgICAgICAgICAga3cgPSBfLmdldFF1ZXJ5UGFyYW0oZG9jdW1lbnQkMS5VUkwsIGt3a2V5KTtcbiAgICAgICAgICAgIGlmIChrdy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba3drZXldID0ga3c7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlZmF1bHRfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trd2tleV0gPSBkZWZhdWx0X3ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH0sXG5cbiAgICBjbGlja1BhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZCA9ICcnLFxuICAgICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgIF8uZWFjaChDTElDS19JRFMsIGZ1bmN0aW9uKGlka2V5KSB7XG4gICAgICAgICAgICBpZCA9IF8uZ2V0UXVlcnlQYXJhbShkb2N1bWVudCQxLlVSTCwgaWRrZXkpO1xuICAgICAgICAgICAgaWYgKGlkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1tpZGtleV0gPSBpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9LFxuXG4gICAgbWFya2V0aW5nUGFyYW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKF8uaW5mby5jYW1wYWlnblBhcmFtcygpLCBfLmluZm8uY2xpY2tQYXJhbXMoKSk7XG4gICAgfSxcblxuICAgIHNlYXJjaEVuZ2luZTogZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICAgICAgaWYgKHJlZmVycmVyLnNlYXJjaCgnaHR0cHM/Oi8vKC4qKWdvb2dsZS4oW14vP10qKScpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2dvb2dsZSc7XG4gICAgICAgIH0gZWxzZSBpZiAocmVmZXJyZXIuc2VhcmNoKCdodHRwcz86Ly8oLiopYmluZy5jb20nKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdiaW5nJztcbiAgICAgICAgfSBlbHNlIGlmIChyZWZlcnJlci5zZWFyY2goJ2h0dHBzPzovLyguKil5YWhvby5jb20nKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICd5YWhvbyc7XG4gICAgICAgIH0gZWxzZSBpZiAocmVmZXJyZXIuc2VhcmNoKCdodHRwcz86Ly8oLiopZHVja2R1Y2tnby5jb20nKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdkdWNrZHVja2dvJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlYXJjaEluZm86IGZ1bmN0aW9uKHJlZmVycmVyKSB7XG4gICAgICAgIHZhciBzZWFyY2ggPSBfLmluZm8uc2VhcmNoRW5naW5lKHJlZmVycmVyKSxcbiAgICAgICAgICAgIHBhcmFtID0gKHNlYXJjaCAhPSAneWFob28nKSA/ICdxJyA6ICdwJyxcbiAgICAgICAgICAgIHJldCA9IHt9O1xuXG4gICAgICAgIGlmIChzZWFyY2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldFsnJHNlYXJjaF9lbmdpbmUnXSA9IHNlYXJjaDtcblxuICAgICAgICAgICAgdmFyIGtleXdvcmQgPSBfLmdldFF1ZXJ5UGFyYW0ocmVmZXJyZXIsIHBhcmFtKTtcbiAgICAgICAgICAgIGlmIChrZXl3b3JkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldFsnbXBfa2V5d29yZCddID0ga2V5d29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyB3aGljaCBicm93c2VyIGlzIHJ1bm5pbmcgdGhpcyBzY3JpcHQuXG4gICAgICogVGhlIG9yZGVyIG9mIHRoZSBjaGVja3MgYXJlIGltcG9ydGFudCBzaW5jZSBtYW55IHVzZXIgYWdlbnRzXG4gICAgICogaW5jbHVkZSBrZXkgd29yZHMgdXNlZCBpbiBsYXRlciBjaGVja3MuXG4gICAgICovXG4gICAgYnJvd3NlcjogZnVuY3Rpb24odXNlcl9hZ2VudCwgdmVuZG9yLCBvcGVyYSkge1xuICAgICAgICB2ZW5kb3IgPSB2ZW5kb3IgfHwgJyc7IC8vIHZlbmRvciBpcyB1bmRlZmluZWQgZm9yIGF0IGxlYXN0IElFOVxuICAgICAgICBpZiAob3BlcmEgfHwgXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnIE9QUi8nKSkge1xuICAgICAgICAgICAgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ01pbmknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnT3BlcmEgTWluaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ09wZXJhJztcbiAgICAgICAgfSBlbHNlIGlmICgvKEJsYWNrQmVycnl8UGxheUJvb2t8QkIxMCkvaS50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0JsYWNrQmVycnknO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0lFTW9iaWxlJykgfHwgXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnV1BEZXNrdG9wJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnSW50ZXJuZXQgRXhwbG9yZXIgTW9iaWxlJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdTYW1zdW5nQnJvd3Nlci8nKSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuc2Ftc3VuZy5jb20vaW50ZXJuZXQvdXNlci1hZ2VudC1zdHJpbmctZm9ybWF0XG4gICAgICAgICAgICByZXR1cm4gJ1NhbXN1bmcgSW50ZXJuZXQnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0VkZ2UnKSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdFZGcvJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnTWljcm9zb2Z0IEVkZ2UnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0ZCSU9TJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnRmFjZWJvb2sgTW9iaWxlJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdXaGFsZS8nKSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly91c2VyLWFnZW50cy5uZXQvYnJvd3NlcnMvd2hhbGUtYnJvd3NlclxuICAgICAgICAgICAgcmV0dXJuICdXaGFsZSBCcm93c2VyJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdDaHJvbWUnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdDaHJvbWUnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0NyaU9TJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2hyb21lIGlPUyc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnVUNXRUInKSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdVQ0Jyb3dzZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuICdVQyBCcm93c2VyJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdGeGlPUycpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ZpcmVmb3ggaU9TJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHZlbmRvciwgJ0FwcGxlJykpIHtcbiAgICAgICAgICAgIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdNb2JpbGUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnTW9iaWxlIFNhZmFyaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ1NhZmFyaSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnQW5kcm9pZCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0FuZHJvaWQgTW9iaWxlJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdLb25xdWVyb3InKSkge1xuICAgICAgICAgICAgcmV0dXJuICdLb25xdWVyb3InO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0ZpcmVmb3gnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdGaXJlZm94JztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdNU0lFJykgfHwgXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnVHJpZGVudC8nKSkge1xuICAgICAgICAgICAgcmV0dXJuICdJbnRlcm5ldCBFeHBsb3Jlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnR2Vja28nKSkge1xuICAgICAgICAgICAgcmV0dXJuICdNb3ppbGxhJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGRldGVjdHMgd2hpY2ggYnJvd3NlciB2ZXJzaW9uIGlzIHJ1bm5pbmcgdGhpcyBzY3JpcHQsXG4gICAgICogcGFyc2luZyBtYWpvciBhbmQgbWlub3IgdmVyc2lvbiAoZS5nLiwgNDIuMSkuIFVzZXIgYWdlbnQgc3RyaW5ncyBmcm9tOlxuICAgICAqIGh0dHA6Ly93d3cudXNlcmFnZW50c3RyaW5nLmNvbS9wYWdlcy91c2VyYWdlbnRzdHJpbmcucGhwXG4gICAgICovXG4gICAgYnJvd3NlclZlcnNpb246IGZ1bmN0aW9uKHVzZXJBZ2VudCwgdmVuZG9yLCBvcGVyYSkge1xuICAgICAgICB2YXIgYnJvd3NlciA9IF8uaW5mby5icm93c2VyKHVzZXJBZ2VudCwgdmVuZG9yLCBvcGVyYSk7XG4gICAgICAgIHZhciB2ZXJzaW9uUmVnZXhzID0ge1xuICAgICAgICAgICAgJ0ludGVybmV0IEV4cGxvcmVyIE1vYmlsZSc6IC9ydjooXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdNaWNyb3NvZnQgRWRnZSc6IC9FZGdlP1xcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0Nocm9tZSc6IC9DaHJvbWVcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdDaHJvbWUgaU9TJzogL0NyaU9TXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnVUMgQnJvd3NlcicgOiAvKFVDQnJvd3NlcnxVQ1dFQilcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdTYWZhcmknOiAvVmVyc2lvblxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ01vYmlsZSBTYWZhcmknOiAvVmVyc2lvblxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ09wZXJhJzogLyhPcGVyYXxPUFIpXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnRmlyZWZveCc6IC9GaXJlZm94XFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnRmlyZWZveCBpT1MnOiAvRnhpT1NcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdLb25xdWVyb3InOiAvS29ucXVlcm9yOihcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0JsYWNrQmVycnknOiAvQmxhY2tCZXJyeSAoXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdBbmRyb2lkIE1vYmlsZSc6IC9hbmRyb2lkXFxzKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnU2Ftc3VuZyBJbnRlcm5ldCc6IC9TYW1zdW5nQnJvd3NlclxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0ludGVybmV0IEV4cGxvcmVyJzogLyhydjp8TVNJRSApKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnTW96aWxsYSc6IC9ydjooXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdXaGFsZSBCcm93c2VyJzogL1doYWxlXFwvKFxcZCsoXFwuXFxkKyk/KS9cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlZ2V4ID0gdmVyc2lvblJlZ2V4c1ticm93c2VyXTtcbiAgICAgICAgaWYgKHJlZ2V4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaGVzID0gdXNlckFnZW50Lm1hdGNoKHJlZ2V4KTtcbiAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMl0pO1xuICAgIH0sXG5cbiAgICBvczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhID0gdXNlckFnZW50O1xuICAgICAgICBpZiAoL1dpbmRvd3MvaS50ZXN0KGEpKSB7XG4gICAgICAgICAgICBpZiAoL1Bob25lLy50ZXN0KGEpIHx8IC9XUERlc2t0b3AvLnRlc3QoYSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1dpbmRvd3MgUGhvbmUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdXaW5kb3dzJztcbiAgICAgICAgfSBlbHNlIGlmICgvKGlQaG9uZXxpUGFkfGlQb2QpLy50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lPUyc7XG4gICAgICAgIH0gZWxzZSBpZiAoL0FuZHJvaWQvLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQW5kcm9pZCc7XG4gICAgICAgIH0gZWxzZSBpZiAoLyhCbGFja0JlcnJ5fFBsYXlCb29rfEJCMTApL2kudGVzdChhKSkge1xuICAgICAgICAgICAgcmV0dXJuICdCbGFja0JlcnJ5JztcbiAgICAgICAgfSBlbHNlIGlmICgvTWFjL2kudGVzdChhKSkge1xuICAgICAgICAgICAgcmV0dXJuICdNYWMgT1MgWCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL0xpbnV4Ly50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0xpbnV4JztcbiAgICAgICAgfSBlbHNlIGlmICgvQ3JPUy8udGVzdChhKSkge1xuICAgICAgICAgICAgcmV0dXJuICdDaHJvbWUgT1MnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGRldmljZTogZnVuY3Rpb24odXNlcl9hZ2VudCkge1xuICAgICAgICBpZiAoL1dpbmRvd3MgUGhvbmUvaS50ZXN0KHVzZXJfYWdlbnQpIHx8IC9XUERlc2t0b3AvLnRlc3QodXNlcl9hZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnV2luZG93cyBQaG9uZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoL2lQYWQvLnRlc3QodXNlcl9hZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnaVBhZCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL2lQb2QvLnRlc3QodXNlcl9hZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnaVBvZCBUb3VjaCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL2lQaG9uZS8udGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdpUGhvbmUnO1xuICAgICAgICB9IGVsc2UgaWYgKC8oQmxhY2tCZXJyeXxQbGF5Qm9va3xCQjEwKS9pLnRlc3QodXNlcl9hZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQmxhY2tCZXJyeSc7XG4gICAgICAgIH0gZWxzZSBpZiAoL0FuZHJvaWQvLnRlc3QodXNlcl9hZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQW5kcm9pZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVmZXJyaW5nRG9tYWluOiBmdW5jdGlvbihyZWZlcnJlcikge1xuICAgICAgICB2YXIgc3BsaXQgPSByZWZlcnJlci5zcGxpdCgnLycpO1xuICAgICAgICBpZiAoc3BsaXQubGVuZ3RoID49IDMpIHtcbiAgICAgICAgICAgIHJldHVybiBzcGxpdFsyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSxcblxuICAgIGN1cnJlbnRVcmw6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gd2luLmxvY2F0aW9uLmhyZWY7XG4gICAgfSxcblxuICAgIHByb3BlcnRpZXM6IGZ1bmN0aW9uKGV4dHJhX3Byb3BzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXh0cmFfcHJvcHMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBleHRyYV9wcm9wcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfLmV4dGVuZChfLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMoe1xuICAgICAgICAgICAgJyRvcyc6IF8uaW5mby5vcygpLFxuICAgICAgICAgICAgJyRicm93c2VyJzogXy5pbmZvLmJyb3dzZXIodXNlckFnZW50LCBuYXZpZ2F0b3IudmVuZG9yLCB3aW5kb3dPcGVyYSksXG4gICAgICAgICAgICAnJHJlZmVycmVyJzogZG9jdW1lbnQkMS5yZWZlcnJlcixcbiAgICAgICAgICAgICckcmVmZXJyaW5nX2RvbWFpbic6IF8uaW5mby5yZWZlcnJpbmdEb21haW4oZG9jdW1lbnQkMS5yZWZlcnJlciksXG4gICAgICAgICAgICAnJGRldmljZSc6IF8uaW5mby5kZXZpY2UodXNlckFnZW50KVxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgJyRjdXJyZW50X3VybCc6IF8uaW5mby5jdXJyZW50VXJsKCksXG4gICAgICAgICAgICAnJGJyb3dzZXJfdmVyc2lvbic6IF8uaW5mby5icm93c2VyVmVyc2lvbih1c2VyQWdlbnQsIG5hdmlnYXRvci52ZW5kb3IsIHdpbmRvd09wZXJhKSxcbiAgICAgICAgICAgICckc2NyZWVuX2hlaWdodCc6IHNjcmVlbi5oZWlnaHQsXG4gICAgICAgICAgICAnJHNjcmVlbl93aWR0aCc6IHNjcmVlbi53aWR0aCxcbiAgICAgICAgICAgICdtcF9saWInOiAnd2ViJyxcbiAgICAgICAgICAgICckbGliX3ZlcnNpb24nOiBDb25maWcuTElCX1ZFUlNJT04sXG4gICAgICAgICAgICAnJGluc2VydF9pZCc6IGNoZWFwX2d1aWQoKSxcbiAgICAgICAgICAgICd0aW1lJzogXy50aW1lc3RhbXAoKSAvIDEwMDAgLy8gZXBvY2ggdGltZSBpbiBzZWNvbmRzXG4gICAgICAgIH0sIF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyhleHRyYV9wcm9wcykpO1xuICAgIH0sXG5cbiAgICBwZW9wbGVfcHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLmV4dGVuZChfLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMoe1xuICAgICAgICAgICAgJyRvcyc6IF8uaW5mby5vcygpLFxuICAgICAgICAgICAgJyRicm93c2VyJzogXy5pbmZvLmJyb3dzZXIodXNlckFnZW50LCBuYXZpZ2F0b3IudmVuZG9yLCB3aW5kb3dPcGVyYSlcbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgICckYnJvd3Nlcl92ZXJzaW9uJzogXy5pbmZvLmJyb3dzZXJWZXJzaW9uKHVzZXJBZ2VudCwgbmF2aWdhdG9yLnZlbmRvciwgd2luZG93T3BlcmEpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBtcFBhZ2VWaWV3UHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMoe1xuICAgICAgICAgICAgJ2N1cnJlbnRfcGFnZV90aXRsZSc6IGRvY3VtZW50JDEudGl0bGUsXG4gICAgICAgICAgICAnY3VycmVudF9kb21haW4nOiB3aW4ubG9jYXRpb24uaG9zdG5hbWUsXG4gICAgICAgICAgICAnY3VycmVudF91cmxfcGF0aCc6IHdpbi5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgICAgICdjdXJyZW50X3VybF9wcm90b2NvbCc6IHdpbi5sb2NhdGlvbi5wcm90b2NvbCxcbiAgICAgICAgICAgICdjdXJyZW50X3VybF9zZWFyY2gnOiB3aW4ubG9jYXRpb24uc2VhcmNoXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBydW4gYXQgbW9zdCBldmVyeSBgd2FpdE1zYCBhbmQgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBuZXh0IGludm9jYXRpb24uXG4gKiBUaHJvdHRsZWQgY2FsbHMgd2lsbCBidWlsZCB1cCBhIGJhdGNoIG9mIGFyZ3MgYW5kIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBhbGwgYXJncyBzaW5jZSB0aGUgbGFzdCBpbnZvY2F0aW9uLlxuICovXG52YXIgYmF0Y2hlZFRocm90dGxlID0gZnVuY3Rpb24gKGZuLCB3YWl0TXMpIHtcbiAgICB2YXIgdGltZW91dFByb21pc2UgPSBudWxsO1xuICAgIHZhciB0aHJvdHRsZWRJdGVtcyA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRocm90dGxlZEl0ZW1zLnB1c2goaXRlbSk7XG5cbiAgICAgICAgaWYgKCF0aW1lb3V0UHJvbWlzZSkge1xuICAgICAgICAgICAgdGltZW91dFByb21pc2UgPSBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGZuLmFwcGx5KHNlbGYsIFt0aHJvdHRsZWRJdGVtc10pO1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0UHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRocm90dGxlZEl0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgICAgIH0sIHdhaXRNcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGltZW91dFByb21pc2U7XG4gICAgfTtcbn07XG5cbnZhciBjaGVhcF9ndWlkID0gZnVuY3Rpb24obWF4bGVuKSB7XG4gICAgdmFyIGd1aWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTApICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDEwKTtcbiAgICByZXR1cm4gbWF4bGVuID8gZ3VpZC5zdWJzdHJpbmcoMCwgbWF4bGVuKSA6IGd1aWQ7XG59O1xuXG4vLyBuYWl2ZSB3YXkgdG8gZXh0cmFjdCBkb21haW4gbmFtZSAoZXhhbXBsZS5jb20pIGZyb20gZnVsbCBob3N0bmFtZSAobXkuc3ViLmV4YW1wbGUuY29tKVxudmFyIFNJTVBMRV9ET01BSU5fTUFUQ0hfUkVHRVggPSAvW2EtejAtOV1bYS16MC05LV0qXFwuW2Etel0rJC9pO1xuLy8gdGhpcyBuZXh0IG9uZSBhdHRlbXB0cyB0byBhY2NvdW50IGZvciBzb21lIGNjU0xEcywgZS5nLiBleHRyYWN0aW5nIG94Zm9yZC5hYy51ayBmcm9tIHd3dy5veGZvcmQuYWMudWtcbnZhciBET01BSU5fTUFUQ0hfUkVHRVggPSAvW2EtejAtOV1bYS16MC05LV0rXFwuW2Etei5dezIsNn0kL2k7XG4vKipcbiAqIEF0dGVtcHRzIHRvIGV4dHJhY3QgbWFpbiBkb21haW4gbmFtZSBmcm9tIGZ1bGwgaG9zdG5hbWUsIHVzaW5nIGEgZmV3IGJsdW50IGhldXJpc3RpY3MuIEZvclxuICogY29tbW9uIFRMRHMgbGlrZSAuY29tLy5vcmcgdGhhdCBhbHdheXMgaGF2ZSBhIHNpbXBsZSBTTEQuVExEIHN0cnVjdHVyZSAoZXhhbXBsZS5jb20pLCB3ZVxuICogc2ltcGx5IGV4dHJhY3QgdGhlIGxhc3QgdHdvIC4tc2VwYXJhdGVkIHBhcnRzIG9mIHRoZSBob3N0bmFtZSAoU0lNUExFX0RPTUFJTl9NQVRDSF9SRUdFWCkuXG4gKiBGb3Igb3RoZXJzLCB3ZSBhdHRlbXB0IHRvIGFjY291bnQgZm9yIHNob3J0IGNjU0xEK1RMRCBjb21ib3MgKC5hYy51aykgd2l0aCB0aGUgbGVnYWN5XG4gKiBET01BSU5fTUFUQ0hfUkVHRVggKGtlcHQgdG8gbWFpbnRhaW4gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCBleGlzdGluZyBNaXhwYW5lbFxuICogaW50ZWdyYXRpb25zKS4gVGhlIG9ubHkgX3JlbGlhYmxlXyB3YXkgdG8gZXh0cmFjdCBkb21haW4gZnJvbSBob3N0bmFtZSBpcyB3aXRoIGFuIHVwLXRvLWRhdGVcbiAqIGxpc3QgbGlrZSBhdCBodHRwczovL3B1YmxpY3N1ZmZpeC5vcmcvIHNvIGZvciBjYXNlcyB0aGF0IHRoaXMgaGVscGVyIGZhaWxzIGF0LCB0aGUgU0RLXG4gKiBvZmZlcnMgdGhlICdjb29raWVfZG9tYWluJyBjb25maWcgb3B0aW9uIHRvIHNldCBpdCBleHBsaWNpdGx5LlxuICogQGV4YW1wbGVcbiAqIGV4dHJhY3RfZG9tYWluKCdteS5zdWIuZXhhbXBsZS5jb20nKVxuICogLy8gJ2V4YW1wbGUuY29tJ1xuICovXG52YXIgZXh0cmFjdF9kb21haW4gPSBmdW5jdGlvbihob3N0bmFtZSkge1xuICAgIHZhciBkb21haW5fcmVnZXggPSBET01BSU5fTUFUQ0hfUkVHRVg7XG4gICAgdmFyIHBhcnRzID0gaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICB2YXIgdGxkID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHRsZC5sZW5ndGggPiA0IHx8IHRsZCA9PT0gJ2NvbScgfHwgdGxkID09PSAnb3JnJykge1xuICAgICAgICBkb21haW5fcmVnZXggPSBTSU1QTEVfRE9NQUlOX01BVENIX1JFR0VYO1xuICAgIH1cbiAgICB2YXIgbWF0Y2hlcyA9IGhvc3RuYW1lLm1hdGNoKGRvbWFpbl9yZWdleCk7XG4gICAgcmV0dXJuIG1hdGNoZXMgPyBtYXRjaGVzWzBdIDogJyc7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgd2UgaGF2ZSBuZXR3b3JrIGNvbm5lY3Rpb24uIGRlZmF1bHQgdG8gdHJ1ZSBmb3IgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IG5hdmlnYXRvci5vbkxpbmUgKElFKVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbnZhciBpc09ubGluZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbkxpbmUgPSB3aW4ubmF2aWdhdG9yWydvbkxpbmUnXTtcbiAgICByZXR1cm4gXy5pc1VuZGVmaW5lZChvbkxpbmUpIHx8IG9uTGluZTtcbn07XG5cbnZhciBOT09QX0ZVTkMgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIEpTT05TdHJpbmdpZnkgPSBudWxsLCBKU09OUGFyc2UgPSBudWxsO1xuaWYgKHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJykge1xuICAgIEpTT05TdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeTtcbiAgICBKU09OUGFyc2UgPSBKU09OLnBhcnNlO1xufVxuSlNPTlN0cmluZ2lmeSA9IEpTT05TdHJpbmdpZnkgfHwgXy5KU09ORW5jb2RlO1xuSlNPTlBhcnNlID0gSlNPTlBhcnNlIHx8IF8uSlNPTkRlY29kZTtcblxuLy8gVU5NSU5JRklFRCBFWFBPUlRTIChmb3IgY2xvc3VyZSBjb21waWxlcilcbl9bJ2luZm8nXSAgICAgICAgICAgICAgICAgICA9IF8uaW5mbztcbl9bJ2luZm8nXVsnYnJvd3NlciddICAgICAgICA9IF8uaW5mby5icm93c2VyO1xuX1snaW5mbyddWydicm93c2VyVmVyc2lvbiddID0gXy5pbmZvLmJyb3dzZXJWZXJzaW9uO1xuX1snaW5mbyddWydkZXZpY2UnXSAgICAgICAgID0gXy5pbmZvLmRldmljZTtcbl9bJ2luZm8nXVsncHJvcGVydGllcyddICAgICA9IF8uaW5mby5wcm9wZXJ0aWVzO1xuX1snaXNCbG9ja2VkVUEnXSAgICAgICAgICAgID0gXy5pc0Jsb2NrZWRVQTtcbl9bJ2lzRW1wdHlPYmplY3QnXSAgICAgICAgICA9IF8uaXNFbXB0eU9iamVjdDtcbl9bJ2lzT2JqZWN0J10gICAgICAgICAgICAgICA9IF8uaXNPYmplY3Q7XG5fWydKU09ORGVjb2RlJ10gICAgICAgICAgICAgPSBfLkpTT05EZWNvZGU7XG5fWydKU09ORW5jb2RlJ10gICAgICAgICAgICAgPSBfLkpTT05FbmNvZGU7XG5fWyd0b0FycmF5J10gICAgICAgICAgICAgICAgPSBfLnRvQXJyYXk7XG5fWydOUE8nXSAgICAgICAgICAgICAgICAgICAgPSBOcG9Qcm9taXNlO1xuXG52YXIgTUlYUEFORUxfREJfTkFNRSA9ICdtaXhwYW5lbEJyb3dzZXJEYic7XG5cbnZhciBSRUNPUkRJTkdfRVZFTlRTX1NUT1JFX05BTUUgPSAnbWl4cGFuZWxSZWNvcmRpbmdFdmVudHMnO1xudmFyIFJFQ09SRElOR19SRUdJU1RSWV9TVE9SRV9OQU1FID0gJ21peHBhbmVsUmVjb3JkaW5nUmVnaXN0cnknO1xuXG4vLyBub3RlOiBpbmNyZW1lbnQgdGhlIHZlcnNpb24gbnVtYmVyIHdoZW4gYWRkaW5nIG5ldyBvYmplY3Qgc3RvcmVzXG52YXIgREJfVkVSU0lPTiA9IDE7XG52YXIgT0JKRUNUX1NUT1JFUyA9IFtSRUNPUkRJTkdfRVZFTlRTX1NUT1JFX05BTUUsIFJFQ09SRElOR19SRUdJU1RSWV9TVE9SRV9OQU1FXTtcblxuLyoqXG4gKiBAdHlwZSB7aW1wb3J0KCcuL3dyYXBwZXInKS5TdG9yYWdlV3JhcHBlcn1cbiAqL1xudmFyIElEQlN0b3JhZ2VXcmFwcGVyID0gZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtQcm9taXNlPElEQkRhdGFiYXNlPnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZGJQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLnN0b3JlTmFtZSA9IHN0b3JlTmFtZTtcbn07XG5cbklEQlN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5fb3BlbkRiID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIG9wZW5SZXF1ZXN0ID0gd2luLmluZGV4ZWREQi5vcGVuKE1JWFBBTkVMX0RCX05BTUUsIERCX1ZFUlNJT04pO1xuICAgICAgICBvcGVuUmVxdWVzdFsnb25lcnJvciddID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVqZWN0KG9wZW5SZXF1ZXN0LmVycm9yKTtcbiAgICAgICAgfTtcblxuICAgICAgICBvcGVuUmVxdWVzdFsnb25zdWNjZXNzJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKG9wZW5SZXF1ZXN0LnJlc3VsdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgb3BlblJlcXVlc3RbJ29udXBncmFkZW5lZWRlZCddID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgZGIgPSBldi50YXJnZXQucmVzdWx0O1xuXG4gICAgICAgICAgICBPQkpFQ1RfU1RPUkVTLmZvckVhY2goZnVuY3Rpb24gKHN0b3JlTmFtZSkge1xuICAgICAgICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5cbklEQlN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghd2luLmluZGV4ZWREQikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlamVjdCgnaW5kZXhlZERCIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmRiUHJvbWlzZSkge1xuICAgICAgICB0aGlzLmRiUHJvbWlzZSA9IHRoaXMuX29wZW5EYigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRiUHJvbWlzZVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoZGJPckVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZGJPckVycm9yIGluc3RhbmNlb2Ygd2luWydJREJEYXRhYmFzZSddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVqZWN0KGRiT3JFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0lEQlRyYW5zYWN0aW9uTW9kZX0gbW9kZVxuICogQHBhcmFtIHtmdW5jdGlvbihJREJPYmplY3RTdG9yZSk6IHZvaWR9IHN0b3JlQ2JcbiAqL1xuSURCU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLm1ha2VUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uIChtb2RlLCBzdG9yZUNiKSB7XG4gICAgdmFyIHN0b3JlTmFtZSA9IHRoaXMuc3RvcmVOYW1lO1xuICAgIHZhciBkb1RyYW5zYWN0aW9uID0gZnVuY3Rpb24gKGRiKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKHN0b3JlTmFtZSwgbW9kZSk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLm9uYWJvcnQgPSB0cmFuc2FjdGlvbi5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJlamVjdCh0cmFuc2FjdGlvbi5lcnJvcik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzdG9yZUNiKHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKHN0b3JlTmFtZSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuZGJQcm9taXNlXG4gICAgICAgIC50aGVuKGRvVHJhbnNhY3Rpb24pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoZXJyICYmIGVyclsnbmFtZSddID09PSAnSW52YWxpZFN0YXRlRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgLy8gdHJ5IHJlb3BlbmluZyB0aGUgREIgaWYgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VkXG4gICAgICAgICAgICAgICAgdGhpcy5kYlByb21pc2UgPSB0aGlzLl9vcGVuRGIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYlByb21pc2UudGhlbihkb1RyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZWplY3QoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbn07XG5cbklEQlN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5zZXRJdGVtID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5tYWtlVHJhbnNhY3Rpb24oJ3JlYWR3cml0ZScsIGZ1bmN0aW9uIChvYmplY3RTdG9yZSkge1xuICAgICAgICBvYmplY3RTdG9yZS5wdXQodmFsdWUsIGtleSk7XG4gICAgfSk7XG59O1xuXG5JREJTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgcmVxO1xuICAgIHJldHVybiB0aGlzLm1ha2VUcmFuc2FjdGlvbigncmVhZG9ubHknLCBmdW5jdGlvbiAob2JqZWN0U3RvcmUpIHtcbiAgICAgICAgcmVxID0gb2JqZWN0U3RvcmUuZ2V0KGtleSk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXEucmVzdWx0O1xuICAgIH0pO1xufTtcblxuSURCU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubWFrZVRyYW5zYWN0aW9uKCdyZWFkd3JpdGUnLCBmdW5jdGlvbiAob2JqZWN0U3RvcmUpIHtcbiAgICAgICAgb2JqZWN0U3RvcmUuZGVsZXRlKGtleSk7XG4gICAgfSk7XG59O1xuXG5JREJTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXE7XG4gICAgcmV0dXJuIHRoaXMubWFrZVRyYW5zYWN0aW9uKCdyZWFkb25seScsIGZ1bmN0aW9uIChvYmplY3RTdG9yZSkge1xuICAgICAgICByZXEgPSBvYmplY3RTdG9yZS5nZXRBbGwoKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcS5yZXN1bHQ7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIEdEUFIgdXRpbHNcbiAqXG4gKiBUaGUgR2VuZXJhbCBEYXRhIFByb3RlY3Rpb24gUmVndWxhdGlvbiAoR0RQUikgaXMgYSByZWd1bGF0aW9uIGluIEVVIGxhdyBvbiBkYXRhIHByb3RlY3Rpb25cbiAqIGFuZCBwcml2YWN5IGZvciBhbGwgaW5kaXZpZHVhbHMgd2l0aGluIHRoZSBFdXJvcGVhbiBVbmlvbi4gSXQgYWRkcmVzc2VzIHRoZSBleHBvcnQgb2YgcGVyc29uYWxcbiAqIGRhdGEgb3V0c2lkZSB0aGUgRVUuIFRoZSBHRFBSIGFpbXMgcHJpbWFyaWx5IHRvIGdpdmUgY29udHJvbCBiYWNrIHRvIGNpdGl6ZW5zIGFuZCByZXNpZGVudHNcbiAqIG92ZXIgdGhlaXIgcGVyc29uYWwgZGF0YSBhbmQgdG8gc2ltcGxpZnkgdGhlIHJlZ3VsYXRvcnkgZW52aXJvbm1lbnQgZm9yIGludGVybmF0aW9uYWwgYnVzaW5lc3NcbiAqIGJ5IHVuaWZ5aW5nIHRoZSByZWd1bGF0aW9uIHdpdGhpbiB0aGUgRVUuXG4gKlxuICogVGhpcyBzZXQgb2YgdXRpbGl0aWVzIGlzIGludGVuZGVkIHRvIGVuYWJsZSBvcHQgaW4vb3V0IGZ1bmN0aW9uYWxpdHkgaW4gdGhlIE1peHBhbmVsIEpTIFNESy5cbiAqIFRoZXNlIGZ1bmN0aW9ucyBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBTREsgYW5kIGFyZSBub3QgaW50ZW5kZWQgdG8gYmUgcHVibGljbHkgZXhwb3NlZC5cbiAqL1xuXG5cbi8qKlxuICogQSBmdW5jdGlvbiB1c2VkIHRvIHRyYWNrIGEgTWl4cGFuZWwgZXZlbnQgKGUuZy4gTWl4cGFuZWxMaWIudHJhY2spXG4gKiBAY2FsbGJhY2sgdHJhY2tGdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LiBUaGlzIGNhbiBiZSBhbnl0aGluZyB0aGUgdXNlciBkb2VzIC0gJ0J1dHRvbiBDbGljaycsICdTaWduIFVwJywgJ0l0ZW0gUHVyY2hhc2VkJywgZXRjLlxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBBIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgd2l0aCB0aGUgZXZlbnQgeW91J3JlIHNlbmRpbmcuIFRoZXNlIGRlc2NyaWJlIHRoZSB1c2VyIHdobyBkaWQgdGhlIGV2ZW50IG9yIGRldGFpbHMgYWJvdXQgdGhlIGV2ZW50IGl0c2VsZi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKi9cblxuLyoqIFB1YmxpYyAqKi9cblxudmFyIEdEUFJfREVGQVVMVF9QRVJTSVNURU5DRV9QUkVGSVggPSAnX19tcF9vcHRfaW5fb3V0Xyc7XG5cbi8qKlxuICogT3B0IHRoZSB1c2VyIGluIHRvIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7dHJhY2tGdW5jdGlvbn0gW29wdGlvbnMudHJhY2tdIC0gZnVuY3Rpb24gdXNlZCBmb3IgdHJhY2tpbmcgYSBNaXhwYW5lbCBldmVudCB0byByZWNvcmQgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50cmFja0V2ZW50TmFtZV0gLSBldmVudCBuYW1lIHRvIGJlIHVzZWQgZm9yIHRyYWNraW5nIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudHJhY2tQcm9wZXJ0aWVzXSAtIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGJlIHRyYWNrZWQgYWxvbmcgd2l0aCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llRXhwaXJhdGlvbl0gLSBudW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llRG9tYWluXSAtIGN1c3RvbSBjb29raWUgZG9tYWluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU2l0ZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdFxuICovXG5mdW5jdGlvbiBvcHRJbih0b2tlbiwgb3B0aW9ucykge1xuICAgIF9vcHRJbk91dCh0cnVlLCB0b2tlbiwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogT3B0IHRoZSB1c2VyIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uXSAtIG51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtb3V0IGNvb2tpZSBleHBpcmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llRG9tYWluXSAtIGN1c3RvbSBjb29raWUgZG9tYWluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU2l0ZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWVdIC0gd2hldGhlciB0aGUgb3B0LW91dCBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1vdXQgY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIG9wdE91dCh0b2tlbiwgb3B0aW9ucykge1xuICAgIF9vcHRJbk91dChmYWxzZSwgdG9rZW4sIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIGluIHRvIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIGluIHRvIHRoZSBnaXZlbiBvcHQgdHlwZVxuICovXG5mdW5jdGlvbiBoYXNPcHRlZEluKHRva2VuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9nZXRTdG9yYWdlVmFsdWUodG9rZW4sIG9wdGlvbnMpID09PSAnMSc7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pZ25vcmVEbnRdIC0gZmxhZyB0byBpZ25vcmUgYnJvd3NlciBETlQgc2V0dGluZ3MgYW5kIGFsd2F5cyByZXR1cm4gZmFsc2VcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQgb2YgdGhlIGdpdmVuIG9wdCB0eXBlXG4gKi9cbmZ1bmN0aW9uIGhhc09wdGVkT3V0KHRva2VuLCBvcHRpb25zKSB7XG4gICAgaWYgKF9oYXNEb05vdFRyYWNrRmxhZ09uKG9wdGlvbnMpKSB7XG4gICAgICAgIGNvbnNvbGUkMS53YXJuKCdUaGlzIGJyb3dzZXIgaGFzIFwiRG8gTm90IFRyYWNrXCIgZW5hYmxlZC4gVGhpcyB3aWxsIHByZXZlbnQgdGhlIE1peHBhbmVsIFNESyBmcm9tIHNlbmRpbmcgYW55IGRhdGEuIFRvIGlnbm9yZSB0aGUgXCJEbyBOb3QgVHJhY2tcIiBicm93c2VyIHNldHRpbmcsIGluaXRpYWxpemUgdGhlIE1peHBhbmVsIGluc3RhbmNlIHdpdGggdGhlIGNvbmZpZyBcImlnbm9yZV9kbnQ6IHRydWVcIicpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIG9wdGVkT3V0ID0gX2dldFN0b3JhZ2VWYWx1ZSh0b2tlbiwgb3B0aW9ucykgPT09ICcwJztcbiAgICBpZiAob3B0ZWRPdXQpIHtcbiAgICAgICAgY29uc29sZSQxLndhcm4oJ1lvdSBhcmUgb3B0ZWQgb3V0IG9mIE1peHBhbmVsIHRyYWNraW5nLiBUaGlzIHdpbGwgcHJldmVudCB0aGUgTWl4cGFuZWwgU0RLIGZyb20gc2VuZGluZyBhbnkgZGF0YS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGVkT3V0O1xufVxuXG4vKipcbiAqIFdyYXAgYSBNaXhwYW5lbExpYiBtZXRob2Qgd2l0aCBhIGNoZWNrIGZvciB3aGV0aGVyIHRoZSB1c2VyIGlzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBJZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0LCByZXR1cm4gZWFybHkgaW5zdGVhZCBvZiBleGVjdXRpbmcgdGhlIG1ldGhvZC5cbiAqIElmIGEgY2FsbGJhY2sgYXJndW1lbnQgd2FzIHByb3ZpZGVkLCBleGVjdXRlIGl0IHBhc3NpbmcgdGhlIDAgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCAtIHdyYXBwZWQgbWV0aG9kIHRvIGJlIGV4ZWN1dGVkIGlmIHRoZSB1c2VyIGhhcyBub3Qgb3B0ZWQgb3V0XG4gKiBAcmV0dXJucyB7Kn0gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgbWV0aG9kIE9SIHVuZGVmaW5lZCBpZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0XG4gKi9cbmZ1bmN0aW9uIGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIobWV0aG9kKSB7XG4gICAgcmV0dXJuIF9hZGRPcHRPdXRDaGVjayhtZXRob2QsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0X2NvbmZpZyhuYW1lKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBXcmFwIGEgTWl4cGFuZWxQZW9wbGUgbWV0aG9kIHdpdGggYSBjaGVjayBmb3Igd2hldGhlciB0aGUgdXNlciBpcyBvcHRlZCBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogSWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCwgcmV0dXJuIGVhcmx5IGluc3RlYWQgb2YgZXhlY3V0aW5nIHRoZSBtZXRob2QuXG4gKiBJZiBhIGNhbGxiYWNrIGFyZ3VtZW50IHdhcyBwcm92aWRlZCwgZXhlY3V0ZSBpdCBwYXNzaW5nIHRoZSAwIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgLSB3cmFwcGVkIG1ldGhvZCB0byBiZSBleGVjdXRlZCBpZiB0aGUgdXNlciBoYXMgbm90IG9wdGVkIG91dFxuICogQHJldHVybnMgeyp9IHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIG1ldGhvZCBPUiB1bmRlZmluZWQgaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dFxuICovXG5mdW5jdGlvbiBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKG1ldGhvZCkge1xuICAgIHJldHVybiBfYWRkT3B0T3V0Q2hlY2sobWV0aG9kLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRfY29uZmlnKG5hbWUpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFdyYXAgYSBNaXhwYW5lbEdyb3VwIG1ldGhvZCB3aXRoIGEgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHVzZXIgaXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIElmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQsIHJldHVybiBlYXJseSBpbnN0ZWFkIG9mIGV4ZWN1dGluZyB0aGUgbWV0aG9kLlxuICogSWYgYSBjYWxsYmFjayBhcmd1bWVudCB3YXMgcHJvdmlkZWQsIGV4ZWN1dGUgaXQgcGFzc2luZyB0aGUgMCBlcnJvciBjb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIC0gd3JhcHBlZCBtZXRob2QgdG8gYmUgZXhlY3V0ZWQgaWYgdGhlIHVzZXIgaGFzIG5vdCBvcHRlZCBvdXRcbiAqIEByZXR1cm5zIHsqfSB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyBtZXRob2QgT1IgdW5kZWZpbmVkIGlmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKG1ldGhvZCkge1xuICAgIHJldHVybiBfYWRkT3B0T3V0Q2hlY2sobWV0aG9kLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRfY29uZmlnKG5hbWUpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENsZWFyIHRoZSB1c2VyJ3Mgb3B0IGluL291dCBzdGF0dXMgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llRXhwaXJhdGlvbl0gLSBudW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llRG9tYWluXSAtIGN1c3RvbSBjb29raWUgZG9tYWluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU2l0ZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdFxuICovXG5mdW5jdGlvbiBjbGVhck9wdEluT3V0KHRva2VuLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgX2dldFN0b3JhZ2Uob3B0aW9ucykucmVtb3ZlKFxuICAgICAgICBfZ2V0U3RvcmFnZUtleSh0b2tlbiwgb3B0aW9ucyksICEhb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZSwgb3B0aW9ucy5jb29raWVEb21haW5cbiAgICApO1xufVxuXG4vKiogUHJpdmF0ZSAqKi9cblxuLyoqXG4gKiBHZXQgc3RvcmFnZSB1dGlsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXVxuICogQHJldHVybnMge29iamVjdH0gZWl0aGVyIF8uY29va2llIG9yIF8ubG9jYWxzdG9yYWdlXG4gKi9cbmZ1bmN0aW9uIF9nZXRTdG9yYWdlKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGUgPT09ICdsb2NhbFN0b3JhZ2UnID8gXy5sb2NhbFN0b3JhZ2UgOiBfLmNvb2tpZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG5hbWUgb2YgdGhlIGNvb2tpZSB0aGF0IGlzIHVzZWQgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZSAodHJhY2tpbmcsIGNvb2tpZSwgZXRjLilcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBuYW1lIG9mIHRoZSBjb29raWUgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZVxuICovXG5mdW5jdGlvbiBfZ2V0U3RvcmFnZUtleSh0b2tlbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiAob3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeCB8fCBHRFBSX0RFRkFVTFRfUEVSU0lTVEVOQ0VfUFJFRklYKSArIHRva2VuO1xufVxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgb2YgdGhlIGNvb2tpZSB0aGF0IGlzIHVzZWQgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZSAodHJhY2tpbmcsIGNvb2tpZSwgZXRjLilcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB2YWx1ZSBvZiB0aGUgY29va2llIGZvciB0aGUgZ2l2ZW4gb3B0IHR5cGVcbiAqL1xuZnVuY3Rpb24gX2dldFN0b3JhZ2VWYWx1ZSh0b2tlbiwgb3B0aW9ucykge1xuICAgIHJldHVybiBfZ2V0U3RvcmFnZShvcHRpb25zKS5nZXQoX2dldFN0b3JhZ2VLZXkodG9rZW4sIG9wdGlvbnMpKTtcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIGhhcyBzZXQgdGhlIEROVC9kb05vdFRyYWNrIHNldHRpbmcgdG8gdHJ1ZSBpbiB0aGVpciBicm93c2VyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMud2luZG93XSAtIGFsdGVybmF0ZSB3aW5kb3cgb2JqZWN0IHRvIGNoZWNrOyB1c2VkIHRvIGZvcmNlIHZhcmlvdXMgRE5UIHNldHRpbmdzIGluIGJyb3dzZXIgdGVzdHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaWdub3JlRG50XSAtIGZsYWcgdG8gaWdub3JlIGJyb3dzZXIgRE5UIHNldHRpbmdzIGFuZCBhbHdheXMgcmV0dXJuIGZhbHNlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgRE5UIHNldHRpbmcgaXMgdHJ1ZVxuICovXG5mdW5jdGlvbiBfaGFzRG9Ob3RUcmFja0ZsYWdPbihvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5pZ25vcmVEbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgd2luJDEgPSAob3B0aW9ucyAmJiBvcHRpb25zLndpbmRvdykgfHwgd2luO1xuICAgIHZhciBuYXYgPSB3aW4kMVsnbmF2aWdhdG9yJ10gfHwge307XG4gICAgdmFyIGhhc0RudE9uID0gZmFsc2U7XG5cbiAgICBfLmVhY2goW1xuICAgICAgICBuYXZbJ2RvTm90VHJhY2snXSwgLy8gc3RhbmRhcmRcbiAgICAgICAgbmF2Wydtc0RvTm90VHJhY2snXSxcbiAgICAgICAgd2luJDFbJ2RvTm90VHJhY2snXVxuICAgIF0sIGZ1bmN0aW9uKGRudFZhbHVlKSB7XG4gICAgICAgIGlmIChfLmluY2x1ZGVzKFt0cnVlLCAxLCAnMScsICd5ZXMnXSwgZG50VmFsdWUpKSB7XG4gICAgICAgICAgICBoYXNEbnRPbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBoYXNEbnRPbjtcbn1cblxuLyoqXG4gKiBTZXQgY29va2llL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIHVzZXIgaW5kaWNhdGluZyB0aGF0IHRoZXkgYXJlIG9wdGVkIGluIG9yIG91dCBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdFZhbHVlIC0gd2hldGhlciB0byBvcHQgdGhlIHVzZXIgaW4gb3Igb3V0IGZvciB0aGUgZ2l2ZW4gb3B0IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7dHJhY2tGdW5jdGlvbn0gW29wdGlvbnMudHJhY2tdIC0gZnVuY3Rpb24gdXNlZCBmb3IgdHJhY2tpbmcgYSBNaXhwYW5lbCBldmVudCB0byByZWNvcmQgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50cmFja0V2ZW50TmFtZV0gLSBldmVudCBuYW1lIHRvIGJlIHVzZWQgZm9yIHRyYWNraW5nIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudHJhY2tQcm9wZXJ0aWVzXSAtIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGJlIHRyYWNrZWQgYWxvbmcgd2l0aCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZUV4cGlyYXRpb25dIC0gbnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1pbiBjb29raWUgZXhwaXJlc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZURvbWFpbl0gLSBjdXN0b20gY29va2llIGRvbWFpblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1NpdGVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc2l0ZS1lbmFibGVkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3RcbiAqL1xuZnVuY3Rpb24gX29wdEluT3V0KG9wdFZhbHVlLCB0b2tlbiwgb3B0aW9ucykge1xuICAgIGlmICghXy5pc1N0cmluZyh0b2tlbikgfHwgIXRva2VuLmxlbmd0aCkge1xuICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ2dkcHIuJyArIChvcHRWYWx1ZSA/ICdvcHRJbicgOiAnb3B0T3V0JykgKyAnIGNhbGxlZCB3aXRoIGFuIGludmFsaWQgdG9rZW4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgX2dldFN0b3JhZ2Uob3B0aW9ucykuc2V0KFxuICAgICAgICBfZ2V0U3RvcmFnZUtleSh0b2tlbiwgb3B0aW9ucyksXG4gICAgICAgIG9wdFZhbHVlID8gMSA6IDAsXG4gICAgICAgIF8uaXNOdW1iZXIob3B0aW9ucy5jb29raWVFeHBpcmF0aW9uKSA/IG9wdGlvbnMuY29va2llRXhwaXJhdGlvbiA6IG51bGwsXG4gICAgICAgICEhb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZSxcbiAgICAgICAgISFvcHRpb25zLnNlY3VyZUNvb2tpZSxcbiAgICAgICAgISFvcHRpb25zLmNyb3NzU2l0ZUNvb2tpZSxcbiAgICAgICAgb3B0aW9ucy5jb29raWVEb21haW5cbiAgICApO1xuXG4gICAgaWYgKG9wdGlvbnMudHJhY2sgJiYgb3B0VmFsdWUpIHsgLy8gb25seSB0cmFjayBldmVudCBpZiBvcHRpbmcgaW4gKG9wdFZhbHVlPXRydWUpXG4gICAgICAgIG9wdGlvbnMudHJhY2sob3B0aW9ucy50cmFja0V2ZW50TmFtZSB8fCAnJG9wdF9pbicsIG9wdGlvbnMudHJhY2tQcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICAnc2VuZF9pbW1lZGlhdGVseSc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFdyYXAgYSBtZXRob2Qgd2l0aCBhIGNoZWNrIGZvciB3aGV0aGVyIHRoZSB1c2VyIGlzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBJZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0LCByZXR1cm4gZWFybHkgaW5zdGVhZCBvZiBleGVjdXRpbmcgdGhlIG1ldGhvZC5cbiAqIElmIGEgY2FsbGJhY2sgYXJndW1lbnQgd2FzIHByb3ZpZGVkLCBleGVjdXRlIGl0IHBhc3NpbmcgdGhlIDAgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCAtIHdyYXBwZWQgbWV0aG9kIHRvIGJlIGV4ZWN1dGVkIGlmIHRoZSB1c2VyIGhhcyBub3Qgb3B0ZWQgb3V0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBnZXRDb25maWdWYWx1ZSAtIGdldHRlciBmdW5jdGlvbiBmb3IgdGhlIE1peHBhbmVsIEFQSSB0b2tlbiBhbmQgb3RoZXIgb3B0aW9ucyB0byBiZSB1c2VkIHdpdGggb3B0LW91dCBjaGVja1xuICogQHJldHVybnMgeyp9IHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIG1ldGhvZCBPUiB1bmRlZmluZWQgaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dFxuICovXG5mdW5jdGlvbiBfYWRkT3B0T3V0Q2hlY2sobWV0aG9kLCBnZXRDb25maWdWYWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGVkT3V0ID0gZmFsc2U7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IGdldENvbmZpZ1ZhbHVlLmNhbGwodGhpcywgJ3Rva2VuJyk7XG4gICAgICAgICAgICB2YXIgaWdub3JlRG50ID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAnaWdub3JlX2RudCcpO1xuICAgICAgICAgICAgdmFyIHBlcnNpc3RlbmNlVHlwZSA9IGdldENvbmZpZ1ZhbHVlLmNhbGwodGhpcywgJ29wdF9vdXRfdHJhY2tpbmdfcGVyc2lzdGVuY2VfdHlwZScpO1xuICAgICAgICAgICAgdmFyIHBlcnNpc3RlbmNlUHJlZml4ID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAnb3B0X291dF90cmFja2luZ19jb29raWVfcHJlZml4Jyk7XG4gICAgICAgICAgICB2YXIgd2luID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAnd2luZG93Jyk7IC8vIHVzZWQgdG8gb3ZlcnJpZGUgd2luZG93IGR1cmluZyBicm93c2VyIHRlc3RzXG5cbiAgICAgICAgICAgIGlmICh0b2tlbikgeyAvLyBpZiB0aGVyZSB3YXMgYW4gaXNzdWUgZ2V0dGluZyB0aGUgdG9rZW4sIGNvbnRpbnVlIG1ldGhvZCBleGVjdXRpb24gYXMgbm9ybWFsXG4gICAgICAgICAgICAgICAgb3B0ZWRPdXQgPSBoYXNPcHRlZE91dCh0b2tlbiwge1xuICAgICAgICAgICAgICAgICAgICBpZ25vcmVEbnQ6IGlnbm9yZURudCxcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdGVuY2VUeXBlOiBwZXJzaXN0ZW5jZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RlbmNlUHJlZml4OiBwZXJzaXN0ZW5jZVByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgd2luZG93OiB3aW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcignVW5leHBlY3RlZCBlcnJvciB3aGVuIGNoZWNraW5nIHRyYWNraW5nIG9wdC1vdXQgc3RhdHVzOiAnICsgZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0ZWRPdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmICh0eXBlb2YoY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICB9O1xufVxuXG52YXIgbG9nZ2VyJDYgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdsb2NrJyk7XG5cbi8qKlxuICogU2hhcmVkTG9jazogYSBtdXRleCBidWlsdCBvbiBIVE1MNSBsb2NhbFN0b3JhZ2UsIHRvIGVuc3VyZSB0aGF0IG9ubHkgb25lIGJyb3dzZXJcbiAqIHdpbmRvdy90YWIgYXQgYSB0aW1lIHdpbGwgYmUgYWJsZSB0byBhY2Nlc3Mgc2hhcmVkIHJlc291cmNlcy5cbiAqXG4gKiBCYXNlZCBvbiB0aGUgQWx1ciBhbmQgVGF1YmVuZmVsZCBmYXN0IGxvY2tcbiAqIChodHRwOi8vd3d3LmNzLnJvY2hlc3Rlci5lZHUvcmVzZWFyY2gvc3luY2hyb25pemF0aW9uL3BzZXVkb2NvZGUvZmFzdGxvY2suaHRtbClcbiAqIHdpdGggYW4gYWRkZWQgdGltZW91dCB0byBlbnN1cmUgdGhlcmUgd2lsbCBiZSBldmVudHVhbCBwcm9ncmVzcyBpbiB0aGUgZXZlbnRcbiAqIHRoYXQgYSB3aW5kb3cgaXMgY2xvc2VkIGluIHRoZSBtaWRkbGUgb2YgdGhlIGNhbGxiYWNrLlxuICpcbiAqIEltcGxlbWVudGF0aW9uIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCB2ZXJzaW9uIGJ5IERhdmlkIFdvbGV2ZXIgKGh0dHBzOi8vZ2l0aHViLmNvbS93b2xldmVyKVxuICogYXQgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vd29sZXZlci81ZmQ3NTczZDFlZjYxNjZlOGY4YzRhZjI4NmE2OTQzMi5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbXlMb2NrID0gbmV3IFNoYXJlZExvY2soJ3NvbWUta2V5Jyk7XG4gKiBteUxvY2sud2l0aExvY2soZnVuY3Rpb24oKSB7XG4gKiAgIGNvbnNvbGUubG9nKCdJIGhvbGQgdGhlIG11dGV4IScpO1xuICogfSk7XG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTaGFyZWRMb2NrID0gZnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLnN0b3JhZ2VLZXkgPSBrZXk7XG4gICAgdGhpcy5zdG9yYWdlID0gb3B0aW9ucy5zdG9yYWdlIHx8IHdpbi5sb2NhbFN0b3JhZ2U7XG4gICAgdGhpcy5wb2xsSW50ZXJ2YWxNUyA9IG9wdGlvbnMucG9sbEludGVydmFsTVMgfHwgMTAwO1xuICAgIHRoaXMudGltZW91dE1TID0gb3B0aW9ucy50aW1lb3V0TVMgfHwgMjAwMDtcblxuICAgIC8vIGRlcGVuZGVuY3ktaW5qZWN0IHByb21pc2UgaW1wbGVtZW50YXRpb24gZm9yIHRlc3RpbmcgcHVycG9zZXNcbiAgICB0aGlzLnByb21pc2VJbXBsID0gb3B0aW9ucy5wcm9taXNlSW1wbCB8fCBQcm9taXNlUG9seWZpbGw7XG59O1xuXG4vLyBwYXNzIGluIGEgc3BlY2lmaWMgcGlkIHRvIHRlc3QgY29udGVudGlvbiBzY2VuYXJpb3M7IG90aGVyd2lzZVxuLy8gaXQgaXMgY2hvc2VuIHJhbmRvbWx5IGZvciBlYWNoIGFjcXVpc2l0aW9uIGF0dGVtcHRcblNoYXJlZExvY2sucHJvdG90eXBlLndpdGhMb2NrID0gZnVuY3Rpb24obG9ja2VkQ0IsIHBpZCkge1xuICAgIHZhciBQcm9taXNlID0gdGhpcy5wcm9taXNlSW1wbDtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoXy5iaW5kKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGkgPSBwaWQgfHwgKG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgJ3wnICsgTWF0aC5yYW5kb20oKSk7XG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuc3RvcmFnZUtleTtcbiAgICAgICAgdmFyIHBvbGxJbnRlcnZhbE1TID0gdGhpcy5wb2xsSW50ZXJ2YWxNUztcbiAgICAgICAgdmFyIHRpbWVvdXRNUyA9IHRoaXMudGltZW91dE1TO1xuICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuc3RvcmFnZTtcblxuICAgICAgICB2YXIga2V5WCA9IGtleSArICc6WCc7XG4gICAgICAgIHZhciBrZXlZID0ga2V5ICsgJzpZJztcbiAgICAgICAgdmFyIGtleVogPSBrZXkgKyAnOlonO1xuXG4gICAgICAgIHZhciBkZWxheSA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWUgPiB0aW1lb3V0TVMpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkNi5lcnJvcignVGltZW91dCB3YWl0aW5nIGZvciBtdXRleCBvbiAnICsga2V5ICsgJzsgY2xlYXJpbmcgbG9jay4gWycgKyBpICsgJ10nKTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5Wik7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleVkpO1xuICAgICAgICAgICAgICAgIGxvb3AoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgcG9sbEludGVydmFsTVMgKiAoTWF0aC5yYW5kb20oKSArIDAuMSkpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciB3YWl0Rm9yID0gZnVuY3Rpb24ocHJlZGljYXRlLCBjYikge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZSgpKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHdhaXRGb3IocHJlZGljYXRlLCBjYik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGdldFNldFkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB2YWxZID0gc3RvcmFnZS5nZXRJdGVtKGtleVkpO1xuICAgICAgICAgICAgaWYgKHZhbFkgJiYgdmFsWSAhPT0gaSkgeyAvLyBpZiBZID09IGkgdGhlbiB0aGlzIHByb2Nlc3MgYWxyZWFkeSBoYXMgdGhlIGxvY2sgKHVzZWZ1bCBmb3IgdGVzdCBjYXNlcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXlZLCBpKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleVkpID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbG9jYWxTdG9yYWdlU3VwcG9ydGVkKHN0b3JhZ2UsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdsb2NhbFN0b3JhZ2Ugc3VwcG9ydCBkcm9wcGVkIHdoaWxlIGFjcXVpcmluZyBsb2NrJykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXlYLCBpKTtcblxuICAgICAgICAgICAgd2FpdEZvcihnZXRTZXRZLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleVgpID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNyaXRpY2FsU2VjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5WSkgIT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3YWl0Rm9yKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFzdG9yYWdlLmdldEl0ZW0oa2V5Wik7XG4gICAgICAgICAgICAgICAgICAgIH0sIGNyaXRpY2FsU2VjdGlvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgY3JpdGljYWxTZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5WiwgJzEnKTtcbiAgICAgICAgICAgIHZhciByZW1vdmVMb2NrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXlaKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleVkpID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXlZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXlYKSA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5WCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbG9ja2VkQ0IoKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTG9jaygpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJldCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVMb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobG9jYWxTdG9yYWdlU3VwcG9ydGVkKHN0b3JhZ2UsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgbG9vcCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xvY2FsU3RvcmFnZSBzdXBwb3J0IGNoZWNrIGZhaWxlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIEB0eXBlIHtpbXBvcnQoJy4vd3JhcHBlcicpLlN0b3JhZ2VXcmFwcGVyfVxuICovXG52YXIgTG9jYWxTdG9yYWdlV3JhcHBlciA9IGZ1bmN0aW9uIChzdG9yYWdlT3ZlcnJpZGUpIHtcbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlT3ZlcnJpZGUgfHwgd2luLmxvY2FsU3RvcmFnZTtcbn07XG5cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG59O1xuXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5zZXRJdGVtID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChfLmJpbmQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OU3RyaW5naWZ5KHZhbHVlKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgfSwgdGhpcykpO1xufTtcblxuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChfLmJpbmQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGl0ZW0gPSBKU09OUGFyc2UodGhpcy5zdG9yYWdlLmdldEl0ZW0oa2V5KSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKGl0ZW0pO1xuICAgIH0sIHRoaXMpKTtcbn07XG5cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoXy5iaW5kKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgfSwgdGhpcykpO1xufTtcblxudmFyIGxvZ2dlciQ1ID0gY29uc29sZV93aXRoX3ByZWZpeCgnYmF0Y2gnKTtcblxuLyoqXG4gKiBSZXF1ZXN0UXVldWU6IHF1ZXVlIGZvciBiYXRjaGluZyBBUEkgcmVxdWVzdHMgd2l0aCBsb2NhbFN0b3JhZ2UgYmFja3VwIGZvciByZXRyaWVzLlxuICogTWFpbnRhaW5zIGFuIGluLW1lbW9yeSBxdWV1ZSB3aGljaCByZXByZXNlbnRzIHRoZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIHRoZSBjdXJyZW50XG4gKiBwYWdlLCBidXQgYWxzbyB3cml0ZXMgYWxsIGl0ZW1zIG91dCB0byBhIGNvcHkgaW4gdGhlIGJyb3dzZXIncyBsb2NhbFN0b3JhZ2UsIHdoaWNoXG4gKiBjYW4gYmUgcmVhZCBvbiBzdWJzZXF1ZW50IHBhZ2Vsb2FkcyBhbmQgcmV0cmllZC4gRm9yIGJhdGNoYWJpbGl0eSwgYWxsIHRoZSByZXF1ZXN0XG4gKiBpdGVtcyBpbiB0aGUgcXVldWUgc2hvdWxkIGJlIG9mIHRoZSBzYW1lIHR5cGUgKGV2ZW50cywgcGVvcGxlIHVwZGF0ZXMsIGdyb3VwIHVwZGF0ZXMpXG4gKiBzbyB0aGV5IGNhbiBiZSBzZW50IGluIGEgc2luZ2xlIHJlcXVlc3QgdG8gdGhlIHNhbWUgQVBJIGVuZHBvaW50LlxuICpcbiAqIExvY2FsU3RvcmFnZSBrZXlpbmcgYW5kIGxvY2tpbmc6IEluIG9yZGVyIGZvciByZWxvYWRzIGFuZCBzdWJzZXF1ZW50IHBhZ2Vsb2FkcyBvZlxuICogdGhlIHNhbWUgc2l0ZSB0byBhY2Nlc3MgdGhlIHNhbWUgcGVyc2lzdGVkIGRhdGEsIHRoZXkgbXVzdCBzaGFyZSB0aGUgc2FtZSBsb2NhbFN0b3JhZ2VcbiAqIGtleSAoZm9yIGluc3RhbmNlIGJhc2VkIG9uIHByb2plY3QgdG9rZW4gYW5kIHF1ZXVlIHR5cGUpLiBUaGVyZWZvcmUgYWNjZXNzIHRvIHRoZVxuICogbG9jYWxTdG9yYWdlIGVudHJ5IGlzIGd1YXJkZWQgYnkgYW4gYXN5bmNocm9ub3VzIG11dGV4IChTaGFyZWRMb2NrKSB0byBwcmV2ZW50XG4gKiBzaW11bHRhbmVvdXNseSBvcGVuIHdpbmRvd3MvdGFicyBmcm9tIG92ZXJ3cml0aW5nIGVhY2ggb3RoZXIncyBkYXRhICh3aGljaCB3b3VsZCBsZWFkXG4gKiB0byBkYXRhIGxvc3MgaW4gc29tZSBzaXR1YXRpb25zKS5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUmVxdWVzdFF1ZXVlID0gZnVuY3Rpb24gKHN0b3JhZ2VLZXksIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLnN0b3JhZ2VLZXkgPSBzdG9yYWdlS2V5O1xuICAgIHRoaXMudXNlUGVyc2lzdGVuY2UgPSBvcHRpb25zLnVzZVBlcnNpc3RlbmNlO1xuICAgIGlmICh0aGlzLnVzZVBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHRoaXMucXVldWVTdG9yYWdlID0gb3B0aW9ucy5xdWV1ZVN0b3JhZ2UgfHwgbmV3IExvY2FsU3RvcmFnZVdyYXBwZXIoKTtcbiAgICAgICAgdGhpcy5sb2NrID0gbmV3IFNoYXJlZExvY2soc3RvcmFnZUtleSwge1xuICAgICAgICAgICAgc3RvcmFnZTogb3B0aW9ucy5zaGFyZWRMb2NrU3RvcmFnZSB8fCB3aW4ubG9jYWxTdG9yYWdlLFxuICAgICAgICAgICAgdGltZW91dE1TOiBvcHRpb25zLnNoYXJlZExvY2tUaW1lb3V0TVMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnJlcG9ydEVycm9yID0gb3B0aW9ucy5lcnJvclJlcG9ydGVyIHx8IF8uYmluZChsb2dnZXIkNS5lcnJvciwgbG9nZ2VyJDUpO1xuXG4gICAgdGhpcy5waWQgPSBvcHRpb25zLnBpZCB8fCBudWxsOyAvLyBwYXNzIHBpZCB0byB0ZXN0IG91dCBzdG9yYWdlIGxvY2sgY29udGVudGlvbiBzY2VuYXJpb3NcblxuICAgIHRoaXMubWVtUXVldWUgPSBbXTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5lbnF1ZXVlVGhyb3R0bGVNcykge1xuICAgICAgICB0aGlzLmVucXVldWVQZXJzaXN0ZWQgPSBiYXRjaGVkVGhyb3R0bGUoXy5iaW5kKHRoaXMuX2VucXVldWVQZXJzaXN0ZWQsIHRoaXMpLCBvcHRpb25zLmVucXVldWVUaHJvdHRsZU1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVucXVldWVQZXJzaXN0ZWQgPSBfLmJpbmQoZnVuY3Rpb24gKHF1ZXVlRW50cnkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbnF1ZXVlUGVyc2lzdGVkKFtxdWV1ZUVudHJ5XSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn07XG5cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuZW5zdXJlSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5xdWV1ZVN0b3JhZ2VcbiAgICAgICAgLmluaXQoKVxuICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBxdWV1ZSBwZXJzaXN0ZW5jZS4gRGlzYWJsaW5nIHBlcnNpc3RlbmNlJywgZXJyKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy51c2VQZXJzaXN0ZW5jZSA9IGZhbHNlO1xuICAgICAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIEFkZCBvbmUgaXRlbSB0byBxdWV1ZXMgKG1lbW9yeSBhbmQgbG9jYWxTdG9yYWdlKS4gVGhlIHF1ZXVlZCBlbnRyeSBpbmNsdWRlc1xuICogdGhlIGdpdmVuIGl0ZW0gYWxvbmcgd2l0aCBhbiBhdXRvLWdlbmVyYXRlZCBJRCBhbmQgYSBcImZsdXNoLWFmdGVyXCIgdGltZXN0YW1wLlxuICogSXQgaXMgZXhwZWN0ZWQgdGhhdCB0aGUgaXRlbSB3aWxsIGJlIHNlbnQgb3ZlciB0aGUgbmV0d29yayBhbmQgZGVxdWV1ZWRcbiAqIGJlZm9yZSB0aGUgZmx1c2gtYWZ0ZXIgdGltZTsgaWYgdGhpcyBkb2Vzbid0IGhhcHBlbiBpdCBpcyBjb25zaWRlcmVkIG9ycGhhbmVkXG4gKiAoZS5nLiwgdGhlIG9yaWdpbmFsIHRhYiB3aGVyZSBpdCB3YXMgZW5xdWV1ZWQgZ290IGNsb3NlZCBiZWZvcmUgaXQgY291bGQgYmVcbiAqIHNlbnQpIGFuZCB0aGUgaXRlbSBjYW4gYmUgc2VudCBieSBhbnkgdGFiIHRoYXQgZmluZHMgaXQgaW4gbG9jYWxTdG9yYWdlLlxuICpcbiAqIFRoZSBmaW5hbCBjYWxsYmFjayBwYXJhbSBpcyBjYWxsZWQgd2l0aCBhIHBhcmFtIGluZGljYXRpbmcgc3VjY2VzcyBvclxuICogZmFpbHVyZSBvZiB0aGUgZW5xdWV1ZSBvcGVyYXRpb247IGl0IGlzIGFzeW5jaHJvbm91cyBiZWNhdXNlIHRoZSBsb2NhbFN0b3JhZ2VcbiAqIGxvY2sgaXMgYXN5bmNocm9ub3VzLlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAoaXRlbSwgZmx1c2hJbnRlcnZhbCkge1xuICAgIHZhciBxdWV1ZUVudHJ5ID0ge1xuICAgICAgICAnaWQnOiBjaGVhcF9ndWlkKCksXG4gICAgICAgICdmbHVzaEFmdGVyJzogbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBmbHVzaEludGVydmFsICogMixcbiAgICAgICAgJ3BheWxvYWQnOiBpdGVtXG4gICAgfTtcblxuICAgIGlmICghdGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICB0aGlzLm1lbVF1ZXVlLnB1c2gocXVldWVFbnRyeSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnF1ZXVlUGVyc2lzdGVkKHF1ZXVlRW50cnkpO1xuICAgIH1cbn07XG5cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuX2VucXVldWVQZXJzaXN0ZWQgPSBmdW5jdGlvbiAocXVldWVFbnRyaWVzKSB7XG4gICAgdmFyIGVucXVldWVJdGVtID0gXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN0b3JlZFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZVRvU3RvcmFnZShzdG9yZWRRdWV1ZS5jb25jYXQocXVldWVFbnRyaWVzKSk7XG4gICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBhZGQgdG8gaW4tbWVtb3J5IHF1ZXVlIHdoZW4gc3RvcmFnZSBzdWNjZWVkc1xuICAgICAgICAgICAgICAgIGlmIChzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1RdWV1ZSA9IHRoaXMubWVtUXVldWUuY29uY2F0KHF1ZXVlRW50cmllcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2NlZWRlZDtcbiAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgZW5xdWV1ZWluZyBpdGVtcycsIGVyciwgcXVldWVFbnRyaWVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcy5sb2NrXG4gICAgICAgIC53aXRoTG9jayhlbnF1ZXVlSXRlbSwgdGhpcy5waWQpXG4gICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgYWNxdWlyaW5nIHN0b3JhZ2UgbG9jaycsIGVycik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0sIHRoaXMpKTtcbn07XG5cbi8qKlxuICogUmVhZCBvdXQgdGhlIGdpdmVuIG51bWJlciBvZiBxdWV1ZSBlbnRyaWVzLiBJZiB0aGlzLm1lbVF1ZXVlXG4gKiBoYXMgZmV3ZXIgdGhhbiBiYXRjaFNpemUgaXRlbXMsIHRoZW4gbG9vayBmb3IgXCJvcnBoYW5lZFwiIGl0ZW1zXG4gKiBpbiB0aGUgcGVyc2lzdGVkIHF1ZXVlIChpdGVtcyB3aGVyZSB0aGUgJ2ZsdXNoQWZ0ZXInIHRpbWUgaGFzXG4gKiBhbHJlYWR5IHBhc3NlZCkuXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuZmlsbEJhdGNoID0gZnVuY3Rpb24gKGJhdGNoU2l6ZSkge1xuICAgIHZhciBiYXRjaCA9IHRoaXMubWVtUXVldWUuc2xpY2UoMCwgYmF0Y2hTaXplKTtcbiAgICBpZiAodGhpcy51c2VQZXJzaXN0ZW5jZSAmJiBiYXRjaC5sZW5ndGggPCBiYXRjaFNpemUpIHtcbiAgICAgICAgLy8gZG9uJ3QgbmVlZCBsb2NrIGp1c3QgdG8gcmVhZCBldmVudHM7IGxvY2FsU3RvcmFnZSBpcyB0aHJlYWQtc2FmZVxuICAgICAgICAvLyBhbmQgdGhlIHdvcnN0IHRoYXQgY291bGQgaGFwcGVuIGlzIGEgZHVwbGljYXRlIHNlbmQgb2Ygc29tZVxuICAgICAgICAvLyBvcnBoYW5lZCBldmVudHMsIHdoaWNoIHdpbGwgYmUgZGVkdXBsaWNhdGVkIG9uIHRoZSBzZXJ2ZXIgc2lkZVxuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZyb21TdG9yYWdlKCk7XG4gICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3RvcmVkUXVldWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmVkUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0gSURzIGFscmVhZHkgaW4gYmF0Y2g7IGRvbid0IGR1cGxpY2F0ZSBvdXQgb2Ygc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgICB2YXIgaWRzSW5CYXRjaCA9IHt9OyAvLyBwb29yIG1hbidzIFNldFxuICAgICAgICAgICAgICAgICAgICBfLmVhY2goYmF0Y2gsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHNJbkJhdGNoW2l0ZW1bJ2lkJ11dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9yZWRRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBzdG9yZWRRdWV1ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSA+IGl0ZW1bJ2ZsdXNoQWZ0ZXInXSAmJiAhaWRzSW5CYXRjaFtpdGVtWydpZCddXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0ub3JwaGFuZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhdGNoLmxlbmd0aCA+PSBiYXRjaFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhdGNoO1xuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZShiYXRjaCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgaXRlbXMgd2l0aCBtYXRjaGluZyAnaWQnIGZyb20gYXJyYXkgKGltbXV0YWJseSlcbiAqIGFsc28gcmVtb3ZlIGFueSBpdGVtIHdpdGhvdXQgYSB2YWxpZCBpZCAoZS5nLiwgbWFsZm9ybWVkXG4gKiBzdG9yYWdlIGVudHJpZXMpLlxuICovXG52YXIgZmlsdGVyT3V0SURzQW5kSW52YWxpZCA9IGZ1bmN0aW9uIChpdGVtcywgaWRTZXQpIHtcbiAgICB2YXIgZmlsdGVyZWRJdGVtcyA9IFtdO1xuICAgIF8uZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW1bJ2lkJ10gJiYgIWlkU2V0W2l0ZW1bJ2lkJ11dKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZEl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZmlsdGVyZWRJdGVtcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGl0ZW1zIHdpdGggbWF0Y2hpbmcgSURzIGZyb20gYm90aCBpbi1tZW1vcnkgcXVldWVcbiAqIGFuZCBwZXJzaXN0ZWQgcXVldWVcbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5yZW1vdmVJdGVtc0J5SUQgPSBmdW5jdGlvbiAoaWRzKSB7XG4gICAgdmFyIGlkU2V0ID0ge307IC8vIHBvb3IgbWFuJ3MgU2V0XG4gICAgXy5lYWNoKGlkcywgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlkU2V0W2lkXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICB0aGlzLm1lbVF1ZXVlID0gZmlsdGVyT3V0SURzQW5kSW52YWxpZCh0aGlzLm1lbVF1ZXVlLCBpZFNldCk7XG4gICAgaWYgKCF0aGlzLnVzZVBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVtb3ZlRnJvbVN0b3JhZ2UgPSBfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5zdXJlSW5pdCgpXG4gICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZyb21TdG9yYWdlKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZWRRdWV1ZSA9IGZpbHRlck91dElEc0FuZEludmFsaWQoc3RvcmVkUXVldWUsIGlkU2V0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZVRvU3RvcmFnZShzdG9yZWRRdWV1ZSk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVhZEZyb21TdG9yYWdlKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBleHRyYSBjaGVjazogZGlkIHN0b3JhZ2UgcmVwb3J0IHN1Y2Nlc3MgYnV0IHNvbWVob3dcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGl0ZW1zIGFyZSBzdGlsbCB0aGVyZT9cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdG9yZWRRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBzdG9yZWRRdWV1ZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtWydpZCddICYmICEhaWRTZXRbaXRlbVsnaWQnXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0l0ZW0gbm90IHJlbW92ZWQgZnJvbSBzdG9yYWdlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIHJlbW92aW5nIGl0ZW1zJywgZXJyLCBpZHMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5sb2NrXG4gICAgICAgICAgICAud2l0aExvY2socmVtb3ZlRnJvbVN0b3JhZ2UsIHRoaXMucGlkKVxuICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgYWNxdWlyaW5nIHN0b3JhZ2UgbG9jaycsIGVycik7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2NhbFN0b3JhZ2VTdXBwb3J0ZWQodGhpcy5sb2NrLnN0b3JhZ2UsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExvb2tzIGxpa2UgbG9jYWxTdG9yYWdlIHdyaXRlcyBoYXZlIHN0b3BwZWQgd29ya2luZyBzb21ldGltZSBhZnRlclxuICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXphdGlvbiAocHJvYmFibHkgZnVsbCksIGFuZCBzbyBub2JvZHkgY2FuIGFjcXVpcmUgbG9ja3NcbiAgICAgICAgICAgICAgICAgICAgLy8gYW55bW9yZS4gQ29uc2lkZXIgaXQgdGVtcG9yYXJpbHkgc2FmZSB0byByZW1vdmUgaXRlbXMgd2l0aG91dCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9jaywgc2luY2Ugbm9ib2R5J3Mgd3JpdGluZyBzdWNjZXNzZnVsbHkgYW55d2F5LlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlRnJvbVN0b3JhZ2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9LLCB3ZSBjb3VsZG4ndCBldmVuIHdyaXRlIG91dCB0aGUgc21hbGxlciBxdWV1ZS4gVHJ5IGNsZWFyaW5nIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnN0b3JhZ2VLZXkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgY2xlYXJpbmcgcXVldWUnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgIH1cbn07XG5cbi8vIGludGVybmFsIGhlbHBlciBmb3IgUmVxdWVzdFF1ZXVlLnVwZGF0ZVBheWxvYWRzXG52YXIgdXBkYXRlUGF5bG9hZHMgPSBmdW5jdGlvbiAoZXhpc3RpbmdJdGVtcywgaXRlbXNUb1VwZGF0ZSkge1xuICAgIHZhciBuZXdJdGVtcyA9IFtdO1xuICAgIF8uZWFjaChleGlzdGluZ0l0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgaWQgPSBpdGVtWydpZCddO1xuICAgICAgICBpZiAoaWQgaW4gaXRlbXNUb1VwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIG5ld1BheWxvYWQgPSBpdGVtc1RvVXBkYXRlW2lkXTtcbiAgICAgICAgICAgIGlmIChuZXdQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlbVsncGF5bG9hZCddID0gbmV3UGF5bG9hZDtcbiAgICAgICAgICAgICAgICBuZXdJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gdXBkYXRlXG4gICAgICAgICAgICBuZXdJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0l0ZW1zO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgcGF5bG9hZHMgb2YgZ2l2ZW4gaXRlbXMgaW4gYm90aCBpbi1tZW1vcnkgcXVldWUgYW5kXG4gKiBwZXJzaXN0ZWQgcXVldWUuIEl0ZW1zIHNldCB0byBudWxsIGFyZSByZW1vdmVkIGZyb20gcXVldWVzLlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLnVwZGF0ZVBheWxvYWRzID0gZnVuY3Rpb24gKGl0ZW1zVG9VcGRhdGUpIHtcbiAgICB0aGlzLm1lbVF1ZXVlID0gdXBkYXRlUGF5bG9hZHModGhpcy5tZW1RdWV1ZSwgaXRlbXNUb1VwZGF0ZSk7XG4gICAgaWYgKCF0aGlzLnVzZVBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NrXG4gICAgICAgICAgICAud2l0aExvY2soXy5iaW5kKGZ1bmN0aW9uIGxvY2tBY3F1aXJlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkUXVldWUgPSB1cGRhdGVQYXlsb2FkcyhzdG9yZWRRdWV1ZSwgaXRlbXNUb1VwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlVG9TdG9yYWdlKHN0b3JlZFF1ZXVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgdXBkYXRpbmcgaXRlbXMnLCBpdGVtc1RvVXBkYXRlLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICB9LCB0aGlzKSwgdGhpcy5waWQpXG4gICAgICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBhY3F1aXJpbmcgc3RvcmFnZSBsb2NrJywgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWFkIGFuZCBwYXJzZSBpdGVtcyBhcnJheSBmcm9tIGxvY2FsU3RvcmFnZSBlbnRyeSwgaGFuZGxpbmdcbiAqIG1hbGZvcm1lZC9taXNzaW5nIGRhdGEgaWYgbmVjZXNzYXJ5LlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLnJlYWRGcm9tU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlU3RvcmFnZS5nZXRJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN0b3JhZ2VFbnRyeSkge1xuICAgICAgICAgICAgaWYgKHN0b3JhZ2VFbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghXy5pc0FycmF5KHN0b3JhZ2VFbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignSW52YWxpZCBzdG9yYWdlIGVudHJ5OicsIHN0b3JhZ2VFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VFbnRyeSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VFbnRyeSB8fCBbXTtcbiAgICAgICAgfSwgdGhpcykpXG4gICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgcmV0cmlldmluZyBxdWV1ZScsIGVycik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sIHRoaXMpKTtcbn07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBpdGVtcyBhcnJheSB0byBsb2NhbFN0b3JhZ2UuXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuc2F2ZVRvU3RvcmFnZSA9IGZ1bmN0aW9uIChxdWV1ZSkge1xuICAgIHJldHVybiB0aGlzLmVuc3VyZUluaXQoKVxuICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWVTdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBxdWV1ZSk7XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBzYXZpbmcgcXVldWUnLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIENsZWFyIG91dCBxdWV1ZXMgKG1lbW9yeSBhbmQgbG9jYWxTdG9yYWdlKS5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm1lbVF1ZXVlID0gW107XG5cbiAgICBpZiAodGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWVTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICB9XG59O1xuXG4vLyBtYXhpbXVtIGludGVydmFsIGJldHdlZW4gcmVxdWVzdCByZXRyaWVzIGFmdGVyIGV4cG9uZW50aWFsIGJhY2tvZmZcbnZhciBNQVhfUkVUUllfSU5URVJWQUxfTVMgPSAxMCAqIDYwICogMTAwMDsgLy8gMTAgbWludXRlc1xuXG52YXIgbG9nZ2VyJDQgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdiYXRjaCcpO1xuXG4vKipcbiAqIFJlcXVlc3RCYXRjaGVyOiBtYW5hZ2VzIHRoZSBxdWV1ZWluZywgZmx1c2hpbmcsIHJldHJ5IGV0YyBvZiByZXF1ZXN0cyBvZiBvbmVcbiAqIHR5cGUgKGV2ZW50cywgcGVvcGxlLCBncm91cHMpLlxuICogVXNlcyBSZXF1ZXN0UXVldWUgdG8gbWFuYWdlIHRoZSBiYWNraW5nIHN0b3JlLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBSZXF1ZXN0QmF0Y2hlciA9IGZ1bmN0aW9uKHN0b3JhZ2VLZXksIG9wdGlvbnMpIHtcbiAgICB0aGlzLmVycm9yUmVwb3J0ZXIgPSBvcHRpb25zLmVycm9yUmVwb3J0ZXI7XG4gICAgdGhpcy5xdWV1ZSA9IG5ldyBSZXF1ZXN0UXVldWUoc3RvcmFnZUtleSwge1xuICAgICAgICBlcnJvclJlcG9ydGVyOiBfLmJpbmQodGhpcy5yZXBvcnRFcnJvciwgdGhpcyksXG4gICAgICAgIHF1ZXVlU3RvcmFnZTogb3B0aW9ucy5xdWV1ZVN0b3JhZ2UsXG4gICAgICAgIHNoYXJlZExvY2tTdG9yYWdlOiBvcHRpb25zLnNoYXJlZExvY2tTdG9yYWdlLFxuICAgICAgICBzaGFyZWRMb2NrVGltZW91dE1TOiBvcHRpb25zLnNoYXJlZExvY2tUaW1lb3V0TVMsXG4gICAgICAgIHVzZVBlcnNpc3RlbmNlOiBvcHRpb25zLnVzZVBlcnNpc3RlbmNlLFxuICAgICAgICBlbnF1ZXVlVGhyb3R0bGVNczogb3B0aW9ucy5lbnF1ZXVlVGhyb3R0bGVNc1xuICAgIH0pO1xuXG4gICAgdGhpcy5saWJDb25maWcgPSBvcHRpb25zLmxpYkNvbmZpZztcbiAgICB0aGlzLnNlbmRSZXF1ZXN0ID0gb3B0aW9ucy5zZW5kUmVxdWVzdEZ1bmM7XG4gICAgdGhpcy5iZWZvcmVTZW5kSG9vayA9IG9wdGlvbnMuYmVmb3JlU2VuZEhvb2s7XG4gICAgdGhpcy5zdG9wQWxsQmF0Y2hpbmcgPSBvcHRpb25zLnN0b3BBbGxCYXRjaGluZ0Z1bmM7XG5cbiAgICAvLyBzZWVkIHZhcmlhYmxlIGJhdGNoIHNpemUgKyBmbHVzaCBpbnRlcnZhbCB3aXRoIGNvbmZpZ3VyZWQgdmFsdWVzXG4gICAgdGhpcy5iYXRjaFNpemUgPSB0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfc2l6ZSddO1xuICAgIHRoaXMuZmx1c2hJbnRlcnZhbCA9IHRoaXMubGliQ29uZmlnWydiYXRjaF9mbHVzaF9pbnRlcnZhbF9tcyddO1xuXG4gICAgdGhpcy5zdG9wcGVkID0gIXRoaXMubGliQ29uZmlnWydiYXRjaF9hdXRvc3RhcnQnXTtcbiAgICB0aGlzLmNvbnNlY3V0aXZlUmVtb3ZhbEZhaWx1cmVzID0gMDtcblxuICAgIC8vIGV4dHJhIGNsaWVudC1zaWRlIGRlZHVwZVxuICAgIHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHkgPSB7fTtcblxuICAgIC8vIE1ha2UgdGhlIGZsdXNoIG9jY3VyIGF0IHRoZSBpbnRlcnZhbCBzcGVjaWZpZWQgYnkgZmx1c2hJbnRlcnZhbE1zLCBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgYXR0ZW1wdCBjb25zZWN1dGl2ZSBmbHVzaGVzXG4gICAgLy8gYXMgbG9uZyBhcyB0aGUgcXVldWUgaXMgbm90IGVtcHR5LiBUaGlzIGlzIHVzZWZ1bCBmb3IgaGlnaC1mcmVxdWVuY3kgZXZlbnRzIGxpa2UgU2Vzc2lvbiBSZXBsYXkgd2hlcmUgd2UgbWlnaHQgZW5kIHVwXG4gICAgLy8gaW4gYSByZXF1ZXN0IGxvb3AgYW5kIGdldCByYXRlbGltaXRlZCBieSB0aGUgc2VydmVyLlxuICAgIHRoaXMuZmx1c2hPbmx5T25JbnRlcnZhbCA9IG9wdGlvbnMuZmx1c2hPbmx5T25JbnRlcnZhbCB8fCBmYWxzZTtcblxuICAgIHRoaXMuX2ZsdXNoUHJvbWlzZSA9IG51bGw7XG59O1xuXG4vKipcbiAqIEFkZCBvbmUgaXRlbSB0byBxdWV1ZS5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIHRoaXMucXVldWUuZW5xdWV1ZShpdGVtLCB0aGlzLmZsdXNoSW50ZXJ2YWwpO1xufTtcblxuLyoqXG4gKiBTdGFydCBmbHVzaGluZyBiYXRjaGVzIGF0IHRoZSBjb25maWd1cmVkIHRpbWUgaW50ZXJ2YWwuIE11c3QgY2FsbFxuICogdGhpcyBtZXRob2QgdXBvbiBTREsgaW5pdCBpbiBvcmRlciB0byBzZW5kIGFueXRoaW5nIG92ZXIgdGhlIG5ldHdvcmsuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xuICAgIHRoaXMuY29uc2VjdXRpdmVSZW1vdmFsRmFpbHVyZXMgPSAwO1xuICAgIHJldHVybiB0aGlzLmZsdXNoKCk7XG59O1xuXG4vKipcbiAqIFN0b3AgZmx1c2hpbmcgYmF0Y2hlcy4gQ2FuIGJlIHJlc3RhcnRlZCBieSBjYWxsaW5nIHN0YXJ0KCkuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy50aW1lb3V0SUQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElEKTtcbiAgICAgICAgdGhpcy50aW1lb3V0SUQgPSBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2xlYXIgb3V0IHF1ZXVlLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZS5jbGVhcigpO1xufTtcblxuLyoqXG4gKiBSZXN0b3JlIGJhdGNoIHNpemUgY29uZmlndXJhdGlvbiB0byB3aGF0ZXZlciBpcyBzZXQgaW4gdGhlIG1haW4gU0RLLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUucmVzZXRCYXRjaFNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmJhdGNoU2l6ZSA9IHRoaXMubGliQ29uZmlnWydiYXRjaF9zaXplJ107XG59O1xuXG4vKipcbiAqIFJlc3RvcmUgZmx1c2ggaW50ZXJ2YWwgdGltZSBjb25maWd1cmF0aW9uIHRvIHdoYXRldmVyIGlzIHNldCBpbiB0aGUgbWFpbiBTREsuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5yZXNldEZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zY2hlZHVsZUZsdXNoKHRoaXMubGliQ29uZmlnWydiYXRjaF9mbHVzaF9pbnRlcnZhbF9tcyddKTtcbn07XG5cbi8qKlxuICogU2NoZWR1bGUgdGhlIG5leHQgZmx1c2ggaW4gdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5zY2hlZHVsZUZsdXNoID0gZnVuY3Rpb24oZmx1c2hNUykge1xuICAgIHRoaXMuZmx1c2hJbnRlcnZhbCA9IGZsdXNoTVM7XG4gICAgaWYgKCF0aGlzLnN0b3BwZWQpIHsgLy8gZG9uJ3Qgc2NoZWR1bGUgYW55bW9yZSBpZiBiYXRjaGluZyBoYXMgYmVlbiBzdG9wcGVkXG4gICAgICAgIHRoaXMudGltZW91dElEID0gc2V0VGltZW91dChfLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RvcHBlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2ZsdXNoUHJvbWlzZSA9IHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyksIHRoaXMuZmx1c2hJbnRlcnZhbCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZW5kIGEgcmVxdWVzdCB1c2luZyB0aGUgc2VuZFJlcXVlc3QgY2FsbGJhY2ssIGJ1dCBwcm9taXNpZmllZC5cbiAqIFRPRE86IHNlbmRSZXF1ZXN0IHNob3VsZCBiZSBwcm9taXNpZmllZCBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5zZW5kUmVxdWVzdFByb21pc2UgPSBmdW5jdGlvbihkYXRhLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlUG9seWZpbGwoXy5iaW5kKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChkYXRhLCBvcHRpb25zLCByZXNvbHZlKTtcbiAgICB9LCB0aGlzKSk7XG59O1xuXG5cbi8qKlxuICogRmx1c2ggb25lIGJhdGNoIHRvIG5ldHdvcmsuIERlcGVuZGluZyBvbiBzdWNjZXNzL2ZhaWx1cmUgbW9kZXMsIGl0IHdpbGwgZWl0aGVyXG4gKiByZW1vdmUgdGhlIGJhdGNoIGZyb20gdGhlIHF1ZXVlIG9yIGxlYXZlIGl0IGluIGZvciByZXRyeSwgYW5kIHNjaGVkdWxlIHRoZSBuZXh0XG4gKiBmbHVzaC4gSW4gY2FzZXMgb2YgbW9zdCBuZXR3b3JrIG9yIEFQSSBmYWlsdXJlcywgaXQgd2lsbCBiYWNrIG9mZiBleHBvbmVudGlhbGx5XG4gKiB3aGVuIHJldHJ5aW5nLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZW5kQmVhY29uXSAtIHdoZXRoZXIgdG8gc2VuZCBiYXRjaCB3aXRoXG4gKiBuYXZpZ2F0b3Iuc2VuZEJlYWNvbiAob25seSB1c2VmdWwgZm9yIHNlbmRpbmcgYmF0Y2hlcyBiZWZvcmUgcGFnZSB1bmxvYWRzLCBhc1xuICogc2VuZEJlYWNvbiBvZmZlcnMgbm8gY2FsbGJhY2tzIG9yIHN0YXR1cyBpbmRpY2F0aW9ucylcbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmICh0aGlzLnJlcXVlc3RJblByb2dyZXNzKSB7XG4gICAgICAgIGxvZ2dlciQ0LmxvZygnRmx1c2g6IFJlcXVlc3QgYWxyZWFkeSBpbiBwcm9ncmVzcycpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlcXVlc3RJblByb2dyZXNzID0gdHJ1ZTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB0aW1lb3V0TVMgPSB0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfcmVxdWVzdF90aW1lb3V0X21zJ107XG4gICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHZhciBjdXJyZW50QmF0Y2hTaXplID0gdGhpcy5iYXRjaFNpemU7XG5cbiAgICByZXR1cm4gdGhpcy5xdWV1ZS5maWxsQmF0Y2goY3VycmVudEJhdGNoU2l6ZSlcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uKGJhdGNoKSB7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgbW9yZSBpdGVtcyBpbiB0aGUgcXVldWUgdGhhbiB0aGUgYmF0Y2ggc2l6ZSwgYXR0ZW1wdFxuICAgICAgICAgICAgLy8gdG8gZmx1c2ggYWdhaW4gYWZ0ZXIgdGhlIGN1cnJlbnQgYmF0Y2ggaXMgZG9uZS5cbiAgICAgICAgICAgIHZhciBhdHRlbXB0U2Vjb25kYXJ5Rmx1c2ggPSBiYXRjaC5sZW5ndGggPT09IGN1cnJlbnRCYXRjaFNpemU7XG4gICAgICAgICAgICB2YXIgZGF0YUZvclJlcXVlc3QgPSBbXTtcbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1lZEl0ZW1zID0ge307XG4gICAgICAgICAgICBfLmVhY2goYmF0Y2gsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGl0ZW1bJ3BheWxvYWQnXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iZWZvcmVTZW5kSG9vayAmJiAhaXRlbS5vcnBoYW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkID0gdGhpcy5iZWZvcmVTZW5kSG9vayhwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbXBfc2VudF9ieV9saWJfdmVyc2lvbiBwcm9wIGNhcHR1cmVzIHdoaWNoIGxpYiB2ZXJzaW9uIGFjdHVhbGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIHNlbmRzIGVhY2ggZXZlbnQgKHJlZ2FyZGxlc3Mgb2Ygd2hpY2ggdmVyc2lvbiBvcmlnaW5hbGx5IHF1ZXVlZFxuICAgICAgICAgICAgICAgICAgICAvLyBpdCBmb3Igc2VuZGluZylcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBheWxvYWRbJ2V2ZW50J10gJiYgcGF5bG9hZFsncHJvcGVydGllcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkWydwcm9wZXJ0aWVzJ10gPSBfLmV4dGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkWydwcm9wZXJ0aWVzJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeydtcF9zZW50X2J5X2xpYl92ZXJzaW9uJzogQ29uZmlnLkxJQl9WRVJTSU9OfVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYWRkUGF5bG9hZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtSWQgPSBpdGVtWydpZCddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXSB8fCAwKSA+IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdbZHVwZV0gaXRlbSBJRCBzZW50IHRvbyBtYW55IHRpbWVzLCBub3Qgc2VuZGluZycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2hTaXplOiBiYXRjaC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzU2VudDogdGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUGF5bG9hZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignW2R1cGVdIGZvdW5kIGl0ZW0gd2l0aCBubyBJRCcsIHtpdGVtOiBpdGVtfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkUGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUZvclJlcXVlc3QucHVzaChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZEl0ZW1zW2l0ZW1bJ2lkJ11dID0gcGF5bG9hZDtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAoZGF0YUZvclJlcXVlc3QubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTsgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVtb3ZlSXRlbXNGcm9tUXVldWUgPSBfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlXG4gICAgICAgICAgICAgICAgICAgIC5yZW1vdmVJdGVtc0J5SUQoXG4gICAgICAgICAgICAgICAgICAgICAgICBfLm1hcChiYXRjaCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbVsnaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdWNjZWVkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsaWVudC1zaWRlIGRlZHVwZVxuICAgICAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGJhdGNoLCBfLmJpbmQoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtSWQgPSBpdGVtWydpZCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdID0gdGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHlbaXRlbUlkXSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdID4gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignW2R1cGVdIGl0ZW0gSUQgc2VudCB0b28gbWFueSB0aW1lcycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoU2l6ZTogYmF0Y2gubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzU2VudDogdGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1tkdXBlXSBmb3VuZCBpdGVtIHdpdGggbm8gSUQgd2hpbGUgcmVtb3ZpbmcnLCB7aXRlbTogaXRlbX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uc2VjdXRpdmVSZW1vdmFsRmFpbHVyZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsdXNoT25seU9uSW50ZXJ2YWwgJiYgIWF0dGVtcHRTZWNvbmRhcnlGbHVzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTsgLy8gc2NoZWR1bGUgbmV4dCBiYXRjaCB3aXRoIGEgZGVsYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmx1c2goKTsgLy8gaGFuZGxlIG5leHQgYmF0Y2ggaWYgdGhlIHF1ZXVlIGlzbid0IGVtcHR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKyt0aGlzLmNvbnNlY3V0aXZlUmVtb3ZhbEZhaWx1cmVzID4gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdUb28gbWFueSBxdWV1ZSBmYWlsdXJlczsgZGlzYWJsaW5nIGJhdGNoaW5nIHN5c3RlbS4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wQWxsQmF0Y2hpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICB2YXIgYmF0Y2hTZW5kQ2FsbGJhY2sgPSBfLmJpbmQoZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0SW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgQVBJIHJlc3BvbnNlIGluIGEgdHJ5LWNhdGNoIHRvIG1ha2Ugc3VyZSB3ZSBjYW4gcmVzZXQgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsdXNoIG9wZXJhdGlvbiBpZiBzb21ldGhpbmcgZ29lcyB3cm9uZ1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnVubG9hZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHBlcnNpc3RlZCBkYXRhIHRvIGluY2x1ZGUgaG9vayB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlLnVwZGF0ZVBheWxvYWRzKHRyYW5zZm9ybWVkSXRlbXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgXy5pc09iamVjdChyZXMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLmVycm9yID09PSAndGltZW91dCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZSA+PSB0aW1lb3V0TVNcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdOZXR3b3JrIHRpbWVvdXQ7IHJldHJ5aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgXy5pc09iamVjdChyZXMpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMuaHR0cFN0YXR1c0NvZGUgPj0gNTAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHJlcy5odHRwU3RhdHVzQ29kZSA9PT0gNDI5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IChyZXMuaHR0cFN0YXR1c0NvZGUgPD0gMCAmJiAhaXNPbmxpbmUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgcmVzLmVycm9yID09PSAndGltZW91dCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV0d29yayBvciBBUEkgZXJyb3IsIG9yIDQyOSBUb28gTWFueSBSZXF1ZXN0cywgcmV0cnlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXRyeU1TID0gdGhpcy5mbHVzaEludGVydmFsICogMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMucmV0cnlBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5TVMgPSAocGFyc2VJbnQocmVzLnJldHJ5QWZ0ZXIsIDEwKSAqIDEwMDApIHx8IHJldHJ5TVM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeU1TID0gTWF0aC5taW4oTUFYX1JFVFJZX0lOVEVSVkFMX01TLCByZXRyeU1TKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yOyByZXRyeSBpbiAnICsgcmV0cnlNUyArICcgbXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVGbHVzaChyZXRyeU1TKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QocmVzKSAmJiByZXMuaHR0cFN0YXR1c0NvZGUgPT09IDQxMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gNDEzIFBheWxvYWQgVG9vIExhcmdlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYWx2ZWRCYXRjaFNpemUgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGN1cnJlbnRCYXRjaFNpemUgLyAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXRjaFNpemUgPSBNYXRoLm1pbih0aGlzLmJhdGNoU2l6ZSwgaGFsdmVkQmF0Y2hTaXplLCBiYXRjaC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCc0MTMgcmVzcG9uc2U7IHJlZHVjaW5nIGJhdGNoIHNpemUgdG8gJyArIHRoaXMuYmF0Y2hTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignU2luZ2xlLWV2ZW50IHJlcXVlc3QgdG9vIGxhcmdlOyBkcm9wcGluZycsIGJhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0QmF0Y2hTaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUl0ZW1zRnJvbVF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWNjZXNzZnVsIG5ldHdvcmsgcmVxdWVzdCtyZXNwb25zZTsgcmVtb3ZlIGVhY2ggaXRlbSBpbiBiYXRjaCBmcm9tIHF1ZXVlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAoZXZlbiBpZiBpdCB3YXMgZS5nLiBhIDQwMCwgaW4gd2hpY2ggY2FzZSByZXRyeWluZyB3b24ndCBoZWxwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlbW92ZUl0ZW1zRnJvbVF1ZXVlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBoYW5kbGluZyBBUEkgcmVzcG9uc2UnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICB2ZXJib3NlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlnbm9yZV9qc29uX2Vycm9yczogdHJ1ZSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgICAgICAgICAgICB0aW1lb3V0X21zOiB0aW1lb3V0TVMgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAob3B0aW9ucy51bmxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy50cmFuc3BvcnQgPSAnc2VuZEJlYWNvbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIkNC5sb2coJ01JWFBBTkVMIFJFUVVFU1Q6JywgZGF0YUZvclJlcXVlc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3RQcm9taXNlKGRhdGFGb3JSZXF1ZXN0LCByZXF1ZXN0T3B0aW9ucykudGhlbihiYXRjaFNlbmRDYWxsYmFjayk7XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgZmx1c2hpbmcgcmVxdWVzdCBxdWV1ZScsIGVycik7XG4gICAgICAgICAgICB0aGlzLnJlc2V0Rmx1c2goKTtcbiAgICAgICAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBMb2cgZXJyb3IgdG8gZ2xvYmFsIGxvZ2dlciBhbmQgb3B0aW9uYWwgdXNlci1kZWZpbmVkIGxvZ2dlci5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnJlcG9ydEVycm9yID0gZnVuY3Rpb24obXNnLCBlcnIpIHtcbiAgICBsb2dnZXIkNC5lcnJvci5hcHBseShsb2dnZXIkNC5lcnJvciwgYXJndW1lbnRzKTtcbiAgICBpZiAodGhpcy5lcnJvclJlcG9ydGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXJyb3JSZXBvcnRlcihtc2csIGVycik7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICBsb2dnZXIkNC5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9zZXNzaW9uLXJlY29yZGluZycpLlNlcmlhbGl6ZWRSZWNvcmRpbmd9IHNlcmlhbGl6ZWRSZWNvcmRpbmdcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG52YXIgaXNSZWNvcmRpbmdFeHBpcmVkID0gZnVuY3Rpb24oc2VyaWFsaXplZFJlY29yZGluZykge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiAhc2VyaWFsaXplZFJlY29yZGluZyB8fCBub3cgPiBzZXJpYWxpemVkUmVjb3JkaW5nWydtYXhFeHBpcmVzJ10gfHwgbm93ID4gc2VyaWFsaXplZFJlY29yZGluZ1snaWRsZUV4cGlyZXMnXTtcbn07XG5cbnZhciBSRUNPUkRfRU5RVUVVRV9USFJPVFRMRV9NUyA9IDI1MDtcblxudmFyIGxvZ2dlciQzID0gY29uc29sZV93aXRoX3ByZWZpeCgncmVjb3JkZXInKTtcbnZhciBDb21wcmVzc2lvblN0cmVhbSA9IHdpblsnQ29tcHJlc3Npb25TdHJlYW0nXTtcblxudmFyIFJFQ09SREVSX0JBVENIRVJfTElCX0NPTkZJRyA9IHtcbiAgICAnYmF0Y2hfc2l6ZSc6IDEwMDAsXG4gICAgJ2JhdGNoX2ZsdXNoX2ludGVydmFsX21zJzogMTAgKiAxMDAwLFxuICAgICdiYXRjaF9yZXF1ZXN0X3RpbWVvdXRfbXMnOiA5MCAqIDEwMDAsXG4gICAgJ2JhdGNoX2F1dG9zdGFydCc6IHRydWVcbn07XG5cbnZhciBBQ1RJVkVfU09VUkNFUyA9IG5ldyBTZXQoW1xuICAgIEluY3JlbWVudGFsU291cmNlLk1vdXNlTW92ZSxcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5Nb3VzZUludGVyYWN0aW9uLFxuICAgIEluY3JlbWVudGFsU291cmNlLlNjcm9sbCxcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5WaWV3cG9ydFJlc2l6ZSxcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5JbnB1dCxcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5Ub3VjaE1vdmUsXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuTWVkaWFJbnRlcmFjdGlvbixcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5EcmFnLFxuICAgIEluY3JlbWVudGFsU291cmNlLlNlbGVjdGlvbixcbl0pO1xuXG5mdW5jdGlvbiBpc1VzZXJFdmVudChldikge1xuICAgIHJldHVybiBldi50eXBlID09PSBFdmVudFR5cGUuSW5jcmVtZW50YWxTbmFwc2hvdCAmJiBBQ1RJVkVfU09VUkNFUy5oYXMoZXYuZGF0YS5zb3VyY2UpO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlcmlhbGl6ZWRSZWNvcmRpbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZGxlRXhwaXJlc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IG1heEV4cGlyZXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXBsYXlTdGFydFRpbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZXFOb1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGJhdGNoU3RhcnRVcmxcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZXBsYXlJZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHRhYklkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVwbGF5U3RhcnRVcmxcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNlc3Npb25SZWNvcmRpbmdPcHRpb25zXG4gKiBAcHJvcGVydHkge09iamVjdH0gW29wdGlvbnMubWl4cGFuZWxJbnN0YW5jZV0gLSByZWZlcmVuY2UgdG8gdGhlIGNvcmUgTWl4cGFuZWxMaWJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBbb3B0aW9ucy5yZXBsYXlJZF0gLSB1bmlxdWUgdXVpZCBmb3IgYSBzaW5nbGUgcmVwbGF5XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbklkbGVUaW1lb3V0XSAtIGNhbGxiYWNrIHdoZW4gYSByZWNvcmRpbmcgcmVhY2hlcyBpZGxlIHRpbWVvdXRcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IFtvcHRpb25zLm9uTWF4TGVuZ3RoUmVhY2hlZF0gLSBjYWxsYmFjayB3aGVuIGEgcmVjb3JkaW5nIHJlYWNoZXMgaXRzIG1heGltdW0gbGVuZ3RoXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbb3B0aW9ucy5ycndlYlJlY29yZF0gLSBycndlYidzIGByZWNvcmRgIGZ1bmN0aW9uXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbkJhdGNoU2VudF0gLSBjYWxsYmFjayB3aGVuIGEgYmF0Y2ggb2YgZXZlbnRzIGlzIHNlbnQgdG8gdGhlIHNlcnZlclxuICogQHByb3BlcnR5IHtTdG9yYWdlfSBbb3B0aW9ucy5zaGFyZWRMb2NrU3RvcmFnZV0gLSBvcHRpb25hbCBzdG9yYWdlIGZvciBzaGFyZWQgbG9jaywgdXNlZCBmb3IgdGVzdCBkZXBlbmRlbmN5IGluamVjdGlvblxuICogb3B0aW9uYWwgcHJvcGVydGllcyBmb3IgZGVzZXJpYWxpemF0aW9uOlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGlkbGVFeHBpcmVzXG4gKiBAcHJvcGVydHkge251bWJlcn0gbWF4RXhwaXJlc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlcGxheVN0YXJ0VGltZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNlcU5vXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYmF0Y2hTdGFydFVybFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJlcGxheVN0YXJ0VXJsXG4gKi9cblxuXG4vKipcbiAqIFRoaXMgY2xhc3MgZW5jYXBzdWxhdGVzIGEgc2luZ2xlIHNlc3Npb24gcmVjb3JkaW5nIGFuZCBpdHMgbGlmZWN5Y2xlLlxuICogQHBhcmFtIHtTZXNzaW9uUmVjb3JkaW5nT3B0aW9uc30gb3B0aW9uc1xuICovXG52YXIgU2Vzc2lvblJlY29yZGluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9taXhwYW5lbCA9IG9wdGlvbnMubWl4cGFuZWxJbnN0YW5jZTtcbiAgICB0aGlzLl9vbklkbGVUaW1lb3V0ID0gb3B0aW9ucy5vbklkbGVUaW1lb3V0IHx8IE5PT1BfRlVOQztcbiAgICB0aGlzLl9vbk1heExlbmd0aFJlYWNoZWQgPSBvcHRpb25zLm9uTWF4TGVuZ3RoUmVhY2hlZCB8fCBOT09QX0ZVTkM7XG4gICAgdGhpcy5fb25CYXRjaFNlbnQgPSBvcHRpb25zLm9uQmF0Y2hTZW50IHx8IE5PT1BfRlVOQztcbiAgICB0aGlzLl9ycndlYlJlY29yZCA9IG9wdGlvbnMucnJ3ZWJSZWNvcmQgfHwgbnVsbDtcblxuICAgIC8vIGludGVybmFsIHJyd2ViIHN0b3BSZWNvcmRpbmcgZnVuY3Rpb25cbiAgICB0aGlzLl9zdG9wUmVjb3JkaW5nID0gbnVsbDtcbiAgICB0aGlzLnJlcGxheUlkID0gb3B0aW9ucy5yZXBsYXlJZDtcblxuICAgIHRoaXMuYmF0Y2hTdGFydFVybCA9IG9wdGlvbnMuYmF0Y2hTdGFydFVybCB8fCBudWxsO1xuICAgIHRoaXMucmVwbGF5U3RhcnRVcmwgPSBvcHRpb25zLnJlcGxheVN0YXJ0VXJsIHx8IG51bGw7XG4gICAgdGhpcy5pZGxlRXhwaXJlcyA9IG9wdGlvbnMuaWRsZUV4cGlyZXMgfHwgbnVsbDtcbiAgICB0aGlzLm1heEV4cGlyZXMgPSBvcHRpb25zLm1heEV4cGlyZXMgfHwgbnVsbDtcbiAgICB0aGlzLnJlcGxheVN0YXJ0VGltZSA9IG9wdGlvbnMucmVwbGF5U3RhcnRUaW1lIHx8IG51bGw7XG4gICAgdGhpcy5zZXFObyA9IG9wdGlvbnMuc2VxTm8gfHwgMDtcblxuICAgIHRoaXMuaWRsZVRpbWVvdXRJZCA9IG51bGw7XG4gICAgdGhpcy5tYXhUaW1lb3V0SWQgPSBudWxsO1xuXG4gICAgdGhpcy5yZWNvcmRNYXhNcyA9IE1BWF9SRUNPUkRJTkdfTVM7XG4gICAgdGhpcy5yZWNvcmRNaW5NcyA9IDA7XG5cbiAgICAvLyBkaXNhYmxlIHBlcnNpc3RlbmNlIGlmIGxvY2FsU3RvcmFnZSBpcyBub3Qgc3VwcG9ydGVkXG4gICAgLy8gcmVxdWVzdC1xdWV1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgZGlzYWJsZSBwZXJzaXN0ZW5jZSBpZiBpbmRleGVkREIgZmFpbHMgdG8gaW5pdGlhbGl6ZVxuICAgIHZhciB1c2VQZXJzaXN0ZW5jZSA9IGxvY2FsU3RvcmFnZVN1cHBvcnRlZChvcHRpb25zLnNoYXJlZExvY2tTdG9yYWdlLCB0cnVlKTtcblxuICAgIC8vIGVhY2ggcmVwbGF5IGhhcyBpdHMgb3duIGJhdGNoZXIga2V5IHRvIGF2b2lkIGNvbmZsaWN0cyBiZXR3ZWVuIHJyd2ViIGV2ZW50cyBvZiBkaWZmZXJlbnQgcmVjb3JkaW5nc1xuICAgIC8vIHRoaXMgd2lsbCBiZSBpbXBvcnRhbnQgd2hlbiBwZXJzaXN0ZW5jZSBpcyBpbnRyb2R1Y2VkXG4gICAgdGhpcy5iYXRjaGVyS2V5ID0gJ19fbXByZWNfJyArIHRoaXMuZ2V0Q29uZmlnKCduYW1lJykgKyAnXycgKyB0aGlzLmdldENvbmZpZygndG9rZW4nKSArICdfJyArIHRoaXMucmVwbGF5SWQ7XG4gICAgdGhpcy5xdWV1ZVN0b3JhZ2UgPSBuZXcgSURCU3RvcmFnZVdyYXBwZXIoUkVDT1JESU5HX0VWRU5UU19TVE9SRV9OQU1FKTtcbiAgICB0aGlzLmJhdGNoZXIgPSBuZXcgUmVxdWVzdEJhdGNoZXIodGhpcy5iYXRjaGVyS2V5LCB7XG4gICAgICAgIGVycm9yUmVwb3J0ZXI6IHRoaXMucmVwb3J0RXJyb3IuYmluZCh0aGlzKSxcbiAgICAgICAgZmx1c2hPbmx5T25JbnRlcnZhbDogdHJ1ZSxcbiAgICAgICAgbGliQ29uZmlnOiBSRUNPUkRFUl9CQVRDSEVSX0xJQl9DT05GSUcsXG4gICAgICAgIHNlbmRSZXF1ZXN0RnVuYzogdGhpcy5mbHVzaEV2ZW50c1dpdGhPcHRPdXQuYmluZCh0aGlzKSxcbiAgICAgICAgcXVldWVTdG9yYWdlOiB0aGlzLnF1ZXVlU3RvcmFnZSxcbiAgICAgICAgc2hhcmVkTG9ja1N0b3JhZ2U6IG9wdGlvbnMuc2hhcmVkTG9ja1N0b3JhZ2UsXG4gICAgICAgIHVzZVBlcnNpc3RlbmNlOiB1c2VQZXJzaXN0ZW5jZSxcbiAgICAgICAgc3RvcEFsbEJhdGNoaW5nRnVuYzogdGhpcy5zdG9wUmVjb3JkaW5nLmJpbmQodGhpcyksXG5cbiAgICAgICAgLy8gaW5jcmVhc2VkIHRocm90dGxlIGFuZCBzaGFyZWQgbG9jayB0aW1lb3V0IGJlY2F1c2UgcmVjb3JkaW5nIGV2ZW50cyBhcmUgdmVyeSBoaWdoIGZyZXF1ZW5jeS5cbiAgICAgICAgLy8gdGhpcyB3aWxsIG1pbmltaXplIHRoZSBhbW91bnQgb2YgbG9jayBjb250ZW50aW9uIGJldHdlZW4gZW5xdWV1ZWQgZXZlbnRzLlxuICAgICAgICAvLyBmb3Igc2Vzc2lvbiByZWNvcmRpbmdzIHRoZXJlIGlzIGEgbG9jayBmb3IgZWFjaCB0YWIgYW55d2F5LCBzbyB0aGVyZSdzIG5vIHJpc2sgb2YgZGVhZGxvY2sgYmV0d2VlbiB0YWJzLlxuICAgICAgICBlbnF1ZXVlVGhyb3R0bGVNczogUkVDT1JEX0VOUVVFVUVfVEhST1RUTEVfTVMsXG4gICAgICAgIHNoYXJlZExvY2tUaW1lb3V0TVM6IDEwICogMTAwMCxcbiAgICB9KTtcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLnVubG9hZFBlcnNpc3RlZERhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5iYXRjaGVyLnN0b3AoKTtcbiAgICByZXR1cm4gdGhpcy5iYXRjaGVyLmZsdXNoKClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWVTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5iYXRjaGVyS2V5KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZ1Zhcikge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC5nZXRfY29uZmlnKGNvbmZpZ1Zhcik7XG59O1xuXG4vLyBBbGlhcyBmb3IgZ2V0Q29uZmlnLCB1c2VkIGJ5IHRoZSBjb21tb24gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYiBmdW5jdGlvbiB3aGljaFxuLy8gcmVhY2hlcyBpbnRvIHRoaXMgY2xhc3MgaW5zdGFuY2UgYW5kIGV4cGVjdHMgdGhlIHNuYWtlIGNhc2UgdmVyc2lvbiBvZiB0aGUgZnVuY3Rpb24uXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FtZWxjYXNlXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5nZXRfY29uZmlnID0gZnVuY3Rpb24oY29uZmlnVmFyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29uZmlnKGNvbmZpZ1Zhcik7XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5zdGFydFJlY29yZGluZyA9IGZ1bmN0aW9uIChzaG91bGRTdG9wQmF0Y2hlcikge1xuICAgIGlmICh0aGlzLl9ycndlYlJlY29yZCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdycndlYiByZWNvcmQgZnVuY3Rpb24gbm90IHByb3ZpZGVkLiAnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdG9wUmVjb3JkaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGxvZ2dlciQzLmxvZygnUmVjb3JkaW5nIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHNraXBwaW5nIHN0YXJ0UmVjb3JkaW5nLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZWNvcmRNYXhNcyA9IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfbWF4X21zJyk7XG4gICAgaWYgKHRoaXMucmVjb3JkTWF4TXMgPiBNQVhfUkVDT1JESU5HX01TKSB7XG4gICAgICAgIHRoaXMucmVjb3JkTWF4TXMgPSBNQVhfUkVDT1JESU5HX01TO1xuICAgICAgICBsb2dnZXIkMy5jcml0aWNhbCgncmVjb3JkX21heF9tcyBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuICcgKyBNQVhfUkVDT1JESU5HX01TICsgJ21zLiBDYXBwaW5nIHZhbHVlLicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5tYXhFeHBpcmVzKSB7XG4gICAgICAgIHRoaXMubWF4RXhwaXJlcyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgdGhpcy5yZWNvcmRNYXhNcztcbiAgICB9XG5cbiAgICB0aGlzLnJlY29yZE1pbk1zID0gdGhpcy5nZXRDb25maWcoJ3JlY29yZF9taW5fbXMnKTtcbiAgICBpZiAodGhpcy5yZWNvcmRNaW5NcyA+IE1BWF9WQUxVRV9GT1JfTUlOX1JFQ09SRElOR19NUykge1xuICAgICAgICB0aGlzLnJlY29yZE1pbk1zID0gTUFYX1ZBTFVFX0ZPUl9NSU5fUkVDT1JESU5HX01TO1xuICAgICAgICBsb2dnZXIkMy5jcml0aWNhbCgncmVjb3JkX21pbl9tcyBjYW5ub3QgYmUgZ3JlYXRlciB0aGFuICcgKyBNQVhfVkFMVUVfRk9SX01JTl9SRUNPUkRJTkdfTVMgKyAnbXMuIENhcHBpbmcgdmFsdWUuJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnJlcGxheVN0YXJ0VGltZSkge1xuICAgICAgICB0aGlzLnJlcGxheVN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB0aGlzLmJhdGNoU3RhcnRVcmwgPSBfLmluZm8uY3VycmVudFVybCgpO1xuICAgICAgICB0aGlzLnJlcGxheVN0YXJ0VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkU3RvcEJhdGNoZXIgfHwgdGhpcy5yZWNvcmRNaW5NcyA+IDApIHtcbiAgICAgICAgLy8gdGhlIHByaW1hcnkgY2FzZSBmb3Igc2hvdWxkU3RvcEJhdGNoZXIgaXMgd2hlbiB3ZSdyZSBzdGFydGluZyByZWNvcmRpbmcgYWZ0ZXIgYSByZXNldFxuICAgICAgICAvLyBhbmQgZG9uJ3Qgd2FudCB0byBzZW5kIGFueXRoaW5nIG92ZXIgdGhlIG5ldHdvcmsgdW50aWwgdGhlcmUnc1xuICAgICAgICAvLyBhY3R1YWwgdXNlciBhY3Rpdml0eVxuICAgICAgICAvLyB0aGlzIGFsc28gYXBwbGllcyBpZiB0aGUgbWluaW11bSByZWNvcmRpbmcgbGVuZ3RoIGhhcyBub3QgYmVlbiBoaXQgeWV0XG4gICAgICAgIC8vIHNvIHRoYXQgd2UgZG9uJ3Qgc2VuZCBkYXRhIHVudGlsIHdlIGtub3cgdGhlIHJlY29yZGluZyB3aWxsIGJlIGxvbmcgZW5vdWdoXG4gICAgICAgIHRoaXMuYmF0Y2hlci5zdG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5iYXRjaGVyLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgdmFyIHJlc2V0SWRsZVRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmlkbGVUaW1lb3V0SWQpO1xuICAgICAgICB2YXIgaWRsZVRpbWVvdXRNcyA9IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfaWRsZV90aW1lb3V0X21zJyk7XG4gICAgICAgIHRoaXMuaWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fb25JZGxlVGltZW91dCwgaWRsZVRpbWVvdXRNcyk7XG4gICAgICAgIHRoaXMuaWRsZUV4cGlyZXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIGlkbGVUaW1lb3V0TXM7XG4gICAgfS5iaW5kKHRoaXMpO1xuICAgIHJlc2V0SWRsZVRpbWVvdXQoKTtcblxuICAgIHZhciBibG9ja1NlbGVjdG9yID0gdGhpcy5nZXRDb25maWcoJ3JlY29yZF9ibG9ja19zZWxlY3RvcicpO1xuICAgIGlmIChibG9ja1NlbGVjdG9yID09PSAnJyB8fCBibG9ja1NlbGVjdG9yID09PSBudWxsKSB7XG4gICAgICAgIGJsb2NrU2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy5fc3RvcFJlY29yZGluZyA9IHRoaXMuX3Jyd2ViUmVjb3JkKHtcbiAgICAgICAgICAgICdlbWl0JzogZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaWRsZUV4cGlyZXMgJiYgdGhpcy5pZGxlRXhwaXJlcyA8IGV2LnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbklkbGVUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzVXNlckV2ZW50KGV2KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5iYXRjaGVyLnN0b3BwZWQgJiYgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLnJlcGxheVN0YXJ0VGltZSA+PSB0aGlzLnJlY29yZE1pbk1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBmbHVzaGluZyBhZ2FpbiBhZnRlciB1c2VyIGFjdGl2aXR5XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJhdGNoZXIuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNldElkbGVUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHByb21pc2Ugb25seSB1c2VkIHRvIGF3YWl0IGR1cmluZyB0ZXN0c1xuICAgICAgICAgICAgICAgIHRoaXMuX19lbnF1ZXVlUHJvbWlzZSA9IHRoaXMuYmF0Y2hlci5lbnF1ZXVlKGV2KTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgICAgICdibG9ja0NsYXNzJzogdGhpcy5nZXRDb25maWcoJ3JlY29yZF9ibG9ja19jbGFzcycpLFxuICAgICAgICAgICAgJ2Jsb2NrU2VsZWN0b3InOiBibG9ja1NlbGVjdG9yLFxuICAgICAgICAgICAgJ2NvbGxlY3RGb250cyc6IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfY29sbGVjdF9mb250cycpLFxuICAgICAgICAgICAgJ2RhdGFVUkxPcHRpb25zJzogeyAvLyBjYW52YXMgaW1hZ2Ugb3B0aW9ucyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxDYW52YXNFbGVtZW50L3RvRGF0YVVSTClcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdpbWFnZS93ZWJwJyxcbiAgICAgICAgICAgICAgICAncXVhbGl0eSc6IDAuNlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtYXNrQWxsSW5wdXRzJzogdHJ1ZSxcbiAgICAgICAgICAgICdtYXNrVGV4dENsYXNzJzogdGhpcy5nZXRDb25maWcoJ3JlY29yZF9tYXNrX3RleHRfY2xhc3MnKSxcbiAgICAgICAgICAgICdtYXNrVGV4dFNlbGVjdG9yJzogdGhpcy5nZXRDb25maWcoJ3JlY29yZF9tYXNrX3RleHRfc2VsZWN0b3InKSxcbiAgICAgICAgICAgICdyZWNvcmRDYW52YXMnOiB0aGlzLmdldENvbmZpZygncmVjb3JkX2NhbnZhcycpLFxuICAgICAgICAgICAgJ3NhbXBsaW5nJzoge1xuICAgICAgICAgICAgICAgICdjYW52YXMnOiAxNVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignVW5leHBlY3RlZCBlcnJvciB3aGVuIHN0YXJ0aW5nIHJyd2ViIHJlY29yZGluZy4nLCBlcnIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGhpcy5fc3RvcFJlY29yZGluZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdycndlYiBmYWlsZWQgdG8gc3RhcnQsIHNraXBwaW5nIHRoaXMgcmVjb3JkaW5nLicpO1xuICAgICAgICB0aGlzLl9zdG9wUmVjb3JkaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdG9wUmVjb3JkaW5nKCk7IC8vIHN0b3AgYmF0Y2hlciBsb29waW5nIGFuZCBhbnkgdGltZW91dHNcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtYXhUaW1lb3V0TXMgPSB0aGlzLm1heEV4cGlyZXMgLSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB0aGlzLm1heFRpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fb25NYXhMZW5ndGhSZWFjaGVkLmJpbmQodGhpcyksIG1heFRpbWVvdXRNcyk7XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5zdG9wUmVjb3JkaW5nID0gZnVuY3Rpb24gKHNraXBGbHVzaCkge1xuICAgIGlmICghdGhpcy5pc1Jyd2ViU3RvcHBlZCgpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wUmVjb3JkaW5nKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3Igd2l0aCBycndlYiBzdG9wUmVjb3JkaW5nJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdG9wUmVjb3JkaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZmx1c2hQcm9taXNlO1xuICAgIGlmICh0aGlzLmJhdGNoZXIuc3RvcHBlZCkge1xuICAgICAgICAvLyBuZXZlciBnb3QgdXNlciBhY3Rpdml0eSB0byBmbHVzaCBhZnRlciByZXNldCwgc28ganVzdCBjbGVhciB0aGUgYmF0Y2hlclxuICAgICAgICBmbHVzaFByb21pc2UgPSB0aGlzLmJhdGNoZXIuY2xlYXIoKTtcbiAgICB9IGVsc2UgaWYgKCFza2lwRmx1c2gpIHtcbiAgICAgICAgLy8gZmx1c2ggYW55IHJlbWFpbmluZyBldmVudHMgZnJvbSBydW5uaW5nIGJhdGNoZXJcbiAgICAgICAgZmx1c2hQcm9taXNlID0gdGhpcy5iYXRjaGVyLmZsdXNoKCk7XG4gICAgfVxuICAgIHRoaXMuYmF0Y2hlci5zdG9wKCk7XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5pZGxlVGltZW91dElkKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5tYXhUaW1lb3V0SWQpO1xuICAgIHJldHVybiBmbHVzaFByb21pc2U7XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5pc1Jyd2ViU3RvcHBlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcFJlY29yZGluZyA9PT0gbnVsbDtcbn07XG5cblxuLyoqXG4gKiBGbHVzaGVzIHRoZSBjdXJyZW50IGJhdGNoIG9mIGV2ZW50cyB0byB0aGUgc2VydmVyLCBidXQgcGFzc2VzIGFuIG9wdC1vdXQgY2FsbGJhY2sgdG8gbWFrZSBzdXJlXG4gKiB3ZSBzdG9wIHJlY29yZGluZyBhbmQgZHVtcCBhbnkgcXVldWVkIGV2ZW50cyBpZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0LlxuICovXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5mbHVzaEV2ZW50c1dpdGhPcHRPdXQgPSBmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICB2YXIgb25PcHRPdXQgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICAvLyBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliIGludm9rZXMgdGhpcyBmdW5jdGlvbiB3aXRoIGNvZGU9MCB3aGVuIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXRcbiAgICAgICAgaWYgKGNvZGUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFJlY29yZGluZygpO1xuICAgICAgICAgICAgY2Ioe2Vycm9yOiAnVHJhY2tpbmcgaGFzIGJlZW4gb3B0ZWQgb3V0LCBzdG9wcGluZyByZWNvcmRpbmcuJ30pO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fZmx1c2hFdmVudHMoZGF0YSwgb3B0aW9ucywgY2IsIG9uT3B0T3V0KTtcbn07XG5cbi8qKlxuICogQHJldHVybnMge1NlcmlhbGl6ZWRSZWNvcmRpbmd9XG4gKi9cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBkb24ndCBicmVhayBpZiBtaXhwYW5lbCBpbnN0YW5jZSB3YXMgZGVzdHJveWVkIGF0IHNvbWUgcG9pbnRcbiAgICB2YXIgdGFiSWQ7XG4gICAgdHJ5IHtcbiAgICAgICAgdGFiSWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfdGFiX2lkKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBnZXR0aW5nIHRhYiBJRCBmb3Igc2VyaWFsaXphdGlvbiAnLCBlKTtcbiAgICAgICAgdGFiSWQgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgICdyZXBsYXlJZCc6IHRoaXMucmVwbGF5SWQsXG4gICAgICAgICdzZXFObyc6IHRoaXMuc2VxTm8sXG4gICAgICAgICdyZXBsYXlTdGFydFRpbWUnOiB0aGlzLnJlcGxheVN0YXJ0VGltZSxcbiAgICAgICAgJ2JhdGNoU3RhcnRVcmwnOiB0aGlzLmJhdGNoU3RhcnRVcmwsXG4gICAgICAgICdyZXBsYXlTdGFydFVybCc6IHRoaXMucmVwbGF5U3RhcnRVcmwsXG4gICAgICAgICdpZGxlRXhwaXJlcyc6IHRoaXMuaWRsZUV4cGlyZXMsXG4gICAgICAgICdtYXhFeHBpcmVzJzogdGhpcy5tYXhFeHBpcmVzLFxuICAgICAgICAndGFiSWQnOiB0YWJJZCxcbiAgICB9O1xufTtcblxuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7U2VyaWFsaXplZFJlY29yZGluZ30gc2VyaWFsaXplZFJlY29yZGluZ1xuICogQHBhcmFtIHtTZXNzaW9uUmVjb3JkaW5nT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge1Nlc3Npb25SZWNvcmRpbmd9XG4gKi9cblNlc3Npb25SZWNvcmRpbmcuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoc2VyaWFsaXplZFJlY29yZGluZywgb3B0aW9ucykge1xuICAgIHZhciByZWNvcmRpbmcgPSBuZXcgU2Vzc2lvblJlY29yZGluZyhfLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICByZXBsYXlJZDogc2VyaWFsaXplZFJlY29yZGluZ1sncmVwbGF5SWQnXSxcbiAgICAgICAgYmF0Y2hTdGFydFVybDogc2VyaWFsaXplZFJlY29yZGluZ1snYmF0Y2hTdGFydFVybCddLFxuICAgICAgICByZXBsYXlTdGFydFVybDogc2VyaWFsaXplZFJlY29yZGluZ1sncmVwbGF5U3RhcnRVcmwnXSxcbiAgICAgICAgaWRsZUV4cGlyZXM6IHNlcmlhbGl6ZWRSZWNvcmRpbmdbJ2lkbGVFeHBpcmVzJ10sXG4gICAgICAgIG1heEV4cGlyZXM6IHNlcmlhbGl6ZWRSZWNvcmRpbmdbJ21heEV4cGlyZXMnXSxcbiAgICAgICAgcmVwbGF5U3RhcnRUaW1lOiBzZXJpYWxpemVkUmVjb3JkaW5nWydyZXBsYXlTdGFydFRpbWUnXSxcbiAgICAgICAgc2VxTm86IHNlcmlhbGl6ZWRSZWNvcmRpbmdbJ3NlcU5vJ10sXG4gICAgICAgIHNoYXJlZExvY2tTdG9yYWdlOiBvcHRpb25zLnNoYXJlZExvY2tTdG9yYWdlLFxuICAgIH0pKTtcblxuICAgIHJldHVybiByZWNvcmRpbmc7XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5fc2VuZFJlcXVlc3QgPSBmdW5jdGlvbihjdXJyZW50UmVwbGF5SWQsIHJlcVBhcmFtcywgcmVxQm9keSwgY2FsbGJhY2spIHtcbiAgICB2YXIgb25TdWNjZXNzID0gZnVuY3Rpb24gKHJlc3BvbnNlLCByZXNwb25zZUJvZHkpIHtcbiAgICAgICAgLy8gVXBkYXRlIGJhdGNoIHNwZWNpZmljIHByb3BzIG9ubHkgaWYgdGhlIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWwgdG8gZ3VhcmFudGVlIG9yZGVyaW5nLlxuICAgICAgICAvLyBSZXF1ZXN0QmF0Y2hlciB3aWxsIGFsd2F5cyBmbHVzaCB0aGUgbmV4dCBiYXRjaCBhZnRlciB0aGUgcHJldmlvdXMgb25lIHN1Y2NlZWRzLlxuICAgICAgICAvLyBleHRyYSBjaGVjayB0byBzZWUgaWYgdGhlIHJlcGxheSBJRCBoYXMgY2hhbmdlZCBzbyB0aGF0IHdlIGRvbid0IGluY3JlbWVudCB0aGUgc2VxTm8gb24gdGhlIHdyb25nIHJlcGxheVxuICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDAgJiYgdGhpcy5yZXBsYXlJZCA9PT0gY3VycmVudFJlcGxheUlkKSB7XG4gICAgICAgICAgICB0aGlzLnNlcU5vKys7XG4gICAgICAgICAgICB0aGlzLmJhdGNoU3RhcnRVcmwgPSBfLmluZm8uY3VycmVudFVybCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb25CYXRjaFNlbnQoKTtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgc3RhdHVzOiAwLFxuICAgICAgICAgICAgaHR0cFN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICAgIHJlc3BvbnNlQm9keTogcmVzcG9uc2VCb2R5LFxuICAgICAgICAgICAgcmV0cnlBZnRlcjogcmVzcG9uc2UuaGVhZGVycy5nZXQoJ1JldHJ5LUFmdGVyJylcbiAgICAgICAgfSk7XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgd2luWydmZXRjaCddKHRoaXMuZ2V0Q29uZmlnKCdhcGlfaG9zdCcpICsgJy8nICsgdGhpcy5nZXRDb25maWcoJ2FwaV9yb3V0ZXMnKVsncmVjb3JkJ10gKyAnPycgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHJlcVBhcmFtcyksIHtcbiAgICAgICAgJ21ldGhvZCc6ICdQT1NUJyxcbiAgICAgICAgJ2hlYWRlcnMnOiB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCYXNpYyAnICsgYnRvYSh0aGlzLmdldENvbmZpZygndG9rZW4nKSArICc6JyksXG4gICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSdcbiAgICAgICAgfSxcbiAgICAgICAgJ2JvZHknOiByZXFCb2R5LFxuICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIHJlc3BvbnNlLmpzb24oKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZUJvZHkpIHtcbiAgICAgICAgICAgIG9uU3VjY2VzcyhyZXNwb25zZSwgcmVzcG9uc2VCb2R5KTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh7ZXJyb3I6IGVycm9yfSk7XG4gICAgICAgIH0pO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBjYWxsYmFjayh7ZXJyb3I6IGVycm9yLCBodHRwU3RhdHVzQ29kZTogMH0pO1xuICAgIH0pO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuX2ZsdXNoRXZlbnRzID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbiAoZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgbnVtRXZlbnRzID0gZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAobnVtRXZlbnRzID4gMCkge1xuICAgICAgICB2YXIgcmVwbGF5SWQgPSB0aGlzLnJlcGxheUlkO1xuXG4gICAgICAgIC8vIGVhY2ggcnJ3ZWIgZXZlbnQgaGFzIGEgdGltZXN0YW1wIC0gbGV2ZXJhZ2UgdGhvc2UgdG8gZ2V0IHRpbWUgcHJvcGVydGllc1xuICAgICAgICB2YXIgYmF0Y2hTdGFydFRpbWUgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIGJhdGNoRW5kVGltZSA9IC1JbmZpbml0eTtcbiAgICAgICAgdmFyIGhhc0Z1bGxTbmFwc2hvdCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUV2ZW50czsgaSsrKSB7XG4gICAgICAgICAgICBiYXRjaFN0YXJ0VGltZSA9IE1hdGgubWluKGJhdGNoU3RhcnRUaW1lLCBkYXRhW2ldLnRpbWVzdGFtcCk7XG4gICAgICAgICAgICBiYXRjaEVuZFRpbWUgPSBNYXRoLm1heChiYXRjaEVuZFRpbWUsIGRhdGFbaV0udGltZXN0YW1wKTtcbiAgICAgICAgICAgIGlmIChkYXRhW2ldLnR5cGUgPT09IEV2ZW50VHlwZS5GdWxsU25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICBoYXNGdWxsU25hcHNob3QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2VxTm8gPT09IDApIHtcbiAgICAgICAgICAgIGlmICghaGFzRnVsbFNuYXBzaG90KSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soe2Vycm9yOiAnRmlyc3QgYmF0Y2ggZG9lcyBub3QgY29udGFpbiBhIGZ1bGwgc25hcHNob3QuIEFib3J0aW5nIHJlY29yZGluZy4nfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wUmVjb3JkaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVwbGF5U3RhcnRUaW1lID0gYmF0Y2hTdGFydFRpbWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMucmVwbGF5U3RhcnRUaW1lKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdSZXBsYXkgc3RhcnQgdGltZSBub3Qgc2V0IGJ1dCBzZXFObyBpcyBub3QgMC4gVXNpbmcgY3VycmVudCBiYXRjaCBzdGFydCB0aW1lIGFzIGEgZmFsbGJhY2suJyk7XG4gICAgICAgICAgICB0aGlzLnJlcGxheVN0YXJ0VGltZSA9IGJhdGNoU3RhcnRUaW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlcGxheUxlbmd0aE1zID0gYmF0Y2hFbmRUaW1lIC0gdGhpcy5yZXBsYXlTdGFydFRpbWU7XG5cbiAgICAgICAgdmFyIHJlcVBhcmFtcyA9IHtcbiAgICAgICAgICAgICckY3VycmVudF91cmwnOiB0aGlzLmJhdGNoU3RhcnRVcmwsXG4gICAgICAgICAgICAnJGxpYl92ZXJzaW9uJzogQ29uZmlnLkxJQl9WRVJTSU9OLFxuICAgICAgICAgICAgJ2JhdGNoX3N0YXJ0X3RpbWUnOiBiYXRjaFN0YXJ0VGltZSAvIDEwMDAsXG4gICAgICAgICAgICAnZGlzdGluY3RfaWQnOiBTdHJpbmcodGhpcy5fbWl4cGFuZWwuZ2V0X2Rpc3RpbmN0X2lkKCkpLFxuICAgICAgICAgICAgJ21wX2xpYic6ICd3ZWInLFxuICAgICAgICAgICAgJ3JlcGxheV9pZCc6IHJlcGxheUlkLFxuICAgICAgICAgICAgJ3JlcGxheV9sZW5ndGhfbXMnOiByZXBsYXlMZW5ndGhNcyxcbiAgICAgICAgICAgICdyZXBsYXlfc3RhcnRfdGltZSc6IHRoaXMucmVwbGF5U3RhcnRUaW1lIC8gMTAwMCxcbiAgICAgICAgICAgICdyZXBsYXlfc3RhcnRfdXJsJzogdGhpcy5yZXBsYXlTdGFydFVybCxcbiAgICAgICAgICAgICdzZXEnOiB0aGlzLnNlcU5vXG4gICAgICAgIH07XG4gICAgICAgIHZhciBldmVudHNKc29uID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG5cbiAgICAgICAgLy8gc2VuZCBJRCBtYW5hZ2VtZW50IHByb3BzIGlmIHRoZXkgZXhpc3RcbiAgICAgICAgdmFyIGRldmljZUlkID0gdGhpcy5fbWl4cGFuZWwuZ2V0X3Byb3BlcnR5KCckZGV2aWNlX2lkJyk7XG4gICAgICAgIGlmIChkZXZpY2VJZCkge1xuICAgICAgICAgICAgcmVxUGFyYW1zWyckZGV2aWNlX2lkJ10gPSBkZXZpY2VJZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXNlcklkID0gdGhpcy5fbWl4cGFuZWwuZ2V0X3Byb3BlcnR5KCckdXNlcl9pZCcpO1xuICAgICAgICBpZiAodXNlcklkKSB7XG4gICAgICAgICAgICByZXFQYXJhbXNbJyR1c2VyX2lkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQ29tcHJlc3Npb25TdHJlYW0pIHtcbiAgICAgICAgICAgIHZhciBqc29uU3RyZWFtID0gbmV3IEJsb2IoW2V2ZW50c0pzb25dLCB7dHlwZTogJ2FwcGxpY2F0aW9uL2pzb24nfSkuc3RyZWFtKCk7XG4gICAgICAgICAgICB2YXIgZ3ppcFN0cmVhbSA9IGpzb25TdHJlYW0ucGlwZVRocm91Z2gobmV3IENvbXByZXNzaW9uU3RyZWFtKCdnemlwJykpO1xuICAgICAgICAgICAgbmV3IFJlc3BvbnNlKGd6aXBTdHJlYW0pXG4gICAgICAgICAgICAgICAgLmJsb2IoKVxuICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uKGNvbXByZXNzZWRCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcVBhcmFtc1snZm9ybWF0J10gPSAnZ3ppcCc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRSZXF1ZXN0KHJlcGxheUlkLCByZXFQYXJhbXMsIGNvbXByZXNzZWRCbG9iLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcVBhcmFtc1snZm9ybWF0J10gPSAnYm9keSc7XG4gICAgICAgICAgICB0aGlzLl9zZW5kUmVxdWVzdChyZXBsYXlJZCwgcmVxUGFyYW1zLCBldmVudHNKc29uLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5yZXBvcnRFcnJvciA9IGZ1bmN0aW9uKG1zZywgZXJyKSB7XG4gICAgbG9nZ2VyJDMuZXJyb3IuYXBwbHkobG9nZ2VyJDMuZXJyb3IsIGFyZ3VtZW50cyk7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFlcnIgJiYgIShtc2cgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgIG1zZyA9IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0Q29uZmlnKCdlcnJvcl9yZXBvcnRlcicpKG1zZywgZXJyKTtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgICBsb2dnZXIkMy5lcnJvcihlcnIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogTW9kdWxlIGZvciBoYW5kbGluZyB0aGUgc3RvcmFnZSBhbmQgcmV0cmlldmFsIG9mIHJlY29yZGluZyBtZXRhZGF0YSBhcyB3ZWxsIGFzIGFueSBhY3RpdmUgcmVjb3JkaW5ncy5cbiAqIE1ha2VzIHN1cmUgdGhhdCBvbmx5IG9uZSB0YWIgY2FuIGJlIHJlY29yZGluZyBhdCBhIHRpbWUuXG4gKi9cbnZhciBSZWNvcmRpbmdSZWdpc3RyeSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5pZGIgPSBuZXcgSURCU3RvcmFnZVdyYXBwZXIoUkVDT1JESU5HX1JFR0lTVFJZX1NUT1JFX05BTUUpO1xuICAgIHRoaXMuZXJyb3JSZXBvcnRlciA9IG9wdGlvbnMuZXJyb3JSZXBvcnRlcjtcbiAgICB0aGlzLm1peHBhbmVsSW5zdGFuY2UgPSBvcHRpb25zLm1peHBhbmVsSW5zdGFuY2U7XG4gICAgdGhpcy5zaGFyZWRMb2NrU3RvcmFnZSA9IG9wdGlvbnMuc2hhcmVkTG9ja1N0b3JhZ2U7XG59O1xuXG5SZWNvcmRpbmdSZWdpc3RyeS5wcm90b3R5cGUuaGFuZGxlRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdGhpcy5lcnJvclJlcG9ydGVyKCdJbmRleGVkREIgZXJyb3I6ICcsIGVycik7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3Nlc3Npb24tcmVjb3JkaW5nJykuU2VyaWFsaXplZFJlY29yZGluZ30gc2VyaWFsaXplZFJlY29yZGluZ1xuICovXG5SZWNvcmRpbmdSZWdpc3RyeS5wcm90b3R5cGUuc2V0QWN0aXZlUmVjb3JkaW5nID0gZnVuY3Rpb24gKHNlcmlhbGl6ZWRSZWNvcmRpbmcpIHtcbiAgICB2YXIgdGFiSWQgPSBzZXJpYWxpemVkUmVjb3JkaW5nWyd0YWJJZCddO1xuICAgIGlmICghdGFiSWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdObyB0YWIgSUQgaXMgc2V0LCBjYW5ub3QgcGVyc2lzdCByZWNvcmRpbmcgbWV0YWRhdGEuJyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmlkYi5pbml0KClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRiLnNldEl0ZW0odGFiSWQsIHNlcmlhbGl6ZWRSZWNvcmRpbmcpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaCh0aGlzLmhhbmRsZUVycm9yLmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxpbXBvcnQoJy4vc2Vzc2lvbi1yZWNvcmRpbmcnKS5TZXJpYWxpemVkUmVjb3JkaW5nPn1cbiAqL1xuUmVjb3JkaW5nUmVnaXN0cnkucHJvdG90eXBlLmdldEFjdGl2ZVJlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pZGIuaW5pdCgpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkYi5nZXRJdGVtKHRoaXMubWl4cGFuZWxJbnN0YW5jZS5nZXRfdGFiX2lkKCkpO1xuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChzZXJpYWxpemVkUmVjb3JkaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNSZWNvcmRpbmdFeHBpcmVkKHNlcmlhbGl6ZWRSZWNvcmRpbmcpID8gbnVsbCA6IHNlcmlhbGl6ZWRSZWNvcmRpbmc7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLmNhdGNoKHRoaXMuaGFuZGxlRXJyb3IuYmluZCh0aGlzKSk7XG59O1xuXG5SZWNvcmRpbmdSZWdpc3RyeS5wcm90b3R5cGUuY2xlYXJBY3RpdmVSZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gbWFyayByZWNvcmRpbmcgYXMgZXhwaXJlZCBpbnN0ZWFkIG9mIGRlbGV0aW5nIGl0IGluIGNhc2UgdGhlIHBhZ2UgdW5sb2FkcyBtaWQtZmx1c2ggYW5kIGRvZXNuJ3QgbWFrZSBpdCB0byBpbmdlc3Rpb24uXG4gICAgLy8gdGhpcyB3aWxsIGVuc3VyZSB0aGUgbmV4dCBwYWdlbG9hZCB3aWxsIGZsdXNoIHRoZSByZW1haW5pbmcgZXZlbnRzLCBidXQgbm90IHRyeSB0byBjb250aW51ZSB0aGUgcmVjb3JkaW5nLlxuICAgIHJldHVybiB0aGlzLmdldEFjdGl2ZVJlY29yZGluZygpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChzZXJpYWxpemVkUmVjb3JkaW5nKSB7XG4gICAgICAgICAgICBpZiAoc2VyaWFsaXplZFJlY29yZGluZykge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRSZWNvcmRpbmdbJ21heEV4cGlyZXMnXSA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0QWN0aXZlUmVjb3JkaW5nKHNlcmlhbGl6ZWRSZWNvcmRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIC5jYXRjaCh0aGlzLmhhbmRsZUVycm9yLmJpbmQodGhpcykpO1xufTtcblxuLyoqXG4gKiBGbHVzaCBhbnkgaW5hY3RpdmUgcmVjb3JkaW5ncyBmcm9tIHRoZSByZWdpc3RyeSB0byBtaW5pbWl6ZSBkYXRhIGxvc3MuXG4gKiBUaGUgbWFpbiBpZGVhIGhlcmUgaXMgdGhhdCB3ZSBjYW4gZmx1c2ggcmVtYWluaW5nIHJyd2ViIGV2ZW50cyBvbiB0aGUgbmV4dCBwYWdlIGxvYWQgaWYgYSB0YWIgaXMgY2xvc2VkIG1pZC1iYXRjaC5cbiAqL1xuUmVjb3JkaW5nUmVnaXN0cnkucHJvdG90eXBlLmZsdXNoSW5hY3RpdmVSZWNvcmRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlkYi5pbml0KClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pZGIuZ2V0QWxsKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHNlcmlhbGl6ZWRSZWNvcmRpbmdzKSB7XG4gICAgICAgICAgICAvLyBjbGVhbiB1cCBhbnkgZXhwaXJlZCByZWNvcmRpbmdzIGZyb20gdGhlIHJlZ2lzdHJ5LCBub24tZXhwaXJlZCBvbmVzIG1heSBiZSBhY3RpdmUgaW4gb3RoZXIgdGFic1xuICAgICAgICAgICAgdmFyIHVubG9hZFByb21pc2VzID0gc2VyaWFsaXplZFJlY29yZGluZ3NcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChzZXJpYWxpemVkUmVjb3JkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1JlY29yZGluZ0V4cGlyZWQoc2VyaWFsaXplZFJlY29yZGluZyk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChzZXJpYWxpemVkUmVjb3JkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZXNzaW9uUmVjb3JkaW5nID0gU2Vzc2lvblJlY29yZGluZy5kZXNlcmlhbGl6ZShzZXJpYWxpemVkUmVjb3JkaW5nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaXhwYW5lbEluc3RhbmNlOiB0aGlzLm1peHBhbmVsSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFyZWRMb2NrU3RvcmFnZTogdGhpcy5zaGFyZWRMb2NrU3RvcmFnZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25SZWNvcmRpbmcudW5sb2FkUGVyc2lzdGVkRGF0YSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhwaXJlZCByZWNvcmRpbmcgd2FzIHN1Y2Nlc3NmdWxseSBmbHVzaGVkLCB3ZSBjYW4gY2xlYW4gaXQgdXAgZnJvbSB0aGUgcmVnaXN0cnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pZGIucmVtb3ZlSXRlbShzZXJpYWxpemVkUmVjb3JkaW5nWyd0YWJJZCddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCh0aGlzLmhhbmRsZUVycm9yLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwuYWxsKHVubG9hZFByb21pc2VzKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICAuY2F0Y2godGhpcy5oYW5kbGVFcnJvci5iaW5kKHRoaXMpKTtcbn07XG5cbnZhciBsb2dnZXIkMiA9IGNvbnNvbGVfd2l0aF9wcmVmaXgoJ3JlY29yZGVyJyk7XG5cbi8qKlxuICogUmVjb3JkZXIgQVBJOiBidW5kbGVzIHJyd2ViIGFuZCBhbmQgZXhwb3NlcyBtZXRob2RzIHRvIHN0YXJ0IGFuZCBzdG9wIHJlY29yZGluZ3MuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubWl4cGFuZWxJbnN0YW5jZV0gLSByZWZlcmVuY2UgdG8gdGhlIGNvcmUgTWl4cGFuZWxMaWJcbiovXG52YXIgTWl4cGFuZWxSZWNvcmRlciA9IGZ1bmN0aW9uKG1peHBhbmVsSW5zdGFuY2UsIHJyd2ViUmVjb3JkLCBzaGFyZWRMb2NrU3RvcmFnZSkge1xuICAgIHRoaXMubWl4cGFuZWxJbnN0YW5jZSA9IG1peHBhbmVsSW5zdGFuY2U7XG4gICAgdGhpcy5ycndlYlJlY29yZCA9IHJyd2ViUmVjb3JkIHx8IHJlY29yZDtcbiAgICB0aGlzLnNoYXJlZExvY2tTdG9yYWdlID0gc2hhcmVkTG9ja1N0b3JhZ2U7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtpbXBvcnQoJy4vcmVnaXN0cnknKS5SZWNvcmRpbmdSZWdpc3RyeX1cbiAgICAgKi9cbiAgICB0aGlzLnJlY29yZGluZ1JlZ2lzdHJ5ID0gbmV3IFJlY29yZGluZ1JlZ2lzdHJ5KHtcbiAgICAgICAgbWl4cGFuZWxJbnN0YW5jZTogdGhpcy5taXhwYW5lbEluc3RhbmNlLFxuICAgICAgICBlcnJvclJlcG9ydGVyOiBsb2dnZXIkMi5lcnJvcixcbiAgICAgICAgc2hhcmVkTG9ja1N0b3JhZ2U6IHNoYXJlZExvY2tTdG9yYWdlXG4gICAgfSk7XG4gICAgdGhpcy5fZmx1c2hJbmFjdGl2ZVByb21pc2UgPSB0aGlzLnJlY29yZGluZ1JlZ2lzdHJ5LmZsdXNoSW5hY3RpdmVSZWNvcmRpbmdzKCk7XG5cbiAgICB0aGlzLmFjdGl2ZVJlY29yZGluZyA9IG51bGw7XG59O1xuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5zdGFydFJlY29yZGluZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAodGhpcy5hY3RpdmVSZWNvcmRpbmcgJiYgIXRoaXMuYWN0aXZlUmVjb3JkaW5nLmlzUnJ3ZWJTdG9wcGVkKCkpIHtcbiAgICAgICAgbG9nZ2VyJDIubG9nKCdSZWNvcmRpbmcgYWxyZWFkeSBpbiBwcm9ncmVzcywgc2tpcHBpbmcgc3RhcnRSZWNvcmRpbmcuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb25JZGxlVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyJDIubG9nKCdJZGxlIHRpbWVvdXQgcmVhY2hlZCwgcmVzdGFydGluZyByZWNvcmRpbmcuJyk7XG4gICAgICAgIHRoaXMucmVzZXRSZWNvcmRpbmcoKTtcbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB2YXIgb25NYXhMZW5ndGhSZWFjaGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXIkMi5sb2coJ01heCByZWNvcmRpbmcgbGVuZ3RoIHJlYWNoZWQsIHN0b3BwaW5nIHJlY29yZGluZy4nKTtcbiAgICAgICAgdGhpcy5yZXNldFJlY29yZGluZygpO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIHZhciBvbkJhdGNoU2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZWNvcmRpbmdSZWdpc3RyeS5zZXRBY3RpdmVSZWNvcmRpbmcodGhpcy5hY3RpdmVSZWNvcmRpbmcuc2VyaWFsaXplKCkpO1xuICAgICAgICB0aGlzWydfX2ZsdXNoUHJvbWlzZSddID0gdGhpcy5hY3RpdmVSZWNvcmRpbmcuYmF0Y2hlci5fZmx1c2hQcm9taXNlO1xuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtpbXBvcnQoJy4vc2Vzc2lvbi1yZWNvcmRpbmcnKS5TZXNzaW9uUmVjb3JkaW5nT3B0aW9uc31cbiAgICAgKi9cbiAgICB2YXIgc2Vzc2lvblJlY29yZGluZ09wdGlvbnMgPSB7XG4gICAgICAgIG1peHBhbmVsSW5zdGFuY2U6IHRoaXMubWl4cGFuZWxJbnN0YW5jZSxcbiAgICAgICAgb25CYXRjaFNlbnQ6IG9uQmF0Y2hTZW50LFxuICAgICAgICBvbklkbGVUaW1lb3V0OiBvbklkbGVUaW1lb3V0LFxuICAgICAgICBvbk1heExlbmd0aFJlYWNoZWQ6IG9uTWF4TGVuZ3RoUmVhY2hlZCxcbiAgICAgICAgcmVwbGF5SWQ6IF8uVVVJRCgpLFxuICAgICAgICBycndlYlJlY29yZDogdGhpcy5ycndlYlJlY29yZCxcbiAgICAgICAgc2hhcmVkTG9ja1N0b3JhZ2U6IHRoaXMuc2hhcmVkTG9ja1N0b3JhZ2VcbiAgICB9O1xuXG4gICAgaWYgKG9wdGlvbnMuYWN0aXZlU2VyaWFsaXplZFJlY29yZGluZykge1xuICAgICAgICB0aGlzLmFjdGl2ZVJlY29yZGluZyA9IFNlc3Npb25SZWNvcmRpbmcuZGVzZXJpYWxpemUob3B0aW9ucy5hY3RpdmVTZXJpYWxpemVkUmVjb3JkaW5nLCBzZXNzaW9uUmVjb3JkaW5nT3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSZWNvcmRpbmcgPSBuZXcgU2Vzc2lvblJlY29yZGluZyhzZXNzaW9uUmVjb3JkaW5nT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdGhpcy5hY3RpdmVSZWNvcmRpbmcuc3RhcnRSZWNvcmRpbmcob3B0aW9ucy5zaG91bGRTdG9wQmF0Y2hlcik7XG4gICAgcmV0dXJuIHRoaXMucmVjb3JkaW5nUmVnaXN0cnkuc2V0QWN0aXZlUmVjb3JkaW5nKHRoaXMuYWN0aXZlUmVjb3JkaW5nLnNlcmlhbGl6ZSgpKTtcbn07XG5cbk1peHBhbmVsUmVjb3JkZXIucHJvdG90eXBlLnN0b3BSZWNvcmRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RvcFByb21pc2UgPSB0aGlzLl9zdG9wQ3VycmVudFJlY29yZGluZyhmYWxzZSk7XG4gICAgdGhpcy5yZWNvcmRpbmdSZWdpc3RyeS5jbGVhckFjdGl2ZVJlY29yZGluZygpO1xuICAgIHRoaXMuYWN0aXZlUmVjb3JkaW5nID0gbnVsbDtcbiAgICByZXR1cm4gc3RvcFByb21pc2U7XG59O1xuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5wYXVzZVJlY29yZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9zdG9wQ3VycmVudFJlY29yZGluZyhmYWxzZSk7XG59O1xuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5fc3RvcEN1cnJlbnRSZWNvcmRpbmcgPSBmdW5jdGlvbihza2lwRmx1c2gpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVSZWNvcmRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlUmVjb3JkaW5nLnN0b3BSZWNvcmRpbmcoc2tpcEZsdXNoKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG59O1xuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5yZXN1bWVSZWNvcmRpbmcgPSBmdW5jdGlvbiAoc3RhcnROZXdJZkluYWN0aXZlKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlUmVjb3JkaW5nICYmIHRoaXMuYWN0aXZlUmVjb3JkaW5nLmlzUnJ3ZWJTdG9wcGVkKCkpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSZWNvcmRpbmcuc3RhcnRSZWNvcmRpbmcoZmFsc2UpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUobnVsbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVjb3JkaW5nUmVnaXN0cnkuZ2V0QWN0aXZlUmVjb3JkaW5nKClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGFjdGl2ZVNlcmlhbGl6ZWRSZWNvcmRpbmcpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmVTZXJpYWxpemVkUmVjb3JkaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRSZWNvcmRpbmcoe2FjdGl2ZVNlcmlhbGl6ZWRSZWNvcmRpbmc6IGFjdGl2ZVNlcmlhbGl6ZWRSZWNvcmRpbmd9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnROZXdJZkluYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRSZWNvcmRpbmcoe3Nob3VsZFN0b3BCYXRjaGVyOiBmYWxzZX0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMi5sb2coJ05vIHJlc3VtYWJsZSByZWNvcmRpbmcgZm91bmQuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG5cbk1peHBhbmVsUmVjb3JkZXIucHJvdG90eXBlLnJlc2V0UmVjb3JkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3RvcFJlY29yZGluZygpO1xuICAgIHRoaXMuc3RhcnRSZWNvcmRpbmcoe3Nob3VsZFN0b3BCYXRjaGVyOiB0cnVlfSk7XG59O1xuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5nZXRBY3RpdmVSZXBsYXlJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVSZWNvcmRpbmcgJiYgIXRoaXMuYWN0aXZlUmVjb3JkaW5nLmlzUnJ3ZWJTdG9wcGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlUmVjb3JkaW5nLnJlcGxheUlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8vIGdldHRlciBzbyB0aGF0IG9sZGVyIG1peHBhbmVsLWNvcmUgdmVyc2lvbnMgY2FuIHN0aWxsIHJldHJpZXZlIHRoZSByZXBsYXkgSURcbi8vIHdoZW4gcHVsbGluZyB0aGUgbGF0ZXN0IHJlY29yZGVyIGJ1bmRsZSBmcm9tIHRoZSBDRE5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZSwgJ3JlcGxheUlkJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBY3RpdmVSZXBsYXlJZCgpO1xuICAgIH1cbn0pO1xuXG53aW5bJ19fbXBfcmVjb3JkZXInXSA9IE1peHBhbmVsUmVjb3JkZXI7XG5cbi8vIHN0YXRlbGVzcyB1dGlsc1xuLy8gbW9zdGx5IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21peHBhbmVsL21peHBhbmVsLWpzL2Jsb2IvOTg5YWRhNTBmNTE4ZWRhYjQ3YjljNGZkOTUzNWY5ZmJkNWVjNWZjMC9zcmMvYXV0b3RyYWNrLXV0aWxzLmpzXG5cblxudmFyIEVWX0NIQU5HRSA9ICdjaGFuZ2UnO1xudmFyIEVWX0NMSUNLID0gJ2NsaWNrJztcbnZhciBFVl9IQVNIQ0hBTkdFID0gJ2hhc2hjaGFuZ2UnO1xudmFyIEVWX01QX0xPQ0FUSU9OX0NIQU5HRSA9ICdtcF9sb2NhdGlvbmNoYW5nZSc7XG52YXIgRVZfUE9QU1RBVEUgPSAncG9wc3RhdGUnO1xuLy8gVE9ETyBzY3JvbGxlbmQgaXNuJ3QgYXZhaWxhYmxlIGluIFNhZmFyaTogZG9jdW1lbnQgb3IgcG9seWZpbGw/XG52YXIgRVZfU0NST0xMRU5EID0gJ3Njcm9sbGVuZCc7XG52YXIgRVZfU1VCTUlUID0gJ3N1Ym1pdCc7XG5cbnZhciBDTElDS19FVkVOVF9QUk9QUyA9IFtcbiAgICAnY2xpZW50WCcsICdjbGllbnRZJyxcbiAgICAnb2Zmc2V0WCcsICdvZmZzZXRZJyxcbiAgICAncGFnZVgnLCAncGFnZVknLFxuICAgICdzY3JlZW5YJywgJ3NjcmVlblknLFxuICAgICd4JywgJ3knXG5dO1xudmFyIE9QVF9JTl9DTEFTU0VTID0gWydtcC1pbmNsdWRlJ107XG52YXIgT1BUX09VVF9DTEFTU0VTID0gWydtcC1uby10cmFjayddO1xudmFyIFNFTlNJVElWRV9EQVRBX0NMQVNTRVMgPSBPUFRfT1VUX0NMQVNTRVMuY29uY2F0KFsnbXAtc2Vuc2l0aXZlJ10pO1xudmFyIFRSQUNLRURfQVRUUlMgPSBbXG4gICAgJ2FyaWEtbGFiZWwnLCAnYXJpYS1sYWJlbGxlZGJ5JywgJ2FyaWEtZGVzY3JpYmVkYnknLFxuICAgICdocmVmJywgJ25hbWUnLCAncm9sZScsICd0aXRsZScsICd0eXBlJ1xuXTtcblxudmFyIGxvZ2dlciQxID0gY29uc29sZV93aXRoX3ByZWZpeCgnYXV0b2NhcHR1cmUnKTtcblxuXG5mdW5jdGlvbiBnZXRDbGFzc2VzKGVsKSB7XG4gICAgdmFyIGNsYXNzZXMgPSB7fTtcbiAgICB2YXIgY2xhc3NMaXN0ID0gZ2V0Q2xhc3NOYW1lKGVsKS5zcGxpdCgnICcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3NMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjbHMgPSBjbGFzc0xpc3RbaV07XG4gICAgICAgIGlmIChjbHMpIHtcbiAgICAgICAgICAgIGNsYXNzZXNbY2xzXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzZXM7XG59XG5cbi8qXG4gKiBHZXQgdGhlIGNsYXNzTmFtZSBvZiBhbiBlbGVtZW50LCBhY2NvdW50aW5nIGZvciBlZGdlIGNhc2VzIHdoZXJlIGVsZW1lbnQuY2xhc3NOYW1lIGlzIGFuIG9iamVjdFxuICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIGVsZW1lbnQgdG8gZ2V0IHRoZSBjbGFzc05hbWUgb2ZcbiAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBlbGVtZW50J3MgY2xhc3NcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKGVsKSB7XG4gICAgc3dpdGNoKHR5cGVvZiBlbC5jbGFzc05hbWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBlbC5jbGFzc05hbWU7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6IC8vIGhhbmRsZSBjYXNlcyB3aGVyZSBjbGFzc05hbWUgbWlnaHQgYmUgU1ZHQW5pbWF0ZWRTdHJpbmcgb3Igc29tZSBvdGhlciB0eXBlXG4gICAgICAgICAgICByZXR1cm4gZWwuY2xhc3NOYW1lLmJhc2VWYWwgfHwgZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnO1xuICAgICAgICBkZWZhdWx0OiAvLyBmdXR1cmUgcHJvb2ZcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFByZXZpb3VzRWxlbWVudFNpYmxpbmcoZWwpIHtcbiAgICBpZiAoZWwucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgICAgICByZXR1cm4gZWwucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBlbCA9IGVsLnByZXZpb3VzU2libGluZztcbiAgICAgICAgfSB3aGlsZSAoZWwgJiYgIWlzRWxlbWVudE5vZGUoZWwpKTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydGllc0Zyb21FbGVtZW50KGVsLCBldiwgYmxvY2tBdHRyc1NldCwgZXh0cmFBdHRycywgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSB7XG4gICAgdmFyIHByb3BzID0ge1xuICAgICAgICAnJGNsYXNzZXMnOiBnZXRDbGFzc05hbWUoZWwpLnNwbGl0KCcgJyksXG4gICAgICAgICckdGFnX25hbWUnOiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKClcbiAgICB9O1xuICAgIHZhciBlbElkID0gZWwuaWQ7XG4gICAgaWYgKGVsSWQpIHtcbiAgICAgICAgcHJvcHNbJyRpZCddID0gZWxJZDtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tFbGVtZW50RGV0YWlscyhlbCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycykpIHtcbiAgICAgICAgXy5lYWNoKFRSQUNLRURfQVRUUlMuY29uY2F0KGV4dHJhQXR0cnMpLCBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKGF0dHIpICYmICFibG9ja0F0dHJzU2V0W2F0dHJdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJWYWwgPSBlbC5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFRyYWNrVmFsdWUoYXR0clZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbJyRhdHRyLScgKyBhdHRyXSA9IGF0dHJWYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgbnRoQ2hpbGQgPSAxO1xuICAgIHZhciBudGhPZlR5cGUgPSAxO1xuICAgIHZhciBjdXJyZW50RWxlbSA9IGVsO1xuICAgIHdoaWxlIChjdXJyZW50RWxlbSA9IGdldFByZXZpb3VzRWxlbWVudFNpYmxpbmcoY3VycmVudEVsZW0pKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgbnRoQ2hpbGQrKztcbiAgICAgICAgaWYgKGN1cnJlbnRFbGVtLnRhZ05hbWUgPT09IGVsLnRhZ05hbWUpIHtcbiAgICAgICAgICAgIG50aE9mVHlwZSsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb3BzWyckbnRoX2NoaWxkJ10gPSBudGhDaGlsZDtcbiAgICBwcm9wc1snJG50aF9vZl90eXBlJ10gPSBudGhPZlR5cGU7XG5cbiAgICByZXR1cm4gcHJvcHM7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BzRm9yRE9NRXZlbnQoZXYsIGNvbmZpZykge1xuICAgIHZhciBhbGxvd0VsZW1lbnRDYWxsYmFjayA9IGNvbmZpZy5hbGxvd0VsZW1lbnRDYWxsYmFjaztcbiAgICB2YXIgYWxsb3dTZWxlY3RvcnMgPSBjb25maWcuYWxsb3dTZWxlY3RvcnMgfHwgW107XG4gICAgdmFyIGJsb2NrQXR0cnMgPSBjb25maWcuYmxvY2tBdHRycyB8fCBbXTtcbiAgICB2YXIgYmxvY2tFbGVtZW50Q2FsbGJhY2sgPSBjb25maWcuYmxvY2tFbGVtZW50Q2FsbGJhY2s7XG4gICAgdmFyIGJsb2NrU2VsZWN0b3JzID0gY29uZmlnLmJsb2NrU2VsZWN0b3JzIHx8IFtdO1xuICAgIHZhciBjYXB0dXJlVGV4dENvbnRlbnQgPSBjb25maWcuY2FwdHVyZVRleHRDb250ZW50IHx8IGZhbHNlO1xuICAgIHZhciBjYXB0dXJlRXh0cmFBdHRycyA9IGNvbmZpZy5jYXB0dXJlRXh0cmFBdHRycyB8fCBbXTtcbiAgICB2YXIgY2FwdHVyZWRGb3JIZWF0TWFwID0gY29uZmlnLmNhcHR1cmVkRm9ySGVhdE1hcCB8fCBmYWxzZTtcblxuICAgIC8vIGNvbnZlcnQgYXJyYXkgdG8gc2V0IGV2ZXJ5IHRpbWUsIGFzIHRoZSBjb25maWcgbWF5IGhhdmUgY2hhbmdlZFxuICAgIHZhciBibG9ja0F0dHJzU2V0ID0ge307XG4gICAgXy5lYWNoKGJsb2NrQXR0cnMsIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgYmxvY2tBdHRyc1NldFthdHRyXSA9IHRydWU7XG4gICAgfSk7XG5cbiAgICB2YXIgcHJvcHMgPSBudWxsO1xuXG4gICAgdmFyIHRhcmdldCA9IHR5cGVvZiBldi50YXJnZXQgPT09ICd1bmRlZmluZWQnID8gZXYuc3JjRWxlbWVudCA6IGV2LnRhcmdldDtcbiAgICBpZiAoaXNUZXh0Tm9kZSh0YXJnZXQpKSB7IC8vIGRlZmVhdCBTYWZhcmkgYnVnIChzZWU6IGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbClcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgICBzaG91bGRUcmFja0RvbUV2ZW50KHRhcmdldCwgZXYpICYmXG4gICAgICAgIGlzRWxlbWVudEFsbG93ZWQodGFyZ2V0LCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSAmJlxuICAgICAgICAhaXNFbGVtZW50QmxvY2tlZCh0YXJnZXQsIGV2LCBibG9ja0VsZW1lbnRDYWxsYmFjaywgYmxvY2tTZWxlY3RvcnMpXG4gICAgKSB7XG4gICAgICAgIHZhciB0YXJnZXRFbGVtZW50TGlzdCA9IFt0YXJnZXRdO1xuICAgICAgICB2YXIgY3VyRWwgPSB0YXJnZXQ7XG4gICAgICAgIHdoaWxlIChjdXJFbC5wYXJlbnROb2RlICYmICFpc1RhZyhjdXJFbCwgJ2JvZHknKSkge1xuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudExpc3QucHVzaChjdXJFbC5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgIGN1ckVsID0gY3VyRWwucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGVtZW50c0pzb24gPSBbXTtcbiAgICAgICAgdmFyIGhyZWYsIGV4cGxpY2l0Tm9UcmFjayA9IGZhbHNlO1xuICAgICAgICBfLmVhY2godGFyZ2V0RWxlbWVudExpc3QsIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICB2YXIgc2hvdWxkVHJhY2tEZXRhaWxzID0gc2hvdWxkVHJhY2tFbGVtZW50RGV0YWlscyhlbCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycyk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBlbGVtZW50IG9yIGEgcGFyZW50IGVsZW1lbnQgaXMgYW4gYW5jaG9yIHRhZ1xuICAgICAgICAgICAgLy8gaW5jbHVkZSB0aGUgaHJlZiBhcyBhIHByb3BlcnR5XG4gICAgICAgICAgICBpZiAoIWJsb2NrQXR0cnNTZXRbJ2hyZWYnXSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xuICAgICAgICAgICAgICAgIGhyZWYgPSBlbC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgICAgICAgICBocmVmID0gc2hvdWxkVHJhY2tEZXRhaWxzICYmIHNob3VsZFRyYWNrVmFsdWUoaHJlZikgJiYgaHJlZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlzRWxlbWVudEJsb2NrZWQoZWwsIGV2LCBibG9ja0VsZW1lbnRDYWxsYmFjaywgYmxvY2tTZWxlY3RvcnMpKSB7XG4gICAgICAgICAgICAgICAgZXhwbGljaXROb1RyYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbWVudHNKc29uLnB1c2goZ2V0UHJvcGVydGllc0Zyb21FbGVtZW50KGVsLCBldiwgYmxvY2tBdHRyc1NldCwgY2FwdHVyZUV4dHJhQXR0cnMsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycykpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBpZiAoIWV4cGxpY2l0Tm9UcmFjaykge1xuICAgICAgICAgICAgdmFyIGRvY0VsZW1lbnQgPSBkb2N1bWVudCQxWydkb2N1bWVudEVsZW1lbnQnXTtcbiAgICAgICAgICAgIHByb3BzID0ge1xuICAgICAgICAgICAgICAgICckZXZlbnRfdHlwZSc6IGV2LnR5cGUsXG4gICAgICAgICAgICAgICAgJyRob3N0Jzogd2luLmxvY2F0aW9uLmhvc3QsXG4gICAgICAgICAgICAgICAgJyRwYXRobmFtZSc6IHdpbi5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAnJGVsZW1lbnRzJzogIGVsZW1lbnRzSnNvbixcbiAgICAgICAgICAgICAgICAnJGVsX2F0dHJfX2hyZWYnOiBocmVmLFxuICAgICAgICAgICAgICAgICckdmlld3BvcnRIZWlnaHQnOiBNYXRoLm1heChkb2NFbGVtZW50WydjbGllbnRIZWlnaHQnXSwgd2luWydpbm5lckhlaWdodCddIHx8IDApLFxuICAgICAgICAgICAgICAgICckdmlld3BvcnRXaWR0aCc6IE1hdGgubWF4KGRvY0VsZW1lbnRbJ2NsaWVudFdpZHRoJ10sIHdpblsnaW5uZXJXaWR0aCddIHx8IDApLFxuICAgICAgICAgICAgICAgICckcGFnZUhlaWdodCc6IGRvY3VtZW50JDFbJ2JvZHknXVsnb2Zmc2V0SGVpZ2h0J10gfHwgMCxcbiAgICAgICAgICAgICAgICAnJHBhZ2VXaWR0aCc6IGRvY3VtZW50JDFbJ2JvZHknXVsnb2Zmc2V0V2lkdGgnXSB8fCAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF8uZWFjaChjYXB0dXJlRXh0cmFBdHRycywgZnVuY3Rpb24oYXR0cikge1xuICAgICAgICAgICAgICAgIGlmICghYmxvY2tBdHRyc1NldFthdHRyXSAmJiB0YXJnZXQuaGFzQXR0cmlidXRlKGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFRyYWNrVmFsdWUoYXR0clZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzWyckZWxfYXR0cl9fJyArIGF0dHJdID0gYXR0clZhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY2FwdHVyZVRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFRleHQgPSBnZXRTYWZlVGV4dCh0YXJnZXQsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50VGV4dCAmJiBlbGVtZW50VGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbJyRlbF90ZXh0J10gPSBlbGVtZW50VGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChldi50eXBlID09PSBFVl9DTElDSykge1xuICAgICAgICAgICAgICAgIF8uZWFjaChDTElDS19FVkVOVF9QUk9QUywgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCBpbiBldikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbJyQnICsgcHJvcF0gPSBldltwcm9wXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjYXB0dXJlZEZvckhlYXRNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNbJyRjYXB0dXJlZF9mb3JfaGVhdG1hcCddID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gZ3Vlc3NSZWFsQ2xpY2tUYXJnZXQoZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcHJpb3JpdGl6ZSB0ZXh0IGNvbnRlbnQgZnJvbSBcInJlYWxcIiBjbGljayB0YXJnZXQgaWYgZGlmZmVyZW50IGZyb20gb3JpZ2luYWwgdGFyZ2V0XG4gICAgICAgICAgICBpZiAoY2FwdHVyZVRleHRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRUZXh0ID0gZ2V0U2FmZVRleHQodGFyZ2V0LCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudFRleHQgJiYgZWxlbWVudFRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzWyckZWxfdGV4dCddID0gZWxlbWVudFRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0IG1heSBoYXZlIGJlZW4gcmVjYWxjdWxhdGVkOyBjaGVjayBhbGxvd2xpc3RzIGFuZCBibG9ja2xpc3RzIGFnYWluXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAhaXNFbGVtZW50QWxsb3dlZCh0YXJnZXQsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzRWxlbWVudEJsb2NrZWQodGFyZ2V0LCBldiwgYmxvY2tFbGVtZW50Q2FsbGJhY2ssIGJsb2NrU2VsZWN0b3JzKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0UHJvcHMgPSBnZXRQcm9wZXJ0aWVzRnJvbUVsZW1lbnQodGFyZ2V0LCBldiwgYmxvY2tBdHRyc1NldCwgY2FwdHVyZUV4dHJhQXR0cnMsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycyk7XG4gICAgICAgICAgICAgICAgcHJvcHNbJyR0YXJnZXQnXSA9IHRhcmdldFByb3BzO1xuICAgICAgICAgICAgICAgIC8vIHB1bGwgdXAgbW9yZSBwcm9wcyBvbnRvIG1haW4gZXZlbnQgcHJvcHNcbiAgICAgICAgICAgICAgICBwcm9wc1snJGVsX2NsYXNzZXMnXSA9IHRhcmdldFByb3BzWyckY2xhc3NlcyddO1xuICAgICAgICAgICAgICAgIF8uZXh0ZW5kKHByb3BzLCBfLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgICAgICAnJGVsX2lkJzogdGFyZ2V0UHJvcHNbJyRpZCddLFxuICAgICAgICAgICAgICAgICAgICAnJGVsX3RhZ19uYW1lJzogdGFyZ2V0UHJvcHNbJyR0YWdfbmFtZSddXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzO1xufVxuXG5cbi8qKlxuICogR2V0IHRoZSBkaXJlY3QgdGV4dCBjb250ZW50IG9mIGFuIGVsZW1lbnQsIHByb3RlY3RpbmcgYWdhaW5zdCBzZW5zaXRpdmUgZGF0YSBjb2xsZWN0aW9uLlxuICogQ29uY2F0cyB0ZXh0Q29udGVudCBvZiBlYWNoIG9mIHRoZSBlbGVtZW50J3MgdGV4dCBub2RlIGNoaWxkcmVuOyB0aGlzIGF2b2lkcyBwb3RlbnRpYWxcbiAqIGNvbGxlY3Rpb24gb2Ygc2Vuc2l0aXZlIGRhdGEgdGhhdCBjb3VsZCBoYXBwZW4gaWYgd2UgdXNlZCBlbGVtZW50LnRleHRDb250ZW50IGFuZCB0aGVcbiAqIGVsZW1lbnQgaGFkIHNlbnNpdGl2ZSBjaGlsZCBlbGVtZW50cywgc2luY2UgZWxlbWVudC50ZXh0Q29udGVudCBpbmNsdWRlcyBjaGlsZCBjb250ZW50LlxuICogU2NydWJzIHZhbHVlcyB0aGF0IGxvb2sgbGlrZSB0aGV5IGNvdWxkIGJlIHNlbnNpdGl2ZSAoaS5lLiBjYyBvciBzc24gbnVtYmVyKS5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgLSBlbGVtZW50IHRvIGdldCB0aGUgdGV4dCBvZlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhbGxvd1NlbGVjdG9ycyAtIENTUyBzZWxlY3RvcnMgZm9yIGVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIGluY2x1ZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZWxlbWVudCdzIGRpcmVjdCB0ZXh0IGNvbnRlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0U2FmZVRleHQoZWwsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpIHtcbiAgICB2YXIgZWxUZXh0ID0gJyc7XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tFbGVtZW50RGV0YWlscyhlbCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycykgJiYgZWwuY2hpbGROb2RlcyAmJiBlbC5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICBfLmVhY2goZWwuY2hpbGROb2RlcywgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChpc1RleHROb2RlKGNoaWxkKSAmJiBjaGlsZC50ZXh0Q29udGVudCkge1xuICAgICAgICAgICAgICAgIGVsVGV4dCArPSBfLnRyaW0oY2hpbGQudGV4dENvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgIC8vIHNjcnViIHBvdGVudGlhbGx5IHNlbnNpdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KC8oXFxzKykvKS5maWx0ZXIoc2hvdWxkVHJhY2tWYWx1ZSkuam9pbignJylcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9ybWFsaXplIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHJcXG5dL2csICcgJykucmVwbGFjZSgvWyBdKy9nLCAnICcpXG4gICAgICAgICAgICAgICAgICAgIC8vIHRydW5jYXRlXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzdHJpbmcoMCwgMjU1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF8udHJpbShlbFRleHQpO1xufVxuXG5mdW5jdGlvbiBndWVzc1JlYWxDbGlja1RhcmdldChldikge1xuICAgIHZhciB0YXJnZXQgPSBldi50YXJnZXQ7XG4gICAgdmFyIGNvbXBvc2VkUGF0aCA9IGV2Wydjb21wb3NlZFBhdGgnXSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tcG9zZWRQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gY29tcG9zZWRQYXRoW2ldO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBpc1RhZyhub2RlLCAnYScpIHx8XG4gICAgICAgICAgICBpc1RhZyhub2RlLCAnYnV0dG9uJykgfHxcbiAgICAgICAgICAgIGlzVGFnKG5vZGUsICdpbnB1dCcpIHx8XG4gICAgICAgICAgICBpc1RhZyhub2RlLCAnc2VsZWN0JykgfHxcbiAgICAgICAgICAgIChub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAnYnV0dG9uJylcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBub2RlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50QWxsb3dlZChlbCwgZXYsIGFsbG93RWxlbWVudENhbGxiYWNrLCBhbGxvd1NlbGVjdG9ycykge1xuICAgIGlmIChhbGxvd0VsZW1lbnRDYWxsYmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFhbGxvd0VsZW1lbnRDYWxsYmFjayhlbCwgZXYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBlbGVtZW50IGluIGFsbG93RWxlbWVudENhbGxiYWNrJywgZXJyKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghYWxsb3dTZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICAgIC8vIG5vIGFsbG93bGlzdDsgYWxsIGVsZW1lbnRzIGFyZSBmYWlyIGdhbWVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxvd1NlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc2VsID0gYWxsb3dTZWxlY3RvcnNbaV07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoZWxbJ21hdGNoZXMnXShzZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyJDEuY3JpdGljYWwoJ0Vycm9yIHdoaWxlIGNoZWNraW5nIHNlbGVjdG9yOiAnICsgc2VsLCBlcnIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNFbGVtZW50QmxvY2tlZChlbCwgZXYsIGJsb2NrRWxlbWVudENhbGxiYWNrLCBibG9ja1NlbGVjdG9ycykge1xuICAgIHZhciBpO1xuXG4gICAgaWYgKGJsb2NrRWxlbWVudENhbGxiYWNrKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoYmxvY2tFbGVtZW50Q2FsbGJhY2soZWwsIGV2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBlbGVtZW50IGluIGJsb2NrRWxlbWVudENhbGxiYWNrJywgZXJyKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJsb2NrU2VsZWN0b3JzICYmIGJsb2NrU2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgICAvLyBwcm9ncmFtbWF0aWNhbGx5IHByZXZlbnQgdHJhY2tpbmcgb2YgZWxlbWVudHMgdGhhdCBtYXRjaCBDU1Mgc2VsZWN0b3JzXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja1NlbGVjdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNlbCA9IGJsb2NrU2VsZWN0b3JzW2ldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZWxbJ21hdGNoZXMnXShzZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBzZWxlY3RvcjogJyArIHNlbCwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFsbG93IHVzZXJzIHRvIHByb2dyYW1tYXRpY2FsbHkgcHJldmVudCB0cmFja2luZyBvZiBlbGVtZW50cyBieSBhZGRpbmcgZGVmYXVsdCBjbGFzc2VzIHN1Y2ggYXMgJ21wLW5vLXRyYWNrJ1xuICAgIHZhciBjbGFzc2VzID0gZ2V0Q2xhc3NlcyhlbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IE9QVF9PVVRfQ0xBU1NFUy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY2xhc3Nlc1tPUFRfT1VUX0NMQVNTRVNbaV1dKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLypcbiAqIENoZWNrIHdoZXRoZXIgYSBET00gbm9kZSBoYXMgbm9kZVR5cGUgTm9kZS5FTEVNRU5UX05PREVcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIG5vZGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG5vZGUgaXMgb2YgdGhlIGNvcnJlY3Qgbm9kZVR5cGVcbiAqL1xuZnVuY3Rpb24gaXNFbGVtZW50Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMTsgLy8gTm9kZS5FTEVNRU5UX05PREUgLSB1c2UgaW50ZWdlciBjb25zdGFudCBmb3IgYnJvd3NlciBwb3J0YWJpbGl0eVxufVxuXG4vKlxuICogQ2hlY2sgd2hldGhlciBhbiBlbGVtZW50IGlzIG9mIGEgZ2l2ZW4gdGFnIHR5cGUuXG4gKiBEdWUgdG8gcG90ZW50aWFsIHJlZmVyZW5jZSBkaXNjcmVwYW5jaWVzIChzdWNoIGFzIHRoZSB3ZWJjb21wb25lbnRzLmpzIHBvbHlmaWxsKSxcbiAqIHdlIHdhbnQgdG8gbWF0Y2ggdGFnTmFtZXMgaW5zdGVhZCBvZiBzcGVjaWZpYyByZWZlcmVuY2VzIGJlY2F1c2Ugc29tZXRoaW5nIGxpa2VcbiAqIGVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkgd29uJ3QgYWx3YXlzIHdvcmsgYmVjYXVzZSBlbGVtZW50IG1pZ2h0IG5vdCBiZSBhIG5hdGl2ZVxuICogZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgLSBlbGVtZW50IHRvIGNoZWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIC0gdGFnIG5hbWUgKGUuZy4sIFwiZGl2XCIpXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBlbCBpcyBvZiB0aGUgZ2l2ZW4gdGFnIHR5cGVcbiAqL1xuZnVuY3Rpb24gaXNUYWcoZWwsIHRhZykge1xuICAgIHJldHVybiBlbCAmJiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qXG4gKiBDaGVjayB3aGV0aGVyIGEgRE9NIG5vZGUgaXMgYSBURVhUX05PREVcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIG5vZGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG5vZGUgaXMgb2YgdHlwZSBOb2RlLlRFWFRfTk9ERVxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSAzOyAvLyBOb2RlLlRFWFRfTk9ERSAtIHVzZSBpbnRlZ2VyIGNvbnN0YW50IGZvciBicm93c2VyIHBvcnRhYmlsaXR5XG59XG5cbmZ1bmN0aW9uIG1pbkRPTUFwaXNTdXBwb3J0ZWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFyIHRlc3RFbCA9IGRvY3VtZW50JDEuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHJldHVybiAhIXRlc3RFbFsnbWF0Y2hlcyddO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKlxuICogQ2hlY2sgd2hldGhlciBhIERPTSBldmVudCBzaG91bGQgYmUgXCJ0cmFja2VkXCIgb3IgaWYgaXQgbWF5IGNvbnRhaW4gc2Vuc2l0aXZlIGRhdGFcbiAqIHVzaW5nIGEgdmFyaWV0eSBvZiBoZXVyaXN0aWNzLlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCAtIGVsZW1lbnQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7RXZlbnR9IGV2IC0gZXZlbnQgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBldmVudCBzaG91bGQgYmUgdHJhY2tlZFxuICovXG5mdW5jdGlvbiBzaG91bGRUcmFja0RvbUV2ZW50KGVsLCBldikge1xuICAgIGlmICghZWwgfHwgaXNUYWcoZWwsICdodG1sJykgfHwgIWlzRWxlbWVudE5vZGUoZWwpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHRhZyA9IGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgICAgIHJldHVybiBldi50eXBlID09PSBFVl9TVUJNSVQ7XG4gICAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgICAgIGlmIChbJ2J1dHRvbicsICdzdWJtaXQnXS5pbmRleE9mKGVsLmdldEF0dHJpYnV0ZSgndHlwZScpKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXYudHlwZSA9PT0gRVZfQ0hBTkdFO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXYudHlwZSA9PT0gRVZfQ0xJQ0s7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgICAgICAgIHJldHVybiBldi50eXBlID09PSBFVl9DSEFOR0U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZXYudHlwZSA9PT0gRVZfQ0xJQ0s7XG4gICAgfVxufVxuXG4vKlxuICogQ2hlY2sgd2hldGhlciBhIERPTSBlbGVtZW50IHNob3VsZCBiZSBcInRyYWNrZWRcIiBvciBpZiBpdCBtYXkgY29udGFpbiBzZW5zaXRpdmUgZGF0YVxuICogdXNpbmcgYSB2YXJpZXR5IG9mIGhldXJpc3RpY3MuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIC0gZWxlbWVudCB0byBjaGVja1xuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhbGxvd1NlbGVjdG9ycyAtIENTUyBzZWxlY3RvcnMgZm9yIGVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIGluY2x1ZGVkXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgZWxlbWVudCBzaG91bGQgYmUgdHJhY2tlZFxuICovXG5mdW5jdGlvbiBzaG91bGRUcmFja0VsZW1lbnREZXRhaWxzKGVsLCBldiwgYWxsb3dFbGVtZW50Q2FsbGJhY2ssIGFsbG93U2VsZWN0b3JzKSB7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIWlzRWxlbWVudEFsbG93ZWQoZWwsIGV2LCBhbGxvd0VsZW1lbnRDYWxsYmFjaywgYWxsb3dTZWxlY3RvcnMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBjdXJFbCA9IGVsOyBjdXJFbC5wYXJlbnROb2RlICYmICFpc1RhZyhjdXJFbCwgJ2JvZHknKTsgY3VyRWwgPSBjdXJFbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gZ2V0Q2xhc3NlcyhjdXJFbCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBTRU5TSVRJVkVfREFUQV9DTEFTU0VTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2xhc3Nlc1tTRU5TSVRJVkVfREFUQV9DTEFTU0VTW2ldXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlbENsYXNzZXMgPSBnZXRDbGFzc2VzKGVsKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgT1BUX0lOX0NMQVNTRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGVsQ2xhc3Nlc1tPUFRfSU5fQ0xBU1NFU1tpXV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZG9uJ3Qgc2VuZCBkYXRhIGZyb20gaW5wdXRzIG9yIHNpbWlsYXIgZWxlbWVudHMgc2luY2UgdGhlcmUgd2lsbCBhbHdheXMgYmVcbiAgICAvLyBhIHJpc2sgb2YgY2xpZW50c2lkZSBqYXZhc2NyaXB0IHBsYWNpbmcgc2Vuc2l0aXZlIGRhdGEgaW4gYXR0cmlidXRlc1xuICAgIGlmIChcbiAgICAgICAgaXNUYWcoZWwsICdpbnB1dCcpIHx8XG4gICAgICAgIGlzVGFnKGVsLCAnc2VsZWN0JykgfHxcbiAgICAgICAgaXNUYWcoZWwsICd0ZXh0YXJlYScpIHx8XG4gICAgICAgIGVsLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICd0cnVlJ1xuICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gZG9uJ3QgaW5jbHVkZSBoaWRkZW4gb3IgcGFzc3dvcmQgZmllbGRzXG4gICAgdmFyIHR5cGUgPSBlbC50eXBlIHx8ICcnO1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHsgLy8gaXQncyBwb3NzaWJsZSBmb3IgZWwudHlwZSB0byBiZSBhIERPTSBlbGVtZW50IGlmIGVsIGlzIGEgZm9ybSB3aXRoIGEgY2hpbGQgaW5wdXRbbmFtZT1cInR5cGVcIl1cbiAgICAgICAgc3dpdGNoKHR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnaGlkZGVuJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlICdwYXNzd29yZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCBkYXRhIGZyb20gZmllbGRzIHRoYXQgbG9vayBsaWtlIHNlbnNpdGl2ZSBmaWVsZHNcbiAgICB2YXIgbmFtZSA9IGVsLm5hbWUgfHwgZWwuaWQgfHwgJyc7XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykgeyAvLyBpdCdzIHBvc3NpYmxlIGZvciBlbC5uYW1lIG9yIGVsLmlkIHRvIGJlIGEgRE9NIGVsZW1lbnQgaWYgZWwgaXMgYSBmb3JtIHdpdGggYSBjaGlsZCBpbnB1dFtuYW1lPVwibmFtZVwiXVxuICAgICAgICB2YXIgc2Vuc2l0aXZlTmFtZVJlZ2V4ID0gL15jY3xjYXJkbnVtfGNjbnVtfGNyZWRpdGNhcmR8Y3NjfGN2Y3xjdnZ8ZXhwfHBhc3N8cHdkfHJvdXRpbmd8c2VjY29kZXxzZWN1cml0eWNvZGV8c2VjdXJpdHludW18c29jaWFsc2VjfHNvY3NlY3xzc24vaTtcbiAgICAgICAgaWYgKHNlbnNpdGl2ZU5hbWVSZWdleC50ZXN0KG5hbWUucmVwbGFjZSgvW15hLXpBLVowLTldL2csICcnKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG5cbi8qXG4gKiBDaGVjayB3aGV0aGVyIGEgc3RyaW5nIHZhbHVlIHNob3VsZCBiZSBcInRyYWNrZWRcIiBvciBpZiBpdCBtYXkgY29udGFpbiBzZW5zaXRpdmUgZGF0YVxuICogdXNpbmcgYSB2YXJpZXR5IG9mIGhldXJpc3RpY3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBzdHJpbmcgdmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBlbGVtZW50IHNob3VsZCBiZSB0cmFja2VkXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFRyYWNrVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgXy5pc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbHVlID0gXy50cmltKHZhbHVlKTtcblxuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgaW5wdXQgdmFsdWUgbG9va3MgbGlrZSBhIGNyZWRpdCBjYXJkIG51bWJlclxuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgxNDQ5MzI3NDUzL2NoMDRzMjAuaHRtbFxuICAgICAgICB2YXIgY2NSZWdleCA9IC9eKD86KDRbMC05XXsxMn0oPzpbMC05XXszfSk/KXwoNVsxLTVdWzAtOV17MTR9KXwoNig/OjAxMXw1WzAtOV17Mn0pWzAtOV17MTJ9KXwoM1s0N11bMC05XXsxM30pfCgzKD86MFswLTVdfFs2OF1bMC05XSlbMC05XXsxMX0pfCgoPzoyMTMxfDE4MDB8MzVbMC05XXszfSlbMC05XXsxMX0pKSQvO1xuICAgICAgICBpZiAoY2NSZWdleC50ZXN0KCh2YWx1ZSB8fCAnJykucmVwbGFjZSgvWy0gXS9nLCAnJykpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgaW5wdXQgdmFsdWUgbG9va3MgbGlrZSBhIHNvY2lhbCBzZWN1cml0eSBudW1iZXJcbiAgICAgICAgdmFyIHNzblJlZ2V4ID0gLyheXFxkezN9LT9cXGR7Mn0tP1xcZHs0fSQpLztcbiAgICAgICAgaWYgKHNzblJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIEFVVE9DQVBUVVJFX0NPTkZJR19LRVkgPSAnYXV0b2NhcHR1cmUnO1xudmFyIExFR0FDWV9QQUdFVklFV19DT05GSUdfS0VZID0gJ3RyYWNrX3BhZ2V2aWV3JztcblxudmFyIFBBR0VWSUVXX09QVElPTl9GVUxMX1VSTCA9ICdmdWxsLXVybCc7XG52YXIgUEFHRVZJRVdfT1BUSU9OX1VSTF9XSVRIX1BBVEhfQU5EX1FVRVJZX1NUUklORyA9ICd1cmwtd2l0aC1wYXRoLWFuZC1xdWVyeS1zdHJpbmcnO1xudmFyIFBBR0VWSUVXX09QVElPTl9VUkxfV0lUSF9QQVRIID0gJ3VybC13aXRoLXBhdGgnO1xuXG52YXIgQ09ORklHX0FMTE9XX0VMRU1FTlRfQ0FMTEJBQ0sgPSAnYWxsb3dfZWxlbWVudF9jYWxsYmFjayc7XG52YXIgQ09ORklHX0FMTE9XX1NFTEVDVE9SUyA9ICdhbGxvd19zZWxlY3RvcnMnO1xudmFyIENPTkZJR19BTExPV19VUkxfUkVHRVhFUyA9ICdhbGxvd191cmxfcmVnZXhlcyc7XG52YXIgQ09ORklHX0JMT0NLX0FUVFJTID0gJ2Jsb2NrX2F0dHJzJztcbnZhciBDT05GSUdfQkxPQ0tfRUxFTUVOVF9DQUxMQkFDSyA9ICdibG9ja19lbGVtZW50X2NhbGxiYWNrJztcbnZhciBDT05GSUdfQkxPQ0tfU0VMRUNUT1JTID0gJ2Jsb2NrX3NlbGVjdG9ycyc7XG52YXIgQ09ORklHX0JMT0NLX1VSTF9SRUdFWEVTID0gJ2Jsb2NrX3VybF9yZWdleGVzJztcbnZhciBDT05GSUdfQ0FQVFVSRV9FWFRSQV9BVFRSUyA9ICdjYXB0dXJlX2V4dHJhX2F0dHJzJztcbnZhciBDT05GSUdfQ0FQVFVSRV9URVhUX0NPTlRFTlQgPSAnY2FwdHVyZV90ZXh0X2NvbnRlbnQnO1xudmFyIENPTkZJR19TQ1JPTExfQ0FQVFVSRV9BTEwgPSAnc2Nyb2xsX2NhcHR1cmVfYWxsJztcbnZhciBDT05GSUdfU0NST0xMX0NIRUNLUE9JTlRTID0gJ3Njcm9sbF9kZXB0aF9wZXJjZW50X2NoZWNrcG9pbnRzJztcbnZhciBDT05GSUdfVFJBQ0tfQ0xJQ0sgPSAnY2xpY2snO1xudmFyIENPTkZJR19UUkFDS19JTlBVVCA9ICdpbnB1dCc7XG52YXIgQ09ORklHX1RSQUNLX1BBR0VWSUVXID0gJ3BhZ2V2aWV3JztcbnZhciBDT05GSUdfVFJBQ0tfU0NST0xMID0gJ3Njcm9sbCc7XG52YXIgQ09ORklHX1RSQUNLX1NVQk1JVCA9ICdzdWJtaXQnO1xuXG52YXIgQ09ORklHX0RFRkFVTFRTJDEgPSB7fTtcbkNPTkZJR19ERUZBVUxUUyQxW0NPTkZJR19BTExPV19TRUxFQ1RPUlNdID0gW107XG5DT05GSUdfREVGQVVMVFMkMVtDT05GSUdfQUxMT1dfVVJMX1JFR0VYRVNdID0gW107XG5DT05GSUdfREVGQVVMVFMkMVtDT05GSUdfQkxPQ0tfQVRUUlNdID0gW107XG5DT05GSUdfREVGQVVMVFMkMVtDT05GSUdfQkxPQ0tfRUxFTUVOVF9DQUxMQkFDS10gPSBudWxsO1xuQ09ORklHX0RFRkFVTFRTJDFbQ09ORklHX0JMT0NLX1NFTEVDVE9SU10gPSBbXTtcbkNPTkZJR19ERUZBVUxUUyQxW0NPTkZJR19CTE9DS19VUkxfUkVHRVhFU10gPSBbXTtcbkNPTkZJR19ERUZBVUxUUyQxW0NPTkZJR19DQVBUVVJFX0VYVFJBX0FUVFJTXSA9IFtdO1xuQ09ORklHX0RFRkFVTFRTJDFbQ09ORklHX0NBUFRVUkVfVEVYVF9DT05URU5UXSA9IGZhbHNlO1xuQ09ORklHX0RFRkFVTFRTJDFbQ09ORklHX1NDUk9MTF9DQVBUVVJFX0FMTF0gPSBmYWxzZTtcbkNPTkZJR19ERUZBVUxUUyQxW0NPTkZJR19TQ1JPTExfQ0hFQ0tQT0lOVFNdID0gWzI1LCA1MCwgNzUsIDEwMF07XG5DT05GSUdfREVGQVVMVFMkMVtDT05GSUdfVFJBQ0tfQ0xJQ0tdID0gdHJ1ZTtcbkNPTkZJR19ERUZBVUxUUyQxW0NPTkZJR19UUkFDS19JTlBVVF0gPSB0cnVlO1xuQ09ORklHX0RFRkFVTFRTJDFbQ09ORklHX1RSQUNLX1BBR0VWSUVXXSA9IFBBR0VWSUVXX09QVElPTl9GVUxMX1VSTDtcbkNPTkZJR19ERUZBVUxUUyQxW0NPTkZJR19UUkFDS19TQ1JPTExdID0gdHJ1ZTtcbkNPTkZJR19ERUZBVUxUUyQxW0NPTkZJR19UUkFDS19TVUJNSVRdID0gdHJ1ZTtcblxudmFyIERFRkFVTFRfUFJPUFMgPSB7XG4gICAgJyRtcF9hdXRvY2FwdHVyZSc6IHRydWVcbn07XG5cbnZhciBNUF9FVl9DTElDSyA9ICckbXBfY2xpY2snO1xudmFyIE1QX0VWX0lOUFVUID0gJyRtcF9pbnB1dF9jaGFuZ2UnO1xudmFyIE1QX0VWX1NDUk9MTCA9ICckbXBfc2Nyb2xsJztcbnZhciBNUF9FVl9TVUJNSVQgPSAnJG1wX3N1Ym1pdCc7XG5cbi8qKlxuICogQXV0b2NhcHR1cmU6IG1hbmFnZXMgYXV0b21hdGljIGV2ZW50IHRyYWNraW5nXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEF1dG9jYXB0dXJlID0gZnVuY3Rpb24obXApIHtcbiAgICB0aGlzLm1wID0gbXA7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghbWluRE9NQXBpc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdBdXRvY2FwdHVyZSB1bmF2YWlsYWJsZTogbWlzc2luZyByZXF1aXJlZCBET00gQVBJcycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pbml0UGFnZXZpZXdUcmFja2luZygpO1xuICAgIHRoaXMuaW5pdENsaWNrVHJhY2tpbmcoKTtcbiAgICB0aGlzLmluaXRJbnB1dFRyYWNraW5nKCk7XG4gICAgdGhpcy5pbml0U2Nyb2xsVHJhY2tpbmcoKTtcbiAgICB0aGlzLmluaXRTdWJtaXRUcmFja2luZygpO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmdldEZ1bGxDb25maWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXV0b2NhcHR1cmVDb25maWcgPSB0aGlzLm1wLmdldF9jb25maWcoQVVUT0NBUFRVUkVfQ09ORklHX0tFWSk7XG4gICAgaWYgKCFhdXRvY2FwdHVyZUNvbmZpZykge1xuICAgICAgICAvLyBBdXRvY2FwdHVyZSBpcyBjb21wbGV0ZWx5IG9mZlxuICAgICAgICByZXR1cm4ge307XG4gICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KGF1dG9jYXB0dXJlQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gXy5leHRlbmQoe30sIENPTkZJR19ERUZBVUxUUyQxLCBhdXRvY2FwdHVyZUNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXV0b2NhcHR1cmUgY29uZmlnIGlzIG5vbi1vYmplY3QgdHJ1dGh5IHZhbHVlLCByZXR1cm4gZGVmYXVsdFxuICAgICAgICByZXR1cm4gQ09ORklHX0RFRkFVTFRTJDE7XG4gICAgfVxufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiB0aGlzLmdldEZ1bGxDb25maWcoKVtrZXldO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmN1cnJlbnRVcmxCbG9ja2VkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGN1cnJlbnRVcmwgPSBfLmluZm8uY3VycmVudFVybCgpO1xuXG4gICAgdmFyIGFsbG93VXJsUmVnZXhlcyA9IHRoaXMuZ2V0Q29uZmlnKENPTkZJR19BTExPV19VUkxfUkVHRVhFUykgfHwgW107XG4gICAgaWYgKGFsbG93VXJsUmVnZXhlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gd2UncmUgdXNpbmcgYW4gYWxsb3dsaXN0LCBvbmx5IHRyYWNrIGlmIGN1cnJlbnQgVVJMIG1hdGNoZXNcbiAgICAgICAgdmFyIGFsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFsbG93VXJsUmVnZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGFsbG93UmVnZXggPSBhbGxvd1VybFJlZ2V4ZXNbaV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VXJsLm1hdGNoKGFsbG93UmVnZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIkMS5jcml0aWNhbCgnRXJyb3Igd2hpbGUgY2hlY2tpbmcgYmxvY2sgVVJMIHJlZ2V4OiAnICsgYWxsb3dSZWdleCwgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFsbG93ZWQpIHtcbiAgICAgICAgICAgIC8vIHdhc24ndCBhbGxvd2VkIGJ5IGFueSByZWdleFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYmxvY2tVcmxSZWdleGVzID0gdGhpcy5nZXRDb25maWcoQ09ORklHX0JMT0NLX1VSTF9SRUdFWEVTKSB8fCBbXTtcbiAgICBpZiAoIWJsb2NrVXJsUmVnZXhlcyB8fCAhYmxvY2tVcmxSZWdleGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGJsb2NrVXJsUmVnZXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRVcmwubWF0Y2goYmxvY2tVcmxSZWdleGVzW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdFcnJvciB3aGlsZSBjaGVja2luZyBibG9jayBVUkwgcmVnZXg6ICcgKyBibG9ja1VybFJlZ2V4ZXNbaV0sIGVycik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUucGFnZXZpZXdUcmFja2luZ0NvbmZpZyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHN1cHBvcnRzIGJvdGggYXV0b2NhcHR1cmUgY29uZmlnIGFuZCBvbGQgdHJhY2tfcGFnZXZpZXcgY29uZmlnXG4gICAgaWYgKHRoaXMubXAuZ2V0X2NvbmZpZyhBVVRPQ0FQVFVSRV9DT05GSUdfS0VZKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX1BBR0VWSUVXKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5tcC5nZXRfY29uZmlnKExFR0FDWV9QQUdFVklFV19DT05GSUdfS0VZKTtcbiAgICB9XG59O1xuXG4vLyBoZWxwZXIgZm9yIGV2ZW50IGhhbmRsZXJzXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUudHJhY2tEb21FdmVudCA9IGZ1bmN0aW9uKGV2LCBtcEV2ZW50TmFtZSkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRVcmxCbG9ja2VkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wcyA9IGdldFByb3BzRm9yRE9NRXZlbnQoZXYsIHtcbiAgICAgICAgYWxsb3dFbGVtZW50Q2FsbGJhY2s6IHRoaXMuZ2V0Q29uZmlnKENPTkZJR19BTExPV19FTEVNRU5UX0NBTExCQUNLKSxcbiAgICAgICAgYWxsb3dTZWxlY3RvcnM6IHRoaXMuZ2V0Q29uZmlnKENPTkZJR19BTExPV19TRUxFQ1RPUlMpLFxuICAgICAgICBibG9ja0F0dHJzOiB0aGlzLmdldENvbmZpZyhDT05GSUdfQkxPQ0tfQVRUUlMpLFxuICAgICAgICBibG9ja0VsZW1lbnRDYWxsYmFjazogdGhpcy5nZXRDb25maWcoQ09ORklHX0JMT0NLX0VMRU1FTlRfQ0FMTEJBQ0spLFxuICAgICAgICBibG9ja1NlbGVjdG9yczogdGhpcy5nZXRDb25maWcoQ09ORklHX0JMT0NLX1NFTEVDVE9SUyksXG4gICAgICAgIGNhcHR1cmVFeHRyYUF0dHJzOiB0aGlzLmdldENvbmZpZyhDT05GSUdfQ0FQVFVSRV9FWFRSQV9BVFRSUyksXG4gICAgICAgIGNhcHR1cmVUZXh0Q29udGVudDogdGhpcy5nZXRDb25maWcoQ09ORklHX0NBUFRVUkVfVEVYVF9DT05URU5UKSxcbiAgICAgICAgY2FwdHVyZWRGb3JIZWF0TWFwOiBtcEV2ZW50TmFtZSA9PT0gTVBfRVZfQ0xJQ0sgJiYgIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19DTElDSykgJiYgdGhpcy5tcC5pc19yZWNvcmRpbmdfaGVhdG1hcF9kYXRhKCksXG4gICAgfSk7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICAgIF8uZXh0ZW5kKHByb3BzLCBERUZBVUxUX1BST1BTKTtcbiAgICAgICAgdGhpcy5tcC50cmFjayhtcEV2ZW50TmFtZSwgcHJvcHMpO1xuICAgIH1cbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5pbml0Q2xpY2tUcmFja2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX0NMSUNLLCB0aGlzLmxpc3RlbmVyQ2xpY2spO1xuXG4gICAgaWYgKCF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfQ0xJQ0spICYmICF0aGlzLm1wLmdldF9jb25maWcoJ3JlY29yZF9oZWF0bWFwX2RhdGEnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlciQxLmxvZygnSW5pdGlhbGl6aW5nIGNsaWNrIHRyYWNraW5nJyk7XG5cbiAgICB0aGlzLmxpc3RlbmVyQ2xpY2sgPSB3aW4uYWRkRXZlbnRMaXN0ZW5lcihFVl9DTElDSywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfQ0xJQ0spICYmICF0aGlzLm1wLmlzX3JlY29yZGluZ19oZWF0bWFwX2RhdGEoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tEb21FdmVudChldiwgTVBfRVZfQ0xJQ0spO1xuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuaW5pdElucHV0VHJhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9DSEFOR0UsIHRoaXMubGlzdGVuZXJDaGFuZ2UpO1xuXG4gICAgaWYgKCF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfSU5QVVQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyJDEubG9nKCdJbml0aWFsaXppbmcgaW5wdXQgdHJhY2tpbmcnKTtcblxuICAgIHRoaXMubGlzdGVuZXJDaGFuZ2UgPSB3aW4uYWRkRXZlbnRMaXN0ZW5lcihFVl9DSEFOR0UsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRDb25maWcoQ09ORklHX1RSQUNLX0lOUFVUKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tEb21FdmVudChldiwgTVBfRVZfSU5QVVQpO1xuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuXG5BdXRvY2FwdHVyZS5wcm90b3R5cGUuaW5pdFBhZ2V2aWV3VHJhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9QT1BTVEFURSwgdGhpcy5saXN0ZW5lclBvcHN0YXRlKTtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9IQVNIQ0hBTkdFLCB0aGlzLmxpc3RlbmVySGFzaGNoYW5nZSk7XG4gICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZfTVBfTE9DQVRJT05fQ0hBTkdFLCB0aGlzLmxpc3RlbmVyTG9jYXRpb25jaGFuZ2UpO1xuXG4gICAgaWYgKCF0aGlzLnBhZ2V2aWV3VHJhY2tpbmdDb25maWcoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlciQxLmxvZygnSW5pdGlhbGl6aW5nIHBhZ2V2aWV3IHRyYWNraW5nJyk7XG5cbiAgICB2YXIgcHJldmlvdXNUcmFja2VkVXJsID0gJyc7XG4gICAgdmFyIHRyYWNrZWQgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuY3VycmVudFVybEJsb2NrZWQoKSkge1xuICAgICAgICB0cmFja2VkID0gdGhpcy5tcC50cmFja19wYWdldmlldyhERUZBVUxUX1BST1BTKTtcbiAgICB9XG4gICAgaWYgKHRyYWNrZWQpIHtcbiAgICAgICAgcHJldmlvdXNUcmFja2VkVXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVyUG9wc3RhdGUgPSB3aW4uYWRkRXZlbnRMaXN0ZW5lcihFVl9QT1BTVEFURSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChFVl9NUF9MT0NBVElPTl9DSEFOR0UpKTtcbiAgICB9KTtcbiAgICB0aGlzLmxpc3RlbmVySGFzaGNoYW5nZSA9IHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX0hBU0hDSEFOR0UsIGZ1bmN0aW9uKCkge1xuICAgICAgICB3aW4uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZfTVBfTE9DQVRJT05fQ0hBTkdFKSk7XG4gICAgfSk7XG4gICAgdmFyIG5hdGl2ZVB1c2hTdGF0ZSA9IHdpbi5oaXN0b3J5LnB1c2hTdGF0ZTtcbiAgICBpZiAodHlwZW9mIG5hdGl2ZVB1c2hTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3aW4uaGlzdG9yeS5wdXNoU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgdW51c2VkLCB1cmwpIHtcbiAgICAgICAgICAgIG5hdGl2ZVB1c2hTdGF0ZS5jYWxsKHdpbi5oaXN0b3J5LCBzdGF0ZSwgdW51c2VkLCB1cmwpO1xuICAgICAgICAgICAgd2luLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVWX01QX0xPQ0FUSU9OX0NIQU5HRSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgbmF0aXZlUmVwbGFjZVN0YXRlID0gd2luLmhpc3RvcnkucmVwbGFjZVN0YXRlO1xuICAgIGlmICh0eXBlb2YgbmF0aXZlUmVwbGFjZVN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdpbi5oaXN0b3J5LnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCB1bnVzZWQsIHVybCkge1xuICAgICAgICAgICAgbmF0aXZlUmVwbGFjZVN0YXRlLmNhbGwod2luLmhpc3RvcnksIHN0YXRlLCB1bnVzZWQsIHVybCk7XG4gICAgICAgICAgICB3aW4uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoRVZfTVBfTE9DQVRJT05fQ0hBTkdFKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRoaXMubGlzdGVuZXJMb2NhdGlvbmNoYW5nZSA9IHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX01QX0xPQ0FUSU9OX0NIQU5HRSwgc2FmZXdyYXAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRVcmxCbG9ja2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjdXJyZW50VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcbiAgICAgICAgdmFyIHNob3VsZFRyYWNrID0gZmFsc2U7XG4gICAgICAgIHZhciBkaWRQYXRoQ2hhbmdlID0gY3VycmVudFVybC5zcGxpdCgnIycpWzBdLnNwbGl0KCc/JylbMF0gIT09IHByZXZpb3VzVHJhY2tlZFVybC5zcGxpdCgnIycpWzBdLnNwbGl0KCc/JylbMF07XG4gICAgICAgIHZhciB0cmFja1BhZ2V2aWV3T3B0aW9uID0gdGhpcy5wYWdldmlld1RyYWNraW5nQ29uZmlnKCk7XG4gICAgICAgIGlmICh0cmFja1BhZ2V2aWV3T3B0aW9uID09PSBQQUdFVklFV19PUFRJT05fRlVMTF9VUkwpIHtcbiAgICAgICAgICAgIHNob3VsZFRyYWNrID0gY3VycmVudFVybCAhPT0gcHJldmlvdXNUcmFja2VkVXJsO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYWNrUGFnZXZpZXdPcHRpb24gPT09IFBBR0VWSUVXX09QVElPTl9VUkxfV0lUSF9QQVRIX0FORF9RVUVSWV9TVFJJTkcpIHtcbiAgICAgICAgICAgIHNob3VsZFRyYWNrID0gY3VycmVudFVybC5zcGxpdCgnIycpWzBdICE9PSBwcmV2aW91c1RyYWNrZWRVcmwuc3BsaXQoJyMnKVswXTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmFja1BhZ2V2aWV3T3B0aW9uID09PSBQQUdFVklFV19PUFRJT05fVVJMX1dJVEhfUEFUSCkge1xuICAgICAgICAgICAgc2hvdWxkVHJhY2sgPSBkaWRQYXRoQ2hhbmdlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZFRyYWNrKSB7XG4gICAgICAgICAgICB2YXIgdHJhY2tlZCA9IHRoaXMubXAudHJhY2tfcGFnZXZpZXcoREVGQVVMVF9QUk9QUyk7XG4gICAgICAgICAgICBpZiAodHJhY2tlZCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzVHJhY2tlZFVybCA9IGN1cnJlbnRVcmw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlkUGF0aENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFNjcm9sbENoZWNrcG9pbnQgPSAwO1xuICAgICAgICAgICAgICAgIGxvZ2dlciQxLmxvZygnUGF0aCBjaGFuZ2U6IHJlLWluaXRpYWxpemluZyBzY3JvbGwgZGVwdGggY2hlY2twb2ludHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSkpO1xufTtcblxuQXV0b2NhcHR1cmUucHJvdG90eXBlLmluaXRTY3JvbGxUcmFja2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKEVWX1NDUk9MTEVORCwgdGhpcy5saXN0ZW5lclNjcm9sbCk7XG5cbiAgICBpZiAoIXRoaXMuZ2V0Q29uZmlnKENPTkZJR19UUkFDS19TQ1JPTEwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nZ2VyJDEubG9nKCdJbml0aWFsaXppbmcgc2Nyb2xsIHRyYWNraW5nJyk7XG4gICAgdGhpcy5sYXN0U2Nyb2xsQ2hlY2twb2ludCA9IDA7XG5cbiAgICB0aGlzLmxpc3RlbmVyU2Nyb2xsID0gd2luLmFkZEV2ZW50TGlzdGVuZXIoRVZfU0NST0xMRU5ELCBzYWZld3JhcChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfU0NST0xMKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRVcmxCbG9ja2VkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG91bGRUcmFjayA9IHRoaXMuZ2V0Q29uZmlnKENPTkZJR19TQ1JPTExfQ0FQVFVSRV9BTEwpO1xuICAgICAgICB2YXIgc2Nyb2xsQ2hlY2twb2ludHMgPSAodGhpcy5nZXRDb25maWcoQ09ORklHX1NDUk9MTF9DSEVDS1BPSU5UUykgfHwgW10pXG4gICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pO1xuXG4gICAgICAgIHZhciBzY3JvbGxUb3AgPSB3aW4uc2Nyb2xsWTtcbiAgICAgICAgdmFyIHByb3BzID0gXy5leHRlbmQoeyckc2Nyb2xsX3RvcCc6IHNjcm9sbFRvcH0sIERFRkFVTFRfUFJPUFMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHNjcm9sbEhlaWdodCA9IGRvY3VtZW50JDEuYm9keS5zY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsUGVyY2VudGFnZSA9IE1hdGgucm91bmQoKHNjcm9sbFRvcCAvIChzY3JvbGxIZWlnaHQgLSB3aW4uaW5uZXJIZWlnaHQpKSAqIDEwMCk7XG4gICAgICAgICAgICBwcm9wc1snJHNjcm9sbF9oZWlnaHQnXSA9IHNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgIHByb3BzWyckc2Nyb2xsX3BlcmNlbnRhZ2UnXSA9IHNjcm9sbFBlcmNlbnRhZ2U7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsUGVyY2VudGFnZSA+IHRoaXMubGFzdFNjcm9sbENoZWNrcG9pbnQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcm9sbENoZWNrcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGVja3BvaW50ID0gc2Nyb2xsQ2hlY2twb2ludHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFBlcmNlbnRhZ2UgPj0gY2hlY2twb2ludCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0U2Nyb2xsQ2hlY2twb2ludCA8IGNoZWNrcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wc1snJHNjcm9sbF9jaGVja3BvaW50J10gPSBjaGVja3BvaW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0U2Nyb2xsQ2hlY2twb2ludCA9IGNoZWNrcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRUcmFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyJDEuY3JpdGljYWwoJ0Vycm9yIHdoaWxlIGNhbGN1bGF0aW5nIHNjcm9sbCBwZXJjZW50YWdlJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkVHJhY2spIHtcbiAgICAgICAgICAgIHRoaXMubXAudHJhY2soTVBfRVZfU0NST0xMLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpKTtcbn07XG5cbkF1dG9jYXB0dXJlLnByb3RvdHlwZS5pbml0U3VibWl0VHJhY2tpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB3aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVl9TVUJNSVQsIHRoaXMubGlzdGVuZXJTdWJtaXQpO1xuXG4gICAgaWYgKCF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfU1VCTUlUKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxvZ2dlciQxLmxvZygnSW5pdGlhbGl6aW5nIHN1Ym1pdCB0cmFja2luZycpO1xuXG4gICAgdGhpcy5saXN0ZW5lclN1Ym1pdCA9IHdpbi5hZGRFdmVudExpc3RlbmVyKEVWX1NVQk1JVCwgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdldENvbmZpZyhDT05GSUdfVFJBQ0tfU1VCTUlUKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tEb21FdmVudChldiwgTVBfRVZfU1VCTUlUKTtcbiAgICB9LmJpbmQodGhpcykpO1xufTtcblxuLy8gVE9ETyBpbnRlZ3JhdGUgZXJyb3JfcmVwb3J0ZXIgZnJvbSBtaXhwYW5lbCBpbnN0YW5jZVxuc2FmZXdyYXBDbGFzcyhBdXRvY2FwdHVyZSk7XG5cbnZhciBmZXRjaCA9IHdpblsnZmV0Y2gnXTtcbnZhciBsb2dnZXIgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdmbGFncycpO1xuXG52YXIgRkxBR1NfQ09ORklHX0tFWSA9ICdmbGFncyc7XG5cbnZhciBDT05GSUdfQ09OVEVYVCA9ICdjb250ZXh0JztcbnZhciBDT05GSUdfREVGQVVMVFMgPSB7fTtcbkNPTkZJR19ERUZBVUxUU1tDT05GSUdfQ09OVEVYVF0gPSB7fTtcblxuLyoqXG4gKiBGZWF0dXJlRmxhZ01hbmFnZXI6IHN1cHBvcnQgZm9yIE1peHBhbmVsJ3MgZmVhdHVyZSBmbGFnZ2luZyBwcm9kdWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEZlYXR1cmVGbGFnTWFuYWdlciA9IGZ1bmN0aW9uKGluaXRPcHRpb25zKSB7XG4gICAgdGhpcy5nZXRNcENvbmZpZyA9IGluaXRPcHRpb25zLmdldENvbmZpZ0Z1bmM7XG4gICAgdGhpcy5nZXREaXN0aW5jdElkID0gaW5pdE9wdGlvbnMuZ2V0RGlzdGluY3RJZEZ1bmM7XG4gICAgdGhpcy50cmFjayA9IGluaXRPcHRpb25zLnRyYWNraW5nRnVuYztcbn07XG5cbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghbWluQXBpc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgIGxvZ2dlci5jcml0aWNhbCgnRmVhdHVyZSBGbGFncyB1bmF2YWlsYWJsZTogbWlzc2luZyBtaW5pbXVtIHJlcXVpcmVkIEFQSXMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSBudWxsO1xuICAgIHRoaXMuZmV0Y2hGbGFncygpO1xuXG4gICAgdGhpcy50cmFja2VkRmVhdHVyZXMgPSBuZXcgU2V0KCk7XG59O1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmdldEZ1bGxDb25maWcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZmZDb25maWcgPSB0aGlzLmdldE1wQ29uZmlnKEZMQUdTX0NPTkZJR19LRVkpO1xuICAgIGlmICghZmZDb25maWcpIHtcbiAgICAgICAgLy8gZmxhZ3MgYXJlIGNvbXBsZXRlbHkgb2ZmXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoZmZDb25maWcpKSB7XG4gICAgICAgIHJldHVybiBfLmV4dGVuZCh7fSwgQ09ORklHX0RFRkFVTFRTLCBmZkNvbmZpZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uZmlnIGlzIG5vbi1vYmplY3QgdHJ1dGh5IHZhbHVlLCByZXR1cm4gZGVmYXVsdFxuICAgICAgICByZXR1cm4gQ09ORklHX0RFRkFVTFRTO1xuICAgIH1cbn07XG5cbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RnVsbENvbmZpZygpW2tleV07XG59O1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmlzU3lzdGVtRW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0TXBDb25maWcoRkxBR1NfQ09ORklHX0tFWSk7XG59O1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmFyZUZsYWdzUmVhZHkgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuaXNTeXN0ZW1FbmFibGVkKCkpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKCdGZWF0dXJlIEZsYWdzIG5vdCBlbmFibGVkJyk7XG4gICAgfVxuICAgIHJldHVybiAhIXRoaXMuZmxhZ3M7XG59O1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmZldGNoRmxhZ3MgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuaXNTeXN0ZW1FbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkaXN0aW5jdElkID0gdGhpcy5nZXREaXN0aW5jdElkKCk7XG4gICAgbG9nZ2VyLmxvZygnRmV0Y2hpbmcgZmxhZ3MgZm9yIGRpc3RpbmN0IElEOiAnICsgZGlzdGluY3RJZCk7XG4gICAgdmFyIHJlcVBhcmFtcyA9IHtcbiAgICAgICAgJ2NvbnRleHQnOiBfLmV4dGVuZCh7J2Rpc3RpbmN0X2lkJzogZGlzdGluY3RJZH0sIHRoaXMuZ2V0Q29uZmlnKENPTkZJR19DT05URVhUKSlcbiAgICB9O1xuICAgIHRoaXMuZmV0Y2hQcm9taXNlID0gd2luWydmZXRjaCddKHRoaXMuZ2V0TXBDb25maWcoJ2FwaV9ob3N0JykgKyAnLycgKyB0aGlzLmdldE1wQ29uZmlnKCdhcGlfcm91dGVzJylbJ2ZsYWdzJ10sIHtcbiAgICAgICAgJ21ldGhvZCc6ICdQT1NUJyxcbiAgICAgICAgJ2hlYWRlcnMnOiB7XG4gICAgICAgICAgICAnQXV0aG9yaXphdGlvbic6ICdCYXNpYyAnICsgYnRvYSh0aGlzLmdldE1wQ29uZmlnKCd0b2tlbicpICsgJzonKSxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJ1xuICAgICAgICB9LFxuICAgICAgICAnYm9keSc6IEpTT04uc3RyaW5naWZ5KHJlcVBhcmFtcylcbiAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCkudGhlbihmdW5jdGlvbihyZXNwb25zZUJvZHkpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZUZsYWdzID0gcmVzcG9uc2VCb2R5WydmbGFncyddO1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZUZsYWdzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBmbGFncyBpbiBBUEkgcmVzcG9uc2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmbGFncyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIF8uZWFjaChyZXNwb25zZUZsYWdzLCBmdW5jdGlvbihkYXRhLCBrZXkpIHtcbiAgICAgICAgICAgICAgICBmbGFncy5zZXQoa2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICdrZXknOiBkYXRhWyd2YXJpYW50X2tleSddLFxuICAgICAgICAgICAgICAgICAgICAndmFsdWUnOiBkYXRhWyd2YXJpYW50X3ZhbHVlJ11cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgICAgICB9LmJpbmQodGhpcykpLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9LmJpbmQodGhpcykpLmNhdGNoKGZ1bmN0aW9uKCkge30pO1xufTtcblxuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5nZXRWYXJpYW50ID0gZnVuY3Rpb24oZmVhdHVyZU5hbWUsIGZhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLmZldGNoUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmNyaXRpY2FsKCdGZWF0dXJlIEZsYWdzIG5vdCBpbml0aWFsaXplZCcpO1xuICAgICAgICAgICAgcmVzb2x2ZShmYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZldGNoUHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYXJpYW50U3luYyhmZWF0dXJlTmFtZSwgZmFsbGJhY2spO1xuICAgIH0uYmluZCh0aGlzKSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIH0pO1xufTtcblxuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5nZXRWYXJpYW50U3luYyA9IGZ1bmN0aW9uKGZlYXR1cmVOYW1lLCBmYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5hcmVGbGFnc1JlYWR5KCkpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnRmxhZ3Mgbm90IGxvYWRlZCB5ZXQnKTtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIH1cbiAgICB2YXIgZmVhdHVyZSA9IHRoaXMuZmxhZ3MuZ2V0KGZlYXR1cmVOYW1lKTtcbiAgICBpZiAoIWZlYXR1cmUpIHtcbiAgICAgICAgbG9nZ2VyLmxvZygnTm8gZmxhZyBmb3VuZDogXCInICsgZmVhdHVyZU5hbWUgKyAnXCInKTtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgIH1cbiAgICB0aGlzLnRyYWNrRmVhdHVyZUNoZWNrKGZlYXR1cmVOYW1lLCBmZWF0dXJlKTtcbiAgICByZXR1cm4gZmVhdHVyZTtcbn07XG5cbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuZ2V0VmFyaWFudFZhbHVlID0gZnVuY3Rpb24oZmVhdHVyZU5hbWUsIGZhbGxiYWNrVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYXJpYW50KGZlYXR1cmVOYW1lLCB7J3ZhbHVlJzogZmFsbGJhY2tWYWx1ZX0pLnRoZW4oZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICByZXR1cm4gZmVhdHVyZVsndmFsdWUnXTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tWYWx1ZTtcbiAgICB9KTtcbn07XG5cbi8vIFRPRE8gcmVtb3ZlIGRlcHJlY2F0ZWQgbWV0aG9kXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmdldEZlYXR1cmVEYXRhID0gZnVuY3Rpb24oZmVhdHVyZU5hbWUsIGZhbGxiYWNrVmFsdWUpIHtcbiAgICBsb2dnZXIuY3JpdGljYWwoJ21peHBhbmVsLmZsYWdzLmdldF9mZWF0dXJlX2RhdGEoKSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS4gVXNlIG1peHBhbmVsLmZsYWdzLmdldF92YXJpYW50X3ZhbHVlKCkgaW5zdGVhZC4nKTtcbiAgICByZXR1cm4gdGhpcy5nZXRWYXJpYW50VmFsdWUoZmVhdHVyZU5hbWUsIGZhbGxiYWNrVmFsdWUpO1xufTtcblxuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5nZXRWYXJpYW50VmFsdWVTeW5jID0gZnVuY3Rpb24oZmVhdHVyZU5hbWUsIGZhbGxiYWNrVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYXJpYW50U3luYyhmZWF0dXJlTmFtZSwgeyd2YWx1ZSc6IGZhbGxiYWNrVmFsdWV9KVsndmFsdWUnXTtcbn07XG5cbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24oZmVhdHVyZU5hbWUsIGZhbGxiYWNrVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRWYXJpYW50VmFsdWUoZmVhdHVyZU5hbWUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRW5hYmxlZFN5bmMoZmVhdHVyZU5hbWUsIGZhbGxiYWNrVmFsdWUpO1xuICAgIH0uYmluZCh0aGlzKSkuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrVmFsdWU7XG4gICAgfSk7XG59O1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmlzRW5hYmxlZFN5bmMgPSBmdW5jdGlvbihmZWF0dXJlTmFtZSwgZmFsbGJhY2tWYWx1ZSkge1xuICAgIGZhbGxiYWNrVmFsdWUgPSBmYWxsYmFja1ZhbHVlIHx8IGZhbHNlO1xuICAgIHZhciB2YWwgPSB0aGlzLmdldFZhcmlhbnRWYWx1ZVN5bmMoZmVhdHVyZU5hbWUsIGZhbGxiYWNrVmFsdWUpO1xuICAgIGlmICh2YWwgIT09IHRydWUgJiYgdmFsICE9PSBmYWxzZSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoJ0ZlYXR1cmUgZmxhZyBcIicgKyBmZWF0dXJlTmFtZSArICdcIiB2YWx1ZTogJyArIHZhbCArICcgaXMgbm90IGEgYm9vbGVhbjsgcmV0dXJuaW5nIGZhbGxiYWNrIHZhbHVlOiAnICsgZmFsbGJhY2tWYWx1ZSk7XG4gICAgICAgIHZhbCA9IGZhbGxiYWNrVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG59O1xuXG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLnRyYWNrRmVhdHVyZUNoZWNrID0gZnVuY3Rpb24oZmVhdHVyZU5hbWUsIGZlYXR1cmUpIHtcbiAgICBpZiAodGhpcy50cmFja2VkRmVhdHVyZXMuaGFzKGZlYXR1cmVOYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudHJhY2tlZEZlYXR1cmVzLmFkZChmZWF0dXJlTmFtZSk7XG4gICAgdGhpcy50cmFjaygnJGV4cGVyaW1lbnRfc3RhcnRlZCcsIHtcbiAgICAgICAgJ0V4cGVyaW1lbnQgbmFtZSc6IGZlYXR1cmVOYW1lLFxuICAgICAgICAnVmFyaWFudCBuYW1lJzogZmVhdHVyZVsna2V5J10sXG4gICAgICAgICckZXhwZXJpbWVudF90eXBlJzogJ2ZlYXR1cmVfZmxhZydcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIG1pbkFwaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuICEhZmV0Y2ggJiZcbiAgICAgIHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiBTZXQgIT09ICd1bmRlZmluZWQnO1xufVxuXG5zYWZld3JhcENsYXNzKEZlYXR1cmVGbGFnTWFuYWdlcik7XG5cbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGVbJ2FyZV9mbGFnc19yZWFkeSddID0gRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5hcmVGbGFnc1JlYWR5O1xuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZVsnZ2V0X3ZhcmlhbnQnXSA9IEZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuZ2V0VmFyaWFudDtcbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGVbJ2dldF92YXJpYW50X3N5bmMnXSA9IEZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGUuZ2V0VmFyaWFudFN5bmM7XG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlWydnZXRfdmFyaWFudF92YWx1ZSddID0gRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5nZXRWYXJpYW50VmFsdWU7XG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlWydnZXRfdmFyaWFudF92YWx1ZV9zeW5jJ10gPSBGZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmdldFZhcmlhbnRWYWx1ZVN5bmM7XG5GZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlWydpc19lbmFibGVkJ10gPSBGZWF0dXJlRmxhZ01hbmFnZXIucHJvdG90eXBlLmlzRW5hYmxlZDtcbkZlYXR1cmVGbGFnTWFuYWdlci5wcm90b3R5cGVbJ2lzX2VuYWJsZWRfc3luYyddID0gRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5pc0VuYWJsZWRTeW5jO1xuXG4vLyBEZXByZWNhdGVkIG1ldGhvZFxuRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZVsnZ2V0X2ZlYXR1cmVfZGF0YSddID0gRmVhdHVyZUZsYWdNYW5hZ2VyLnByb3RvdHlwZS5nZXRGZWF0dXJlRGF0YTtcblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG5cbi8qKlxuICogRG9tVHJhY2tlciBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgRG9tVHJhY2tlciA9IGZ1bmN0aW9uKCkge307XG5cblxuLy8gaW50ZXJmYWNlXG5Eb21UcmFja2VyLnByb3RvdHlwZS5jcmVhdGVfcHJvcGVydGllcyA9IGZ1bmN0aW9uKCkge307XG5Eb21UcmFja2VyLnByb3RvdHlwZS5ldmVudF9oYW5kbGVyID0gZnVuY3Rpb24oKSB7fTtcbkRvbVRyYWNrZXIucHJvdG90eXBlLmFmdGVyX3RyYWNrX2hhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xuXG5Eb21UcmFja2VyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24obWl4cGFuZWxfaW5zdGFuY2UpIHtcbiAgICB0aGlzLm1wID0gbWl4cGFuZWxfaW5zdGFuY2U7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gcXVlcnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudF9uYW1lXG4gKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb249fSB1c2VyX2NhbGxiYWNrXG4gKi9cbkRvbVRyYWNrZXIucHJvdG90eXBlLnRyYWNrID0gZnVuY3Rpb24ocXVlcnksIGV2ZW50X25hbWUsIHByb3BlcnRpZXMsIHVzZXJfY2FsbGJhY2spIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIGVsZW1lbnRzID0gXy5kb21fcXVlcnkocXVlcnkpO1xuXG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ1RoZSBET00gcXVlcnkgKCcgKyBxdWVyeSArICcpIHJldHVybmVkIDAgZWxlbWVudHMnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF8uZWFjaChlbGVtZW50cywgZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICBfLnJlZ2lzdGVyX2V2ZW50KGVsZW1lbnQsIHRoaXMub3ZlcnJpZGVfZXZlbnQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0ge307XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSB0aGF0LmNyZWF0ZV9wcm9wZXJ0aWVzKHByb3BlcnRpZXMsIHRoaXMpO1xuICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSB0aGF0Lm1wLmdldF9jb25maWcoJ3RyYWNrX2xpbmtzX3RpbWVvdXQnKTtcblxuICAgICAgICAgICAgdGhhdC5ldmVudF9oYW5kbGVyKGUsIHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBtaXhwYW5lbCBzZXJ2ZXJzIGRvbid0IGdldCBiYWNrIHRvIHVzIGluIHRpbWVcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHRoYXQudHJhY2tfY2FsbGJhY2sodXNlcl9jYWxsYmFjaywgcHJvcHMsIG9wdGlvbnMsIHRydWUpLCB0aW1lb3V0KTtcblxuICAgICAgICAgICAgLy8gZmlyZSB0aGUgdHJhY2tpbmcgZXZlbnRcbiAgICAgICAgICAgIHRoYXQubXAudHJhY2soZXZlbnRfbmFtZSwgcHJvcHMsIHRoYXQudHJhY2tfY2FsbGJhY2sodXNlcl9jYWxsYmFjaywgcHJvcHMsIG9wdGlvbnMpKTtcbiAgICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdXNlcl9jYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB0aW1lb3V0X29jY3VyZWRcbiAqL1xuRG9tVHJhY2tlci5wcm90b3R5cGUudHJhY2tfY2FsbGJhY2sgPSBmdW5jdGlvbih1c2VyX2NhbGxiYWNrLCBwcm9wcywgb3B0aW9ucywgdGltZW91dF9vY2N1cmVkKSB7XG4gICAgdGltZW91dF9vY2N1cmVkID0gdGltZW91dF9vY2N1cmVkIHx8IGZhbHNlO1xuICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gb3B0aW9ucyBpcyByZWZlcmVuY2VkIGZyb20gYm90aCBjYWxsYmFja3MsIHNvIHdlIGNhbiBoYXZlXG4gICAgICAgIC8vIGEgJ2xvY2snIG9mIHNvcnRzIHRvIGVuc3VyZSBvbmx5IG9uZSBmaXJlc1xuICAgICAgICBpZiAob3B0aW9ucy5jYWxsYmFja19maXJlZCkgeyByZXR1cm47IH1cbiAgICAgICAgb3B0aW9ucy5jYWxsYmFja19maXJlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHVzZXJfY2FsbGJhY2sgJiYgdXNlcl9jYWxsYmFjayh0aW1lb3V0X29jY3VyZWQsIHByb3BzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIHVzZXIgY2FuIHByZXZlbnQgdGhlIGRlZmF1bHQgZnVuY3Rpb25hbGl0eSBieVxuICAgICAgICAgICAgLy8gcmV0dXJuaW5nIGZhbHNlIGZyb20gdGhlaXIgY2FsbGJhY2tcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQuYWZ0ZXJfdHJhY2tfaGFuZGxlcihwcm9wcywgb3B0aW9ucywgdGltZW91dF9vY2N1cmVkKTtcbiAgICB9O1xufTtcblxuRG9tVHJhY2tlci5wcm90b3R5cGUuY3JlYXRlX3Byb3BlcnRpZXMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzLCBlbGVtZW50KSB7XG4gICAgdmFyIHByb3BzO1xuXG4gICAgaWYgKHR5cGVvZihwcm9wZXJ0aWVzKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcm9wcyA9IHByb3BlcnRpZXMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcHMgPSBfLmV4dGVuZCh7fSwgcHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb3BzO1xufTtcblxuLyoqXG4gKiBMaW5rVHJhY2tlciBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRG9tVHJhY2tlclxuICovXG52YXIgTGlua1RyYWNrZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm92ZXJyaWRlX2V2ZW50ID0gJ2NsaWNrJztcbn07XG5fLmluaGVyaXQoTGlua1RyYWNrZXIsIERvbVRyYWNrZXIpO1xuXG5MaW5rVHJhY2tlci5wcm90b3R5cGUuY3JlYXRlX3Byb3BlcnRpZXMgPSBmdW5jdGlvbihwcm9wZXJ0aWVzLCBlbGVtZW50KSB7XG4gICAgdmFyIHByb3BzID0gTGlua1RyYWNrZXIuc3VwZXJjbGFzcy5jcmVhdGVfcHJvcGVydGllcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKGVsZW1lbnQuaHJlZikgeyBwcm9wc1sndXJsJ10gPSBlbGVtZW50LmhyZWY7IH1cblxuICAgIHJldHVybiBwcm9wcztcbn07XG5cbkxpbmtUcmFja2VyLnByb3RvdHlwZS5ldmVudF9oYW5kbGVyID0gZnVuY3Rpb24oZXZ0LCBlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5uZXdfdGFiID0gKFxuICAgICAgICBldnQud2hpY2ggPT09IDIgfHxcbiAgICAgICAgZXZ0Lm1ldGFLZXkgfHxcbiAgICAgICAgZXZ0LmN0cmxLZXkgfHxcbiAgICAgICAgZWxlbWVudC50YXJnZXQgPT09ICdfYmxhbmsnXG4gICAgKTtcbiAgICBvcHRpb25zLmhyZWYgPSBlbGVtZW50LmhyZWY7XG5cbiAgICBpZiAoIW9wdGlvbnMubmV3X3RhYikge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59O1xuXG5MaW5rVHJhY2tlci5wcm90b3R5cGUuYWZ0ZXJfdHJhY2tfaGFuZGxlciA9IGZ1bmN0aW9uKHByb3BzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMubmV3X3RhYikgeyByZXR1cm47IH1cblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IG9wdGlvbnMuaHJlZjtcbiAgICB9LCAwKTtcbn07XG5cbi8qKlxuICogRm9ybVRyYWNrZXIgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIERvbVRyYWNrZXJcbiAqL1xudmFyIEZvcm1UcmFja2VyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vdmVycmlkZV9ldmVudCA9ICdzdWJtaXQnO1xufTtcbl8uaW5oZXJpdChGb3JtVHJhY2tlciwgRG9tVHJhY2tlcik7XG5cbkZvcm1UcmFja2VyLnByb3RvdHlwZS5ldmVudF9oYW5kbGVyID0gZnVuY3Rpb24oZXZ0LCBlbGVtZW50LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbn07XG5cbkZvcm1UcmFja2VyLnByb3RvdHlwZS5hZnRlcl90cmFja19oYW5kbGVyID0gZnVuY3Rpb24ocHJvcHMsIG9wdGlvbnMpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBvcHRpb25zLmVsZW1lbnQuc3VibWl0KCk7XG4gICAgfSwgMCk7XG59O1xuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cblxuLyoqIEBjb25zdCAqLyB2YXIgU0VUX0FDVElPTiAgICAgID0gJyRzZXQnO1xuLyoqIEBjb25zdCAqLyB2YXIgU0VUX09OQ0VfQUNUSU9OID0gJyRzZXRfb25jZSc7XG4vKiogQGNvbnN0ICovIHZhciBVTlNFVF9BQ1RJT04gICAgPSAnJHVuc2V0Jztcbi8qKiBAY29uc3QgKi8gdmFyIEFERF9BQ1RJT04gICAgICA9ICckYWRkJztcbi8qKiBAY29uc3QgKi8gdmFyIEFQUEVORF9BQ1RJT04gICA9ICckYXBwZW5kJztcbi8qKiBAY29uc3QgKi8gdmFyIFVOSU9OX0FDVElPTiAgICA9ICckdW5pb24nO1xuLyoqIEBjb25zdCAqLyB2YXIgUkVNT1ZFX0FDVElPTiAgID0gJyRyZW1vdmUnO1xuLyoqIEBjb25zdCAqLyB2YXIgREVMRVRFX0FDVElPTiAgID0gJyRkZWxldGUnO1xuXG4vLyBDb21tb24gaW50ZXJuYWwgbWV0aG9kcyBmb3IgbWl4cGFuZWwucGVvcGxlIGFuZCBtaXhwYW5lbC5ncm91cCBBUElzLlxuLy8gVGhlc2UgbWV0aG9kcyBzaG91bGRuJ3QgaW52b2x2ZSBuZXR3b3JrIEkvTy5cbnZhciBhcGlBY3Rpb25zID0ge1xuICAgIHNldF9hY3Rpb246IGZ1bmN0aW9uKHByb3AsIHRvKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkc2V0ID0ge307XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgICAgICBfLmVhY2gocHJvcCwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNldFtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2V0W3Byb3BdID0gdG87XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhW1NFVF9BQ1RJT05dID0gJHNldDtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIHVuc2V0X2FjdGlvbjogZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJHVuc2V0ID0gW107XG4gICAgICAgIGlmICghXy5pc0FycmF5KHByb3ApKSB7XG4gICAgICAgICAgICBwcm9wID0gW3Byb3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5lYWNoKHByb3AsIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAkdW5zZXQucHVzaChrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgZGF0YVtVTlNFVF9BQ1RJT05dID0gJHVuc2V0O1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgc2V0X29uY2VfYWN0aW9uOiBmdW5jdGlvbihwcm9wLCB0bykge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJHNldF9vbmNlID0ge307XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgICAgICBfLmVhY2gocHJvcCwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNldF9vbmNlW2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzZXRfb25jZVtwcm9wXSA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbU0VUX09OQ0VfQUNUSU9OXSA9ICRzZXRfb25jZTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIHVuaW9uX2FjdGlvbjogZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICR1bmlvbiA9IHt9O1xuICAgICAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgICAgICBfLmVhY2gobGlzdF9uYW1lLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAkdW5pb25ba10gPSBfLmlzQXJyYXkodikgPyB2IDogW3ZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHVuaW9uW2xpc3RfbmFtZV0gPSBfLmlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcyA6IFt2YWx1ZXNdO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbVU5JT05fQUNUSU9OXSA9ICR1bmlvbjtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIGFwcGVuZF9hY3Rpb246IGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICRhcHBlbmQgPSB7fTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICAgICAgXy5lYWNoKGxpc3RfbmFtZSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJGFwcGVuZFtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkYXBwZW5kW2xpc3RfbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW0FQUEVORF9BQ1RJT05dID0gJGFwcGVuZDtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIHJlbW92ZV9hY3Rpb246IGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICRyZW1vdmUgPSB7fTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICAgICAgXy5lYWNoKGxpc3RfbmFtZSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJHJlbW92ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkcmVtb3ZlW2xpc3RfbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW1JFTU9WRV9BQ1RJT05dID0gJHJlbW92ZTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIGRlbGV0ZV9hY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICBkYXRhW0RFTEVURV9BQ1RJT05dID0gJyc7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn07XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuLyoqXG4gKiBNaXhwYW5lbCBHcm91cCBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTWl4cGFuZWxHcm91cCA9IGZ1bmN0aW9uKCkge307XG5cbl8uZXh0ZW5kKE1peHBhbmVsR3JvdXAucHJvdG90eXBlLCBhcGlBY3Rpb25zKTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbihtaXhwYW5lbF9pbnN0YW5jZSwgZ3JvdXBfa2V5LCBncm91cF9pZCkge1xuICAgIHRoaXMuX21peHBhbmVsID0gbWl4cGFuZWxfaW5zdGFuY2U7XG4gICAgdGhpcy5fZ3JvdXBfa2V5ID0gZ3JvdXBfa2V5O1xuICAgIHRoaXMuX2dyb3VwX2lkID0gZ3JvdXBfaWQ7XG59O1xuXG4vKipcbiAqIFNldCBwcm9wZXJ0aWVzIG9uIGEgZ3JvdXAuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5zZXQoJ0xvY2F0aW9uJywgJzQwNSBIb3dhcmQnKTtcbiAqXG4gKiAgICAgLy8gb3Igc2V0IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZVxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnNldCh7XG4gKiAgICAgICAgICAnTG9jYXRpb24nOiAnNDA1IEhvd2FyZCcsXG4gKiAgICAgICAgICAnRm91bmRlZCcgOiAyMDA5LFxuICogICAgIH0pO1xuICogICAgIC8vIHByb3BlcnRpZXMgY2FuIGJlIHN0cmluZ3MsIGludGVnZXJzLCBkYXRlcywgb3IgbGlzdHNcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gW3RvXSBBIHZhbHVlIHRvIHNldCBvbiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5zZXQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24ocHJvcCwgdG8sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnNldF9hY3Rpb24ocHJvcCwgdG8pO1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdG87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogU2V0IHByb3BlcnRpZXMgb24gYSBncm91cCwgb25seSBpZiB0aGV5IGRvIG5vdCB5ZXQgZXhpc3QuXG4gKiBUaGlzIHdpbGwgbm90IG92ZXJ3cml0ZSBwcmV2aW91cyBncm91cCBwcm9wZXJ0eSB2YWx1ZXMsIHVubGlrZVxuICogZ3JvdXAuc2V0KCkuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5zZXRfb25jZSgnTG9jYXRpb24nLCAnNDA1IEhvd2FyZCcpO1xuICpcbiAqICAgICAvLyBvciBzZXQgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykuc2V0X29uY2Uoe1xuICogICAgICAgICAgJ0xvY2F0aW9uJzogJzQwNSBIb3dhcmQnLFxuICogICAgICAgICAgJ0ZvdW5kZWQnIDogMjAwOSxcbiAqICAgICB9KTtcbiAqICAgICAvLyBwcm9wZXJ0aWVzIGNhbiBiZSBzdHJpbmdzLCBpbnRlZ2VycywgbGlzdHMgb3IgZGF0ZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gW3RvXSBBIHZhbHVlIHRvIHNldCBvbiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5zZXRfb25jZSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihwcm9wLCB0bywgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuc2V0X29uY2VfYWN0aW9uKHByb3AsIHRvKTtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICBjYWxsYmFjayA9IHRvO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIFVuc2V0IHByb3BlcnRpZXMgb24gYSBncm91cCBwZXJtYW5lbnRseS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnVuc2V0KCdGb3VuZGVkJyk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3AgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS51bnNldCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihwcm9wLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy51bnNldF9hY3Rpb24ocHJvcCk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBNZXJnZSBhIGdpdmVuIGxpc3Qgd2l0aCBhIGxpc3QtdmFsdWVkIGdyb3VwIHByb3BlcnR5LCBleGNsdWRpbmcgZHVwbGljYXRlIHZhbHVlcy5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIG1lcmdlIGEgdmFsdWUgdG8gYSBsaXN0LCBjcmVhdGluZyBpdCBpZiBuZWVkZWRcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS51bmlvbignTG9jYXRpb24nLCBbJ1NhbiBGcmFuY2lzY28nLCAnTG9uZG9uJ10pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBsaXN0X25hbWUgTmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVmFsdWVzIHRvIG1lcmdlIHdpdGggdGhlIGdpdmVuIHByb3BlcnR5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLnVuaW9uID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWVzLCBjYWxsYmFjaykge1xuICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB2YWx1ZXM7XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGhpcy51bmlvbl9hY3Rpb24obGlzdF9uYW1lLCB2YWx1ZXMpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogUGVybWFuZW50bHkgZGVsZXRlIGEgZ3JvdXAuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5kZWxldGUoKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWydkZWxldGUnXSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIC8vIGJyYWNrZXQgbm90YXRpb24gYWJvdmUgcHJldmVudHMgYSBtaW5pZmljYXRpb24gZXJyb3IgcmVsYXRlZCB0byByZXNlcnZlZCB3b3Jkc1xuICAgIHZhciBkYXRhID0gdGhpcy5kZWxldGVfYWN0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBSZW1vdmUgYSBwcm9wZXJ0eSBmcm9tIGEgZ3JvdXAuIFRoZSB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgaWYgZG9lc24ndCBleGlzdC5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnJlbW92ZSgnTG9jYXRpb24nLCAnTG9uZG9uJyk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGxpc3RfbmFtZSBOYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBWYWx1ZSB0byByZW1vdmUgZnJvbSB0aGUgZ2l2ZW4gZ3JvdXAgcHJvcGVydHlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqL1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUucmVtb3ZlID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnJlbW92ZV9hY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuX3NlbmRfcmVxdWVzdCA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgZGF0YVsnJGdyb3VwX2tleSddID0gdGhpcy5fZ3JvdXBfa2V5O1xuICAgIGRhdGFbJyRncm91cF9pZCddID0gdGhpcy5fZ3JvdXBfaWQ7XG4gICAgZGF0YVsnJHRva2VuJ10gPSB0aGlzLl9nZXRfY29uZmlnKCd0b2tlbicpO1xuXG4gICAgdmFyIGRhdGVfZW5jb2RlZF9kYXRhID0gXy5lbmNvZGVEYXRlcyhkYXRhKTtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuX3RyYWNrX29yX2JhdGNoKHtcbiAgICAgICAgdHlwZTogJ2dyb3VwcycsXG4gICAgICAgIGRhdGE6IGRhdGVfZW5jb2RlZF9kYXRhLFxuICAgICAgICBlbmRwb2ludDogdGhpcy5fZ2V0X2NvbmZpZygnYXBpX2hvc3QnKSArICcvJyArICB0aGlzLl9nZXRfY29uZmlnKCdhcGlfcm91dGVzJylbJ2dyb3VwcyddLFxuICAgICAgICBiYXRjaGVyOiB0aGlzLl9taXhwYW5lbC5yZXF1ZXN0X2JhdGNoZXJzLmdyb3Vwc1xuICAgIH0sIGNhbGxiYWNrKTtcbn07XG5cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLl9pc19yZXNlcnZlZF9wcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcCA9PT0gJyRncm91cF9rZXknIHx8IHByb3AgPT09ICckZ3JvdXBfaWQnO1xufTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuX2dldF9jb25maWcgPSBmdW5jdGlvbihjb25mKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLmdldF9jb25maWcoY29uZik7XG59O1xuXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC50b1N0cmluZygpICsgJy5ncm91cC4nICsgdGhpcy5fZ3JvdXBfa2V5ICsgJy4nICsgdGhpcy5fZ3JvdXBfaWQ7XG59O1xuXG4vLyBNaXhwYW5lbEdyb3VwIEV4cG9ydHNcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWydyZW1vdmUnXSAgID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUucmVtb3ZlO1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3NldCddICAgICAgPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5zZXQ7XG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsnc2V0X29uY2UnXSA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnNldF9vbmNlO1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3VuaW9uJ10gICAgPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS51bmlvbjtcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWyd1bnNldCddICAgID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUudW5zZXQ7XG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsndG9TdHJpbmcnXSA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cbi8qKlxuICogTWl4cGFuZWwgUGVvcGxlIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNaXhwYW5lbFBlb3BsZSA9IGZ1bmN0aW9uKCkge307XG5cbl8uZXh0ZW5kKE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZSwgYXBpQWN0aW9ucyk7XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKG1peHBhbmVsX2luc3RhbmNlKSB7XG4gICAgdGhpcy5fbWl4cGFuZWwgPSBtaXhwYW5lbF9pbnN0YW5jZTtcbn07XG5cbi8qXG4qIFNldCBwcm9wZXJ0aWVzIG9uIGEgdXNlciByZWNvcmQuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIG1peHBhbmVsLnBlb3BsZS5zZXQoJ2dlbmRlcicsICdtJyk7XG4qXG4qICAgICAvLyBvciBzZXQgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuc2V0KHtcbiogICAgICAgICAnQ29tcGFueSc6ICdBY21lJyxcbiogICAgICAgICAnUGxhbic6ICdQcmVtaXVtJyxcbiogICAgICAgICAnVXBncmFkZSBkYXRlJzogbmV3IERhdGUoKVxuKiAgICAgfSk7XG4qICAgICAvLyBwcm9wZXJ0aWVzIGNhbiBiZSBzdHJpbmdzLCBpbnRlZ2VycywgZGF0ZXMsIG9yIGxpc3RzXG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuKiBAcGFyYW0geyp9IFt0b10gQSB2YWx1ZSB0byBzZXQgb24gdGhlIGdpdmVuIHByb3BlcnR5IG5hbWVcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuc2V0ID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihwcm9wLCB0bywgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuc2V0X2FjdGlvbihwcm9wLCB0byk7XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB0bztcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIHJlZmVycmVyIGluZm8gaGFzIGJlZW4gdXBkYXRlZCBhbmQgc2F2ZWRcbiAgICBpZiAodGhpcy5fZ2V0X2NvbmZpZygnc2F2ZV9yZWZlcnJlcicpKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLnVwZGF0ZV9yZWZlcnJlcl9pbmZvKGRvY3VtZW50LnJlZmVycmVyKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgJHNldCBvYmplY3Qgd2l0aCBkZWZhdWx0IHBlb3BsZSBwcm9wZXJ0aWVzXG4gICAgZGF0YVtTRVRfQUNUSU9OXSA9IF8uZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgXy5pbmZvLnBlb3BsZV9wcm9wZXJ0aWVzKCksXG4gICAgICAgIGRhdGFbU0VUX0FDVElPTl1cbiAgICApO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIFNldCBwcm9wZXJ0aWVzIG9uIGEgdXNlciByZWNvcmQsIG9ubHkgaWYgdGhleSBkbyBub3QgeWV0IGV4aXN0LlxuKiBUaGlzIHdpbGwgbm90IG92ZXJ3cml0ZSBwcmV2aW91cyBwZW9wbGUgcHJvcGVydHkgdmFsdWVzLCB1bmxpa2VcbiogcGVvcGxlLnNldCgpLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuc2V0X29uY2UoJ0ZpcnN0IExvZ2luIERhdGUnLCBuZXcgRGF0ZSgpKTtcbipcbiogICAgIC8vIG9yIHNldCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2VcbiogICAgIG1peHBhbmVsLnBlb3BsZS5zZXRfb25jZSh7XG4qICAgICAgICAgJ0ZpcnN0IExvZ2luIERhdGUnOiBuZXcgRGF0ZSgpLFxuKiAgICAgICAgICdTdGFydGluZyBQbGFuJzogJ1ByZW1pdW0nXG4qICAgICB9KTtcbipcbiogICAgIC8vIHByb3BlcnRpZXMgY2FuIGJlIHN0cmluZ3MsIGludGVnZXJzIG9yIGRhdGVzXG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuKiBAcGFyYW0geyp9IFt0b10gQSB2YWx1ZSB0byBzZXQgb24gdGhlIGdpdmVuIHByb3BlcnR5IG5hbWVcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuc2V0X29uY2UgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKHByb3AsIHRvLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy5zZXRfb25jZV9hY3Rpb24ocHJvcCwgdG8pO1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdG87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIFVuc2V0IHByb3BlcnRpZXMgb24gYSB1c2VyIHJlY29yZCAocGVybWFuZW50bHkgcmVtb3ZlcyB0aGUgcHJvcGVydGllcyBhbmQgdGhlaXIgdmFsdWVzIGZyb20gYSBwcm9maWxlKS5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuc2V0KCdnZW5kZXInKTtcbipcbiogICAgIC8vIG9yIHVuc2V0IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZVxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuc2V0KFsnZ2VuZGVyJywgJ0NvbXBhbnknXSk7XG4qXG4qIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBwcm9wIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gYXJyYXksIHRoaXMgaXMgYSBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLlxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS51bnNldCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24ocHJvcCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMudW5zZXRfYWN0aW9uKHByb3ApO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIEluY3JlbWVudC9kZWNyZW1lbnQgbnVtZXJpYyBwZW9wbGUgYW5hbHl0aWNzIHByb3BlcnRpZXMuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQoJ3BhZ2Vfdmlld3MnLCAxKTtcbipcbiogICAgIC8vIG9yLCBmb3IgY29udmVuaWVuY2UsIGlmIHlvdSdyZSBqdXN0IGluY3JlbWVudGluZyBhIGNvdW50ZXIgYnlcbiogICAgIC8vIDEsIHlvdSBjYW4gc2ltcGx5IGRvXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KCdwYWdlX3ZpZXdzJyk7XG4qXG4qICAgICAvLyB0byBkZWNyZW1lbnQgYSBjb3VudGVyLCBwYXNzIGEgbmVnYXRpdmUgbnVtYmVyXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KCdjcmVkaXRzX2xlZnQnLCAtMSk7XG4qXG4qICAgICAvLyBsaWtlIG1peHBhbmVsLnBlb3BsZS5zZXQoKSwgeW91IGNhbiBpbmNyZW1lbnQgbXVsdGlwbGVcbiogICAgIC8vIHByb3BlcnRpZXMgYXQgb25jZTpcbiogICAgIG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQoe1xuKiAgICAgICAgIGNvdW50ZXIxOiAxLFxuKiAgICAgICAgIGNvdW50ZXIyOiA2XG4qICAgICB9KTtcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCBudW1lcmljIHZhbHVlcy5cbiogQHBhcmFtIHtOdW1iZXJ9IFtieV0gQW4gYW1vdW50IHRvIGluY3JlbWVudCB0aGUgZ2l2ZW4gcHJvcGVydHlcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuaW5jcmVtZW50ID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihwcm9wLCBieSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHt9O1xuICAgIHZhciAkYWRkID0ge307XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgXy5lYWNoKHByb3AsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocGFyc2VGbG9hdCh2KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdJbnZhbGlkIGluY3JlbWVudCB2YWx1ZSBwYXNzZWQgdG8gbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCAtIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRhZGRba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGNhbGxiYWNrID0gYnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29udmVuaWVuY2U6IG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQoJ3Byb3BlcnR5Jyk7IHdpbGxcbiAgICAgICAgLy8gaW5jcmVtZW50ICdwcm9wZXJ0eScgYnkgMVxuICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChieSkpIHtcbiAgICAgICAgICAgIGJ5ID0gMTtcbiAgICAgICAgfVxuICAgICAgICAkYWRkW3Byb3BdID0gYnk7XG4gICAgfVxuICAgIGRhdGFbQUREX0FDVElPTl0gPSAkYWRkO1xuXG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiogQXBwZW5kIGEgdmFsdWUgdG8gYSBsaXN0LXZhbHVlZCBwZW9wbGUgYW5hbHl0aWNzIHByb3BlcnR5LlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICAvLyBhcHBlbmQgYSB2YWx1ZSB0byBhIGxpc3QsIGNyZWF0aW5nIGl0IGlmIG5lZWRlZFxuKiAgICAgbWl4cGFuZWwucGVvcGxlLmFwcGVuZCgncGFnZXNfdmlzaXRlZCcsICdob21lcGFnZScpO1xuKlxuKiAgICAgLy8gbGlrZSBtaXhwYW5lbC5wZW9wbGUuc2V0KCksIHlvdSBjYW4gYXBwZW5kIG11bHRpcGxlXG4qICAgICAvLyBwcm9wZXJ0aWVzIGF0IG9uY2U6XG4qICAgICBtaXhwYW5lbC5wZW9wbGUuYXBwZW5kKHtcbiogICAgICAgICBsaXN0MTogJ2JvYicsXG4qICAgICAgICAgbGlzdDI6IDEyM1xuKiAgICAgfSk7XG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbGlzdF9uYW1lIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4qIEBwYXJhbSB7Kn0gW3ZhbHVlXSB2YWx1ZSBBbiBpdGVtIHRvIGFwcGVuZCB0byB0aGUgbGlzdFxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5hcHBlbmQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IHZhbHVlO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRoaXMuYXBwZW5kX2FjdGlvbihsaXN0X25hbWUsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBSZW1vdmUgYSB2YWx1ZSBmcm9tIGEgbGlzdC12YWx1ZWQgcGVvcGxlIGFuYWx5dGljcyBwcm9wZXJ0eS5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnJlbW92ZSgnU2Nob29sJywgJ1VDQicpO1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxpc3RfbmFtZSBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuKiBAcGFyYW0geyp9IFt2YWx1ZV0gdmFsdWUgSXRlbSB0byByZW1vdmUgZnJvbSB0aGUgbGlzdFxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5yZW1vdmUgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IHZhbHVlO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRoaXMucmVtb3ZlX2FjdGlvbihsaXN0X25hbWUsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBNZXJnZSBhIGdpdmVuIGxpc3Qgd2l0aCBhIGxpc3QtdmFsdWVkIHBlb3BsZSBhbmFseXRpY3MgcHJvcGVydHksXG4qIGV4Y2x1ZGluZyBkdXBsaWNhdGUgdmFsdWVzLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICAvLyBtZXJnZSBhIHZhbHVlIHRvIGEgbGlzdCwgY3JlYXRpbmcgaXQgaWYgbmVlZGVkXG4qICAgICBtaXhwYW5lbC5wZW9wbGUudW5pb24oJ3BhZ2VzX3Zpc2l0ZWQnLCAnaG9tZXBhZ2UnKTtcbipcbiogICAgIC8vIGxpa2UgbWl4cGFuZWwucGVvcGxlLnNldCgpLCB5b3UgY2FuIGFwcGVuZCBtdWx0aXBsZVxuKiAgICAgLy8gcHJvcGVydGllcyBhdCBvbmNlOlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuaW9uKHtcbiogICAgICAgICBsaXN0MTogJ2JvYicsXG4qICAgICAgICAgbGlzdDI6IDEyM1xuKiAgICAgfSk7XG4qXG4qICAgICAvLyBsaWtlIG1peHBhbmVsLnBlb3BsZS5hcHBlbmQoKSwgeW91IGNhbiBhcHBlbmQgbXVsdGlwbGVcbiogICAgIC8vIHZhbHVlcyB0byB0aGUgc2FtZSBsaXN0OlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuaW9uKHtcbiogICAgICAgICBsaXN0MTogWydib2InLCAnYmlsbHknXVxuKiAgICAgfSk7XG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbGlzdF9uYW1lIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4qIEBwYXJhbSB7Kn0gW3ZhbHVlXSBWYWx1ZSAvIHZhbHVlcyB0byBtZXJnZSB3aXRoIHRoZSBnaXZlbiBwcm9wZXJ0eVxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS51bmlvbiA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IHZhbHVlcztcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB0aGlzLnVuaW9uX2FjdGlvbihsaXN0X25hbWUsIHZhbHVlcyk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiAqIFJlY29yZCB0aGF0IHlvdSBoYXZlIGNoYXJnZWQgdGhlIGN1cnJlbnQgdXNlciBhIGNlcnRhaW4gYW1vdW50XG4gKiBvZiBtb25leS4gQ2hhcmdlcyByZWNvcmRlZCB3aXRoIHRyYWNrX2NoYXJnZSgpIHdpbGwgYXBwZWFyIGluIHRoZVxuICogTWl4cGFuZWwgcmV2ZW51ZSByZXBvcnQuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyBjaGFyZ2UgYSB1c2VyICQ1MFxuICogICAgIG1peHBhbmVsLnBlb3BsZS50cmFja19jaGFyZ2UoNTApO1xuICpcbiAqICAgICAvLyBjaGFyZ2UgYSB1c2VyICQzMC41MCBvbiB0aGUgMm5kIG9mIGphbnVhcnlcbiAqICAgICBtaXhwYW5lbC5wZW9wbGUudHJhY2tfY2hhcmdlKDMwLjUwLCB7XG4gKiAgICAgICAgICckdGltZSc6IG5ldyBEYXRlKCdqYW4gMSAyMDEyJylcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IFRoZSBhbW91bnQgb2YgbW9uZXkgY2hhcmdlZCB0byB0aGUgY3VycmVudCB1c2VyXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIEFuIGFzc29jaWF0aXZlIGFycmF5IG9mIHByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGFyZ2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBzZXJ2ZXIgcmVzcG9uZHNcbiAqIEBkZXByZWNhdGVkXG4gKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS50cmFja19jaGFyZ2UgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUkMS5lcnJvcignbWl4cGFuZWwucGVvcGxlLnRyYWNrX2NoYXJnZSgpIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBoYXMgYW55IGVmZmVjdC4nKTtcbn0pO1xuXG4vKlxuICogUGVybWFuZW50bHkgY2xlYXIgYWxsIHJldmVudWUgcmVwb3J0IHRyYW5zYWN0aW9ucyBmcm9tIHRoZVxuICogY3VycmVudCB1c2VyJ3MgcGVvcGxlIGFuYWx5dGljcyBwcm9maWxlLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwucGVvcGxlLmNsZWFyX2NoYXJnZXMoKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmNsZWFyX2NoYXJnZXMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnNldCgnJHRyYW5zYWN0aW9ucycsIFtdLCBjYWxsYmFjayk7XG59O1xuXG4vKlxuKiBQZXJtYW5lbnRseSBkZWxldGVzIHRoZSBjdXJyZW50IHBlb3BsZSBhbmFseXRpY3MgcHJvZmlsZSBmcm9tXG4qIE1peHBhbmVsICh1c2luZyB0aGUgY3VycmVudCBkaXN0aW5jdF9pZCkuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIC8vIHJlbW92ZSB0aGUgYWxsIGRhdGEgeW91IGhhdmUgc3RvcmVkIGFib3V0IHRoZSBjdXJyZW50IHVzZXJcbiogICAgIG1peHBhbmVsLnBlb3BsZS5kZWxldGVfdXNlcigpO1xuKlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5kZWxldGVfdXNlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5faWRlbnRpZnlfY2FsbGVkKCkpIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKCdtaXhwYW5lbC5wZW9wbGUuZGVsZXRlX3VzZXIoKSByZXF1aXJlcyB5b3UgdG8gY2FsbCBpZGVudGlmeSgpIGZpcnN0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB7JyRkZWxldGUnOiB0aGlzLl9taXhwYW5lbC5nZXRfZGlzdGluY3RfaWQoKX07XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhKTtcbn07XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC50b1N0cmluZygpICsgJy5wZW9wbGUnO1xufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9zZW5kX3JlcXVlc3QgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICAgIGRhdGFbJyR0b2tlbiddID0gdGhpcy5fZ2V0X2NvbmZpZygndG9rZW4nKTtcbiAgICBkYXRhWyckZGlzdGluY3RfaWQnXSA9IHRoaXMuX21peHBhbmVsLmdldF9kaXN0aW5jdF9pZCgpO1xuICAgIHZhciBkZXZpY2VfaWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfcHJvcGVydHkoJyRkZXZpY2VfaWQnKTtcbiAgICB2YXIgdXNlcl9pZCA9IHRoaXMuX21peHBhbmVsLmdldF9wcm9wZXJ0eSgnJHVzZXJfaWQnKTtcbiAgICB2YXIgaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCA9IHRoaXMuX21peHBhbmVsLmdldF9wcm9wZXJ0eSgnJGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQnKTtcbiAgICBpZiAoZGV2aWNlX2lkKSB7XG4gICAgICAgIGRhdGFbJyRkZXZpY2VfaWQnXSA9IGRldmljZV9pZDtcbiAgICB9XG4gICAgaWYgKHVzZXJfaWQpIHtcbiAgICAgICAgZGF0YVsnJHVzZXJfaWQnXSA9IHVzZXJfaWQ7XG4gICAgfVxuICAgIGlmIChoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkKSB7XG4gICAgICAgIGRhdGFbJyRoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkJ10gPSBoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkO1xuICAgIH1cblxuICAgIHZhciBkYXRlX2VuY29kZWRfZGF0YSA9IF8uZW5jb2RlRGF0ZXMoZGF0YSk7XG5cbiAgICBpZiAoIXRoaXMuX2lkZW50aWZ5X2NhbGxlZCgpKSB7XG4gICAgICAgIHRoaXMuX2VucXVldWUoZGF0YSk7XG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRfY29uZmlnKCd2ZXJib3NlJykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh7c3RhdHVzOiAtMSwgZXJyb3I6IG51bGx9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfLnRydW5jYXRlKGRhdGVfZW5jb2RlZF9kYXRhLCAyNTUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC5fdHJhY2tfb3JfYmF0Y2goe1xuICAgICAgICB0eXBlOiAncGVvcGxlJyxcbiAgICAgICAgZGF0YTogZGF0ZV9lbmNvZGVkX2RhdGEsXG4gICAgICAgIGVuZHBvaW50OiB0aGlzLl9nZXRfY29uZmlnKCdhcGlfaG9zdCcpICsgJy8nICsgIHRoaXMuX2dldF9jb25maWcoJ2FwaV9yb3V0ZXMnKVsnZW5nYWdlJ10sXG4gICAgICAgIGJhdGNoZXI6IHRoaXMuX21peHBhbmVsLnJlcXVlc3RfYmF0Y2hlcnMucGVvcGxlXG4gICAgfSwgY2FsbGJhY2spO1xufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9nZXRfY29uZmlnID0gZnVuY3Rpb24oY29uZl92YXIpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuZ2V0X2NvbmZpZyhjb25mX3Zhcik7XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2lkZW50aWZ5X2NhbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC5fZmxhZ3MuaWRlbnRpZnlfY2FsbGVkID09PSB0cnVlO1xufTtcblxuLy8gUXVldWUgdXAgZW5nYWdlIG9wZXJhdGlvbnMgaWYgaWRlbnRpZnkgaGFzbid0IGJlZW4gY2FsbGVkIHlldC5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5fZW5xdWV1ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAoU0VUX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFNFVF9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoU0VUX09OQ0VfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoU0VUX09OQ0VfQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKFVOU0VUX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFVOU0VUX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChBRERfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoQUREX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChBUFBFTkRfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoQVBQRU5EX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChSRU1PVkVfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoUkVNT1ZFX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChVTklPTl9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShVTklPTl9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignSW52YWxpZCBjYWxsIHRvIF9lbnF1ZXVlKCk6JywgZGF0YSk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9mbHVzaF9vbmVfcXVldWUgPSBmdW5jdGlvbihhY3Rpb24sIGFjdGlvbl9tZXRob2QsIGNhbGxiYWNrLCBxdWV1ZV90b19wYXJhbXNfZm4pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBxdWV1ZWRfZGF0YSA9IF8uZXh0ZW5kKHt9LCB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5sb2FkX3F1ZXVlKGFjdGlvbikpO1xuICAgIHZhciBhY3Rpb25fcGFyYW1zID0gcXVldWVkX2RhdGE7XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocXVldWVkX2RhdGEpICYmIF8uaXNPYmplY3QocXVldWVkX2RhdGEpICYmICFfLmlzRW1wdHlPYmplY3QocXVldWVkX2RhdGEpKSB7XG4gICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKGFjdGlvbiwgcXVldWVkX2RhdGEpO1xuICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uc2F2ZSgpO1xuICAgICAgICBpZiAocXVldWVfdG9fcGFyYW1zX2ZuKSB7XG4gICAgICAgICAgICBhY3Rpb25fcGFyYW1zID0gcXVldWVfdG9fcGFyYW1zX2ZuKHF1ZXVlZF9kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBhY3Rpb25fbWV0aG9kLmNhbGwoX3RoaXMsIGFjdGlvbl9wYXJhbXMsIGZ1bmN0aW9uKHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgICAgICAgICAvLyBvbiBiYWQgcmVzcG9uc2UsIHdlIHdhbnQgdG8gYWRkIGl0IGJhY2sgdG8gdGhlIHF1ZXVlXG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoYWN0aW9uLCBxdWV1ZWRfZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vLyBGbHVzaCBxdWV1ZWQgZW5nYWdlIG9wZXJhdGlvbnMgLSBvcmRlciBkb2VzIG5vdCBtYXR0ZXIsXG4vLyBhbmQgdGhlcmUgYXJlIG5ldHdvcmsgbGV2ZWwgcmFjZSBjb25kaXRpb25zIGFueXdheVxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uKFxuICAgIF9zZXRfY2FsbGJhY2ssIF9hZGRfY2FsbGJhY2ssIF9hcHBlbmRfY2FsbGJhY2ssIF9zZXRfb25jZV9jYWxsYmFjaywgX3VuaW9uX2NhbGxiYWNrLCBfdW5zZXRfY2FsbGJhY2ssIF9yZW1vdmVfY2FsbGJhY2tcbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9mbHVzaF9vbmVfcXVldWUoU0VUX0FDVElPTiwgdGhpcy5zZXQsIF9zZXRfY2FsbGJhY2spO1xuICAgIHRoaXMuX2ZsdXNoX29uZV9xdWV1ZShTRVRfT05DRV9BQ1RJT04sIHRoaXMuc2V0X29uY2UsIF9zZXRfb25jZV9jYWxsYmFjayk7XG4gICAgdGhpcy5fZmx1c2hfb25lX3F1ZXVlKFVOU0VUX0FDVElPTiwgdGhpcy51bnNldCwgX3Vuc2V0X2NhbGxiYWNrLCBmdW5jdGlvbihxdWV1ZSkgeyByZXR1cm4gXy5rZXlzKHF1ZXVlKTsgfSk7XG4gICAgdGhpcy5fZmx1c2hfb25lX3F1ZXVlKEFERF9BQ1RJT04sIHRoaXMuaW5jcmVtZW50LCBfYWRkX2NhbGxiYWNrKTtcbiAgICB0aGlzLl9mbHVzaF9vbmVfcXVldWUoVU5JT05fQUNUSU9OLCB0aGlzLnVuaW9uLCBfdW5pb25fY2FsbGJhY2spO1xuXG4gICAgLy8gd2UgaGF2ZSB0byBmaXJlIG9mZiBlYWNoICRhcHBlbmQgaW5kaXZpZHVhbGx5IHNpbmNlIHRoZXJlIGlzXG4gICAgLy8gbm8gY29uY2F0IG1ldGhvZCBzZXJ2ZXIgc2lkZVxuICAgIHZhciAkYXBwZW5kX3F1ZXVlID0gdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10ubG9hZF9xdWV1ZShBUFBFTkRfQUNUSU9OKTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoJGFwcGVuZF9xdWV1ZSkgJiYgXy5pc0FycmF5KCRhcHBlbmRfcXVldWUpICYmICRhcHBlbmRfcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciAkYXBwZW5kX2l0ZW07XG4gICAgICAgIHZhciBhcHBlbmRfY2FsbGJhY2sgPSBmdW5jdGlvbihyZXNwb25zZSwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKEFQUEVORF9BQ1RJT04sICRhcHBlbmRfaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoX2FwcGVuZF9jYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICBfYXBwZW5kX2NhbGxiYWNrKHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9ICRhcHBlbmRfcXVldWUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICRhcHBlbmRfcXVldWUgPSB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5sb2FkX3F1ZXVlKEFQUEVORF9BQ1RJT04pO1xuICAgICAgICAgICAgJGFwcGVuZF9pdGVtID0gJGFwcGVuZF9xdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5zYXZlKCk7XG4gICAgICAgICAgICBpZiAoIV8uaXNFbXB0eU9iamVjdCgkYXBwZW5kX2l0ZW0pKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYXBwZW5kKCRhcHBlbmRfaXRlbSwgYXBwZW5kX2NhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNhbWUgZm9yICRyZW1vdmVcbiAgICB2YXIgJHJlbW92ZV9xdWV1ZSA9IHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLmxvYWRfcXVldWUoUkVNT1ZFX0FDVElPTik7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKCRyZW1vdmVfcXVldWUpICYmIF8uaXNBcnJheSgkcmVtb3ZlX3F1ZXVlKSAmJiAkcmVtb3ZlX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgJHJlbW92ZV9pdGVtO1xuICAgICAgICB2YXIgcmVtb3ZlX2NhbGxiYWNrID0gZnVuY3Rpb24ocmVzcG9uc2UsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShSRU1PVkVfQUNUSU9OLCAkcmVtb3ZlX2l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKF9yZW1vdmVfY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgX3JlbW92ZV9jYWxsYmFjayhyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGogPSAkcmVtb3ZlX3F1ZXVlLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAkcmVtb3ZlX3F1ZXVlID0gdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10ubG9hZF9xdWV1ZShSRU1PVkVfQUNUSU9OKTtcbiAgICAgICAgICAgICRyZW1vdmVfaXRlbSA9ICRyZW1vdmVfcXVldWUucG9wKCk7XG4gICAgICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uc2F2ZSgpO1xuICAgICAgICAgICAgaWYgKCFfLmlzRW1wdHlPYmplY3QoJHJlbW92ZV9pdGVtKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZSgkcmVtb3ZlX2l0ZW0sIHJlbW92ZV9jYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2lzX3Jlc2VydmVkX3Byb3BlcnR5ID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiBwcm9wID09PSAnJGRpc3RpbmN0X2lkJyB8fCBwcm9wID09PSAnJHRva2VuJyB8fCBwcm9wID09PSAnJGRldmljZV9pZCcgfHwgcHJvcCA9PT0gJyR1c2VyX2lkJyB8fCBwcm9wID09PSAnJGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQnO1xufTtcblxuLy8gTWl4cGFuZWxQZW9wbGUgRXhwb3J0c1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydzZXQnXSAgICAgICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuc2V0O1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydzZXRfb25jZSddICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuc2V0X29uY2U7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3Vuc2V0J10gICAgICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS51bnNldDtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnaW5jcmVtZW50J10gICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmluY3JlbWVudDtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnYXBwZW5kJ10gICAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmFwcGVuZDtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsncmVtb3ZlJ10gICAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnJlbW92ZTtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsndW5pb24nXSAgICAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnVuaW9uO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWyd0cmFja19jaGFyZ2UnXSAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudHJhY2tfY2hhcmdlO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydjbGVhcl9jaGFyZ2VzJ10gPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuY2xlYXJfY2hhcmdlcztcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnZGVsZXRlX3VzZXInXSAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmRlbGV0ZV91c2VyO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWyd0b1N0cmluZyddICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuXG4vKlxuICogQ29uc3RhbnRzXG4gKi9cbi8qKiBAY29uc3QgKi8gdmFyIFNFVF9RVUVVRV9LRVkgICAgICAgICAgPSAnX19tcHMnO1xuLyoqIEBjb25zdCAqLyB2YXIgU0VUX09OQ0VfUVVFVUVfS0VZICAgICA9ICdfX21wc28nO1xuLyoqIEBjb25zdCAqLyB2YXIgVU5TRVRfUVVFVUVfS0VZICAgICAgICA9ICdfX21wdXMnO1xuLyoqIEBjb25zdCAqLyB2YXIgQUREX1FVRVVFX0tFWSAgICAgICAgICA9ICdfX21wYSc7XG4vKiogQGNvbnN0ICovIHZhciBBUFBFTkRfUVVFVUVfS0VZICAgICAgID0gJ19fbXBhcCc7XG4vKiogQGNvbnN0ICovIHZhciBSRU1PVkVfUVVFVUVfS0VZICAgICAgID0gJ19fbXByJztcbi8qKiBAY29uc3QgKi8gdmFyIFVOSU9OX1FVRVVFX0tFWSAgICAgICAgPSAnX19tcHUnO1xuLy8gVGhpcyBrZXkgaXMgZGVwcmVjYXRlZCwgYnV0IHdlIHdhbnQgdG8gY2hlY2sgZm9yIGl0IHRvIHNlZSB3aGV0aGVyIGFsaWFzaW5nIGlzIGFsbG93ZWQuXG4vKiogQGNvbnN0ICovIHZhciBQRU9QTEVfRElTVElOQ1RfSURfS0VZID0gJyRwZW9wbGVfZGlzdGluY3RfaWQnO1xuLyoqIEBjb25zdCAqLyB2YXIgQUxJQVNfSURfS0VZICAgICAgICAgICA9ICdfX2FsaWFzJztcbi8qKiBAY29uc3QgKi8gdmFyIEVWRU5UX1RJTUVSU19LRVkgICAgICAgPSAnX190aW1lcnMnO1xuLyoqIEBjb25zdCAqLyB2YXIgUkVTRVJWRURfUFJPUEVSVElFUyA9IFtcbiAgICBTRVRfUVVFVUVfS0VZLFxuICAgIFNFVF9PTkNFX1FVRVVFX0tFWSxcbiAgICBVTlNFVF9RVUVVRV9LRVksXG4gICAgQUREX1FVRVVFX0tFWSxcbiAgICBBUFBFTkRfUVVFVUVfS0VZLFxuICAgIFJFTU9WRV9RVUVVRV9LRVksXG4gICAgVU5JT05fUVVFVUVfS0VZLFxuICAgIFBFT1BMRV9ESVNUSU5DVF9JRF9LRVksXG4gICAgQUxJQVNfSURfS0VZLFxuICAgIEVWRU5UX1RJTUVSU19LRVlcbl07XG5cbi8qKlxuICogTWl4cGFuZWwgUGVyc2lzdGVuY2UgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE1peHBhbmVsUGVyc2lzdGVuY2UgPSBmdW5jdGlvbihjb25maWcpIHtcbiAgICB0aGlzWydwcm9wcyddID0ge307XG4gICAgdGhpcy5jYW1wYWlnbl9wYXJhbXNfc2F2ZWQgPSBmYWxzZTtcblxuICAgIGlmIChjb25maWdbJ3BlcnNpc3RlbmNlX25hbWUnXSkge1xuICAgICAgICB0aGlzLm5hbWUgPSAnbXBfJyArIGNvbmZpZ1sncGVyc2lzdGVuY2VfbmFtZSddO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubmFtZSA9ICdtcF8nICsgY29uZmlnWyd0b2tlbiddICsgJ19taXhwYW5lbCc7XG4gICAgfVxuXG4gICAgdmFyIHN0b3JhZ2VfdHlwZSA9IGNvbmZpZ1sncGVyc2lzdGVuY2UnXTtcbiAgICBpZiAoc3RvcmFnZV90eXBlICE9PSAnY29va2llJyAmJiBzdG9yYWdlX3R5cGUgIT09ICdsb2NhbFN0b3JhZ2UnKSB7XG4gICAgICAgIGNvbnNvbGUkMS5jcml0aWNhbCgnVW5rbm93biBwZXJzaXN0ZW5jZSB0eXBlICcgKyBzdG9yYWdlX3R5cGUgKyAnOyBmYWxsaW5nIGJhY2sgdG8gY29va2llJyk7XG4gICAgICAgIHN0b3JhZ2VfdHlwZSA9IGNvbmZpZ1sncGVyc2lzdGVuY2UnXSA9ICdjb29raWUnO1xuICAgIH1cblxuICAgIGlmIChzdG9yYWdlX3R5cGUgPT09ICdsb2NhbFN0b3JhZ2UnICYmIF8ubG9jYWxTdG9yYWdlLmlzX3N1cHBvcnRlZCgpKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IF8ubG9jYWxTdG9yYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IF8uY29va2llO1xuICAgIH1cblxuICAgIHRoaXMubG9hZCgpO1xuICAgIHRoaXMudXBkYXRlX2NvbmZpZyhjb25maWcpO1xuICAgIHRoaXMudXBncmFkZSgpO1xuICAgIHRoaXMuc2F2ZSgpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucHJvcGVydGllcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwID0ge307XG5cbiAgICB0aGlzLmxvYWQoKTtcblxuICAgIC8vIEZpbHRlciBvdXQgcmVzZXJ2ZWQgcHJvcGVydGllc1xuICAgIF8uZWFjaCh0aGlzWydwcm9wcyddLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgIGlmICghXy5pbmNsdWRlKFJFU0VSVkVEX1BST1BFUlRJRVMsIGspKSB7XG4gICAgICAgICAgICBwW2tdID0gdjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxuXG4gICAgdmFyIGVudHJ5ID0gdGhpcy5zdG9yYWdlLnBhcnNlKHRoaXMubmFtZSk7XG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgdGhpc1sncHJvcHMnXSA9IF8uZXh0ZW5kKHt9LCBlbnRyeSk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBncmFkZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvbGRfY29va2llLFxuICAgICAgICBvbGRfbG9jYWxzdG9yYWdlO1xuXG4gICAgLy8gaWYgdHJhbnNmZXJyaW5nIGZyb20gY29va2llIHRvIGxvY2FsU3RvcmFnZSBvciB2aWNlLXZlcnNhLCBjb3B5IGV4aXN0aW5nXG4gICAgLy8gc3VwZXIgcHJvcGVydGllcyBvdmVyIHRvIG5ldyBzdG9yYWdlIG1vZGVcbiAgICBpZiAodGhpcy5zdG9yYWdlID09PSBfLmxvY2FsU3RvcmFnZSkge1xuICAgICAgICBvbGRfY29va2llID0gXy5jb29raWUucGFyc2UodGhpcy5uYW1lKTtcblxuICAgICAgICBfLmNvb2tpZS5yZW1vdmUodGhpcy5uYW1lKTtcbiAgICAgICAgXy5jb29raWUucmVtb3ZlKHRoaXMubmFtZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKG9sZF9jb29raWUpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJfb25jZShvbGRfY29va2llKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5zdG9yYWdlID09PSBfLmNvb2tpZSkge1xuICAgICAgICBvbGRfbG9jYWxzdG9yYWdlID0gXy5sb2NhbFN0b3JhZ2UucGFyc2UodGhpcy5uYW1lKTtcblxuICAgICAgICBfLmxvY2FsU3RvcmFnZS5yZW1vdmUodGhpcy5uYW1lKTtcblxuICAgICAgICBpZiAob2xkX2xvY2Fsc3RvcmFnZSkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcl9vbmNlKG9sZF9sb2NhbHN0b3JhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7IHJldHVybjsgfVxuXG4gICAgdGhpcy5zdG9yYWdlLnNldChcbiAgICAgICAgdGhpcy5uYW1lLFxuICAgICAgICBKU09OU3RyaW5naWZ5KHRoaXNbJ3Byb3BzJ10pLFxuICAgICAgICB0aGlzLmV4cGlyZV9kYXlzLFxuICAgICAgICB0aGlzLmNyb3NzX3N1YmRvbWFpbixcbiAgICAgICAgdGhpcy5zZWN1cmUsXG4gICAgICAgIHRoaXMuY3Jvc3Nfc2l0ZSxcbiAgICAgICAgdGhpcy5jb29raWVfZG9tYWluXG4gICAgKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmxvYWRfcHJvcCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHRoaXMubG9hZCgpO1xuICAgIHJldHVybiB0aGlzWydwcm9wcyddW2tleV07XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAvLyByZW1vdmUgYm90aCBkb21haW4gYW5kIHN1YmRvbWFpbiBjb29raWVzXG4gICAgdGhpcy5zdG9yYWdlLnJlbW92ZSh0aGlzLm5hbWUsIGZhbHNlLCB0aGlzLmNvb2tpZV9kb21haW4pO1xuICAgIHRoaXMuc3RvcmFnZS5yZW1vdmUodGhpcy5uYW1lLCB0cnVlLCB0aGlzLmNvb2tpZV9kb21haW4pO1xufTtcblxuLy8gcmVtb3ZlcyB0aGUgc3RvcmFnZSBlbnRyeSBhbmQgZGVsZXRlcyBhbGwgbG9hZGVkIGRhdGFcbi8vIGZvcmNlZCBuYW1lIGZvciB0ZXN0c1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZSgpO1xuICAgIHRoaXNbJ3Byb3BzJ10gPSB7fTtcbn07XG5cbi8qKlxuKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiogQHBhcmFtIHsqPX0gZGVmYXVsdF92YWx1ZVxuKiBAcGFyYW0ge251bWJlcj19IGRheXNcbiovXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5yZWdpc3Rlcl9vbmNlID0gZnVuY3Rpb24ocHJvcHMsIGRlZmF1bHRfdmFsdWUsIGRheXMpIHtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wcykpIHtcbiAgICAgICAgaWYgKHR5cGVvZihkZWZhdWx0X3ZhbHVlKSA9PT0gJ3VuZGVmaW5lZCcpIHsgZGVmYXVsdF92YWx1ZSA9ICdOb25lJzsgfVxuICAgICAgICB0aGlzLmV4cGlyZV9kYXlzID0gKHR5cGVvZihkYXlzKSA9PT0gJ3VuZGVmaW5lZCcpID8gdGhpcy5kZWZhdWx0X2V4cGlyeSA6IGRheXM7XG5cbiAgICAgICAgdGhpcy5sb2FkKCk7XG5cbiAgICAgICAgXy5lYWNoKHByb3BzLCBmdW5jdGlvbih2YWwsIHByb3ApIHtcbiAgICAgICAgICAgIGlmICghdGhpc1sncHJvcHMnXS5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCB0aGlzWydwcm9wcyddW3Byb3BdID09PSBkZWZhdWx0X3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpc1sncHJvcHMnXVtwcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5zYXZlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiogQHBhcmFtIHtudW1iZXI9fSBkYXlzXG4qL1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbihwcm9wcywgZGF5cykge1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3BzKSkge1xuICAgICAgICB0aGlzLmV4cGlyZV9kYXlzID0gKHR5cGVvZihkYXlzKSA9PT0gJ3VuZGVmaW5lZCcpID8gdGhpcy5kZWZhdWx0X2V4cGlyeSA6IGRheXM7XG5cbiAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgIF8uZXh0ZW5kKHRoaXNbJ3Byb3BzJ10sIHByb3BzKTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgdGhpcy5sb2FkKCk7XG4gICAgaWYgKHByb3AgaW4gdGhpc1sncHJvcHMnXSkge1xuICAgICAgICBkZWxldGUgdGhpc1sncHJvcHMnXVtwcm9wXTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX3NlYXJjaF9rZXl3b3JkID0gZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICB0aGlzLnJlZ2lzdGVyKF8uaW5mby5zZWFyY2hJbmZvKHJlZmVycmVyKSk7XG59O1xuXG4vLyBFWFBPUlRFRCBNRVRIT0QsIHdlIHRlc3QgdGhpcyBkaXJlY3RseS5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9yZWZlcnJlcl9pbmZvID0gZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICAvLyBJZiByZWZlcnJlciBkb2Vzbid0IGV4aXN0LCB3ZSB3YW50IHRvIG5vdGUgdGhlIGZhY3QgdGhhdCBpdCB3YXMgdHlwZS1pbiB0cmFmZmljLlxuICAgIHRoaXMucmVnaXN0ZXJfb25jZSh7XG4gICAgICAgICckaW5pdGlhbF9yZWZlcnJlcic6IHJlZmVycmVyIHx8ICckZGlyZWN0JyxcbiAgICAgICAgJyRpbml0aWFsX3JlZmVycmluZ19kb21haW4nOiBfLmluZm8ucmVmZXJyaW5nRG9tYWluKHJlZmVycmVyKSB8fCAnJGRpcmVjdCdcbiAgICB9LCAnJyk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5nZXRfcmVmZXJyZXJfaW5mbyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMoe1xuICAgICAgICAnJGluaXRpYWxfcmVmZXJyZXInOiB0aGlzWydwcm9wcyddWyckaW5pdGlhbF9yZWZlcnJlciddLFxuICAgICAgICAnJGluaXRpYWxfcmVmZXJyaW5nX2RvbWFpbic6IHRoaXNbJ3Byb3BzJ11bJyRpbml0aWFsX3JlZmVycmluZ19kb21haW4nXVxuICAgIH0pO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuZGVmYXVsdF9leHBpcnkgPSB0aGlzLmV4cGlyZV9kYXlzID0gY29uZmlnWydjb29raWVfZXhwaXJhdGlvbiddO1xuICAgIHRoaXMuc2V0X2Rpc2FibGVkKGNvbmZpZ1snZGlzYWJsZV9wZXJzaXN0ZW5jZSddKTtcbiAgICB0aGlzLnNldF9jb29raWVfZG9tYWluKGNvbmZpZ1snY29va2llX2RvbWFpbiddKTtcbiAgICB0aGlzLnNldF9jcm9zc19zaXRlKGNvbmZpZ1snY3Jvc3Nfc2l0ZV9jb29raWUnXSk7XG4gICAgdGhpcy5zZXRfY3Jvc3Nfc3ViZG9tYWluKGNvbmZpZ1snY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZSddKTtcbiAgICB0aGlzLnNldF9zZWN1cmUoY29uZmlnWydzZWN1cmVfY29va2llJ10pO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2Rpc2FibGVkID0gZnVuY3Rpb24oZGlzYWJsZWQpIHtcbiAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zZXRfY29va2llX2RvbWFpbiA9IGZ1bmN0aW9uKGNvb2tpZV9kb21haW4pIHtcbiAgICBpZiAoY29va2llX2RvbWFpbiAhPT0gdGhpcy5jb29raWVfZG9tYWluKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuY29va2llX2RvbWFpbiA9IGNvb2tpZV9kb21haW47XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNldF9jcm9zc19zaXRlID0gZnVuY3Rpb24oY3Jvc3Nfc2l0ZSkge1xuICAgIGlmIChjcm9zc19zaXRlICE9PSB0aGlzLmNyb3NzX3NpdGUpIHtcbiAgICAgICAgdGhpcy5jcm9zc19zaXRlID0gY3Jvc3Nfc2l0ZTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2Nyb3NzX3N1YmRvbWFpbiA9IGZ1bmN0aW9uKGNyb3NzX3N1YmRvbWFpbikge1xuICAgIGlmIChjcm9zc19zdWJkb21haW4gIT09IHRoaXMuY3Jvc3Nfc3ViZG9tYWluKSB7XG4gICAgICAgIHRoaXMuY3Jvc3Nfc3ViZG9tYWluID0gY3Jvc3Nfc3ViZG9tYWluO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5nZXRfY3Jvc3Nfc3ViZG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY3Jvc3Nfc3ViZG9tYWluO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X3NlY3VyZSA9IGZ1bmN0aW9uKHNlY3VyZSkge1xuICAgIGlmIChzZWN1cmUgIT09IHRoaXMuc2VjdXJlKSB7XG4gICAgICAgIHRoaXMuc2VjdXJlID0gc2VjdXJlID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5fYWRkX3RvX3Blb3BsZV9xdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBkYXRhKSB7XG4gICAgdmFyIHFfa2V5ID0gdGhpcy5fZ2V0X3F1ZXVlX2tleShxdWV1ZSksXG4gICAgICAgIHFfZGF0YSA9IGRhdGFbcXVldWVdLFxuICAgICAgICBzZXRfcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoU0VUX0FDVElPTiksXG4gICAgICAgIHNldF9vbmNlX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFNFVF9PTkNFX0FDVElPTiksXG4gICAgICAgIHVuc2V0X3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFVOU0VUX0FDVElPTiksXG4gICAgICAgIGFkZF9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShBRERfQUNUSU9OKSxcbiAgICAgICAgdW5pb25fcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoVU5JT05fQUNUSU9OKSxcbiAgICAgICAgcmVtb3ZlX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFJFTU9WRV9BQ1RJT04sIFtdKSxcbiAgICAgICAgYXBwZW5kX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKEFQUEVORF9BQ1RJT04sIFtdKTtcblxuICAgIGlmIChxX2tleSA9PT0gU0VUX1FVRVVFX0tFWSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHNldCBxdWV1ZSAtIHdlIGNhbiBvdmVycmlkZSBhbnkgZXhpc3RpbmcgdmFsdWVzXG4gICAgICAgIF8uZXh0ZW5kKHNldF9xLCBxX2RhdGEpO1xuICAgICAgICAvLyBpZiB0aGVyZSB3YXMgYSBwZW5kaW5nIGluY3JlbWVudCwgb3ZlcnJpZGUgaXRcbiAgICAgICAgLy8gd2l0aCB0aGUgc2V0LlxuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoQUREX0FDVElPTiwgcV9kYXRhKTtcbiAgICAgICAgLy8gaWYgdGhlcmUgd2FzIGEgcGVuZGluZyB1bmlvbiwgb3ZlcnJpZGUgaXRcbiAgICAgICAgLy8gd2l0aCB0aGUgc2V0LlxuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5JT05fQUNUSU9OLCBxX2RhdGEpO1xuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5TRVRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IFNFVF9PTkNFX1FVRVVFX0tFWSkge1xuICAgICAgICAvLyBvbmx5IHF1ZXVlIHRoZSBkYXRhIGlmIHRoZXJlIGlzIG5vdCBhbHJlYWR5IGEgc2V0X29uY2UgY2FsbCBmb3IgaXQuXG4gICAgICAgIF8uZWFjaChxX2RhdGEsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIGlmICghKGsgaW4gc2V0X29uY2VfcSkpIHtcbiAgICAgICAgICAgICAgICBzZXRfb25jZV9xW2tdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gVU5TRVRfUVVFVUVfS0VZKSB7XG4gICAgICAgIF8uZWFjaChxX2RhdGEsIGZ1bmN0aW9uKHByb3ApIHtcblxuICAgICAgICAgICAgLy8gdW5kbyBwcmV2aW91c2x5LXF1ZXVlZCBhY3Rpb25zIG9uIHRoaXMga2V5XG4gICAgICAgICAgICBfLmVhY2goW3NldF9xLCBzZXRfb25jZV9xLCBhZGRfcSwgdW5pb25fcV0sIGZ1bmN0aW9uKGVucXVldWVkX29iaikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wIGluIGVucXVldWVkX29iaikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZW5xdWV1ZWRfb2JqW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXy5lYWNoKGFwcGVuZF9xLCBmdW5jdGlvbihhcHBlbmRfb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgaW4gYXBwZW5kX29iaikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXBwZW5kX29ialtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdW5zZXRfcVtwcm9wXSA9IHRydWU7XG5cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gQUREX1FVRVVFX0tFWSkge1xuICAgICAgICBfLmVhY2gocV9kYXRhLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBleGlzdHMgaW4gdGhlIHNldCBxdWV1ZSwgaW5jcmVtZW50XG4gICAgICAgICAgICAvLyB0aGUgdmFsdWVcbiAgICAgICAgICAgIGlmIChrIGluIHNldF9xKSB7XG4gICAgICAgICAgICAgICAgc2V0X3Fba10gKz0gdjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgZG9lc24ndCBleGlzdCwgdXBkYXRlIHRoZSBhZGRcbiAgICAgICAgICAgICAgICAvLyBxdWV1ZVxuICAgICAgICAgICAgICAgIGlmICghKGsgaW4gYWRkX3EpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZF9xW2tdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkX3Fba10gKz0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gVU5JT05fUVVFVUVfS0VZKSB7XG4gICAgICAgIF8uZWFjaChxX2RhdGEsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrIGluIHVuaW9uX3EpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaW9uX3Fba10gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBkdXBsaWNhdGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgXy5lYWNoKHYsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfLmluY2x1ZGUodW5pb25fcVtrXSwgaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaW9uX3Fba10ucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKFVOU0VUX0FDVElPTiwgcV9kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHFfa2V5ID09PSBSRU1PVkVfUVVFVUVfS0VZKSB7XG4gICAgICAgIHJlbW92ZV9xLnB1c2gocV9kYXRhKTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKEFQUEVORF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gQVBQRU5EX1FVRVVFX0tFWSkge1xuICAgICAgICBhcHBlbmRfcS5wdXNoKHFfZGF0YSk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfVxuXG4gICAgY29uc29sZSQxLmxvZygnTUlYUEFORUwgUEVPUExFIFJFUVVFU1QgKFFVRVVFRCwgUEVORElORyBJREVOVElGWSk6Jyk7XG4gICAgY29uc29sZSQxLmxvZyhkYXRhKTtcblxuICAgIHRoaXMuc2F2ZSgpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBkYXRhKSB7XG4gICAgdmFyIHEgPSB0aGlzWydwcm9wcyddW3RoaXMuX2dldF9xdWV1ZV9rZXkocXVldWUpXTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocSkpIHtcbiAgICAgICAgXy5lYWNoKGRhdGEsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIGlmIChxdWV1ZSA9PT0gQVBQRU5EX0FDVElPTiB8fCBxdWV1ZSA9PT0gUkVNT1ZFX0FDVElPTikge1xuICAgICAgICAgICAgICAgIC8vIGxpc3QgYWN0aW9uczogb25seSByZW1vdmUgaWYgYm90aCBrK3YgbWF0Y2hcbiAgICAgICAgICAgICAgICAvLyBlLmcuIHJlbW92ZSBzaG91bGQgbm90IG92ZXJyaWRlIGFwcGVuZCBpbiBhIGNhc2UgbGlrZVxuICAgICAgICAgICAgICAgIC8vIGFwcGVuZCh7Zm9vOiAnYmFyJ30pOyByZW1vdmUoe2ZvbzogJ3F1eCd9KVxuICAgICAgICAgICAgICAgIF8uZWFjaChxLCBmdW5jdGlvbihxdWV1ZWRfYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZWRfYWN0aW9uW2tdID09PSB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcXVldWVkX2FjdGlvbltrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUubG9hZF9xdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZF9wcm9wKHRoaXMuX2dldF9xdWV1ZV9rZXkocXVldWUpKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLl9nZXRfcXVldWVfa2V5ID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgICBpZiAocXVldWUgPT09IFNFVF9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIFNFVF9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gU0VUX09OQ0VfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBTRVRfT05DRV9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gVU5TRVRfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBVTlNFVF9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gQUREX0FDVElPTikge1xuICAgICAgICByZXR1cm4gQUREX1FVRVVFX0tFWTtcbiAgICB9IGVsc2UgaWYgKHF1ZXVlID09PSBBUFBFTkRfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBBUFBFTkRfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IFJFTU9WRV9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIFJFTU9WRV9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gVU5JT05fQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBVTklPTl9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKCdJbnZhbGlkIHF1ZXVlOicsIHF1ZXVlKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5fZ2V0X29yX2NyZWF0ZV9xdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBkZWZhdWx0X3ZhbCkge1xuICAgIHZhciBrZXkgPSB0aGlzLl9nZXRfcXVldWVfa2V5KHF1ZXVlKTtcbiAgICBkZWZhdWx0X3ZhbCA9IF8uaXNVbmRlZmluZWQoZGVmYXVsdF92YWwpID8ge30gOiBkZWZhdWx0X3ZhbDtcbiAgICByZXR1cm4gdGhpc1sncHJvcHMnXVtrZXldIHx8ICh0aGlzWydwcm9wcyddW2tleV0gPSBkZWZhdWx0X3ZhbCk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zZXRfZXZlbnRfdGltZXIgPSBmdW5jdGlvbihldmVudF9uYW1lLCB0aW1lc3RhbXApIHtcbiAgICB2YXIgdGltZXJzID0gdGhpcy5sb2FkX3Byb3AoRVZFTlRfVElNRVJTX0tFWSkgfHwge307XG4gICAgdGltZXJzW2V2ZW50X25hbWVdID0gdGltZXN0YW1wO1xuICAgIHRoaXNbJ3Byb3BzJ11bRVZFTlRfVElNRVJTX0tFWV0gPSB0aW1lcnM7XG4gICAgdGhpcy5zYXZlKCk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5yZW1vdmVfZXZlbnRfdGltZXIgPSBmdW5jdGlvbihldmVudF9uYW1lKSB7XG4gICAgdmFyIHRpbWVycyA9IHRoaXMubG9hZF9wcm9wKEVWRU5UX1RJTUVSU19LRVkpIHx8IHt9O1xuICAgIHZhciB0aW1lc3RhbXAgPSB0aW1lcnNbZXZlbnRfbmFtZV07XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHRpbWVzdGFtcCkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNbJ3Byb3BzJ11bRVZFTlRfVElNRVJTX0tFWV1bZXZlbnRfbmFtZV07XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGltZXN0YW1wO1xufTtcblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG4vKlxuICogTWl4cGFuZWwgSlMgTGlicmFyeVxuICpcbiAqIENvcHlyaWdodCAyMDEyLCBNaXhwYW5lbCwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkXG4gKiBodHRwOi8vbWl4cGFuZWwuY29tL1xuICpcbiAqIEluY2x1ZGVzIHBvcnRpb25zIG9mIFVuZGVyc2NvcmUuanNcbiAqIGh0dHA6Ly9kb2N1bWVudGNsb3VkLmdpdGh1Yi5jb20vdW5kZXJzY29yZS9cbiAqIChjKSAyMDExIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBJbmMuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuLypcblNJTVBMRSBTVFlMRSBHVUlERTpcblxudGhpcy54ID09PSBwdWJsaWMgZnVuY3Rpb25cbnRoaXMuX3ggPT09IGludGVybmFsIC0gb25seSB1c2Ugd2l0aGluIHRoaXMgZmlsZVxudGhpcy5fX3ggPT09IHByaXZhdGUgLSBvbmx5IHVzZSB3aXRoaW4gdGhlIGNsYXNzXG5cbkdsb2JhbHMgc2hvdWxkIGJlIGFsbCBjYXBzXG4qL1xuXG52YXIgaW5pdF90eXBlOyAgICAgICAvLyBNT0RVTEUgb3IgU05JUFBFVCBsb2FkZXJcbi8vIGFsbG93IGJ1bmRsZXJzIHRvIHNwZWNpZnkgaG93IGV4dHJhIGNvZGUgKHJlY29yZGVyIGJ1bmRsZSkgc2hvdWxkIGJlIGxvYWRlZFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG52YXIgbG9hZF9leHRyYV9idW5kbGUgPSBmdW5jdGlvbihzcmMsIF9vbmxvYWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3Ioc3JjICsgJyBub3QgYXZhaWxhYmxlIGluIHRoaXMgYnVpbGQuJyk7XG59O1xuXG52YXIgbWl4cGFuZWxfbWFzdGVyOyAvLyBtYWluIG1peHBhbmVsIGluc3RhbmNlIC8gb2JqZWN0XG52YXIgSU5JVF9NT0RVTEUgID0gMDtcbnZhciBJTklUX1NOSVBQRVQgPSAxO1xuXG52YXIgSURFTlRJVFlfRlVOQyA9IGZ1bmN0aW9uKHgpIHtyZXR1cm4geDt9O1xuXG4vKiogQGNvbnN0ICovIHZhciBQUklNQVJZX0lOU1RBTkNFX05BTUUgPSAnbWl4cGFuZWwnO1xuLyoqIEBjb25zdCAqLyB2YXIgUEFZTE9BRF9UWVBFX0JBU0U2NCAgID0gJ2Jhc2U2NCc7XG4vKiogQGNvbnN0ICovIHZhciBQQVlMT0FEX1RZUEVfSlNPTiAgICAgPSAnanNvbic7XG4vKiogQGNvbnN0ICovIHZhciBERVZJQ0VfSURfUFJFRklYICAgICAgPSAnJGRldmljZTonO1xuXG5cbi8qXG4gKiBEeW5hbWljLi4uIGNvbnN0YW50cz8gSXMgdGhhdCBhbiBveHltb3Jvbj9cbiAqL1xuLy8gaHR0cDovL2hhY2tzLm1vemlsbGEub3JnLzIwMDkvMDcvY3Jvc3Mtc2l0ZS14bWxodHRwcmVxdWVzdC13aXRoLWNvcnMvXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0RPTS9YTUxIdHRwUmVxdWVzdCN3aXRoQ3JlZGVudGlhbHNcbnZhciBVU0VfWEhSID0gKHdpbi5YTUxIdHRwUmVxdWVzdCAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKSk7XG5cbi8vIElFPDEwIGRvZXMgbm90IHN1cHBvcnQgY3Jvc3Mtb3JpZ2luIFhIUidzIGJ1dCBzY3JpcHQgdGFnc1xuLy8gd2l0aCBkZWZlciB3b24ndCBibG9jayB3aW5kb3cub25sb2FkOyBFTlFVRVVFX1JFUVVFU1RTXG4vLyBzaG91bGQgb25seSBiZSB0cnVlIGZvciBPcGVyYTwxMlxudmFyIEVOUVVFVUVfUkVRVUVTVFMgPSAhVVNFX1hIUiAmJiAodXNlckFnZW50LmluZGV4T2YoJ01TSUUnKSA9PT0gLTEpICYmICh1c2VyQWdlbnQuaW5kZXhPZignTW96aWxsYScpID09PSAtMSk7XG5cbi8vIHNhdmUgcmVmZXJlbmNlIHRvIG5hdmlnYXRvci5zZW5kQmVhY29uIHNvIGl0IGNhbiBiZSBtaW5pZmllZFxudmFyIHNlbmRCZWFjb24gPSBudWxsO1xuaWYgKG5hdmlnYXRvclsnc2VuZEJlYWNvbiddKSB7XG4gICAgc2VuZEJlYWNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBsYXRlIHJlZmVyZW5jZSB0byBuYXZpZ2F0b3Iuc2VuZEJlYWNvbiB0byBhbGxvdyBwYXRjaGluZy9zcHlpbmdcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvclsnc2VuZEJlYWNvbiddLmFwcGx5KG5hdmlnYXRvciwgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG52YXIgREVGQVVMVF9BUElfUk9VVEVTID0ge1xuICAgICd0cmFjayc6ICAndHJhY2svJyxcbiAgICAnZW5nYWdlJzogJ2VuZ2FnZS8nLFxuICAgICdncm91cHMnOiAnZ3JvdXBzLycsXG4gICAgJ3JlY29yZCc6ICdyZWNvcmQvJyxcbiAgICAnZmxhZ3MnOiAgJ2ZsYWdzLydcbn07XG5cbi8qXG4gKiBNb2R1bGUtbGV2ZWwgZ2xvYmFsc1xuICovXG52YXIgREVGQVVMVF9DT05GSUcgPSB7XG4gICAgJ2FwaV9ob3N0JzogICAgICAgICAgICAgICAgICAgICAgICAgICdodHRwczovL2FwaS1qcy5taXhwYW5lbC5jb20nLFxuICAgICdhcGlfcm91dGVzJzogICAgICAgICAgICAgICAgICAgICAgICBERUZBVUxUX0FQSV9ST1VURVMsXG4gICAgJ2FwaV9leHRyYV9xdWVyeV9wYXJhbXMnOiAgICAgICAgICAgIHt9LFxuICAgICdhcGlfbWV0aG9kJzogICAgICAgICAgICAgICAgICAgICAgICAnUE9TVCcsXG4gICAgJ2FwaV90cmFuc3BvcnQnOiAgICAgICAgICAgICAgICAgICAgICdYSFInLFxuICAgICdhcGlfcGF5bG9hZF9mb3JtYXQnOiAgICAgICAgICAgICAgICBQQVlMT0FEX1RZUEVfQkFTRTY0LFxuICAgICdhcHBfaG9zdCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9taXhwYW5lbC5jb20nLFxuICAgICdhdXRvY2FwdHVyZSc6ICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnY2RuJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2h0dHBzOi8vY2RuLm14cG5sLmNvbScsXG4gICAgJ2Nyb3NzX3NpdGVfY29va2llJzogICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdjcm9zc19zdWJkb21haW5fY29va2llJzogICAgICAgICAgICB0cnVlLFxuICAgICdlcnJvcl9yZXBvcnRlcic6ICAgICAgICAgICAgICAgICAgICBOT09QX0ZVTkMsXG4gICAgJ2ZsYWdzJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdwZXJzaXN0ZW5jZSc6ICAgICAgICAgICAgICAgICAgICAgICAnY29va2llJyxcbiAgICAncGVyc2lzdGVuY2VfbmFtZSc6ICAgICAgICAgICAgICAgICAgJycsXG4gICAgJ2Nvb2tpZV9kb21haW4nOiAgICAgICAgICAgICAgICAgICAgICcnLFxuICAgICdjb29raWVfbmFtZSc6ICAgICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAnbG9hZGVkJzogICAgICAgICAgICAgICAgICAgICAgICAgICAgTk9PUF9GVU5DLFxuICAgICdtcF9sb2FkZXInOiAgICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICd0cmFja19tYXJrZXRpbmcnOiAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICd0cmFja19wYWdldmlldyc6ICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnc2tpcF9maXJzdF90b3VjaF9tYXJrZXRpbmcnOiAgICAgICAgZmFsc2UsXG4gICAgJ3N0b3JlX2dvb2dsZSc6ICAgICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ3N0b3BfdXRtX3BlcnNpc3RlbmNlJzogICAgICAgICAgICAgIGZhbHNlLFxuICAgICdzYXZlX3JlZmVycmVyJzogICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICd0ZXN0JzogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAndmVyYm9zZSc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2ltZyc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdkZWJ1Zyc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAndHJhY2tfbGlua3NfdGltZW91dCc6ICAgICAgICAgICAgICAgMzAwLFxuICAgICdjb29raWVfZXhwaXJhdGlvbic6ICAgICAgICAgICAgICAgICAzNjUsXG4gICAgJ3VwZ3JhZGUnOiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdkaXNhYmxlX3BlcnNpc3RlbmNlJzogICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnZGlzYWJsZV9jb29raWUnOiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3NlY3VyZV9jb29raWUnOiAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdpcCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICdvcHRfb3V0X3RyYWNraW5nX2J5X2RlZmF1bHQnOiAgICAgICBmYWxzZSxcbiAgICAnb3B0X291dF9wZXJzaXN0ZW5jZV9ieV9kZWZhdWx0JzogICAgZmFsc2UsXG4gICAgJ29wdF9vdXRfdHJhY2tpbmdfcGVyc2lzdGVuY2VfdHlwZSc6ICdsb2NhbFN0b3JhZ2UnLFxuICAgICdvcHRfb3V0X3RyYWNraW5nX2Nvb2tpZV9wcmVmaXgnOiAgICBudWxsLFxuICAgICdwcm9wZXJ0eV9ibGFja2xpc3QnOiAgICAgICAgICAgICAgICBbXSxcbiAgICAneGhyX2hlYWRlcnMnOiAgICAgICAgICAgICAgICAgICAgICAge30sIC8vIHsgaGVhZGVyOiB2YWx1ZSwgaGVhZGVyMjogdmFsdWUgfVxuICAgICdpZ25vcmVfZG50JzogICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnYmF0Y2hfcmVxdWVzdHMnOiAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAnYmF0Y2hfc2l6ZSc6ICAgICAgICAgICAgICAgICAgICAgICAgNTAsXG4gICAgJ2JhdGNoX2ZsdXNoX2ludGVydmFsX21zJzogICAgICAgICAgIDUwMDAsXG4gICAgJ2JhdGNoX3JlcXVlc3RfdGltZW91dF9tcyc6ICAgICAgICAgIDkwMDAwLFxuICAgICdiYXRjaF9hdXRvc3RhcnQnOiAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICdob29rcyc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAncmVjb3JkX2Jsb2NrX2NsYXNzJzogICAgICAgICAgICAgICAgbmV3IFJlZ0V4cCgnXihtcC1ibG9ja3xmcy1leGNsdWRlfGFtcC1ibG9ja3xyci1ibG9ja3xwaC1uby1jYXB0dXJlKSQnKSxcbiAgICAncmVjb3JkX2Jsb2NrX3NlbGVjdG9yJzogICAgICAgICAgICAgJ2ltZywgdmlkZW8nLFxuICAgICdyZWNvcmRfY2FudmFzJzogICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAncmVjb3JkX2NvbGxlY3RfZm9udHMnOiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3JlY29yZF9oZWF0bWFwX2RhdGEnOiAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdyZWNvcmRfaWRsZV90aW1lb3V0X21zJzogICAgICAgICAgICAzMCAqIDYwICogMTAwMCwgLy8gMzAgbWludXRlc1xuICAgICdyZWNvcmRfbWFza190ZXh0X2NsYXNzJzogICAgICAgICAgICBuZXcgUmVnRXhwKCdeKG1wLW1hc2t8ZnMtbWFza3xhbXAtbWFza3xyci1tYXNrfHBoLW1hc2spJCcpLFxuICAgICdyZWNvcmRfbWFza190ZXh0X3NlbGVjdG9yJzogICAgICAgICAnKicsXG4gICAgJ3JlY29yZF9tYXhfbXMnOiAgICAgICAgICAgICAgICAgICAgIE1BWF9SRUNPUkRJTkdfTVMsXG4gICAgJ3JlY29yZF9taW5fbXMnOiAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgJ3JlY29yZF9zZXNzaW9uc19wZXJjZW50JzogICAgICAgICAgIDAsXG4gICAgJ3JlY29yZGVyX3NyYyc6ICAgICAgICAgICAgICAgICAgICAgICdodHRwczovL2Nkbi5teHBubC5jb20vbGlicy9taXhwYW5lbC1yZWNvcmRlci5taW4uanMnXG59O1xuXG52YXIgRE9NX0xPQURFRCA9IGZhbHNlO1xuXG4vKipcbiAqIE1peHBhbmVsIExpYnJhcnkgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE1peHBhbmVsTGliID0gZnVuY3Rpb24oKSB7fTtcblxuXG4vKipcbiAqIGNyZWF0ZV9tcGxpYih0b2tlbjpzdHJpbmcsIGNvbmZpZzpvYmplY3QsIG5hbWU6c3RyaW5nKVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBieSB0aGUgaW5pdCBtZXRob2Qgb2YgTWl4cGFuZWxMaWIgb2JqZWN0c1xuICogYXMgd2VsbCBhcyB0aGUgbWFpbiBpbml0aWFsaXplciBhdCB0aGUgZW5kIG9mIHRoZSBKU0xpYiAodGhhdFxuICogaW5pdGlhbGl6ZXMgZG9jdW1lbnQubWl4cGFuZWwgYXMgd2VsbCBhcyBhbnkgYWRkaXRpb25hbCBpbnN0YW5jZXNcbiAqIGRlY2xhcmVkIGJlZm9yZSB0aGlzIGZpbGUgaGFzIGxvYWRlZCkuXG4gKi9cbnZhciBjcmVhdGVfbXBsaWIgPSBmdW5jdGlvbih0b2tlbiwgY29uZmlnLCBuYW1lKSB7XG4gICAgdmFyIGluc3RhbmNlLFxuICAgICAgICB0YXJnZXQgPSAobmFtZSA9PT0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FKSA/IG1peHBhbmVsX21hc3RlciA6IG1peHBhbmVsX21hc3RlcltuYW1lXTtcblxuICAgIGlmICh0YXJnZXQgJiYgaW5pdF90eXBlID09PSBJTklUX01PRFVMRSkge1xuICAgICAgICBpbnN0YW5jZSA9IHRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGFyZ2V0ICYmICFfLmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdZb3UgaGF2ZSBhbHJlYWR5IGluaXRpYWxpemVkICcgKyBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZSA9IG5ldyBNaXhwYW5lbExpYigpO1xuICAgIH1cblxuICAgIGluc3RhbmNlLl9jYWNoZWRfZ3JvdXBzID0ge307IC8vIGNhY2hlIGdyb3VwcyBpbiBhIHBvb2xcblxuICAgIGluc3RhbmNlLl9pbml0KHRva2VuLCBjb25maWcsIG5hbWUpO1xuXG4gICAgaW5zdGFuY2VbJ3Blb3BsZSddID0gbmV3IE1peHBhbmVsUGVvcGxlKCk7XG4gICAgaW5zdGFuY2VbJ3Blb3BsZSddLl9pbml0KGluc3RhbmNlKTtcblxuICAgIGlmICghaW5zdGFuY2UuZ2V0X2NvbmZpZygnc2tpcF9maXJzdF90b3VjaF9tYXJrZXRpbmcnKSkge1xuICAgICAgICAvLyBXZSBuZWVkIG51bGwgVVRNIHBhcmFtcyBpbiB0aGUgb2JqZWN0IGJlY2F1c2VcbiAgICAgICAgLy8gVVRNIHBhcmFtZXRlcnMgYWN0IGFzIGEgdHVwbGUuIElmIGFueSBVVE0gcGFyYW1cbiAgICAgICAgLy8gaXMgcHJlc2VudCwgdGhlbiB3ZSBzZXQgYWxsIFVUTSBwYXJhbXMgaW5jbHVkaW5nXG4gICAgICAgIC8vIGVtcHR5IG9uZXMgdG9nZXRoZXJcbiAgICAgICAgdmFyIHV0bV9wYXJhbXMgPSBfLmluZm8uY2FtcGFpZ25QYXJhbXMobnVsbCk7XG4gICAgICAgIHZhciBpbml0aWFsX3V0bV9wYXJhbXMgPSB7fTtcbiAgICAgICAgdmFyIGhhc191dG0gPSBmYWxzZTtcbiAgICAgICAgXy5lYWNoKHV0bV9wYXJhbXMsIGZ1bmN0aW9uKHV0bV92YWx1ZSwgdXRtX2tleSkge1xuICAgICAgICAgICAgaW5pdGlhbF91dG1fcGFyYW1zWydpbml0aWFsXycgKyB1dG1fa2V5XSA9IHV0bV92YWx1ZTtcbiAgICAgICAgICAgIGlmICh1dG1fdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBoYXNfdXRtID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNfdXRtKSB7XG4gICAgICAgICAgICBpbnN0YW5jZVsncGVvcGxlJ10uc2V0X29uY2UoaW5pdGlhbF91dG1fcGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIGFueSBpbnN0YW5jZSBvbiB0aGUgcGFnZSBoYXMgZGVidWcgPSB0cnVlLCB3ZSBzZXQgdGhlXG4gICAgLy8gZ2xvYmFsIGRlYnVnIHRvIGJlIHRydWVcbiAgICBDb25maWcuREVCVUcgPSBDb25maWcuREVCVUcgfHwgaW5zdGFuY2UuZ2V0X2NvbmZpZygnZGVidWcnKTtcblxuICAgIC8vIGlmIHRhcmdldCBpcyBub3QgZGVmaW5lZCwgd2UgY2FsbGVkIGluaXQgYWZ0ZXIgdGhlIGxpYiBhbHJlYWR5XG4gICAgLy8gbG9hZGVkLCBzbyB0aGVyZSB3b24ndCBiZSBhbiBhcnJheSBvZiB0aGluZ3MgdG8gZXhlY3V0ZVxuICAgIGlmICghXy5pc1VuZGVmaW5lZCh0YXJnZXQpICYmIF8uaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgIC8vIENydW5jaCB0aHJvdWdoIHRoZSBwZW9wbGUgcXVldWUgZmlyc3QgLSB3ZSBxdWV1ZSB0aGlzIGRhdGEgdXAgJlxuICAgICAgICAvLyBmbHVzaCBvbiBpZGVudGlmeSwgc28gaXQncyBiZXR0ZXIgdG8gZG8gYWxsIHRoZXNlIG9wZXJhdGlvbnMgZmlyc3RcbiAgICAgICAgaW5zdGFuY2UuX2V4ZWN1dGVfYXJyYXkuY2FsbChpbnN0YW5jZVsncGVvcGxlJ10sIHRhcmdldFsncGVvcGxlJ10pO1xuICAgICAgICBpbnN0YW5jZS5fZXhlY3V0ZV9hcnJheSh0YXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbn07XG5cbi8vIEluaXRpYWxpemF0aW9uIG1ldGhvZHNcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBNaXhwYW5lbCB0cmFja2luZyBvYmplY3QuXG4gKiBBbGwgbmV3IGluc3RhbmNlcyBhcmUgYWRkZWQgdG8gdGhlIG1haW4gbWl4cGFuZWwgb2JqZWN0IGFzIHN1YiBwcm9wZXJ0aWVzIChzdWNoIGFzXG4gKiBtaXhwYW5lbC5saWJyYXJ5X25hbWUpIGFuZCBhbHNvIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24uIFRvIGRlZmluZSBhXG4gKiBzZWNvbmQgaW5zdGFuY2Ugb24gdGhlIHBhZ2UsIHlvdSB3b3VsZCBjYWxsOlxuICpcbiAqICAgICBtaXhwYW5lbC5pbml0KCduZXcgdG9rZW4nLCB7IHlvdXI6ICdjb25maWcnIH0sICdsaWJyYXJ5X25hbWUnKTtcbiAqXG4gKiBhbmQgdXNlIGl0IGxpa2Ugc286XG4gKlxuICogICAgIG1peHBhbmVsLmxpYnJhcnlfbmFtZS50cmFjayguLi4pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiAgIFlvdXIgTWl4cGFuZWwgQVBJIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZS4gPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9taXhwYW5lbC9taXhwYW5lbC1qcy9ibG9iL3YyLjQ2LjAvc3JjL21peHBhbmVsLWNvcmUuanMjTDg4LUwxMjdcIj5TZWUgYSBsaXN0IG9mIGRlZmF1bHQgY29uZmlnIG9wdGlvbnM8L2E+LlxuICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSAgICBUaGUgbmFtZSBmb3IgdGhlIG5ldyBtaXhwYW5lbCBpbnN0YW5jZSB0aGF0IHlvdSB3YW50IGNyZWF0ZWRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAodG9rZW4sIGNvbmZpZywgbmFtZSkge1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdZb3UgbXVzdCBuYW1lIHlvdXIgbmV3IGxpYnJhcnk6IGluaXQodG9rZW4sIGNvbmZpZywgbmFtZSknKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdZb3UgbXVzdCBpbml0aWFsaXplIHRoZSBtYWluIG1peHBhbmVsIG9iamVjdCByaWdodCBhZnRlciB5b3UgaW5jbHVkZSB0aGUgTWl4cGFuZWwganMgc25pcHBldCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gY3JlYXRlX21wbGliKHRva2VuLCBjb25maWcsIG5hbWUpO1xuICAgIG1peHBhbmVsX21hc3RlcltuYW1lXSA9IGluc3RhbmNlO1xuICAgIGluc3RhbmNlLl9sb2FkZWQoKTtcblxuICAgIHJldHVybiBpbnN0YW5jZTtcbn07XG5cbi8vIG1peHBhbmVsLl9pbml0KHRva2VuOnN0cmluZywgY29uZmlnOm9iamVjdCwgbmFtZTpzdHJpbmcpXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBzZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBtaXhwYW5lbFxuLy8gbGlicmFyeS4gIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhpcyBtZXRob2QgYW5kIHRoZSBpbml0KC4uLilcbi8vIG1ldGhvZCBpcyB0aGlzIG9uZSBpbml0aWFsaXplcyB0aGUgYWN0dWFsIGluc3RhbmNlLCB3aGVyZWFzIHRoZVxuLy8gaW5pdCguLi4pIG1ldGhvZCBzZXRzIHVwIGEgbmV3IGxpYnJhcnkgYW5kIGNhbGxzIF9pbml0IG9uIGl0LlxuLy9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKHRva2VuLCBjb25maWcsIG5hbWUpIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG5cbiAgICB0aGlzWydfX2xvYWRlZCddID0gdHJ1ZTtcbiAgICB0aGlzWydjb25maWcnXSA9IHt9O1xuXG4gICAgdmFyIHZhcmlhYmxlX2ZlYXR1cmVzID0ge307XG5cbiAgICAvLyBkZWZhdWx0IHRvIEpTT04gcGF5bG9hZCBmb3Igc3RhbmRhcmQgbWl4cGFuZWwuY29tIEFQSSBob3N0c1xuICAgIGlmICghKCdhcGlfcGF5bG9hZF9mb3JtYXQnIGluIGNvbmZpZykpIHtcbiAgICAgICAgdmFyIGFwaV9ob3N0ID0gY29uZmlnWydhcGlfaG9zdCddIHx8IERFRkFVTFRfQ09ORklHWydhcGlfaG9zdCddO1xuICAgICAgICBpZiAoYXBpX2hvc3QubWF0Y2goL1xcLm1peHBhbmVsXFwuY29tLykpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlX2ZlYXR1cmVzWydhcGlfcGF5bG9hZF9mb3JtYXQnXSA9IFBBWUxPQURfVFlQRV9KU09OO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXRfY29uZmlnKF8uZXh0ZW5kKHt9LCBERUZBVUxUX0NPTkZJRywgdmFyaWFibGVfZmVhdHVyZXMsIGNvbmZpZywge1xuICAgICAgICAnbmFtZSc6IG5hbWUsXG4gICAgICAgICd0b2tlbic6IHRva2VuLFxuICAgICAgICAnY2FsbGJhY2tfZm4nOiAoKG5hbWUgPT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkgPyBuYW1lIDogUFJJTUFSWV9JTlNUQU5DRV9OQU1FICsgJy4nICsgbmFtZSkgKyAnLl9qc2MnXG4gICAgfSkpO1xuXG4gICAgdGhpc1snX2pzYyddID0gTk9PUF9GVU5DO1xuXG4gICAgdGhpcy5fX2RvbV9sb2FkZWRfcXVldWUgPSBbXTtcbiAgICB0aGlzLl9fcmVxdWVzdF9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX19kaXNhYmxlZF9ldmVudHMgPSBbXTtcbiAgICB0aGlzLl9mbGFncyA9IHtcbiAgICAgICAgJ2Rpc2FibGVfYWxsX2V2ZW50cyc6IGZhbHNlLFxuICAgICAgICAnaWRlbnRpZnlfY2FsbGVkJzogZmFsc2VcbiAgICB9O1xuXG4gICAgLy8gc2V0IHVwIHJlcXVlc3QgcXVldWVpbmcvYmF0Y2hpbmdcbiAgICB0aGlzLnJlcXVlc3RfYmF0Y2hlcnMgPSB7fTtcbiAgICB0aGlzLl9iYXRjaF9yZXF1ZXN0cyA9IHRoaXMuZ2V0X2NvbmZpZygnYmF0Y2hfcmVxdWVzdHMnKTtcbiAgICBpZiAodGhpcy5fYmF0Y2hfcmVxdWVzdHMpIHtcbiAgICAgICAgaWYgKCFfLmxvY2FsU3RvcmFnZS5pc19zdXBwb3J0ZWQodHJ1ZSkgfHwgIVVTRV9YSFIpIHtcbiAgICAgICAgICAgIHRoaXMuX2JhdGNoX3JlcXVlc3RzID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zb2xlJDEubG9nKCdUdXJuaW5nIG9mZiBNaXhwYW5lbCByZXF1ZXN0LXF1ZXVlaW5nOyBuZWVkcyBYSFIgYW5kIGxvY2FsU3RvcmFnZSBzdXBwb3J0Jyk7XG4gICAgICAgICAgICBfLmVhY2godGhpcy5nZXRfYmF0Y2hlcl9jb25maWdzKCksIGZ1bmN0aW9uKGJhdGNoZXJfY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZSQxLmxvZygnQ2xlYXJpbmcgYmF0Y2ggcXVldWUgJyArIGJhdGNoZXJfY29uZmlnLnF1ZXVlX2tleSk7XG4gICAgICAgICAgICAgICAgXy5sb2NhbFN0b3JhZ2UucmVtb3ZlKGJhdGNoZXJfY29uZmlnLnF1ZXVlX2tleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdF9iYXRjaGVycygpO1xuICAgICAgICAgICAgaWYgKHNlbmRCZWFjb24gJiYgd2luLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBCZWZvcmUgcGFnZSBjbG9zZXMgb3IgaGlkZXMgKHVzZXIgdGFicyBhd2F5IGV0YyksIGF0dGVtcHQgdG8gZmx1c2ggYW55IGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIHF1ZXVlZCB1cCB2aWEgbmF2aWdhdG9yLnNlbmRCZWFjb24uIFNpbmNlIHNlbmRCZWFjb24gZG9lc24ndCByZXBvcnQgc3VjY2Vzcy9mYWlsdXJlLFxuICAgICAgICAgICAgICAgIC8vIGV2ZW50cyB3aWxsIG5vdCBiZSByZW1vdmVkIGZyb20gdGhlIHBlcnNpc3RlbnQgc3RvcmU7IGlmIHRoZSBzaXRlIGlzIGxvYWRlZCBhZ2FpbixcbiAgICAgICAgICAgICAgICAvLyB0aGUgZXZlbnRzIHdpbGwgYmUgZmx1c2hlZCBhZ2FpbiBvbiBzdGFydHVwIGFuZCBkZWR1cGxpY2F0ZWQgb24gdGhlIE1peHBhbmVsIHNlcnZlclxuICAgICAgICAgICAgICAgIC8vIHNpZGUuXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gcmVsaWFibGUgd2F5IHRvIGNhcHR1cmUgb25seSBwYWdlIGNsb3NlIGV2ZW50cywgc28gd2UgbGVhbiBvbiB0aGVcbiAgICAgICAgICAgICAgICAvLyB2aXNpYmlsaXR5Y2hhbmdlIGFuZCBwYWdlaGlkZSBldmVudHMgYXMgcmVjb21tZW5kZWQgYXRcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L3VubG9hZF9ldmVudCN1c2FnZV9ub3Rlcy5cbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBldmVudHMgZmlyZSB3aGVuIHRoZSB1c2VyIGNsaWNrcyBhd2F5IGZyb20gdGhlIGN1cnJlbnQgcGFnZS90YWIsIHNvIHdpbGwgb2NjdXJcbiAgICAgICAgICAgICAgICAvLyBtb3JlIGZyZXF1ZW50bHkgdGhhbiBwYWdlIHVubG9hZCwgYnV0IGFyZSB0aGUgb25seSBtZWNoYW5pc20gY3VycmVudGx5IGZvciBjYXB0dXJpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHNjZW5hcmlvIHNvbWV3aGF0IHJlbGlhYmx5LlxuICAgICAgICAgICAgICAgIHZhciBmbHVzaF9vbl91bmxvYWQgPSBfLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZXF1ZXN0X2JhdGNoZXJzLmV2ZW50cy5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RfYmF0Y2hlcnMuZXZlbnRzLmZsdXNoKHt1bmxvYWRpbmc6IHRydWV9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldlsncGVyc2lzdGVkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoX29uX3VubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50JDFbJ3Zpc2liaWxpdHlTdGF0ZSddID09PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2hfb25fdW5sb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10gPSB0aGlzWydjb29raWUnXSA9IG5ldyBNaXhwYW5lbFBlcnNpc3RlbmNlKHRoaXNbJ2NvbmZpZyddKTtcbiAgICB0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHMgPSB7fTtcbiAgICB0aGlzLl9nZHByX2luaXQoKTtcblxuICAgIHZhciB1dWlkID0gXy5VVUlEKCk7XG4gICAgaWYgKCF0aGlzLmdldF9kaXN0aW5jdF9pZCgpKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gc2V0IHRoZSBkaXN0aW5jdCBpZFxuICAgICAgICAvLyBvciB0aGUgZGV2aWNlIGlkIGlmIHNvbWV0aGluZyB3YXMgYWxyZWFkeSBzdG9yZWRcbiAgICAgICAgLy8gaW4gdGhlIHBlcnNpdGVuY2VcbiAgICAgICAgdGhpcy5yZWdpc3Rlcl9vbmNlKHtcbiAgICAgICAgICAgICdkaXN0aW5jdF9pZCc6IERFVklDRV9JRF9QUkVGSVggKyB1dWlkLFxuICAgICAgICAgICAgJyRkZXZpY2VfaWQnOiB1dWlkXG4gICAgICAgIH0sICcnKTtcbiAgICB9XG5cbiAgICB0aGlzLmZsYWdzID0gbmV3IEZlYXR1cmVGbGFnTWFuYWdlcih7XG4gICAgICAgIGdldENvbmZpZ0Z1bmM6IF8uYmluZCh0aGlzLmdldF9jb25maWcsIHRoaXMpLFxuICAgICAgICBnZXREaXN0aW5jdElkRnVuYzogXy5iaW5kKHRoaXMuZ2V0X2Rpc3RpbmN0X2lkLCB0aGlzKSxcbiAgICAgICAgdHJhY2tpbmdGdW5jOiBfLmJpbmQodGhpcy50cmFjaywgdGhpcylcbiAgICB9KTtcbiAgICB0aGlzLmZsYWdzLmluaXQoKTtcbiAgICB0aGlzWydmbGFncyddID0gdGhpcy5mbGFncztcblxuICAgIHRoaXMuYXV0b2NhcHR1cmUgPSBuZXcgQXV0b2NhcHR1cmUodGhpcyk7XG4gICAgdGhpcy5hdXRvY2FwdHVyZS5pbml0KCk7XG5cbiAgICB0aGlzLl9pbml0X3RhYl9pZCgpO1xuICAgIHRoaXMuX2NoZWNrX2FuZF9zdGFydF9zZXNzaW9uX3JlY29yZGluZygpO1xufTtcblxuLyoqXG4gKiBBc3NpZ25zIGEgdW5pcXVlIFVVSUQgdG8gdGhpcyB0YWIgLyB3aW5kb3cgYnkgbGV2ZXJhZ2luZyBzZXNzaW9uU3RvcmFnZS5cbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgZm9yIHNlc3Npb24gcmVjb3JkaW5nLCB3aGVyZSBkYXRhIG11c3QgYmUgaXNvbGF0ZWQgdG8gdGhlIGN1cnJlbnQgdGFiLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2luaXRfdGFiX2lkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKF8uc2Vzc2lvblN0b3JhZ2UuaXNfc3VwcG9ydGVkKCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBrZXlfc3VmZml4ID0gdGhpcy5nZXRfY29uZmlnKCduYW1lJykgKyAnXycgKyB0aGlzLmdldF9jb25maWcoJ3Rva2VuJyk7XG4gICAgICAgICAgICB2YXIgdGFiX2lkX2tleSA9ICdtcF90YWJfaWRfJyArIGtleV9zdWZmaXg7XG5cbiAgICAgICAgICAgIC8vIEEgZmxhZyBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBzZXNzaW9uU3RvcmFnZSBpcyBjb3BpZWQgb3ZlciBhbmQgd2UgbmVlZCB0byBnZW5lcmF0ZSBhIG5ldyB0YWIgSUQuXG4gICAgICAgICAgICAvLyBUaGlzIGVuZm9yY2VzIGEgdW5pcXVlIElEIGluIHRoZSBjYXNlcyBsaWtlIGR1cGxpY2F0ZWQgdGFiLCB3aW5kb3cub3BlbiguLi4pXG4gICAgICAgICAgICB2YXIgc2hvdWxkX2dlbmVyYXRlX25ld190YWJfaWRfa2V5ID0gJ21wX2dlbl9uZXdfdGFiX2lkXycgKyBrZXlfc3VmZml4O1xuICAgICAgICAgICAgaWYgKF8uc2Vzc2lvblN0b3JhZ2UuZ2V0KHNob3VsZF9nZW5lcmF0ZV9uZXdfdGFiX2lkX2tleSkgfHwgIV8uc2Vzc2lvblN0b3JhZ2UuZ2V0KHRhYl9pZF9rZXkpKSB7XG4gICAgICAgICAgICAgICAgXy5zZXNzaW9uU3RvcmFnZS5zZXQodGFiX2lkX2tleSwgJyR0YWItJyArIF8uVVVJRCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgXy5zZXNzaW9uU3RvcmFnZS5zZXQoc2hvdWxkX2dlbmVyYXRlX25ld190YWJfaWRfa2V5LCAnMScpO1xuICAgICAgICAgICAgdGhpcy50YWJfaWQgPSBfLnNlc3Npb25TdG9yYWdlLmdldCh0YWJfaWRfa2V5KTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBmbGFnIHdoZW4gdGhlIHRhYiBpcyB1bmxvYWRlZCB0byBpbmRpY2F0ZSB0aGUgc3RvcmVkIHRhYiBJRCBjYW4gYmUgcmV1c2VkLiBUaGlzIGV2ZW50IGlzIG5vdCByZWxpYWJsZSB0byBkZXRlY3QgYWxsIHBhZ2UgdW5sb2FkcyxcbiAgICAgICAgICAgIC8vIGJ1dCByZWxpYWJsZSBpbiBjYXNlcyB3aGVyZSB0aGUgdXNlciByZW1haW5zIGluIHRoZSB0YWIgZS5nLiBhIHJlZnJlc2ggb3IgaHJlZiBuYXZpZ2F0aW9uLlxuICAgICAgICAgICAgLy8gSWYgdGhlIGZsYWcgaXMgYWJzZW50LCB0aGlzIGluZGljYXRlcyB0byB0aGUgbmV4dCBTREsgaW5zdGFuY2UgdGhhdCB3ZSBjYW4gcmV1c2UgdGhlIHN0b3JlZCB0YWJfaWQuXG4gICAgICAgICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF8uc2Vzc2lvblN0b3JhZ2UucmVtb3ZlKHNob3VsZF9nZW5lcmF0ZV9uZXdfdGFiX2lkX2tleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdFcnJvciBpbml0aWFsaXppbmcgdGFiIGlkJywgZXJyKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdTZXNzaW9uIHN0b3JhZ2UgaXMgbm90IHN1cHBvcnRlZCwgY2Fubm90IGtlZXAgdHJhY2sgb2YgdW5pcXVlIHRhYiBJRC4nKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3RhYl9pZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50YWJfaWQgfHwgbnVsbDtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fc2hvdWxkX2xvYWRfcmVjb3JkZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlY29yZGluZ19yZWdpc3RyeV9pZGIgPSBuZXcgSURCU3RvcmFnZVdyYXBwZXIoUkVDT1JESU5HX1JFR0lTVFJZX1NUT1JFX05BTUUpO1xuICAgIHZhciB0YWJfaWQgPSB0aGlzLmdldF90YWJfaWQoKTtcbiAgICByZXR1cm4gcmVjb3JkaW5nX3JlZ2lzdHJ5X2lkYi5pbml0KClcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlY29yZGluZ19yZWdpc3RyeV9pZGIuZ2V0QWxsKCk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZWNvcmRpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29yZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgZXhwaXJlZCByZWNvcmRpbmdzIGluIHRoZSByZWdpc3RyeSwgd2Ugc2hvdWxkIGxvYWQgdGhlIHJlY29yZGVyIHRvIGZsdXNoIHRoZW1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSdzIGEgcmVjb3JkaW5nIGZvciB0aGlzIHRhYiBpZCwgd2Ugc2hvdWxkIGxvYWQgdGhlIHJlY29yZGVyIHRvIGNvbnRpbnVlIHRoZSByZWNvcmRpbmdcbiAgICAgICAgICAgICAgICBpZiAoaXNSZWNvcmRpbmdFeHBpcmVkKHJlY29yZGluZ3NbaV0pIHx8IHJlY29yZGluZ3NbaV1bJ3RhYklkJ10gPT09IHRhYl9pZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ0Vycm9yIGNoZWNraW5nIHJlY29yZGluZyByZWdpc3RyeScsIGVycik7XG4gICAgICAgIH0sIHRoaXMpKTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fY2hlY2tfYW5kX3N0YXJ0X3Nlc3Npb25fcmVjb3JkaW5nID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihmb3JjZV9zdGFydCkge1xuICAgIGlmICghd2luWydNdXRhdGlvbk9ic2VydmVyJ10pIHtcbiAgICAgICAgY29uc29sZSQxLmNyaXRpY2FsKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTXV0YXRpb25PYnNlcnZlcjsgc2tpcHBpbmcgc2Vzc2lvbiByZWNvcmRpbmcnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsb2FkUmVjb3JkZXIgPSBfLmJpbmQoZnVuY3Rpb24oc3RhcnROZXdJZkluYWN0aXZlKSB7XG4gICAgICAgIHZhciBoYW5kbGVMb2FkZWRSZWNvcmRlciA9IF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY29yZGVyID0gdGhpcy5fcmVjb3JkZXIgfHwgbmV3IHdpblsnX19tcF9yZWNvcmRlciddKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fcmVjb3JkZXJbJ3Jlc3VtZVJlY29yZGluZyddKHN0YXJ0TmV3SWZJbmFjdGl2ZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmIChfLmlzVW5kZWZpbmVkKHdpblsnX19tcF9yZWNvcmRlciddKSkge1xuICAgICAgICAgICAgbG9hZF9leHRyYV9idW5kbGUodGhpcy5nZXRfY29uZmlnKCdyZWNvcmRlcl9zcmMnKSwgaGFuZGxlTG9hZGVkUmVjb3JkZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlTG9hZGVkUmVjb3JkZXIoKTtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIHVzZXIgaXMgc2FtcGxlZCBvciBzdGFydF9zZXNzaW9uX3JlY29yZGluZyBpcyBjYWxsZWQsIHdlIGFsd2F5cyBsb2FkIHRoZSByZWNvcmRlciBzaW5jZSBpdCdzIGd1YXJhbnRlZWQgYSByZWNvcmRpbmcgc2hvdWxkIHN0YXJ0LlxuICAgICAqIE90aGVyd2lzZSwgaWYgdGhlIHJlY29yZGluZyByZWdpc3RyeSBoYXMgYW55IHJlY29yZHMgdGhlbiBpdCdzIGxpa2VseSB0aGVyZSdzIGEgcmVjb3JkaW5nIGluIHByb2dyZXNzIG9yIG9ycGhhbmVkIGRhdGEgdGhhdCBuZWVkcyB0byBiZSBmbHVzaGVkLlxuICAgICAqL1xuICAgIHZhciBpc19zYW1wbGVkID0gdGhpcy5nZXRfY29uZmlnKCdyZWNvcmRfc2Vzc2lvbnNfcGVyY2VudCcpID4gMCAmJiBNYXRoLnJhbmRvbSgpICogMTAwIDw9IHRoaXMuZ2V0X2NvbmZpZygncmVjb3JkX3Nlc3Npb25zX3BlcmNlbnQnKTtcbiAgICBpZiAoZm9yY2Vfc3RhcnQgfHwgaXNfc2FtcGxlZCkge1xuICAgICAgICBsb2FkUmVjb3JkZXIodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2hvdWxkX2xvYWRfcmVjb3JkZXIoKVxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHNob3VsZExvYWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2FkUmVjb3JkZXIoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2hlY2tfYW5kX3N0YXJ0X3Nlc3Npb25fcmVjb3JkaW5nKHRydWUpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0b3Bfc2Vzc2lvbl9yZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlY29yZGVyKSB7XG4gICAgICAgIHRoaXMuX3JlY29yZGVyWydzdG9wUmVjb3JkaW5nJ10oKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucGF1c2Vfc2Vzc2lvbl9yZWNvcmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlY29yZGVyKSB7XG4gICAgICAgIHRoaXMuX3JlY29yZGVyWydwYXVzZVJlY29yZGluZyddKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlc3VtZV9zZXNzaW9uX3JlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVjb3JkZXIpIHtcbiAgICAgICAgdGhpcy5fcmVjb3JkZXJbJ3Jlc3VtZVJlY29yZGluZyddKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLmlzX3JlY29yZGluZ19oZWF0bWFwX2RhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldF9zZXNzaW9uX3JlcGxheV9pZCgpICYmIHRoaXMuZ2V0X2NvbmZpZygncmVjb3JkX2hlYXRtYXBfZGF0YScpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9zZXNzaW9uX3JlY29yZGluZ19wcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciByZXBsYXlfaWQgPSB0aGlzLl9nZXRfc2Vzc2lvbl9yZXBsYXlfaWQoKTtcbiAgICBpZiAocmVwbGF5X2lkKSB7XG4gICAgICAgIHByb3BzWyckbXBfcmVwbGF5X2lkJ10gPSByZXBsYXlfaWQ7XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfc2Vzc2lvbl9yZXBsYXlfdXJsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXBsYXlfdXJsID0gbnVsbDtcbiAgICB2YXIgcmVwbGF5X2lkID0gdGhpcy5fZ2V0X3Nlc3Npb25fcmVwbGF5X2lkKCk7XG4gICAgaWYgKHJlcGxheV9pZCkge1xuICAgICAgICB2YXIgcXVlcnlfcGFyYW1zID0gXy5IVFRQQnVpbGRRdWVyeSh7XG4gICAgICAgICAgICAncmVwbGF5X2lkJzogcmVwbGF5X2lkLFxuICAgICAgICAgICAgJ2Rpc3RpbmN0X2lkJzogdGhpcy5nZXRfZGlzdGluY3RfaWQoKSxcbiAgICAgICAgICAgICd0b2tlbic6IHRoaXMuZ2V0X2NvbmZpZygndG9rZW4nKVxuICAgICAgICB9KTtcbiAgICAgICAgcmVwbGF5X3VybCA9ICdodHRwczovL21peHBhbmVsLmNvbS9wcm9qZWN0cy9yZXBsYXktcmVkaXJlY3Q/JyArIHF1ZXJ5X3BhcmFtcztcbiAgICB9XG4gICAgcmV0dXJuIHJlcGxheV91cmw7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2dldF9zZXNzaW9uX3JlcGxheV9pZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVwbGF5X2lkID0gbnVsbDtcbiAgICBpZiAodGhpcy5fcmVjb3JkZXIpIHtcbiAgICAgICAgcmVwbGF5X2lkID0gdGhpcy5fcmVjb3JkZXJbJ3JlcGxheUlkJ107XG4gICAgfVxuICAgIHJldHVybiByZXBsYXlfaWQgfHwgbnVsbDtcbn07XG5cbi8vIFwicHJpdmF0ZVwiIHB1YmxpYyBtZXRob2QgdG8gcmVhY2ggaW50byB0aGUgcmVjb3JkZXIgaW4gdGVzdCBjYXNlc1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9fZ2V0X3JlY29yZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWNvcmRlcjtcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kc1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2xvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZ2V0X2NvbmZpZygnbG9hZGVkJykodGhpcyk7XG4gICAgdGhpcy5fc2V0X2RlZmF1bHRfc3VwZXJwcm9wcygpO1xuICAgIHRoaXNbJ3Blb3BsZSddLnNldF9vbmNlKHRoaXNbJ3BlcnNpc3RlbmNlJ10uZ2V0X3JlZmVycmVyX2luZm8oKSk7XG5cbiAgICAvLyBgc3RvcmVfZ29vZ2xlYCBpcyBub3cgZGVwcmVjYXRlZCBhbmQgcHJldmlvdXNseSBzdG9yZWQgVVRNIHBhcmFtZXRlcnMgYXJlIGNsZWFyZWRcbiAgICAvLyBmcm9tIHBlcnNpc3RlbmNlIGJ5IGRlZmF1bHQuXG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnc3RvcmVfZ29vZ2xlJykgJiYgdGhpcy5nZXRfY29uZmlnKCdzdG9wX3V0bV9wZXJzaXN0ZW5jZScpKSB7XG4gICAgICAgIHZhciB1dG1fcGFyYW1zID0gXy5pbmZvLmNhbXBhaWduUGFyYW1zKG51bGwpO1xuICAgICAgICBfLmVhY2godXRtX3BhcmFtcywgZnVuY3Rpb24oX3V0bV92YWx1ZSwgdXRtX2tleSkge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB1bnJlZ2lzdGVyIHBlcnNpc3RlZCBVVE0gcGFyYW1ldGVycyBzbyBvbGQgdmFsdWVzXG4gICAgICAgICAgICAvLyBhcmUgbm90IG1peGVkIHdpdGggdGhlIG5ldyBVVE0gcGFyYW1ldGVyc1xuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyKHV0bV9rZXkpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbn07XG5cbi8vIHVwZGF0ZSBwZXJzaXN0ZW5jZSB3aXRoIGluZm8gb24gcmVmZXJyZXIsIFVUTSBwYXJhbXMsIGV0Y1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9zZXRfZGVmYXVsdF9zdXBlcnByb3BzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpc1sncGVyc2lzdGVuY2UnXS51cGRhdGVfc2VhcmNoX2tleXdvcmQoZG9jdW1lbnQkMS5yZWZlcnJlcik7XG4gICAgLy8gUmVnaXN0ZXJpbmcgc3VwZXIgcHJvcGVydGllcyBmb3IgVVRNIHBlcnNpc3RlbmNlIGJ5ICdzdG9yZV9nb29nbGUnIGlzIGRlcHJlY2F0ZWQuXG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnc3RvcmVfZ29vZ2xlJykgJiYgIXRoaXMuZ2V0X2NvbmZpZygnc3RvcF91dG1fcGVyc2lzdGVuY2UnKSkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKF8uaW5mby5jYW1wYWlnblBhcmFtcygpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnc2F2ZV9yZWZlcnJlcicpKSB7XG4gICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10udXBkYXRlX3JlZmVycmVyX2luZm8oZG9jdW1lbnQkMS5yZWZlcnJlcik7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9kb21fbG9hZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgXy5lYWNoKHRoaXMuX19kb21fbG9hZGVkX3F1ZXVlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrX2RvbS5hcHBseSh0aGlzLCBpdGVtKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIGlmICghdGhpcy5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nKCkpIHtcbiAgICAgICAgXy5lYWNoKHRoaXMuX19yZXF1ZXN0X3F1ZXVlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kX3JlcXVlc3QuYXBwbHkodGhpcywgaXRlbSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLl9fZG9tX2xvYWRlZF9xdWV1ZTtcbiAgICBkZWxldGUgdGhpcy5fX3JlcXVlc3RfcXVldWU7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3RyYWNrX2RvbSA9IGZ1bmN0aW9uKERvbUNsYXNzLCBhcmdzKSB7XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnaW1nJykpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ1lvdSBjYW5cXCd0IHVzZSBET00gdHJhY2tpbmcgZnVuY3Rpb25zIHdpdGggaW1nID0gdHJ1ZS4nKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghRE9NX0xPQURFRCkge1xuICAgICAgICB0aGlzLl9fZG9tX2xvYWRlZF9xdWV1ZS5wdXNoKFtEb21DbGFzcywgYXJnc10pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGR0ID0gbmV3IERvbUNsYXNzKCkuaW5pdCh0aGlzKTtcbiAgICByZXR1cm4gZHQudHJhY2suYXBwbHkoZHQsIGFyZ3MpO1xufTtcblxuLyoqXG4gKiBfcHJlcGFyZV9jYWxsYmFjaygpIHNob3VsZCBiZSBjYWxsZWQgYnkgY2FsbGVycyBvZiBfc2VuZF9yZXF1ZXN0IGZvciB1c2VcbiAqIGFzIHRoZSBjYWxsYmFjayBhcmd1bWVudC5cbiAqXG4gKiBJZiB0aGVyZSBpcyBubyBjYWxsYmFjaywgdGhpcyByZXR1cm5zIG51bGwuXG4gKiBJZiB3ZSBhcmUgZ29pbmcgdG8gbWFrZSBYSFIvWERSIHJlcXVlc3RzLCB0aGlzIHJldHVybnMgYSBmdW5jdGlvbi5cbiAqIElmIHdlIGFyZSBnb2luZyB0byB1c2Ugc2NyaXB0IHRhZ3MsIHRoaXMgcmV0dXJucyBhIHN0cmluZyB0byB1c2UgYXMgdGhlXG4gKiBjYWxsYmFjayBHRVQgcGFyYW0uXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fcHJlcGFyZV9jYWxsYmFjayA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBkYXRhKSB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQoY2FsbGJhY2spKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChVU0VfWEhSKSB7XG4gICAgICAgIHZhciBjYWxsYmFja19mdW5jdGlvbiA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYWxsYmFja19mdW5jdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiB0aGUgdXNlciBnaXZlcyB1cyBhIGNhbGxiYWNrLCB3ZSBzdG9yZSBhcyBhIHJhbmRvbVxuICAgICAgICAvLyBwcm9wZXJ0eSBvbiB0aGlzIGluc3RhbmNlcyBqc2MgZnVuY3Rpb24gYW5kIHVwZGF0ZSBvdXJcbiAgICAgICAgLy8gY2FsbGJhY2sgc3RyaW5nIHRvIHJlZmxlY3QgdGhhdC5cbiAgICAgICAgdmFyIGpzYyA9IHRoaXNbJ19qc2MnXTtcbiAgICAgICAgdmFyIHJhbmRvbWl6ZWRfY2IgPSAnJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMCk7XG4gICAgICAgIHZhciBjYWxsYmFja19zdHJpbmcgPSB0aGlzLmdldF9jb25maWcoJ2NhbGxiYWNrX2ZuJykgKyAnWycgKyByYW5kb21pemVkX2NiICsgJ10nO1xuICAgICAgICBqc2NbcmFuZG9taXplZF9jYl0gPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgZGVsZXRlIGpzY1tyYW5kb21pemVkX2NiXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrX3N0cmluZztcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3NlbmRfcmVxdWVzdCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgc3VjY2VlZGVkID0gdHJ1ZTtcblxuICAgIGlmIChFTlFVRVVFX1JFUVVFU1RTKSB7XG4gICAgICAgIHRoaXMuX19yZXF1ZXN0X3F1ZXVlLnB1c2goYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHN1Y2NlZWRlZDtcbiAgICB9XG5cbiAgICB2YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgICAgICBtZXRob2Q6IHRoaXMuZ2V0X2NvbmZpZygnYXBpX21ldGhvZCcpLFxuICAgICAgICB0cmFuc3BvcnQ6IHRoaXMuZ2V0X2NvbmZpZygnYXBpX3RyYW5zcG9ydCcpLFxuICAgICAgICB2ZXJib3NlOiB0aGlzLmdldF9jb25maWcoJ3ZlcmJvc2UnKVxuICAgIH07XG4gICAgdmFyIGJvZHlfZGF0YSA9IG51bGw7XG5cbiAgICBpZiAoIWNhbGxiYWNrICYmIChfLmlzRnVuY3Rpb24ob3B0aW9ucykgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cbiAgICBvcHRpb25zID0gXy5leHRlbmQoREVGQVVMVF9PUFRJT05TLCBvcHRpb25zIHx8IHt9KTtcbiAgICBpZiAoIVVTRV9YSFIpIHtcbiAgICAgICAgb3B0aW9ucy5tZXRob2QgPSAnR0VUJztcbiAgICB9XG4gICAgdmFyIHVzZV9wb3N0ID0gb3B0aW9ucy5tZXRob2QgPT09ICdQT1NUJztcbiAgICB2YXIgdXNlX3NlbmRCZWFjb24gPSBzZW5kQmVhY29uICYmIHVzZV9wb3N0ICYmIG9wdGlvbnMudHJhbnNwb3J0LnRvTG93ZXJDYXNlKCkgPT09ICdzZW5kYmVhY29uJztcblxuICAgIC8vIG5lZWRlZCB0byBjb3JyZWN0bHkgZm9ybWF0IHJlc3BvbnNlc1xuICAgIHZhciB2ZXJib3NlX21vZGUgPSBvcHRpb25zLnZlcmJvc2U7XG4gICAgaWYgKGRhdGFbJ3ZlcmJvc2UnXSkgeyB2ZXJib3NlX21vZGUgPSB0cnVlOyB9XG5cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCd0ZXN0JykpIHsgZGF0YVsndGVzdCddID0gMTsgfVxuICAgIGlmICh2ZXJib3NlX21vZGUpIHsgZGF0YVsndmVyYm9zZSddID0gMTsgfVxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ2ltZycpKSB7IGRhdGFbJ2ltZyddID0gMTsgfVxuICAgIGlmICghVVNFX1hIUikge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGRhdGFbJ2NhbGxiYWNrJ10gPSBjYWxsYmFjaztcbiAgICAgICAgfSBlbHNlIGlmICh2ZXJib3NlX21vZGUgfHwgdGhpcy5nZXRfY29uZmlnKCd0ZXN0JykpIHtcbiAgICAgICAgICAgIC8vIFZlcmJvc2Ugb3V0cHV0IChmcm9tIHZlcmJvc2UgbW9kZSwgb3IgYW4gZXJyb3IgaW4gdGVzdCBtb2RlKSBpcyBhIGpzb24gYmxvYixcbiAgICAgICAgICAgIC8vIHdoaWNoIGJ5IGl0c2VsZiBpcyBub3QgdmFsaWQgamF2YXNjcmlwdC4gV2l0aG91dCBhIGNhbGxiYWNrLCB0aGlzIHZlcmJvc2Ugb3V0cHV0IHdpbGxcbiAgICAgICAgICAgIC8vIGNhdXNlIGFuIGVycm9yIHdoZW4gcmV0dXJuZWQgdmlhIGpzb25wLCBzbyB3ZSBmb3JjZSBhIG5vLW9wIGNhbGxiYWNrIHBhcmFtLlxuICAgICAgICAgICAgLy8gU2VlIHRoZSBFQ01BIHNjcmlwdCBzcGVjOiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtMTIuNFxuICAgICAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9ICcoZnVuY3Rpb24oKXt9KSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkYXRhWydpcCddID0gdGhpcy5nZXRfY29uZmlnKCdpcCcpPzE6MDtcbiAgICBkYXRhWydfJ10gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKS50b1N0cmluZygpO1xuXG4gICAgaWYgKHVzZV9wb3N0KSB7XG4gICAgICAgIGJvZHlfZGF0YSA9ICdkYXRhPScgKyBlbmNvZGVVUklDb21wb25lbnQoZGF0YVsnZGF0YSddKTtcbiAgICAgICAgZGVsZXRlIGRhdGFbJ2RhdGEnXTtcbiAgICB9XG5cbiAgICBfLmV4dGVuZChkYXRhLCB0aGlzLmdldF9jb25maWcoJ2FwaV9leHRyYV9xdWVyeV9wYXJhbXMnKSk7XG5cbiAgICB1cmwgKz0gJz8nICsgXy5IVFRQQnVpbGRRdWVyeShkYXRhKTtcblxuICAgIHZhciBsaWIgPSB0aGlzO1xuICAgIGlmICgnaW1nJyBpbiBkYXRhKSB7XG4gICAgICAgIHZhciBpbWcgPSBkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgICAgICBkb2N1bWVudCQxLmJvZHkuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICB9IGVsc2UgaWYgKHVzZV9zZW5kQmVhY29uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdWNjZWVkZWQgPSBzZW5kQmVhY29uKHVybCwgYm9keV9kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGliLnJlcG9ydF9lcnJvcihlKTtcbiAgICAgICAgICAgIHN1Y2NlZWRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhzdWNjZWVkZWQgPyAxIDogMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxpYi5yZXBvcnRfZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFVTRV9YSFIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHJlcS5vcGVuKG9wdGlvbnMubWV0aG9kLCB1cmwsIHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHRoaXMuZ2V0X2NvbmZpZygneGhyX2hlYWRlcnMnKTtcbiAgICAgICAgICAgIGlmICh1c2VfcG9zdCkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLmVhY2goaGVhZGVycywgZnVuY3Rpb24oaGVhZGVyVmFsdWUsIGhlYWRlck5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lLCBoZWFkZXJWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGltZW91dF9tcyAmJiB0eXBlb2YgcmVxLnRpbWVvdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVxLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXRfbXM7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0X3RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VuZCB0aGUgbXBfb3B0b3V0IGNvb2tpZVxuICAgICAgICAgICAgLy8gd2l0aENyZWRlbnRpYWxzIGNhbm5vdCBiZSBtb2RpZmllZCB1bnRpbCBhZnRlciBjYWxsaW5nIC5vcGVuIG9uIEFuZHJvaWQgYW5kIE1vYmlsZSBTYWZhcmlcbiAgICAgICAgICAgIHJlcS53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT09IDQpIHsgLy8gWE1MSHR0cFJlcXVlc3QuRE9ORSA9PSA0LCBleGNlcHQgaW4gc2FmYXJpIDRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2VfbW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF8uSlNPTkRlY29kZShyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGliLnJlcG9ydF9lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmlnbm9yZV9qc29uX2Vycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVxLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhOdW1iZXIocmVxLnJlc3BvbnNlVGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudGltZW91dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFyZXEuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydF90aW1lID49IHJlcS50aW1lb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9ICd0aW1lb3V0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSAnQmFkIEhUVFAgc3RhdHVzOiAnICsgcmVxLnN0YXR1cyArICcgJyArIHJlcS5zdGF0dXNUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGliLnJlcG9ydF9lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVyYm9zZV9tb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZV9oZWFkZXJzID0gcmVxWydyZXNwb25zZUhlYWRlcnMnXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soe3N0YXR1czogMCwgaHR0cFN0YXR1c0NvZGU6IHJlcVsnc3RhdHVzJ10sIGVycm9yOiBlcnJvciwgcmV0cnlBZnRlcjogcmVzcG9uc2VfaGVhZGVyc1snUmV0cnktQWZ0ZXInXX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXEuc2VuZChib2R5X2RhdGEpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsaWIucmVwb3J0X2Vycm9yKGUpO1xuICAgICAgICAgICAgc3VjY2VlZGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0LmRlZmVyID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0LnNyYyA9IHVybDtcbiAgICAgICAgdmFyIHMgPSBkb2N1bWVudCQxLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgICAgICAgcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIHMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWNjZWVkZWQ7XG59O1xuXG4vKipcbiAqIF9leGVjdXRlX2FycmF5KCkgZGVhbHMgd2l0aCBwcm9jZXNzaW5nIGFueSBtaXhwYW5lbCBmdW5jdGlvblxuICogY2FsbHMgdGhhdCB3ZXJlIGNhbGxlZCBiZWZvcmUgdGhlIE1peHBhbmVsIGxpYnJhcnkgd2VyZSBsb2FkZWRcbiAqIChhbmQgYXJlIHRodXMgc3RvcmVkIGluIGFuIGFycmF5IHNvIHRoZXkgY2FuIGJlIGNhbGxlZCBsYXRlcilcbiAqXG4gKiBOb3RlOiB3ZSBmaXJlIG9mZiBhbGwgdGhlIG1peHBhbmVsIGZ1bmN0aW9uIGNhbGxzICYmIHVzZXIgZGVmaW5lZFxuICogZnVuY3Rpb25zIEJFRk9SRSB3ZSBmaXJlIG9mZiBtaXhwYW5lbCB0cmFja2luZyBjYWxscy4gVGhpcyBpcyBzb1xuICogaWRlbnRpZnkvcmVnaXN0ZXIvc2V0X2NvbmZpZyBjYWxscyBjYW4gcHJvcGVybHkgbW9kaWZ5IGVhcmx5XG4gKiB0cmFja2luZyBjYWxscy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2V4ZWN1dGVfYXJyYXkgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBmbl9uYW1lLCBhbGlhc19jYWxscyA9IFtdLCBvdGhlcl9jYWxscyA9IFtdLCB0cmFja2luZ19jYWxscyA9IFtdO1xuICAgIF8uZWFjaChhcnJheSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgZm5fbmFtZSA9IGl0ZW1bMF07XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KGZuX25hbWUpKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tpbmdfY2FsbHMucHVzaChpdGVtKTsgLy8gY2hhaW5lZCBjYWxsIGUuZy4gbWl4cGFuZWwuZ2V0X2dyb3VwKCkuc2V0KClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGl0ZW0pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzQXJyYXkoaXRlbSkgJiYgZm5fbmFtZSA9PT0gJ2FsaWFzJykge1xuICAgICAgICAgICAgICAgIGFsaWFzX2NhbGxzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNBcnJheShpdGVtKSAmJiBmbl9uYW1lLmluZGV4T2YoJ3RyYWNrJykgIT09IC0xICYmIHR5cGVvZih0aGlzW2ZuX25hbWVdKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRyYWNraW5nX2NhbGxzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG90aGVyX2NhbGxzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHZhciBleGVjdXRlID0gZnVuY3Rpb24oY2FsbHMsIGNvbnRleHQpIHtcbiAgICAgICAgXy5lYWNoKGNhbGxzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KGl0ZW1bMF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hhaW5lZCBjYWxsXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxlciA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGl0ZW0sIGZ1bmN0aW9uKGNhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVyID0gY2FsbGVyW2NhbGxbMF1dLmFwcGx5KGNhbGxlciwgY2FsbC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbaXRlbVswXV0uYXBwbHkodGhpcywgaXRlbS5zbGljZSgxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNvbnRleHQpO1xuICAgIH07XG5cbiAgICBleGVjdXRlKGFsaWFzX2NhbGxzLCB0aGlzKTtcbiAgICBleGVjdXRlKG90aGVyX2NhbGxzLCB0aGlzKTtcbiAgICBleGVjdXRlKHRyYWNraW5nX2NhbGxzLCB0aGlzKTtcbn07XG5cbi8vIHJlcXVlc3QgcXVldWVpbmcgdXRpbHNcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLmFyZV9iYXRjaGVyc19pbml0aWFsaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMucmVxdWVzdF9iYXRjaGVycy5ldmVudHM7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2JhdGNoZXJfY29uZmlncyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBxdWV1ZV9wcmVmaXggPSAnX19tcHFfJyArIHRoaXMuZ2V0X2NvbmZpZygndG9rZW4nKTtcbiAgICB2YXIgYXBpX3JvdXRlcyA9IHRoaXMuZ2V0X2NvbmZpZygnYXBpX3JvdXRlcycpO1xuICAgIHRoaXMuX2JhdGNoZXJfY29uZmlncyA9IHRoaXMuX2JhdGNoZXJfY29uZmlncyB8fCB7XG4gICAgICAgIGV2ZW50czoge3R5cGU6ICdldmVudHMnLCBlbmRwb2ludDogJy8nICsgYXBpX3JvdXRlc1sndHJhY2snXSwgcXVldWVfa2V5OiBxdWV1ZV9wcmVmaXggKyAnX2V2J30sXG4gICAgICAgIHBlb3BsZToge3R5cGU6ICdwZW9wbGUnLCBlbmRwb2ludDogJy8nICsgYXBpX3JvdXRlc1snZW5nYWdlJ10sIHF1ZXVlX2tleTogcXVldWVfcHJlZml4ICsgJ19wcCd9LFxuICAgICAgICBncm91cHM6IHt0eXBlOiAnZ3JvdXBzJywgZW5kcG9pbnQ6ICcvJyArIGFwaV9yb3V0ZXNbJ2dyb3VwcyddLCBxdWV1ZV9rZXk6IHF1ZXVlX3ByZWZpeCArICdfZ3InfVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2JhdGNoZXJfY29uZmlncztcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5pbml0X2JhdGNoZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmFyZV9iYXRjaGVyc19pbml0aWFsaXplZCgpKSB7XG4gICAgICAgIHZhciBiYXRjaGVyX2ZvciA9IF8uYmluZChmdW5jdGlvbihhdHRycykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0QmF0Y2hlcihcbiAgICAgICAgICAgICAgICBhdHRycy5xdWV1ZV9rZXksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsaWJDb25maWc6IHRoaXNbJ2NvbmZpZyddLFxuICAgICAgICAgICAgICAgICAgICBlcnJvclJlcG9ydGVyOiB0aGlzLmdldF9jb25maWcoJ2Vycm9yX3JlcG9ydGVyJyksXG4gICAgICAgICAgICAgICAgICAgIHNlbmRSZXF1ZXN0RnVuYzogXy5iaW5kKGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZW5kX3JlcXVlc3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRfY29uZmlnKCdhcGlfaG9zdCcpICsgYXR0cnMuZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5jb2RlX2RhdGFfZm9yX3JlcXVlc3QoZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmVwYXJlX2NhbGxiYWNrKGNiLCBkYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZVNlbmRIb29rOiBfLmJpbmQoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3J1bl9ob29rKCdiZWZvcmVfc2VuZF8nICsgYXR0cnMudHlwZSwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBzdG9wQWxsQmF0Y2hpbmdGdW5jOiBfLmJpbmQodGhpcy5zdG9wX2JhdGNoX3NlbmRlcnMsIHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICB1c2VQZXJzaXN0ZW5jZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgdmFyIGJhdGNoZXJfY29uZmlncyA9IHRoaXMuZ2V0X2JhdGNoZXJfY29uZmlncygpO1xuICAgICAgICB0aGlzLnJlcXVlc3RfYmF0Y2hlcnMgPSB7XG4gICAgICAgICAgICBldmVudHM6IGJhdGNoZXJfZm9yKGJhdGNoZXJfY29uZmlncy5ldmVudHMpLFxuICAgICAgICAgICAgcGVvcGxlOiBiYXRjaGVyX2ZvcihiYXRjaGVyX2NvbmZpZ3MucGVvcGxlKSxcbiAgICAgICAgICAgIGdyb3VwczogYmF0Y2hlcl9mb3IoYmF0Y2hlcl9jb25maWdzLmdyb3VwcylcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnYmF0Y2hfYXV0b3N0YXJ0JykpIHtcbiAgICAgICAgdGhpcy5zdGFydF9iYXRjaF9zZW5kZXJzKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0YXJ0X2JhdGNoX3NlbmRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9iYXRjaGVyc193ZXJlX3N0YXJ0ZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLmFyZV9iYXRjaGVyc19pbml0aWFsaXplZCgpKSB7XG4gICAgICAgIHRoaXMuX2JhdGNoX3JlcXVlc3RzID0gdHJ1ZTtcbiAgICAgICAgXy5lYWNoKHRoaXMucmVxdWVzdF9iYXRjaGVycywgZnVuY3Rpb24oYmF0Y2hlcikge1xuICAgICAgICAgICAgYmF0Y2hlci5zdGFydCgpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RvcF9iYXRjaF9zZW5kZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYmF0Y2hfcmVxdWVzdHMgPSBmYWxzZTtcbiAgICBfLmVhY2godGhpcy5yZXF1ZXN0X2JhdGNoZXJzLCBmdW5jdGlvbihiYXRjaGVyKSB7XG4gICAgICAgIGJhdGNoZXIuc3RvcCgpO1xuICAgICAgICBiYXRjaGVyLmNsZWFyKCk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIHB1c2goKSBrZWVwcyB0aGUgc3RhbmRhcmQgYXN5bmMtYXJyYXktcHVzaFxuICogYmVoYXZpb3IgYXJvdW5kIGFmdGVyIHRoZSBsaWIgaXMgbG9hZGVkLlxuICogVGhpcyBpcyBvbmx5IHVzZWZ1bCBmb3IgZXh0ZXJuYWwgaW50ZWdyYXRpb25zIHRoYXRcbiAqIGRvIG5vdCB3aXNoIHRvIHJlbHkgb24gb3VyIGNvbnZlbmllbmNlIG1ldGhvZHNcbiAqIChjcmVhdGVkIGluIHRoZSBzbmlwcGV0KS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKiAgICAgbWl4cGFuZWwucHVzaChbJ3JlZ2lzdGVyJywgeyBhOiAnYicgfV0pO1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW0gQSBbZnVuY3Rpb25fbmFtZSwgYXJncy4uLl0gYXJyYXkgdG8gYmUgZXhlY3V0ZWRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgdGhpcy5fZXhlY3V0ZV9hcnJheShbaXRlbV0pO1xufTtcblxuLyoqXG4gKiBEaXNhYmxlIGV2ZW50cyBvbiB0aGUgTWl4cGFuZWwgb2JqZWN0LiBJZiBwYXNzZWQgbm8gYXJndW1lbnRzLFxuICogdGhpcyBmdW5jdGlvbiBkaXNhYmxlcyB0cmFja2luZyBvZiBhbnkgZXZlbnQuIElmIHBhc3NlZCBhblxuICogYXJyYXkgb2YgZXZlbnQgbmFtZXMsIHRob3NlIGV2ZW50cyB3aWxsIGJlIGRpc2FibGVkLCBidXQgb3RoZXJcbiAqIGV2ZW50cyB3aWxsIGNvbnRpbnVlIHRvIGJlIHRyYWNrZWQuXG4gKlxuICogTm90ZTogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzdG9wIG90aGVyIG1peHBhbmVsIGZ1bmN0aW9ucyBmcm9tXG4gKiBmaXJpbmcsIHN1Y2ggYXMgcmVnaXN0ZXIoKSBvciBwZW9wbGUuc2V0KCkuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gW2V2ZW50c10gQW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMgdG8gZGlzYWJsZVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKGV2ZW50cykge1xuICAgIGlmICh0eXBlb2YoZXZlbnRzKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fZmxhZ3MuZGlzYWJsZV9hbGxfZXZlbnRzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fZGlzYWJsZWRfZXZlbnRzID0gdGhpcy5fX2Rpc2FibGVkX2V2ZW50cy5jb25jYXQoZXZlbnRzKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2VuY29kZV9kYXRhX2Zvcl9yZXF1ZXN0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBlbmNvZGVkX2RhdGEgPSBKU09OU3RyaW5naWZ5KGRhdGEpO1xuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ2FwaV9wYXlsb2FkX2Zvcm1hdCcpID09PSBQQVlMT0FEX1RZUEVfQkFTRTY0KSB7XG4gICAgICAgIGVuY29kZWRfZGF0YSA9IF8uYmFzZTY0RW5jb2RlKGVuY29kZWRfZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB7J2RhdGEnOiBlbmNvZGVkX2RhdGF9O1xufTtcblxuLy8gaW50ZXJuYWwgbWV0aG9kIGZvciBoYW5kbGluZyB0cmFjayB2cyBiYXRjaC1lbnF1ZXVlIGxvZ2ljXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3RyYWNrX29yX2JhdGNoID0gZnVuY3Rpb24ob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgdHJ1bmNhdGVkX2RhdGEgPSBfLnRydW5jYXRlKG9wdGlvbnMuZGF0YSwgMjU1KTtcbiAgICB2YXIgZW5kcG9pbnQgPSBvcHRpb25zLmVuZHBvaW50O1xuICAgIHZhciBiYXRjaGVyID0gb3B0aW9ucy5iYXRjaGVyO1xuICAgIHZhciBzaG91bGRfc2VuZF9pbW1lZGlhdGVseSA9IG9wdGlvbnMuc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHk7XG4gICAgdmFyIHNlbmRfcmVxdWVzdF9vcHRpb25zID0gb3B0aW9ucy5zZW5kX3JlcXVlc3Rfb3B0aW9ucyB8fCB7fTtcbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IE5PT1BfRlVOQztcblxuICAgIHZhciByZXF1ZXN0X2VucXVldWVkX29yX2luaXRpYXRlZCA9IHRydWU7XG4gICAgdmFyIHNlbmRfcmVxdWVzdF9pbW1lZGlhdGVseSA9IF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFzZW5kX3JlcXVlc3Rfb3B0aW9ucy5za2lwX2hvb2tzKSB7XG4gICAgICAgICAgICB0cnVuY2F0ZWRfZGF0YSA9IHRoaXMuX3J1bl9ob29rKCdiZWZvcmVfc2VuZF8nICsgb3B0aW9ucy50eXBlLCB0cnVuY2F0ZWRfZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRydW5jYXRlZF9kYXRhKSB7XG4gICAgICAgICAgICBjb25zb2xlJDEubG9nKCdNSVhQQU5FTCBSRVFVRVNUOicpO1xuICAgICAgICAgICAgY29uc29sZSQxLmxvZyh0cnVuY2F0ZWRfZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KFxuICAgICAgICAgICAgICAgIGVuZHBvaW50LFxuICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kZV9kYXRhX2Zvcl9yZXF1ZXN0KHRydW5jYXRlZF9kYXRhKSxcbiAgICAgICAgICAgICAgICBzZW5kX3JlcXVlc3Rfb3B0aW9ucyxcbiAgICAgICAgICAgICAgICB0aGlzLl9wcmVwYXJlX2NhbGxiYWNrKGNhbGxiYWNrLCB0cnVuY2F0ZWRfZGF0YSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuX2JhdGNoX3JlcXVlc3RzICYmICFzaG91bGRfc2VuZF9pbW1lZGlhdGVseSkge1xuICAgICAgICBiYXRjaGVyLmVucXVldWUodHJ1bmNhdGVkX2RhdGEpLnRoZW4oZnVuY3Rpb24oc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICBpZiAoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soMSwgdHJ1bmNhdGVkX2RhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZW5kX3JlcXVlc3RfaW1tZWRpYXRlbHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdF9lbnF1ZXVlZF9vcl9pbml0aWF0ZWQgPSBzZW5kX3JlcXVlc3RfaW1tZWRpYXRlbHkoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVxdWVzdF9lbnF1ZXVlZF9vcl9pbml0aWF0ZWQgJiYgdHJ1bmNhdGVkX2RhdGE7XG59O1xuXG4vKipcbiAqIFRyYWNrIGFuIGV2ZW50LiBUaGlzIGlzIHRoZSBtb3N0IGltcG9ydGFudCBhbmRcbiAqIGZyZXF1ZW50bHkgdXNlZCBNaXhwYW5lbCBmdW5jdGlvbi5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHRyYWNrIGFuIGV2ZW50IG5hbWVkICdSZWdpc3RlcmVkJ1xuICogICAgIG1peHBhbmVsLnRyYWNrKCdSZWdpc3RlcmVkJywgeydHZW5kZXInOiAnTWFsZScsICdBZ2UnOiAyMX0pO1xuICpcbiAqICAgICAvLyB0cmFjayBhbiBldmVudCB1c2luZyBuYXZpZ2F0b3Iuc2VuZEJlYWNvblxuICogICAgIG1peHBhbmVsLnRyYWNrKCdMZWZ0IHBhZ2UnLCB7J2R1cmF0aW9uX3NlY29uZHMnOiAzNX0sIHt0cmFuc3BvcnQ6ICdzZW5kQmVhY29uJ30pO1xuICpcbiAqIFRvIHRyYWNrIGxpbmsgY2xpY2tzIG9yIGZvcm0gc3VibWlzc2lvbnMsIHNlZSB0cmFja19saW5rcygpIG9yIHRyYWNrX2Zvcm1zKCkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LiBUaGlzIGNhbiBiZSBhbnl0aGluZyB0aGUgdXNlciBkb2VzIC0gJ0J1dHRvbiBDbGljaycsICdTaWduIFVwJywgJ0l0ZW0gUHVyY2hhc2VkJywgZXRjLlxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBBIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgd2l0aCB0aGUgZXZlbnQgeW91J3JlIHNlbmRpbmcuIFRoZXNlIGRlc2NyaWJlIHRoZSB1c2VyIHdobyBkaWQgdGhlIGV2ZW50IG9yIGRldGFpbHMgYWJvdXQgdGhlIGV2ZW50IGl0c2VsZi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uYWwgY29uZmlndXJhdGlvbiBmb3IgdGhpcyB0cmFjayByZXF1ZXN0LlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnRyYW5zcG9ydF0gVHJhbnNwb3J0IG1ldGhvZCBmb3IgbmV0d29yayByZXF1ZXN0ICgneGhyJyBvciAnc2VuZEJlYWNvbicpLlxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZW5kX2ltbWVkaWF0ZWx5XSBXaGV0aGVyIHRvIGJ5cGFzcyBiYXRjaGluZy9xdWV1ZWluZyBhbmQgc2VuZCB0cmFjayByZXF1ZXN0IGltbWVkaWF0ZWx5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqIEByZXR1cm5zIHtCb29sZWFufE9iamVjdH0gSWYgdGhlIHRyYWNraW5nIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWxseSBpbml0aWF0ZWQvcXVldWVkLCBhbiBvYmplY3RcbiAqIHdpdGggdGhlIHRyYWNraW5nIHBheWxvYWQgc2VudCB0byB0aGUgQVBJIHNlcnZlciBpcyByZXR1cm5lZDsgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2sgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGV2ZW50X25hbWUsIHByb3BlcnRpZXMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFjYWxsYmFjayAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgdHJhbnNwb3J0ID0gb3B0aW9uc1sndHJhbnNwb3J0J107IC8vIGV4dGVybmFsIEFQSSwgZG9uJ3QgbWluaWZ5ICd0cmFuc3BvcnQnIHByb3BcbiAgICBpZiAodHJhbnNwb3J0KSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNwb3J0ID0gdHJhbnNwb3J0OyAvLyAndHJhbnNwb3J0JyBwcm9wIG5hbWUgY2FuIGJlIG1pbmlmaWVkIGludGVybmFsbHlcbiAgICB9XG4gICAgdmFyIHNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5ID0gb3B0aW9uc1snc2VuZF9pbW1lZGlhdGVseSddO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBOT09QX0ZVTkM7XG4gICAgfVxuXG4gICAgaWYgKF8uaXNVbmRlZmluZWQoZXZlbnRfbmFtZSkpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ05vIGV2ZW50IG5hbWUgcHJvdmlkZWQgdG8gbWl4cGFuZWwudHJhY2snKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudF9pc19kaXNhYmxlZChldmVudF9uYW1lKSkge1xuICAgICAgICBjYWxsYmFjaygwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNldCBkZWZhdWx0c1xuICAgIHByb3BlcnRpZXMgPSBfLmV4dGVuZCh7fSwgcHJvcGVydGllcyk7XG4gICAgcHJvcGVydGllc1sndG9rZW4nXSA9IHRoaXMuZ2V0X2NvbmZpZygndG9rZW4nKTtcblxuICAgIC8vIHNldCAkZHVyYXRpb24gaWYgdGltZV9ldmVudCB3YXMgcHJldmlvdXNseSBjYWxsZWQgZm9yIHRoaXMgZXZlbnRcbiAgICB2YXIgc3RhcnRfdGltZXN0YW1wID0gdGhpc1sncGVyc2lzdGVuY2UnXS5yZW1vdmVfZXZlbnRfdGltZXIoZXZlbnRfbmFtZSk7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHN0YXJ0X3RpbWVzdGFtcCkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uX2luX21zID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydF90aW1lc3RhbXA7XG4gICAgICAgIHByb3BlcnRpZXNbJyRkdXJhdGlvbiddID0gcGFyc2VGbG9hdCgoZHVyYXRpb25faW5fbXMgLyAxMDAwKS50b0ZpeGVkKDMpKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRfZGVmYXVsdF9zdXBlcnByb3BzKCk7XG5cbiAgICB2YXIgbWFya2V0aW5nX3Byb3BlcnRpZXMgPSB0aGlzLmdldF9jb25maWcoJ3RyYWNrX21hcmtldGluZycpXG4gICAgICAgID8gXy5pbmZvLm1hcmtldGluZ1BhcmFtcygpXG4gICAgICAgIDoge307XG5cbiAgICAvLyBub3RlOiBleHRlbmQgd3JpdGVzIHRvIHRoZSBmaXJzdCBvYmplY3QsIHNvIGxldHMgbWFrZSBzdXJlIHdlXG4gICAgLy8gZG9uJ3Qgd3JpdGUgdG8gdGhlIHBlcnNpc3RlbmNlIHByb3BlcnRpZXMgb2JqZWN0IGFuZCBpbmZvXG4gICAgLy8gcHJvcGVydGllcyBvYmplY3QgYnkgcGFzc2luZyBpbiBhIG5ldyBvYmplY3RcblxuICAgIC8vIHVwZGF0ZSBwcm9wZXJ0aWVzIHdpdGggcGFnZXZpZXcgaW5mbyBhbmQgc3VwZXItcHJvcGVydGllc1xuICAgIHByb3BlcnRpZXMgPSBfLmV4dGVuZChcbiAgICAgICAge30sXG4gICAgICAgIF8uaW5mby5wcm9wZXJ0aWVzKHsnbXBfbG9hZGVyJzogdGhpcy5nZXRfY29uZmlnKCdtcF9sb2FkZXInKX0pLFxuICAgICAgICBtYXJrZXRpbmdfcHJvcGVydGllcyxcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS5wcm9wZXJ0aWVzKCksXG4gICAgICAgIHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wcyxcbiAgICAgICAgdGhpcy5nZXRfc2Vzc2lvbl9yZWNvcmRpbmdfcHJvcGVydGllcygpLFxuICAgICAgICBwcm9wZXJ0aWVzXG4gICAgKTtcblxuICAgIHZhciBwcm9wZXJ0eV9ibGFja2xpc3QgPSB0aGlzLmdldF9jb25maWcoJ3Byb3BlcnR5X2JsYWNrbGlzdCcpO1xuICAgIGlmIChfLmlzQXJyYXkocHJvcGVydHlfYmxhY2tsaXN0KSkge1xuICAgICAgICBfLmVhY2gocHJvcGVydHlfYmxhY2tsaXN0LCBmdW5jdGlvbihibGFja2xpc3RlZF9wcm9wKSB7XG4gICAgICAgICAgICBkZWxldGUgcHJvcGVydGllc1tibGFja2xpc3RlZF9wcm9wXTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ0ludmFsaWQgdmFsdWUgZm9yIHByb3BlcnR5X2JsYWNrbGlzdCBjb25maWc6ICcgKyBwcm9wZXJ0eV9ibGFja2xpc3QpO1xuICAgIH1cblxuICAgIHZhciBkYXRhID0ge1xuICAgICAgICAnZXZlbnQnOiBldmVudF9uYW1lLFxuICAgICAgICAncHJvcGVydGllcyc6IHByb3BlcnRpZXNcbiAgICB9O1xuICAgIHZhciByZXQgPSB0aGlzLl90cmFja19vcl9iYXRjaCh7XG4gICAgICAgIHR5cGU6ICdldmVudHMnLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBlbmRwb2ludDogdGhpcy5nZXRfY29uZmlnKCdhcGlfaG9zdCcpICsgJy8nICsgdGhpcy5nZXRfY29uZmlnKCdhcGlfcm91dGVzJylbJ3RyYWNrJ10sXG4gICAgICAgIGJhdGNoZXI6IHRoaXMucmVxdWVzdF9iYXRjaGVycy5ldmVudHMsXG4gICAgICAgIHNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5OiBzaG91bGRfc2VuZF9pbW1lZGlhdGVseSxcbiAgICAgICAgc2VuZF9yZXF1ZXN0X29wdGlvbnM6IG9wdGlvbnNcbiAgICB9LCBjYWxsYmFjayk7XG5cbiAgICByZXR1cm4gcmV0O1xufSk7XG5cbi8qKlxuICogUmVnaXN0ZXIgdGhlIGN1cnJlbnQgdXNlciBpbnRvIG9uZS9tYW55IGdyb3Vwcy5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgICBtaXhwYW5lbC5zZXRfZ3JvdXAoJ2NvbXBhbnknLCBbJ21peHBhbmVsJywgJ2dvb2dsZSddKSAvLyBhbiBhcnJheSBvZiBJRHNcbiAqICAgICAgbWl4cGFuZWwuc2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJylcbiAqICAgICAgbWl4cGFuZWwuc2V0X2dyb3VwKCdjb21wYW55JywgMTI4NzQ2MzEyKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cF9rZXkgR3JvdXAga2V5XG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ3xOdW1iZXJ9IGdyb3VwX2lkcyBBbiBhcnJheSBvZiBncm91cCBJRHMsIG9yIGEgc2luZ3VsYXIgZ3JvdXAgSURcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc2V0X2dyb3VwID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihncm91cF9rZXksIGdyb3VwX2lkcywgY2FsbGJhY2spIHtcbiAgICBpZiAoIV8uaXNBcnJheShncm91cF9pZHMpKSB7XG4gICAgICAgIGdyb3VwX2lkcyA9IFtncm91cF9pZHNdO1xuICAgIH1cbiAgICB2YXIgcHJvcCA9IHt9O1xuICAgIHByb3BbZ3JvdXBfa2V5XSA9IGdyb3VwX2lkcztcbiAgICB0aGlzLnJlZ2lzdGVyKHByb3ApO1xuICAgIHJldHVybiB0aGlzWydwZW9wbGUnXS5zZXQoZ3JvdXBfa2V5LCBncm91cF9pZHMsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIEFkZCBhIG5ldyBncm91cCBmb3IgdGhpcyB1c2VyLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgIG1peHBhbmVsLmFkZF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwX2tleSBHcm91cCBrZXlcbiAqIEBwYXJhbSB7Kn0gZ3JvdXBfaWQgQSB2YWxpZCBNaXhwYW5lbCBwcm9wZXJ0eSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuYWRkX2dyb3VwID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihncm91cF9rZXksIGdyb3VwX2lkLCBjYWxsYmFjaykge1xuICAgIHZhciBvbGRfdmFsdWVzID0gdGhpcy5nZXRfcHJvcGVydHkoZ3JvdXBfa2V5KTtcbiAgICB2YXIgcHJvcCA9IHt9O1xuICAgIGlmIChvbGRfdmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcFtncm91cF9rZXldID0gW2dyb3VwX2lkXTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcihwcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob2xkX3ZhbHVlcy5pbmRleE9mKGdyb3VwX2lkKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG9sZF92YWx1ZXMucHVzaChncm91cF9pZCk7XG4gICAgICAgICAgICBwcm9wW2dyb3VwX2tleV0gPSBvbGRfdmFsdWVzO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3Rlcihwcm9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1sncGVvcGxlJ10udW5pb24oZ3JvdXBfa2V5LCBncm91cF9pZCwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogUmVtb3ZlIGEgZ3JvdXAgZnJvbSB0aGlzIHVzZXIuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAgbWl4cGFuZWwucmVtb3ZlX2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJylcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBfa2V5IEdyb3VwIGtleVxuICogQHBhcmFtIHsqfSBncm91cF9pZCBBIHZhbGlkIE1peHBhbmVsIHByb3BlcnR5IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5yZW1vdmVfZ3JvdXAgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGdyb3VwX2tleSwgZ3JvdXBfaWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIG9sZF92YWx1ZSA9IHRoaXMuZ2V0X3Byb3BlcnR5KGdyb3VwX2tleSk7XG4gICAgLy8gaWYgdGhlIHZhbHVlIGRvZXNuJ3QgZXhpc3QsIHRoZSBwZXJzaXN0ZW50IHN0b3JlIGlzIHVuY2hhbmdlZFxuICAgIGlmIChvbGRfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgaWR4ID0gb2xkX3ZhbHVlLmluZGV4T2YoZ3JvdXBfaWQpO1xuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgICAgICAgIG9sZF92YWx1ZS5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIoe2dyb3VwX2tleTogb2xkX3ZhbHVlfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZF92YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3Rlcihncm91cF9rZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzWydwZW9wbGUnXS5yZW1vdmUoZ3JvdXBfa2V5LCBncm91cF9pZCwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogVHJhY2sgYW4gZXZlbnQgd2l0aCBzcGVjaWZpYyBncm91cHMuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAgbWl4cGFuZWwudHJhY2tfd2l0aF9ncm91cHMoJ3B1cmNoYXNlJywgeydwcm9kdWN0JzogJ2lwaG9uZSd9LCB7J1VuaXZlcnNpdHknOiBbJ1VDQicsICdVQ0xBJ119KVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCAoc2VlIGBtaXhwYW5lbC50cmFjaygpYClcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBBIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGluY2x1ZGUgd2l0aCB0aGUgZXZlbnQgeW91J3JlIHNlbmRpbmcgKHNlZSBgbWl4cGFuZWwudHJhY2soKWApXG4gKiBAcGFyYW0ge09iamVjdD19IGdyb3VwcyBBbiBvYmplY3QgbWFwcGluZyBncm91cCBuYW1lIGtleXMgdG8gb25lIG9yIG1vcmUgdmFsdWVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfd2l0aF9ncm91cHMgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliKGZ1bmN0aW9uKGV2ZW50X25hbWUsIHByb3BlcnRpZXMsIGdyb3VwcywgY2FsbGJhY2spIHtcbiAgICB2YXIgdHJhY2tpbmdfcHJvcHMgPSBfLmV4dGVuZCh7fSwgcHJvcGVydGllcyB8fCB7fSk7XG4gICAgXy5lYWNoKGdyb3VwcywgZnVuY3Rpb24odiwgaykge1xuICAgICAgICBpZiAodiAhPT0gbnVsbCAmJiB2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyYWNraW5nX3Byb3BzW2tdID0gdjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnRyYWNrKGV2ZW50X25hbWUsIHRyYWNraW5nX3Byb3BzLCBjYWxsYmFjayk7XG59KTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9jcmVhdGVfbWFwX2tleSA9IGZ1bmN0aW9uIChncm91cF9rZXksIGdyb3VwX2lkKSB7XG4gICAgcmV0dXJuIGdyb3VwX2tleSArICdfJyArIEpTT04uc3RyaW5naWZ5KGdyb3VwX2lkKTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fcmVtb3ZlX2dyb3VwX2Zyb21fY2FjaGUgPSBmdW5jdGlvbiAoZ3JvdXBfa2V5LCBncm91cF9pZCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWNoZWRfZ3JvdXBzW3RoaXMuX2NyZWF0ZV9tYXBfa2V5KGdyb3VwX2tleSwgZ3JvdXBfaWQpXTtcbn07XG5cbi8qKlxuICogTG9vayB1cCByZWZlcmVuY2UgdG8gYSBNaXhwYW5lbCBncm91cFxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoZ3JvdXBfa2V5LCBncm91cF9pZClcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBfa2V5IEdyb3VwIGtleVxuICogQHBhcmFtIHtPYmplY3R9IGdyb3VwX2lkIEEgdmFsaWQgTWl4cGFuZWwgcHJvcGVydHkgdHlwZVxuICogQHJldHVybnMge09iamVjdH0gQSBNaXhwYW5lbEdyb3VwIGlkZW50aWZpZXJcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9ncm91cCA9IGZ1bmN0aW9uIChncm91cF9rZXksIGdyb3VwX2lkKSB7XG4gICAgdmFyIG1hcF9rZXkgPSB0aGlzLl9jcmVhdGVfbWFwX2tleShncm91cF9rZXksIGdyb3VwX2lkKTtcbiAgICB2YXIgZ3JvdXAgPSB0aGlzLl9jYWNoZWRfZ3JvdXBzW21hcF9rZXldO1xuICAgIGlmIChncm91cCA9PT0gdW5kZWZpbmVkIHx8IGdyb3VwLl9ncm91cF9rZXkgIT09IGdyb3VwX2tleSB8fCBncm91cC5fZ3JvdXBfaWQgIT09IGdyb3VwX2lkKSB7XG4gICAgICAgIGdyb3VwID0gbmV3IE1peHBhbmVsR3JvdXAoKTtcbiAgICAgICAgZ3JvdXAuX2luaXQodGhpcywgZ3JvdXBfa2V5LCBncm91cF9pZCk7XG4gICAgICAgIHRoaXMuX2NhY2hlZF9ncm91cHNbbWFwX2tleV0gPSBncm91cDtcbiAgICB9XG4gICAgcmV0dXJuIGdyb3VwO1xufTtcblxuLyoqXG4gKiBUcmFjayBhIGRlZmF1bHQgTWl4cGFuZWwgcGFnZSB2aWV3IGV2ZW50LCB3aGljaCBpbmNsdWRlcyBleHRyYSBkZWZhdWx0IGV2ZW50IHByb3BlcnRpZXMgdG9cbiAqIGltcHJvdmUgcGFnZSB2aWV3IGRhdGEuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyB0cmFjayBhIGRlZmF1bHQgJG1wX3dlYl9wYWdlX3ZpZXcgZXZlbnRcbiAqICAgICBtaXhwYW5lbC50cmFja19wYWdldmlldygpO1xuICpcbiAqICAgICAvLyB0cmFjayBhIHBhZ2UgdmlldyBldmVudCB3aXRoIGFkZGl0aW9uYWwgZXZlbnQgcHJvcGVydGllc1xuICogICAgIG1peHBhbmVsLnRyYWNrX3BhZ2V2aWV3KHsnYWJfdGVzdF92YXJpYW50JzogJ2NhcmQtbGF5b3V0LWInfSk7XG4gKlxuICogICAgIC8vIGV4YW1wbGUgYXBwcm9hY2ggdG8gdHJhY2sgcGFnZSB2aWV3cyBvbiBkaWZmZXJlbnQgcGFnZSB0eXBlcyBhcyBldmVudCBwcm9wZXJ0aWVzXG4gKiAgICAgbWl4cGFuZWwudHJhY2tfcGFnZXZpZXcoeydwYWdlJzogJ3ByaWNpbmcnfSk7XG4gKiAgICAgbWl4cGFuZWwudHJhY2tfcGFnZXZpZXcoeydwYWdlJzogJ2hvbWVwYWdlJ30pO1xuICpcbiAqICAgICAvLyBVTkNPTU1PTjogVHJhY2tpbmcgYSBwYWdlIHZpZXcgZXZlbnQgd2l0aCBhIGN1c3RvbSBldmVudF9uYW1lIG9wdGlvbi4gTk9UIGV4cGVjdGVkIHRvIGJlIHVzZWQgZm9yXG4gKiAgICAgLy8gaW5kaXZpZHVhbCBwYWdlcyBvbiB0aGUgc2FtZSBzaXRlIG9yIHByb2R1Y3QuIFVzZSBjYXNlcyBmb3IgY3VzdG9tIGV2ZW50X25hbWUgbWF5IGJlIHBhZ2VcbiAqICAgICAvLyB2aWV3cyBvbiBkaWZmZXJlbnQgcHJvZHVjdHMgb3IgaW50ZXJuYWwgYXBwbGljYXRpb25zIHRoYXQgYXJlIGNvbnNpZGVyZWQgY29tcGxldGVseSBzZXBhcmF0ZVxuICogICAgIG1peHBhbmVsLnRyYWNrX3BhZ2V2aWV3KHsncGFnZSc6ICdjdXN0b21lci1zZWFyY2gnfSwgeydldmVudF9uYW1lJzogJ1tpbnRlcm5hbF0gQWRtaW4gUGFnZSBWaWV3J30pO1xuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBUaGUgYGNvbmZpZy50cmFja19wYWdldmlld2Agb3B0aW9uIGZvciA8YSBocmVmPVwiI21peHBhbmVsaW5pdFwiPm1peHBhbmVsLmluaXQoKTwvYT5cbiAqIG1heSBiZSB0dXJuZWQgb24gZm9yIHRyYWNraW5nIHBhZ2UgbG9hZHMgYXV0b21hdGljYWxseS5cbiAqXG4gKiAgICAgLy8gdHJhY2sgb25seSBwYWdlIGxvYWRzXG4gKiAgICAgbWl4cGFuZWwuaW5pdChQUk9KRUNUX1RPS0VOLCB7dHJhY2tfcGFnZXZpZXc6IHRydWV9KTtcbiAqXG4gKiAgICAgLy8gdHJhY2sgd2hlbiB0aGUgVVJMIGNoYW5nZXMgaW4gYW55IG1hbm5lclxuICogICAgIG1peHBhbmVsLmluaXQoUFJPSkVDVF9UT0tFTiwge3RyYWNrX3BhZ2V2aWV3OiAnZnVsbC11cmwnfSk7XG4gKlxuICogICAgIC8vIHRyYWNrIHdoZW4gdGhlIFVSTCBjaGFuZ2VzLCBpZ25vcmluZyBhbnkgY2hhbmdlcyBpbiB0aGUgaGFzaCBwYXJ0XG4gKiAgICAgbWl4cGFuZWwuaW5pdChQUk9KRUNUX1RPS0VOLCB7dHJhY2tfcGFnZXZpZXc6ICd1cmwtd2l0aC1wYXRoLWFuZC1xdWVyeS1zdHJpbmcnfSk7XG4gKlxuICogICAgIC8vIHRyYWNrIHdoZW4gdGhlIHBhdGggY2hhbmdlcywgaWdub3JpbmcgYW55IHF1ZXJ5IHBhcmFtZXRlciBvciBoYXNoIGNoYW5nZXNcbiAqICAgICBtaXhwYW5lbC5pbml0KFBST0pFQ1RfVE9LRU4sIHt0cmFja19wYWdldmlldzogJ3VybC13aXRoLXBhdGgnfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBBbiBvcHRpb25hbCBzZXQgb2YgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIHNlbmQgd2l0aCB0aGUgcGFnZSB2aWV3IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFBhZ2UgdmlldyB0cmFja2luZyBvcHRpb25zXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuZXZlbnRfbmFtZV0gLSBBbHRlcm5hdGUgbmFtZSBmb3IgdGhlIHRyYWNraW5nIGV2ZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbnxPYmplY3R9IElmIHRoZSB0cmFja2luZyByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsbHkgaW5pdGlhdGVkL3F1ZXVlZCwgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSB0cmFja2luZyBwYXlsb2FkIHNlbnQgdG8gdGhlIEFQSSBzZXJ2ZXIgaXMgcmV0dXJuZWQ7IG90aGVyd2lzZSBmYWxzZS5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX3BhZ2V2aWV3ID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBldmVudF9uYW1lID0gb3B0aW9uc1snZXZlbnRfbmFtZSddIHx8ICckbXBfd2ViX3BhZ2Vfdmlldyc7XG5cbiAgICB2YXIgZGVmYXVsdF9wYWdlX3Byb3BlcnRpZXMgPSBfLmV4dGVuZChcbiAgICAgICAgXy5pbmZvLm1wUGFnZVZpZXdQcm9wZXJ0aWVzKCksXG4gICAgICAgIF8uaW5mby5jYW1wYWlnblBhcmFtcygpLFxuICAgICAgICBfLmluZm8uY2xpY2tQYXJhbXMoKVxuICAgICk7XG5cbiAgICB2YXIgZXZlbnRfcHJvcGVydGllcyA9IF8uZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgZGVmYXVsdF9wYWdlX3Byb3BlcnRpZXMsXG4gICAgICAgIHByb3BlcnRpZXNcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMudHJhY2soZXZlbnRfbmFtZSwgZXZlbnRfcHJvcGVydGllcyk7XG59KTtcblxuLyoqXG4gKiBUcmFjayBjbGlja3Mgb24gYSBzZXQgb2YgZG9jdW1lbnQgZWxlbWVudHMuIFNlbGVjdG9yIG11c3QgYmUgYVxuICogdmFsaWQgcXVlcnkuIEVsZW1lbnRzIG11c3QgZXhpc3Qgb24gdGhlIHBhZ2UgYXQgdGhlIHRpbWUgdHJhY2tfbGlua3MgaXMgY2FsbGVkLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gdHJhY2sgY2xpY2sgZm9yIGxpbmsgaWQgI25hdlxuICogICAgIG1peHBhbmVsLnRyYWNrX2xpbmtzKCcjbmF2JywgJ0NsaWNrZWQgTmF2IExpbmsnKTtcbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIHdhaXQgdXAgdG8gMzAwIG1zIGZvciB0aGUgTWl4cGFuZWxcbiAqIHNlcnZlcnMgdG8gcmVzcG9uZC4gSWYgdGhleSBoYXZlIG5vdCByZXNwb25kZWQgYnkgdGhhdCB0aW1lXG4gKiBpdCB3aWxsIGhlYWQgdG8gdGhlIGxpbmsgd2l0aG91dCBlbnN1cmluZyB0aGF0IHlvdXIgZXZlbnRcbiAqIGhhcyBiZWVuIHRyYWNrZWQuICBUbyBjb25maWd1cmUgdGhpcyB0aW1lb3V0IHBsZWFzZSBzZWUgdGhlXG4gKiBzZXRfY29uZmlnKCkgZG9jdW1lbnRhdGlvbiBiZWxvdy5cbiAqXG4gKiBJZiB5b3UgcGFzcyBhIGZ1bmN0aW9uIGluIGFzIHRoZSBwcm9wZXJ0aWVzIGFyZ3VtZW50LCB0aGVcbiAqIGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgRE9NRWxlbWVudCB0aGF0IHRyaWdnZXJlZCB0aGVcbiAqIGV2ZW50IGFzIGFuIGFyZ3VtZW50LiAgWW91IGFyZSBleHBlY3RlZCB0byByZXR1cm4gYW4gb2JqZWN0XG4gKiBmcm9tIHRoZSBmdW5jdGlvbjsgYW55IHByb3BlcnRpZXMgZGVmaW5lZCBvbiB0aGlzIG9iamVjdFxuICogd2lsbCBiZSBzZW50IHRvIG1peHBhbmVsIGFzIGV2ZW50IHByb3BlcnRpZXMuXG4gKlxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBxdWVyeSBBIHZhbGlkIERPTSBxdWVyeSwgZWxlbWVudCBvciBqUXVlcnktZXNxdWUgbGlzdFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHRyYWNrXG4gKiBAcGFyYW0ge09iamVjdHxGdW5jdGlvbn0gW3Byb3BlcnRpZXNdIEEgcHJvcGVydGllcyBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgZGljdGlvbmFyeSBvZiBwcm9wZXJ0aWVzIHdoZW4gcGFzc2VkIGEgRE9NRWxlbWVudFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfbGlua3MgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhY2tfZG9tLmNhbGwodGhpcywgTGlua1RyYWNrZXIsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIFRyYWNrIGZvcm0gc3VibWlzc2lvbnMuIFNlbGVjdG9yIG11c3QgYmUgYSB2YWxpZCBxdWVyeS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHRyYWNrIHN1Ym1pc3Npb24gZm9yIGZvcm0gaWQgJ3JlZ2lzdGVyJ1xuICogICAgIG1peHBhbmVsLnRyYWNrX2Zvcm1zKCcjcmVnaXN0ZXInLCAnQ3JlYXRlZCBBY2NvdW50Jyk7XG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCB3YWl0IHVwIHRvIDMwMCBtcyBmb3IgdGhlIG1peHBhbmVsXG4gKiBzZXJ2ZXJzIHRvIHJlc3BvbmQsIGlmIHRoZXkgaGF2ZSBub3QgcmVzcG9uZGVkIGJ5IHRoYXQgdGltZVxuICogaXQgd2lsbCBoZWFkIHRvIHRoZSBsaW5rIHdpdGhvdXQgZW5zdXJpbmcgdGhhdCB5b3VyIGV2ZW50XG4gKiBoYXMgYmVlbiB0cmFja2VkLiAgVG8gY29uZmlndXJlIHRoaXMgdGltZW91dCBwbGVhc2Ugc2VlIHRoZVxuICogc2V0X2NvbmZpZygpIGRvY3VtZW50YXRpb24gYmVsb3cuXG4gKlxuICogSWYgeW91IHBhc3MgYSBmdW5jdGlvbiBpbiBhcyB0aGUgcHJvcGVydGllcyBhcmd1bWVudCwgdGhlXG4gKiBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdGhlIERPTUVsZW1lbnQgdGhhdCB0cmlnZ2VyZWQgdGhlXG4gKiBldmVudCBhcyBhbiBhcmd1bWVudC4gIFlvdSBhcmUgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIG9iamVjdFxuICogZnJvbSB0aGUgZnVuY3Rpb247IGFueSBwcm9wZXJ0aWVzIGRlZmluZWQgb24gdGhpcyBvYmplY3RcbiAqIHdpbGwgYmUgc2VudCB0byBtaXhwYW5lbCBhcyBldmVudCBwcm9wZXJ0aWVzLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcXVlcnkgQSB2YWxpZCBET00gcXVlcnksIGVsZW1lbnQgb3IgalF1ZXJ5LWVzcXVlIGxpc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byB0cmFja1xuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IFtwcm9wZXJ0aWVzXSBUaGlzIGNhbiBiZSBhIHNldCBvZiBwcm9wZXJ0aWVzLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBwcm9wZXJ0aWVzIGFmdGVyIGJlaW5nIHBhc3NlZCBhIERPTUVsZW1lbnRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX2Zvcm1zID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWNrX2RvbS5jYWxsKHRoaXMsIEZvcm1UcmFja2VyLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBUaW1lIGFuIGV2ZW50IGJ5IGluY2x1ZGluZyB0aGUgdGltZSBiZXR3ZWVuIHRoaXMgY2FsbCBhbmQgYVxuICogbGF0ZXIgJ3RyYWNrJyBjYWxsIGZvciB0aGUgc2FtZSBldmVudCBpbiB0aGUgcHJvcGVydGllcyBzZW50XG4gKiB3aXRoIHRoZSBldmVudC5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHRpbWUgYW4gZXZlbnQgbmFtZWQgJ1JlZ2lzdGVyZWQnXG4gKiAgICAgbWl4cGFuZWwudGltZV9ldmVudCgnUmVnaXN0ZXJlZCcpO1xuICogICAgIG1peHBhbmVsLnRyYWNrKCdSZWdpc3RlcmVkJywgeydHZW5kZXInOiAnTWFsZScsICdBZ2UnOiAyMX0pO1xuICpcbiAqIFdoZW4gY2FsbGVkIGZvciBhIHBhcnRpY3VsYXIgZXZlbnQgbmFtZSwgdGhlIG5leHQgdHJhY2sgY2FsbCBmb3IgdGhhdCBldmVudFxuICogbmFtZSB3aWxsIGluY2x1ZGUgdGhlIGVsYXBzZWQgdGltZSBiZXR3ZWVuIHRoZSAndGltZV9ldmVudCcgYW5kICd0cmFjaydcbiAqIGNhbGxzLiBUaGlzIHZhbHVlIGlzIHN0b3JlZCBhcyBzZWNvbmRzIGluIHRoZSAnJGR1cmF0aW9uJyBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50aW1lX2V2ZW50ID0gZnVuY3Rpb24oZXZlbnRfbmFtZSkge1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKGV2ZW50X25hbWUpKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdObyBldmVudCBuYW1lIHByb3ZpZGVkIHRvIG1peHBhbmVsLnRpbWVfZXZlbnQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudF9pc19kaXNhYmxlZChldmVudF9uYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpc1sncGVyc2lzdGVuY2UnXS5zZXRfZXZlbnRfdGltZXIoZXZlbnRfbmFtZSwgIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbn07XG5cbnZhciBSRUdJU1RFUl9ERUZBVUxUUyA9IHtcbiAgICAncGVyc2lzdGVudCc6IHRydWVcbn07XG4vKipcbiAqIEhlbHBlciB0byBwYXJzZSBvcHRpb25zIHBhcmFtIGZvciByZWdpc3RlciBtZXRob2RzLCBtYWludGFpbmluZ1xuICogbGVnYWN5IHN1cHBvcnQgZm9yIHBsYWluIFwiZGF5c1wiIHBhcmFtIGluc3RlYWQgb2Ygb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gW2RheXNfb3Jfb3B0aW9uc10gJ2RheXMnIG9wdGlvbiAoTnVtYmVyKSwgb3IgT3B0aW9ucyBvYmplY3QgZm9yIHJlZ2lzdGVyIG1ldGhvZHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IG9wdGlvbnMgb2JqZWN0XG4gKi9cbnZhciBvcHRpb25zX2Zvcl9yZWdpc3RlciA9IGZ1bmN0aW9uKGRheXNfb3Jfb3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zO1xuICAgIGlmIChfLmlzT2JqZWN0KGRheXNfb3Jfb3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IGRheXNfb3Jfb3B0aW9ucztcbiAgICB9IGVsc2UgaWYgKCFfLmlzVW5kZWZpbmVkKGRheXNfb3Jfb3B0aW9ucykpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsnZGF5cyc6IGRheXNfb3Jfb3B0aW9uc307XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gXy5leHRlbmQoe30sIFJFR0lTVEVSX0RFRkFVTFRTLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXIgYSBzZXQgb2Ygc3VwZXIgcHJvcGVydGllcywgd2hpY2ggYXJlIGluY2x1ZGVkIHdpdGggYWxsXG4gKiBldmVudHMuIFRoaXMgd2lsbCBvdmVyd3JpdGUgcHJldmlvdXMgc3VwZXIgcHJvcGVydHkgdmFsdWVzLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgJ0dlbmRlcicgYXMgYSBzdXBlciBwcm9wZXJ0eVxuICogICAgIG1peHBhbmVsLnJlZ2lzdGVyKHsnR2VuZGVyJzogJ0ZlbWFsZSd9KTtcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgc2V2ZXJhbCBzdXBlciBwcm9wZXJ0aWVzIHdoZW4gYSB1c2VyIHNpZ25zIHVwXG4gKiAgICAgbWl4cGFuZWwucmVnaXN0ZXIoe1xuICogICAgICAgICAnRW1haWwnOiAnamRvZUBleGFtcGxlLmNvbScsXG4gKiAgICAgICAgICdBY2NvdW50IFR5cGUnOiAnRnJlZSdcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgb25seSBmb3IgdGhlIGN1cnJlbnQgcGFnZWxvYWRcbiAqICAgICBtaXhwYW5lbC5yZWdpc3Rlcih7J05hbWUnOiAnUGF0J30sIHtwZXJzaXN0ZW50OiBmYWxzZX0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIEFuIGFzc29jaWF0aXZlIGFycmF5IG9mIHByb3BlcnRpZXMgdG8gc3RvcmUgYWJvdXQgdGhlIHVzZXJcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gW2RheXNfb3Jfb3B0aW9uc10gT3B0aW9ucyBvYmplY3Qgb3IgbnVtYmVyIG9mIGRheXMgc2luY2UgdGhlIHVzZXIncyBsYXN0IHZpc2l0IHRvIHN0b3JlIHRoZSBzdXBlciBwcm9wZXJ0aWVzIChvbmx5IHZhbGlkIGZvciBwZXJzaXN0ZWQgcHJvcHMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXlzX29yX29wdGlvbnMuZGF5c10gLSBudW1iZXIgb2YgZGF5cyBzaW5jZSB0aGUgdXNlcidzIGxhc3QgdmlzaXQgdG8gc3RvcmUgdGhlIHN1cGVyIHByb3BlcnRpZXMgKG9ubHkgdmFsaWQgZm9yIHBlcnNpc3RlZCBwcm9wcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RheXNfb3Jfb3B0aW9ucy5wZXJzaXN0ZW50PXRydWVdIC0gd2hldGhlciB0byBwdXQgaW4gcGVyc2lzdGVudCBzdG9yYWdlIChjb29raWUvbG9jYWxTdG9yYWdlKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbihwcm9wcywgZGF5c19vcl9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRpb25zX2Zvcl9yZWdpc3RlcihkYXlzX29yX29wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zWydwZXJzaXN0ZW50J10pIHtcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS5yZWdpc3Rlcihwcm9wcywgb3B0aW9uc1snZGF5cyddKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfLmV4dGVuZCh0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHMsIHByb3BzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgc2V0IG9mIHN1cGVyIHByb3BlcnRpZXMgb25seSBvbmNlLiBUaGlzIHdpbGwgbm90XG4gKiBvdmVyd3JpdGUgcHJldmlvdXMgc3VwZXIgcHJvcGVydHkgdmFsdWVzLCB1bmxpa2UgcmVnaXN0ZXIoKS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHJlZ2lzdGVyIGEgc3VwZXIgcHJvcGVydHkgZm9yIHRoZSBmaXJzdCB0aW1lIG9ubHlcbiAqICAgICBtaXhwYW5lbC5yZWdpc3Rlcl9vbmNlKHtcbiAqICAgICAgICAgJ0ZpcnN0IExvZ2luIERhdGUnOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAqICAgICB9KTtcbiAqXG4gKiAgICAgLy8gcmVnaXN0ZXIgb25jZSwgb25seSBmb3IgdGhlIGN1cnJlbnQgcGFnZWxvYWRcbiAqICAgICBtaXhwYW5lbC5yZWdpc3Rlcl9vbmNlKHtcbiAqICAgICAgICAgJ0ZpcnN0IGludGVyYWN0aW9uIHRpbWUnOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAqICAgICB9LCAnTm9uZScsIHtwZXJzaXN0ZW50OiBmYWxzZX0pO1xuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBJZiBkZWZhdWx0X3ZhbHVlIGlzIHNwZWNpZmllZCwgY3VycmVudCBzdXBlciBwcm9wZXJ0aWVzXG4gKiB3aXRoIHRoYXQgdmFsdWUgd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBBbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwcm9wZXJ0aWVzIHRvIHN0b3JlIGFib3V0IHRoZSB1c2VyXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0X3ZhbHVlXSBWYWx1ZSB0byBvdmVycmlkZSBpZiBhbHJlYWR5IHNldCBpbiBzdXBlciBwcm9wZXJ0aWVzIChleDogJ0ZhbHNlJykgRGVmYXVsdDogJ05vbmUnXG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IFtkYXlzX29yX29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IG9yIG51bWJlciBvZiBkYXlzIHNpbmNlIHRoZSB1c2VyJ3MgbGFzdCB2aXNpdCB0byBzdG9yZSB0aGUgc3VwZXIgcHJvcGVydGllcyAob25seSB2YWxpZCBmb3IgcGVyc2lzdGVkIHByb3BzKVxuICogQHBhcmFtIHtib29sZWFufSBbZGF5c19vcl9vcHRpb25zLmRheXNdIC0gbnVtYmVyIG9mIGRheXMgc2luY2UgdGhlIHVzZXIncyBsYXN0IHZpc2l0IHRvIHN0b3JlIHRoZSBzdXBlciBwcm9wZXJ0aWVzIChvbmx5IHZhbGlkIGZvciBwZXJzaXN0ZWQgcHJvcHMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXlzX29yX29wdGlvbnMucGVyc2lzdGVudD10cnVlXSAtIHdoZXRoZXIgdG8gcHV0IGluIHBlcnNpc3RlbnQgc3RvcmFnZSAoY29va2llL2xvY2FsU3RvcmFnZSlcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlZ2lzdGVyX29uY2UgPSBmdW5jdGlvbihwcm9wcywgZGVmYXVsdF92YWx1ZSwgZGF5c19vcl9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBvcHRpb25zX2Zvcl9yZWdpc3RlcihkYXlzX29yX29wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zWydwZXJzaXN0ZW50J10pIHtcbiAgICAgICAgdGhpc1sncGVyc2lzdGVuY2UnXS5yZWdpc3Rlcl9vbmNlKHByb3BzLCBkZWZhdWx0X3ZhbHVlLCBvcHRpb25zWydkYXlzJ10pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YoZGVmYXVsdF92YWx1ZSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBkZWZhdWx0X3ZhbHVlID0gJ05vbmUnO1xuICAgICAgICB9XG4gICAgICAgIF8uZWFjaChwcm9wcywgZnVuY3Rpb24odmFsLCBwcm9wKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCB0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHNbcHJvcF0gPT09IGRlZmF1bHRfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHNbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRGVsZXRlIGEgc3VwZXIgcHJvcGVydHkgc3RvcmVkIHdpdGggdGhlIGN1cnJlbnQgdXNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgVGhlIG5hbWUgb2YgdGhlIHN1cGVyIHByb3BlcnR5IHRvIHJlbW92ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wZXJzaXN0ZW50PXRydWVdIC0gd2hldGhlciB0byBsb29rIGluIHBlcnNpc3RlbnQgc3RvcmFnZSAoY29va2llL2xvY2FsU3RvcmFnZSlcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbihwcm9wZXJ0eSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zX2Zvcl9yZWdpc3RlcihvcHRpb25zKTtcbiAgICBpZiAob3B0aW9uc1sncGVyc2lzdGVudCddKSB7XG4gICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10udW5yZWdpc3Rlcihwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMudW5wZXJzaXN0ZWRfc3VwZXJwcm9wc1twcm9wZXJ0eV07XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9yZWdpc3Rlcl9zaW5nbGUgPSBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHByb3BzW3Byb3BdID0gdmFsdWU7XG4gICAgdGhpcy5yZWdpc3Rlcihwcm9wcyk7XG59O1xuXG4vKipcbiAqIElkZW50aWZ5IGEgdXNlciB3aXRoIGEgdW5pcXVlIElEIHRvIHRyYWNrIHVzZXIgYWN0aXZpdHkgYWNyb3NzXG4gKiBkZXZpY2VzLCB0aWUgYSB1c2VyIHRvIHRoZWlyIGV2ZW50cywgYW5kIGNyZWF0ZSBhIHVzZXIgcHJvZmlsZS5cbiAqIElmIHlvdSBuZXZlciBjYWxsIHRoaXMgbWV0aG9kLCB1bmlxdWUgdmlzaXRvcnMgYXJlIHRyYWNrZWQgdXNpbmdcbiAqIGEgVVVJRCBnZW5lcmF0ZWQgdGhlIGZpcnN0IHRpbWUgdGhleSB2aXNpdCB0aGUgc2l0ZS5cbiAqXG4gKiBDYWxsIGlkZW50aWZ5IHdoZW4geW91IGtub3cgdGhlIGlkZW50aXR5IG9mIHRoZSBjdXJyZW50IHVzZXIsXG4gKiB0eXBpY2FsbHkgYWZ0ZXIgbG9naW4gb3Igc2lnbnVwLiBXZSByZWNvbW1lbmQgYWdhaW5zdCB1c2luZ1xuICogaWRlbnRpZnkgZm9yIGFub255bW91cyB2aXNpdG9ycyB0byB5b3VyIHNpdGUuXG4gKlxuICogIyMjIE5vdGVzOlxuICogSWYgeW91ciBwcm9qZWN0IGhhc1xuICogPGEgaHJlZj1cImh0dHBzOi8vaGVscC5taXhwYW5lbC5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDM5MTMzODUxXCI+SUQgTWVyZ2U8L2E+XG4gKiBlbmFibGVkLCB0aGUgaWRlbnRpZnkgbWV0aG9kIHdpbGwgY29ubmVjdCBwcmUtIGFuZFxuICogcG9zdC1hdXRoZW50aWNhdGlvbiBldmVudHMgd2hlbiBhcHByb3ByaWF0ZS5cbiAqXG4gKiBJZiB5b3VyIHByb2plY3QgZG9lcyBub3QgaGF2ZSBJRCBNZXJnZSBlbmFibGVkLCBpZGVudGlmeSB3aWxsXG4gKiBjaGFuZ2UgdGhlIHVzZXIncyBsb2NhbCBkaXN0aW5jdF9pZCB0byB0aGUgdW5pcXVlIElEIHlvdSBwYXNzLlxuICogRXZlbnRzIHRyYWNrZWQgcHJpb3IgdG8gYXV0aGVudGljYXRpb24gd2lsbCBub3QgYmUgY29ubmVjdGVkXG4gKiB0byB0aGUgc2FtZSB1c2VyIGlkZW50aXR5LiBJZiBJRCBNZXJnZSBpcyBkaXNhYmxlZCwgYWxpYXMgY2FuXG4gKiBiZSB1c2VkIHRvIGNvbm5lY3QgcHJlLSBhbmQgcG9zdC1yZWdpc3RyYXRpb24gZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdW5pcXVlX2lkXSBBIHN0cmluZyB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgYSB1c2VyLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBkaXN0aW5jdF9pZCBjdXJyZW50bHkgaW4gdGhlIHBlcnNpc3RlbnQgc3RvcmUgKGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UpIHdpbGwgYmUgdXNlZC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmlkZW50aWZ5ID0gZnVuY3Rpb24oXG4gICAgbmV3X2Rpc3RpbmN0X2lkLCBfc2V0X2NhbGxiYWNrLCBfYWRkX2NhbGxiYWNrLCBfYXBwZW5kX2NhbGxiYWNrLCBfc2V0X29uY2VfY2FsbGJhY2ssIF91bmlvbl9jYWxsYmFjaywgX3Vuc2V0X2NhbGxiYWNrLCBfcmVtb3ZlX2NhbGxiYWNrXG4pIHtcbiAgICAvLyBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gICAgLy8gIF9zZXRfY2FsbGJhY2s6ZnVuY3Rpb24gIEEgY2FsbGJhY2sgdG8gYmUgcnVuIGlmIGFuZCB3aGVuIHRoZSBQZW9wbGUgc2V0IHF1ZXVlIGlzIGZsdXNoZWRcbiAgICAvLyAgX2FkZF9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSBhZGQgcXVldWUgaXMgZmx1c2hlZFxuICAgIC8vICBfYXBwZW5kX2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIGFwcGVuZCBxdWV1ZSBpcyBmbHVzaGVkXG4gICAgLy8gIF9zZXRfb25jZV9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSBzZXRfb25jZSBxdWV1ZSBpcyBmbHVzaGVkXG4gICAgLy8gIF91bmlvbl9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSB1bmlvbiBxdWV1ZSBpcyBmbHVzaGVkXG4gICAgLy8gIF91bnNldF9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSB1bnNldCBxdWV1ZSBpcyBmbHVzaGVkXG5cbiAgICB2YXIgcHJldmlvdXNfZGlzdGluY3RfaWQgPSB0aGlzLmdldF9kaXN0aW5jdF9pZCgpO1xuICAgIGlmIChuZXdfZGlzdGluY3RfaWQgJiYgcHJldmlvdXNfZGlzdGluY3RfaWQgIT09IG5ld19kaXN0aW5jdF9pZCkge1xuICAgICAgICAvLyB3ZSBhbGxvdyB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbiBpZiBwcmV2aW91cyBkaXN0aW5jdF9pZCBpcyBzYW1lIGFzIG5ld19kaXN0aW5jdF9pZFxuICAgICAgICAvLyBzbyB0aGF0IHlvdSBjYW4gZm9yY2UgZmx1c2ggcGVvcGxlIHVwZGF0ZXMgZm9yIGFub255bW91cyBwcm9maWxlcy5cbiAgICAgICAgaWYgKHR5cGVvZiBuZXdfZGlzdGluY3RfaWQgPT09ICdzdHJpbmcnICYmIG5ld19kaXN0aW5jdF9pZC5pbmRleE9mKERFVklDRV9JRF9QUkVGSVgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignZGlzdGluY3RfaWQgY2Fubm90IGhhdmUgJGRldmljZTogcHJlZml4Jyk7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWdpc3Rlcih7JyR1c2VyX2lkJzogbmV3X2Rpc3RpbmN0X2lkfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldF9wcm9wZXJ0eSgnJGRldmljZV9pZCcpKSB7XG4gICAgICAgIC8vIFRoZSBwZXJzaXN0ZWQgZGlzdGluY3QgaWQgbWlnaHQgbm90IGFjdHVhbGx5IGJlIGEgZGV2aWNlIGlkIGF0IGFsbFxuICAgICAgICAvLyBpdCBtaWdodCBiZSBhIGRpc3RpbmN0IGlkIG9mIHRoZSB1c2VyIGZyb20gYmVmb3JlXG4gICAgICAgIHZhciBkZXZpY2VfaWQgPSBwcmV2aW91c19kaXN0aW5jdF9pZDtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcl9vbmNlKHtcbiAgICAgICAgICAgICckaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCc6IHRydWUsXG4gICAgICAgICAgICAnJGRldmljZV9pZCc6IGRldmljZV9pZFxuICAgICAgICB9LCAnJyk7XG4gICAgfVxuXG4gICAgLy8gaWRlbnRpZnkgb25seSBjaGFuZ2VzIHRoZSBkaXN0aW5jdCBpZCBpZiBpdCBkb2Vzbid0IG1hdGNoIGVpdGhlciB0aGUgZXhpc3Rpbmcgb3IgdGhlIGFsaWFzO1xuICAgIC8vIGlmIGl0J3MgbmV3LCBibG93IGF3YXkgdGhlIGFsaWFzIGFzIHdlbGwuXG4gICAgaWYgKG5ld19kaXN0aW5jdF9pZCAhPT0gcHJldmlvdXNfZGlzdGluY3RfaWQgJiYgbmV3X2Rpc3RpbmN0X2lkICE9PSB0aGlzLmdldF9wcm9wZXJ0eShBTElBU19JRF9LRVkpKSB7XG4gICAgICAgIHRoaXMudW5yZWdpc3RlcihBTElBU19JRF9LRVkpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKHsnZGlzdGluY3RfaWQnOiBuZXdfZGlzdGluY3RfaWR9KTtcbiAgICB9XG4gICAgdGhpcy5fZmxhZ3MuaWRlbnRpZnlfY2FsbGVkID0gdHJ1ZTtcbiAgICAvLyBGbHVzaCBhbnkgcXVldWVkIHVwIHBlb3BsZSByZXF1ZXN0c1xuICAgIHRoaXNbJ3Blb3BsZSddLl9mbHVzaChfc2V0X2NhbGxiYWNrLCBfYWRkX2NhbGxiYWNrLCBfYXBwZW5kX2NhbGxiYWNrLCBfc2V0X29uY2VfY2FsbGJhY2ssIF91bmlvbl9jYWxsYmFjaywgX3Vuc2V0X2NhbGxiYWNrLCBfcmVtb3ZlX2NhbGxiYWNrKTtcblxuICAgIC8vIHNlbmQgYW4gJGlkZW50aWZ5IGV2ZW50IGFueSB0aW1lIHRoZSBkaXN0aW5jdF9pZCBpcyBjaGFuZ2luZyAtIGxvZ2ljIG9uIHRoZSBzZXJ2ZXJcbiAgICAvLyB3aWxsIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0byBkbyBhbnl0aGluZyB3aXRoIGl0LlxuICAgIGlmIChuZXdfZGlzdGluY3RfaWQgIT09IHByZXZpb3VzX2Rpc3RpbmN0X2lkKSB7XG4gICAgICAgIHRoaXMudHJhY2soJyRpZGVudGlmeScsIHtcbiAgICAgICAgICAgICdkaXN0aW5jdF9pZCc6IG5ld19kaXN0aW5jdF9pZCxcbiAgICAgICAgICAgICckYW5vbl9kaXN0aW5jdF9pZCc6IHByZXZpb3VzX2Rpc3RpbmN0X2lkXG4gICAgICAgIH0sIHtza2lwX2hvb2tzOiB0cnVlfSk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZmVhdHVyZSBmbGFncyBhZ2FpbiBpZiBkaXN0aW5jdCBpZCBoYXMgY2hhbmdlZFxuICAgIGlmIChuZXdfZGlzdGluY3RfaWQgIT09IHByZXZpb3VzX2Rpc3RpbmN0X2lkKSB7XG4gICAgICAgIHRoaXMuZmxhZ3MuZmV0Y2hGbGFncygpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2xlYXJzIHN1cGVyIHByb3BlcnRpZXMgYW5kIGdlbmVyYXRlcyBhIG5ldyByYW5kb20gZGlzdGluY3RfaWQgZm9yIHRoaXMgaW5zdGFuY2UuXG4gKiBVc2VmdWwgZm9yIGNsZWFyaW5nIGRhdGEgd2hlbiBhIHVzZXIgbG9ncyBvdXQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10uY2xlYXIoKTtcbiAgICB0aGlzLl9mbGFncy5pZGVudGlmeV9jYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgdXVpZCA9IF8uVVVJRCgpO1xuICAgIHRoaXMucmVnaXN0ZXJfb25jZSh7XG4gICAgICAgICdkaXN0aW5jdF9pZCc6IERFVklDRV9JRF9QUkVGSVggKyB1dWlkLFxuICAgICAgICAnJGRldmljZV9pZCc6IHV1aWRcbiAgICB9LCAnJyk7XG4gICAgdGhpcy5zdG9wX3Nlc3Npb25fcmVjb3JkaW5nKCk7XG4gICAgdGhpcy5fY2hlY2tfYW5kX3N0YXJ0X3Nlc3Npb25fcmVjb3JkaW5nKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgZGlzdGluY3QgaWQgb2YgdGhlIHVzZXIuIFRoaXMgaXMgZWl0aGVyIHRoZSBpZCBhdXRvbWF0aWNhbGx5XG4gKiBnZW5lcmF0ZWQgYnkgdGhlIGxpYnJhcnkgb3IgdGhlIGlkIHRoYXQgaGFzIGJlZW4gcGFzc2VkIGJ5IGEgY2FsbCB0byBpZGVudGlmeSgpLlxuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBnZXRfZGlzdGluY3RfaWQoKSBjYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgdGhlIE1peHBhbmVsIGxpYnJhcnkgaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG4gKiBpbml0KCkgaGFzIGEgbG9hZGVkIGZ1bmN0aW9uIGF2YWlsYWJsZSB0byBoYW5kbGUgdGhpcyBhdXRvbWF0aWNhbGx5LiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gc2V0IGRpc3RpbmN0X2lkIGFmdGVyIHRoZSBtaXhwYW5lbCBsaWJyYXJ5IGhhcyBsb2FkZWRcbiAqICAgICBtaXhwYW5lbC5pbml0KCdZT1VSIFBST0pFQ1QgVE9LRU4nLCB7XG4gKiAgICAgICAgIGxvYWRlZDogZnVuY3Rpb24obWl4cGFuZWwpIHtcbiAqICAgICAgICAgICAgIGRpc3RpbmN0X2lkID0gbWl4cGFuZWwuZ2V0X2Rpc3RpbmN0X2lkKCk7XG4gKiAgICAgICAgIH1cbiAqICAgICB9KTtcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9kaXN0aW5jdF9pZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldF9wcm9wZXJ0eSgnZGlzdGluY3RfaWQnKTtcbn07XG5cbi8qKlxuICogVGhlIGFsaWFzIG1ldGhvZCBjcmVhdGVzIGFuIGFsaWFzIHdoaWNoIE1peHBhbmVsIHdpbGwgdXNlIHRvXG4gKiByZW1hcCBvbmUgaWQgdG8gYW5vdGhlci4gTXVsdGlwbGUgYWxpYXNlcyBjYW4gcG9pbnQgdG8gdGhlXG4gKiBzYW1lIGlkZW50aWZpZXIuXG4gKlxuICogVGhlIGZvbGxvd2luZyBpcyBhIHZhbGlkIHVzZSBvZiBhbGlhczpcbiAqXG4gKiAgICAgbWl4cGFuZWwuYWxpYXMoJ25ld19pZCcsICdleGlzdGluZ19pZCcpO1xuICogICAgIC8vIFlvdSBjYW4gYWRkIG11bHRpcGxlIGlkIGFsaWFzZXMgdG8gdGhlIGV4aXN0aW5nIElEXG4gKiAgICAgbWl4cGFuZWwuYWxpYXMoJ25ld2VyX2lkJywgJ2V4aXN0aW5nX2lkJyk7XG4gKlxuICogQWxpYXNlcyBjYW4gYWxzbyBiZSBjaGFpbmVkIC0gdGhlIGZvbGxvd2luZyBpcyBhIHZhbGlkIGV4YW1wbGU6XG4gKlxuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdfaWQnLCAnZXhpc3RpbmdfaWQnKTtcbiAqICAgICAvLyBjaGFpbiBuZXdlcl9pZCAtIG5ld19pZCAtIGV4aXN0aW5nX2lkXG4gKiAgICAgbWl4cGFuZWwuYWxpYXMoJ25ld2VyX2lkJywgJ25ld19pZCcpO1xuICpcbiAqIEFsaWFzZXMgY2Fubm90IHBvaW50IHRvIG11bHRpcGxlIGlkZW50aWZpZXJzIC0gdGhlIGZvbGxvd2luZ1xuICogZXhhbXBsZSB3aWxsIG5vdCB3b3JrOlxuICpcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3X2lkJywgJ2V4aXN0aW5nX2lkJyk7XG4gKiAgICAgLy8gdGhpcyBpcyBpbnZhbGlkIGFzICduZXdfaWQnIGFscmVhZHkgcG9pbnRzIHRvICdleGlzdGluZ19pZCdcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3X2lkJywgJ25ld2VyX2lkJyk7XG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIElmIHlvdXIgcHJvamVjdCBkb2VzIG5vdCBoYXZlXG4gKiA8YSBocmVmPVwiaHR0cHM6Ly9oZWxwLm1peHBhbmVsLmNvbS9oYy9lbi11cy9hcnRpY2xlcy8zNjAwMzkxMzM4NTFcIj5JRCBNZXJnZTwvYT5cbiAqIGVuYWJsZWQsIHRoZSBiZXN0IHByYWN0aWNlIGlzIHRvIGNhbGwgYWxpYXMgb25jZSB3aGVuIGEgdW5pcXVlXG4gKiBJRCBpcyBmaXJzdCBjcmVhdGVkIGZvciBhIHVzZXIgKGUuZy4sIHdoZW4gYSB1c2VyIGZpcnN0IHJlZ2lzdGVyc1xuICogZm9yIGFuIGFjY291bnQpLiBEbyBub3QgdXNlIGFsaWFzIG11bHRpcGxlIHRpbWVzIGZvciBhIHNpbmdsZVxuICogdXNlciB3aXRob3V0IElEIE1lcmdlIGVuYWJsZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFsaWFzIEEgdW5pcXVlIGlkZW50aWZpZXIgdGhhdCB5b3Ugd2FudCB0byB1c2UgZm9yIHRoaXMgdXNlciBpbiB0aGUgZnV0dXJlLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcmlnaW5hbF0gVGhlIGN1cnJlbnQgaWRlbnRpZmllciBiZWluZyB1c2VkIGZvciB0aGlzIHVzZXIuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5hbGlhcyA9IGZ1bmN0aW9uKGFsaWFzLCBvcmlnaW5hbCkge1xuICAgIC8vIElmIHRoZSAkcGVvcGxlX2Rpc3RpbmN0X2lkIGtleSBleGlzdHMgaW4gcGVyc2lzdGVuY2UsIHRoZXJlIGhhcyBiZWVuIGEgcHJldmlvdXNcbiAgICAvLyBtaXhwYW5lbC5wZW9wbGUuaWRlbnRpZnkoKSBjYWxsIG1hZGUgZm9yIHRoaXMgdXNlci4gSXQgaXMgVkVSWSBCQUQgdG8gbWFrZSBhbiBhbGlhcyB3aXRoXG4gICAgLy8gdGhpcyBJRCwgYXMgaXQgd2lsbCBkdXBsaWNhdGUgdXNlcnMuXG4gICAgaWYgKGFsaWFzID09PSB0aGlzLmdldF9wcm9wZXJ0eShQRU9QTEVfRElTVElOQ1RfSURfS0VZKSkge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignQXR0ZW1wdGluZyB0byBjcmVhdGUgYWxpYXMgZm9yIGV4aXN0aW5nIFBlb3BsZSB1c2VyIC0gYWJvcnRpbmcuJyk7XG4gICAgICAgIHJldHVybiAtMjtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKG9yaWdpbmFsKSkge1xuICAgICAgICBvcmlnaW5hbCA9IHRoaXMuZ2V0X2Rpc3RpbmN0X2lkKCk7XG4gICAgfVxuICAgIGlmIChhbGlhcyAhPT0gb3JpZ2luYWwpIHtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJfc2luZ2xlKEFMSUFTX0lEX0tFWSwgYWxpYXMpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFjaygnJGNyZWF0ZV9hbGlhcycsIHtcbiAgICAgICAgICAgICdhbGlhcyc6IGFsaWFzLFxuICAgICAgICAgICAgJ2Rpc3RpbmN0X2lkJzogb3JpZ2luYWxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgc2tpcF9ob29rczogdHJ1ZVxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIEZsdXNoIHRoZSBwZW9wbGUgcXVldWVcbiAgICAgICAgICAgIF90aGlzLmlkZW50aWZ5KGFsaWFzKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ2FsaWFzIG1hdGNoZXMgY3VycmVudCBkaXN0aW5jdF9pZCAtIHNraXBwaW5nIGFwaSBjYWxsLicpO1xuICAgICAgICB0aGlzLmlkZW50aWZ5KGFsaWFzKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn07XG5cbi8qKlxuICogUHJvdmlkZSBhIHN0cmluZyB0byByZWNvZ25pemUgdGhlIHVzZXIgYnkuIFRoZSBzdHJpbmcgcGFzc2VkIHRvXG4gKiB0aGlzIG1ldGhvZCB3aWxsIGFwcGVhciBpbiB0aGUgTWl4cGFuZWwgU3RyZWFtcyBwcm9kdWN0IHJhdGhlclxuICogdGhhbiBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBuYW1lLiBOYW1lIHRhZ3MgZG8gbm90IGhhdmUgdG9cbiAqIGJlIHVuaXF1ZS5cbiAqXG4gKiBUaGlzIHZhbHVlIHdpbGwgb25seSBiZSBpbmNsdWRlZCBpbiBTdHJlYW1zIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVfdGFnIEEgaHVtYW4gcmVhZGFibGUgbmFtZSBmb3IgdGhlIHVzZXJcbiAqIEBkZXByZWNhdGVkXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5uYW1lX3RhZyA9IGZ1bmN0aW9uKG5hbWVfdGFnKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJfc2luZ2xlKCdtcF9uYW1lX3RhZycsIG5hbWVfdGFnKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjb25maWd1cmF0aW9uIG9mIGEgbWl4cGFuZWwgbGlicmFyeSBpbnN0YW5jZS5cbiAqXG4gKiBUaGUgZGVmYXVsdCBjb25maWcgaXM6XG4gKlxuICogICAgIHtcbiAqICAgICAgIC8vIGhvc3QgZm9yIHJlcXVlc3RzIChjdXN0b21pemFibGUgZm9yIGUuZy4gYSBsb2NhbCBwcm94eSlcbiAqICAgICAgIGFwaV9ob3N0OiAnaHR0cHM6Ly9hcGktanMubWl4cGFuZWwuY29tJyxcbiAqXG4gKiAgICAgICAvLyBlbmRwb2ludHMgZm9yIGRpZmZlcmVudCB0eXBlcyBvZiByZXF1ZXN0c1xuICogICAgICAgYXBpX3JvdXRlczoge1xuICogICAgICAgICB0cmFjazogJ3RyYWNrLycsXG4gKiAgICAgICAgIGVuZ2FnZTogJ2VuZ2FnZS8nLFxuICogICAgICAgICBncm91cHM6ICdncm91cHMvJyxcbiAqICAgICAgIH1cbiAqXG4gKiAgICAgICAvLyBIVFRQIG1ldGhvZCBmb3IgdHJhY2tpbmcgcmVxdWVzdHNcbiAqICAgICAgIGFwaV9tZXRob2Q6ICdQT1NUJ1xuICpcbiAqICAgICAgIC8vIHRyYW5zcG9ydCBmb3Igc2VuZGluZyByZXF1ZXN0cyAoJ1hIUicgb3IgJ3NlbmRCZWFjb24nKVxuICogICAgICAgLy8gTkI6IHNlbmRCZWFjb24gc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3Igc2NlbmFyaW9zIHN1Y2ggYXNcbiAqICAgICAgIC8vIHBhZ2UgdW5sb2FkIHdoZXJlIGEgXCJiZXN0LWVmZm9ydFwiIGF0dGVtcHQgdG8gc2VuZCBpc1xuICogICAgICAgLy8gYWNjZXB0YWJsZTsgdGhlIHNlbmRCZWFjb24gQVBJIGRvZXMgbm90IHN1cHBvcnQgY2FsbGJhY2tzXG4gKiAgICAgICAvLyBvciBhbnkgd2F5IHRvIGtub3cgdGhlIHJlc3VsdCBvZiB0aGUgcmVxdWVzdC4gTWl4cGFuZWxcbiAqICAgICAgIC8vIHRyYWNraW5nIHZpYSBzZW5kQmVhY29uIHdpbGwgbm90IHN1cHBvcnQgYW55IGV2ZW50LVxuICogICAgICAgLy8gYmF0Y2hpbmcgb3IgcmV0cnkgbWVjaGFuaXNtcy5cbiAqICAgICAgIGFwaV90cmFuc3BvcnQ6ICdYSFInXG4gKlxuICogICAgICAgLy8gcmVxdWVzdC1iYXRjaGluZy9xdWV1ZWluZy9yZXRyeVxuICogICAgICAgYmF0Y2hfcmVxdWVzdHM6IHRydWUsXG4gKlxuICogICAgICAgLy8gbWF4aW11bSBudW1iZXIgb2YgZXZlbnRzL3VwZGF0ZXMgdG8gc2VuZCBpbiBhIHNpbmdsZVxuICogICAgICAgLy8gbmV0d29yayByZXF1ZXN0XG4gKiAgICAgICBiYXRjaF9zaXplOiA1MCxcbiAqXG4gKiAgICAgICAvLyBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZXR3ZWVuIHNlbmRpbmcgYmF0Y2ggcmVxdWVzdHNcbiAqICAgICAgIGJhdGNoX2ZsdXNoX2ludGVydmFsX21zOiA1MDAwLFxuICpcbiAqICAgICAgIC8vIG1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciBuZXR3b3JrIHJlc3BvbnNlcyB0byBiYXRjaCByZXF1ZXN0c1xuICogICAgICAgLy8gYmVmb3JlIHRoZXkgYXJlIGNvbnNpZGVyZWQgdGltZWQtb3V0IGFuZCByZXRyaWVkXG4gKiAgICAgICBiYXRjaF9yZXF1ZXN0X3RpbWVvdXRfbXM6IDkwMDAwLFxuICpcbiAqICAgICAgIC8vIG92ZXJyaWRlIHZhbHVlIGZvciBjb29raWUgZG9tYWluLCBvbmx5IHVzZWZ1bCBmb3IgZW5zdXJpbmdcbiAqICAgICAgIC8vIGNvcnJlY3QgY3Jvc3Mtc3ViZG9tYWluIGNvb2tpZXMgb24gdW51c3VhbCBkb21haW5zIGxpa2VcbiAqICAgICAgIC8vIHN1YmRvbWFpbi5tYWluc2l0ZS5hdm9jYXQuZnI7IE5CIHRoaXMgY2Fubm90IGJlIHVzZWQgdG9cbiAqICAgICAgIC8vIHNldCBjb29raWVzIG9uIGEgZGlmZmVyZW50IGRvbWFpbiB0aGFuIHRoZSBjdXJyZW50IG9yaWdpblxuICogICAgICAgY29va2llX2RvbWFpbjogJydcbiAqXG4gKiAgICAgICAvLyBzdXBlciBwcm9wZXJ0aWVzIGNvb2tpZSBleHBpcmF0aW9uIChpbiBkYXlzKVxuICogICAgICAgY29va2llX2V4cGlyYXRpb246IDM2NVxuICpcbiAqICAgICAgIC8vIGlmIHRydWUsIGNvb2tpZSB3aWxsIGJlIHNldCB3aXRoIFNhbWVTaXRlPU5vbmU7IFNlY3VyZVxuICogICAgICAgLy8gdGhpcyBpcyBvbmx5IHVzZWZ1bCBpbiBzcGVjaWFsIHNpdHVhdGlvbnMsIGxpa2UgZW1iZWRkZWRcbiAqICAgICAgIC8vIDNyZC1wYXJ0eSBpZnJhbWVzIHRoYXQgc2V0IHVwIGEgTWl4cGFuZWwgaW5zdGFuY2VcbiAqICAgICAgIGNyb3NzX3NpdGVfY29va2llOiBmYWxzZVxuICpcbiAqICAgICAgIC8vIHN1cGVyIHByb3BlcnRpZXMgc3BhbiBzdWJkb21haW5zXG4gKiAgICAgICBjcm9zc19zdWJkb21haW5fY29va2llOiB0cnVlXG4gKlxuICogICAgICAgLy8gZGVidWcgbW9kZVxuICogICAgICAgZGVidWc6IGZhbHNlXG4gKlxuICogICAgICAgLy8gaWYgdGhpcyBpcyB0cnVlLCB0aGUgbWl4cGFuZWwgY29va2llIG9yIGxvY2FsU3RvcmFnZSBlbnRyeVxuICogICAgICAgLy8gd2lsbCBiZSBkZWxldGVkLCBhbmQgbm8gdXNlciBwZXJzaXN0ZW5jZSB3aWxsIHRha2UgcGxhY2VcbiAqICAgICAgIGRpc2FibGVfcGVyc2lzdGVuY2U6IGZhbHNlXG4gKlxuICogICAgICAgLy8gaWYgdGhpcyBpcyB0cnVlLCBNaXhwYW5lbCB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lXG4gKiAgICAgICAvLyBDaXR5LCBSZWdpb24gYW5kIENvdW50cnkgZGF0YSB1c2luZyB0aGUgSVAgYWRkcmVzcyBvZlxuICogICAgICAgLy90aGUgY2xpZW50XG4gKiAgICAgICBpcDogdHJ1ZVxuICpcbiAqICAgICAgIC8vIG9wdCB1c2VycyBvdXQgb2YgdHJhY2tpbmcgYnkgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSBieSBkZWZhdWx0XG4gKiAgICAgICBvcHRfb3V0X3RyYWNraW5nX2J5X2RlZmF1bHQ6IGZhbHNlXG4gKlxuICogICAgICAgLy8gb3B0IHVzZXJzIG91dCBvZiBicm93c2VyIGRhdGEgc3RvcmFnZSBieSB0aGlzIE1peHBhbmVsIGluc3RhbmNlIGJ5IGRlZmF1bHRcbiAqICAgICAgIG9wdF9vdXRfcGVyc2lzdGVuY2VfYnlfZGVmYXVsdDogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBwZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCBieSBvcHQtaW4vb3B0LW91dCBtZXRob2RzIC0gY29va2llXG4gKiAgICAgICAvLyBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqICAgICAgIG9wdF9vdXRfdHJhY2tpbmdfcGVyc2lzdGVuY2VfdHlwZTogJ2xvY2FsU3RvcmFnZSdcbiAqXG4gKiAgICAgICAvLyBjdXN0b21pemUgdGhlIG5hbWUgb2YgY29va2llL2xvY2FsU3RvcmFnZSBzZXQgYnkgb3B0LWluL29wdC1vdXQgbWV0aG9kc1xuICogICAgICAgb3B0X291dF90cmFja2luZ19jb29raWVfcHJlZml4OiBudWxsXG4gKlxuICogICAgICAgLy8gdHlwZSBvZiBwZXJzaXN0ZW50IHN0b3JlIGZvciBzdXBlciBwcm9wZXJ0aWVzIChjb29raWUvXG4gKiAgICAgICAvLyBsb2NhbFN0b3JhZ2UpIGlmIHNldCB0byAnbG9jYWxTdG9yYWdlJywgYW55IGV4aXN0aW5nXG4gKiAgICAgICAvLyBtaXhwYW5lbCBjb29raWUgdmFsdWUgd2l0aCB0aGUgc2FtZSBwZXJzaXN0ZW5jZV9uYW1lXG4gKiAgICAgICAvLyB3aWxsIGJlIHRyYW5zZmVycmVkIHRvIGxvY2FsU3RvcmFnZSBhbmQgZGVsZXRlZFxuICogICAgICAgcGVyc2lzdGVuY2U6ICdjb29raWUnXG4gKlxuICogICAgICAgLy8gbmFtZSBmb3Igc3VwZXIgcHJvcGVydGllcyBwZXJzaXN0ZW50IHN0b3JlXG4gKiAgICAgICBwZXJzaXN0ZW5jZV9uYW1lOiAnJ1xuICpcbiAqICAgICAgIC8vIG5hbWVzIG9mIHByb3BlcnRpZXMvc3VwZXJwcm9wZXJ0aWVzIHdoaWNoIHNob3VsZCBuZXZlclxuICogICAgICAgLy8gYmUgc2VudCB3aXRoIHRyYWNrKCkgY2FsbHNcbiAqICAgICAgIHByb3BlcnR5X2JsYWNrbGlzdDogW11cbiAqXG4gKiAgICAgICAvLyBpZiB0aGlzIGlzIHRydWUsIG1peHBhbmVsIGNvb2tpZXMgd2lsbCBiZSBtYXJrZWQgYXNcbiAqICAgICAgIC8vIHNlY3VyZSwgbWVhbmluZyB0aGV5IHdpbGwgb25seSBiZSB0cmFuc21pdHRlZCBvdmVyIGh0dHBzXG4gKiAgICAgICBzZWN1cmVfY29va2llOiBmYWxzZVxuICpcbiAqICAgICAgIC8vIGRpc2FibGVzIGVucmljaGluZyB1c2VyIHByb2ZpbGVzIHdpdGggZmlyc3QgdG91Y2ggbWFya2V0aW5nIGRhdGFcbiAqICAgICAgIHNraXBfZmlyc3RfdG91Y2hfbWFya2V0aW5nOiBmYWxzZVxuICpcbiAqICAgICAgIC8vIHRoZSBhbW91bnQgb2YgdGltZSB0cmFja19saW5rcyB3aWxsXG4gKiAgICAgICAvLyB3YWl0IGZvciBNaXhwYW5lbCdzIHNlcnZlcnMgdG8gcmVzcG9uZFxuICogICAgICAgdHJhY2tfbGlua3NfdGltZW91dDogMzAwXG4gKlxuICogICAgICAgLy8gYWRkcyBhbnkgVVRNIHBhcmFtZXRlcnMgYW5kIGNsaWNrIElEcyBwcmVzZW50IG9uIHRoZSBwYWdlIHRvIGFueSBldmVudHMgZmlyZWRcbiAqICAgICAgIHRyYWNrX21hcmtldGluZzogdHJ1ZVxuICpcbiAqICAgICAgIC8vIGVuYWJsZXMgYXV0b21hdGljIHBhZ2UgdmlldyB0cmFja2luZyB1c2luZyBkZWZhdWx0IHBhZ2UgdmlldyBldmVudHMgdGhyb3VnaFxuICogICAgICAgLy8gdGhlIHRyYWNrX3BhZ2V2aWV3KCkgbWV0aG9kXG4gKiAgICAgICB0cmFja19wYWdldmlldzogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBpZiB5b3Ugc2V0IHVwZ3JhZGUgdG8gYmUgdHJ1ZSwgdGhlIGxpYnJhcnkgd2lsbCBjaGVjayBmb3JcbiAqICAgICAgIC8vIGEgY29va2llIGZyb20gb3VyIG9sZCBqcyBsaWJyYXJ5IGFuZCBpbXBvcnQgc3VwZXJcbiAqICAgICAgIC8vIHByb3BlcnRpZXMgZnJvbSBpdCwgdGhlbiB0aGUgb2xkIGNvb2tpZSBpcyBkZWxldGVkXG4gKiAgICAgICAvLyBUaGUgdXBncmFkZSBjb25maWcgb3B0aW9uIG9ubHkgd29ya3MgaW4gdGhlIGluaXRpYWxpemF0aW9uLFxuICogICAgICAgLy8gc28gbWFrZSBzdXJlIHlvdSBzZXQgaXQgd2hlbiB5b3UgY3JlYXRlIHRoZSBsaWJyYXJ5LlxuICogICAgICAgdXBncmFkZTogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBleHRyYSBIVFRQIHJlcXVlc3QgaGVhZGVycyB0byBzZXQgZm9yIGVhY2ggQVBJIHJlcXVlc3QsIGluXG4gKiAgICAgICAvLyB0aGUgZm9ybWF0IHsnSGVhZGVyLU5hbWUnOiB2YWx1ZX1cbiAqICAgICAgIHhocl9oZWFkZXJzOiB7fVxuICpcbiAqICAgICAgIC8vIHdoZXRoZXIgdG8gaWdub3JlIG9yIHJlc3BlY3QgdGhlIHdlYiBicm93c2VyJ3MgRG8gTm90IFRyYWNrIHNldHRpbmdcbiAqICAgICAgIGlnbm9yZV9kbnQ6IGZhbHNlXG4gKiAgICAgfVxuICpcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIEEgZGljdGlvbmFyeSBvZiBuZXcgY29uZmlndXJhdGlvbiB2YWx1ZXMgdG8gdXBkYXRlXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5zZXRfY29uZmlnID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgaWYgKF8uaXNPYmplY3QoY29uZmlnKSkge1xuICAgICAgICBfLmV4dGVuZCh0aGlzWydjb25maWcnXSwgY29uZmlnKTtcblxuICAgICAgICB2YXIgbmV3X2JhdGNoX3NpemUgPSBjb25maWdbJ2JhdGNoX3NpemUnXTtcbiAgICAgICAgaWYgKG5ld19iYXRjaF9zaXplKSB7XG4gICAgICAgICAgICBfLmVhY2godGhpcy5yZXF1ZXN0X2JhdGNoZXJzLCBmdW5jdGlvbihiYXRjaGVyKSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hlci5yZXNldEJhdGNoU2l6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZ2V0X2NvbmZpZygncGVyc2lzdGVuY2VfbmFtZScpKSB7XG4gICAgICAgICAgICB0aGlzWydjb25maWcnXVsncGVyc2lzdGVuY2VfbmFtZSddID0gdGhpc1snY29uZmlnJ11bJ2Nvb2tpZV9uYW1lJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmdldF9jb25maWcoJ2Rpc2FibGVfcGVyc2lzdGVuY2UnKSkge1xuICAgICAgICAgICAgdGhpc1snY29uZmlnJ11bJ2Rpc2FibGVfcGVyc2lzdGVuY2UnXSA9IHRoaXNbJ2NvbmZpZyddWydkaXNhYmxlX2Nvb2tpZSddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXNbJ3BlcnNpc3RlbmNlJ10pIHtcbiAgICAgICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10udXBkYXRlX2NvbmZpZyh0aGlzWydjb25maWcnXSk7XG4gICAgICAgIH1cbiAgICAgICAgQ29uZmlnLkRFQlVHID0gQ29uZmlnLkRFQlVHIHx8IHRoaXMuZ2V0X2NvbmZpZygnZGVidWcnKTtcblxuICAgICAgICBpZiAoKCdhdXRvY2FwdHVyZScgaW4gY29uZmlnIHx8ICdyZWNvcmRfaGVhdG1hcF9kYXRhJyBpbiBjb25maWcpICYmIHRoaXMuYXV0b2NhcHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0b2NhcHR1cmUuaW5pdCgpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiByZXR1cm5zIHRoZSBjdXJyZW50IGNvbmZpZyBvYmplY3QgZm9yIHRoZSBsaWJyYXJ5LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2NvbmZpZyA9IGZ1bmN0aW9uKHByb3BfbmFtZSkge1xuICAgIHJldHVybiB0aGlzWydjb25maWcnXVtwcm9wX25hbWVdO1xufTtcblxuLyoqXG4gKiBGZXRjaCBhIGhvb2sgZnVuY3Rpb24gZnJvbSBjb25maWcsIHdpdGggc2FmZSBkZWZhdWx0LCBhbmQgcnVuIGl0XG4gKiBhZ2FpbnN0IHRoZSBnaXZlbiBhcmd1bWVudHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBob29rX25hbWUgd2hpY2ggaG9vayB0byByZXRyaWV2ZVxuICogQHJldHVybnMge2FueXxudWxsfSByZXR1cm4gdmFsdWUgb2YgdXNlci1wcm92aWRlZCBob29rLCBvciBudWxsIGlmIG5vdGhpbmcgd2FzIHJldHVybmVkXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fcnVuX2hvb2sgPSBmdW5jdGlvbihob29rX25hbWUpIHtcbiAgICB2YXIgcmV0ID0gKHRoaXNbJ2NvbmZpZyddWydob29rcyddW2hvb2tfbmFtZV0gfHwgSURFTlRJVFlfRlVOQykuYXBwbHkodGhpcywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAodHlwZW9mIHJldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoaG9va19uYW1lICsgJyBob29rIGRpZCBub3QgcmV0dXJuIGEgdmFsdWUnKTtcbiAgICAgICAgcmV0ID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHN1cGVyIHByb3BlcnR5IG5hbWVkIHByb3BlcnR5X25hbWUuIElmIG5vIHN1Y2hcbiAqIHByb3BlcnR5IGlzIHNldCwgZ2V0X3Byb3BlcnR5KCkgd2lsbCByZXR1cm4gdGhlIHVuZGVmaW5lZCB2YWx1ZS5cbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogZ2V0X3Byb3BlcnR5KCkgY2FuIG9ubHkgYmUgY2FsbGVkIGFmdGVyIHRoZSBNaXhwYW5lbCBsaWJyYXJ5IGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuICogaW5pdCgpIGhhcyBhIGxvYWRlZCBmdW5jdGlvbiBhdmFpbGFibGUgdG8gaGFuZGxlIHRoaXMgYXV0b21hdGljYWxseS4gRm9yIGV4YW1wbGU6XG4gKlxuICogICAgIC8vIGdyYWIgdmFsdWUgZm9yICd1c2VyX2lkJyBhZnRlciB0aGUgbWl4cGFuZWwgbGlicmFyeSBoYXMgbG9hZGVkXG4gKiAgICAgbWl4cGFuZWwuaW5pdCgnWU9VUiBQUk9KRUNUIFRPS0VOJywge1xuICogICAgICAgICBsb2FkZWQ6IGZ1bmN0aW9uKG1peHBhbmVsKSB7XG4gKiAgICAgICAgICAgICB1c2VyX2lkID0gbWl4cGFuZWwuZ2V0X3Byb3BlcnR5KCd1c2VyX2lkJyk7XG4gKiAgICAgICAgIH1cbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlfbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3VwZXIgcHJvcGVydHkgeW91IHdhbnQgdG8gcmV0cmlldmVcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9wcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3BlcnR5X25hbWUpIHtcbiAgICByZXR1cm4gdGhpc1sncGVyc2lzdGVuY2UnXS5sb2FkX3Byb3AoW3Byb3BlcnR5X25hbWVdKTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBuYW1lID0gdGhpcy5nZXRfY29uZmlnKCduYW1lJyk7XG4gICAgaWYgKG5hbWUgIT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkge1xuICAgICAgICBuYW1lID0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FICsgJy4nICsgbmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2V2ZW50X2lzX2Rpc2FibGVkID0gZnVuY3Rpb24oZXZlbnRfbmFtZSkge1xuICAgIHJldHVybiBfLmlzQmxvY2tlZFVBKHVzZXJBZ2VudCkgfHxcbiAgICAgICAgdGhpcy5fZmxhZ3MuZGlzYWJsZV9hbGxfZXZlbnRzIHx8XG4gICAgICAgIF8uaW5jbHVkZSh0aGlzLl9fZGlzYWJsZWRfZXZlbnRzLCBldmVudF9uYW1lKTtcbn07XG5cbi8vIHBlcmZvcm0gc29tZSBob3VzZWtlZXBpbmcgYXJvdW5kIEdEUFIgb3B0LWluL291dCBzdGF0ZVxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9nZHByX2luaXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXNfbG9jYWxTdG9yYWdlX3JlcXVlc3RlZCA9IHRoaXMuZ2V0X2NvbmZpZygnb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlJykgPT09ICdsb2NhbFN0b3JhZ2UnO1xuXG4gICAgLy8gdHJ5IHRvIGNvbnZlcnQgb3B0LWluL291dCBjb29raWVzIHRvIGxvY2FsU3RvcmFnZSBpZiBwb3NzaWJsZVxuICAgIGlmIChpc19sb2NhbFN0b3JhZ2VfcmVxdWVzdGVkICYmIF8ubG9jYWxTdG9yYWdlLmlzX3N1cHBvcnRlZCgpKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNfb3B0ZWRfaW5fdHJhY2tpbmcoKSAmJiB0aGlzLmhhc19vcHRlZF9pbl90cmFja2luZyh7J3BlcnNpc3RlbmNlX3R5cGUnOiAnY29va2llJ30pKSB7XG4gICAgICAgICAgICB0aGlzLm9wdF9pbl90cmFja2luZyh7J2VuYWJsZV9wZXJzaXN0ZW5jZSc6IGZhbHNlfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoKSAmJiB0aGlzLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoeydwZXJzaXN0ZW5jZV90eXBlJzogJ2Nvb2tpZSd9KSkge1xuICAgICAgICAgICAgdGhpcy5vcHRfb3V0X3RyYWNraW5nKHsnY2xlYXJfcGVyc2lzdGVuY2UnOiBmYWxzZX0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJfb3B0X2luX291dF90cmFja2luZyh7XG4gICAgICAgICAgICAncGVyc2lzdGVuY2VfdHlwZSc6ICdjb29raWUnLFxuICAgICAgICAgICAgJ2VuYWJsZV9wZXJzaXN0ZW5jZSc6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIGFscmVhZHkgb3B0ZWQgb3V0IC0gaWYgc28sIGNsZWFyICYgZGlzYWJsZSBwZXJzaXN0ZW5jZVxuICAgIGlmICh0aGlzLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoKSkge1xuICAgICAgICB0aGlzLl9nZHByX3VwZGF0ZV9wZXJzaXN0ZW5jZSh7J2NsZWFyX3BlcnNpc3RlbmNlJzogdHJ1ZX0pO1xuXG4gICAgLy8gY2hlY2sgd2hldGhlciB3ZSBzaG91bGQgb3B0IG91dCBieSBkZWZhdWx0XG4gICAgLy8gbm90ZTogd2UgZG9uJ3QgY2xlYXIgcGVyc2lzdGVuY2UgaGVyZSBieSBkZWZhdWx0IHNpbmNlIG9wdC1vdXQgZGVmYXVsdCBzdGF0ZSBpcyBvZnRlblxuICAgIC8vICAgICAgIHVzZWQgYXMgYW4gaW5pdGlhbCBzdGF0ZSB3aGlsZSBHRFBSIGluZm9ybWF0aW9uIGlzIGJlaW5nIGNvbGxlY3RlZFxuICAgIH0gZWxzZSBpZiAoIXRoaXMuaGFzX29wdGVkX2luX3RyYWNraW5nKCkgJiYgKFxuICAgICAgICB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfdHJhY2tpbmdfYnlfZGVmYXVsdCcpIHx8IF8uY29va2llLmdldCgnbXBfb3B0b3V0JylcbiAgICApKSB7XG4gICAgICAgIF8uY29va2llLnJlbW92ZSgnbXBfb3B0b3V0Jyk7XG4gICAgICAgIHRoaXMub3B0X291dF90cmFja2luZyh7XG4gICAgICAgICAgICAnY2xlYXJfcGVyc2lzdGVuY2UnOiB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfcGVyc2lzdGVuY2VfYnlfZGVmYXVsdCcpXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogRW5hYmxlIG9yIGRpc2FibGUgcGVyc2lzdGVuY2UgYmFzZWQgb24gb3B0aW9uc1xuICogb25seSBlbmFibGUvZGlzYWJsZSBpZiBwZXJzaXN0ZW5jZSBpcyBub3QgYWxyZWFkeSBpbiB0aGlzIHN0YXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsZWFyX3BlcnNpc3RlbmNlXSBJZiB0cnVlLCB3aWxsIGRlbGV0ZSBhbGwgZGF0YSBzdG9yZWQgYnkgdGhlIHNkayBpbiBwZXJzaXN0ZW5jZSBhbmQgZGlzYWJsZSBpdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmFibGVfcGVyc2lzdGVuY2VdIElmIHRydWUsIHdpbGwgcmUtZW5hYmxlIHNkayBwZXJzaXN0ZW5jZVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHZhciBkaXNhYmxlZDtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zWydjbGVhcl9wZXJzaXN0ZW5jZSddKSB7XG4gICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMgJiYgb3B0aW9uc1snZW5hYmxlX3BlcnNpc3RlbmNlJ10pIHtcbiAgICAgICAgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldF9jb25maWcoJ2Rpc2FibGVfcGVyc2lzdGVuY2UnKSAmJiB0aGlzWydwZXJzaXN0ZW5jZSddLmRpc2FibGVkICE9PSBkaXNhYmxlZCkge1xuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnNldF9kaXNhYmxlZChkaXNhYmxlZCk7XG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuc3RvcF9iYXRjaF9zZW5kZXJzKCk7XG4gICAgICAgIHRoaXMuc3RvcF9zZXNzaW9uX3JlY29yZGluZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9ubHkgc3RhcnQgYmF0Y2hlcnMgYWZ0ZXIgb3B0LWluIGlmIHRoZXkgaGF2ZSBwcmV2aW91c2x5IGJlZW4gc3RhcnRlZFxuICAgICAgICAvLyBpbiBvcmRlciB0byBhdm9pZCB1bmludGVudGlvbmFsbHkgc3RhcnRpbmcgdXAgYmF0Y2hpbmcgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgIGlmICh0aGlzLl9iYXRjaGVyc193ZXJlX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRfYmF0Y2hfc2VuZGVycygpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gY2FsbCBhIGJhc2UgZ2RwciBmdW5jdGlvbiBhZnRlciBjb25zdHJ1Y3RpbmcgdGhlIGFwcHJvcHJpYXRlIHRva2VuIGFuZCBvcHRpb25zIGFyZ3Ncbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZ2Rwcl9jYWxsX2Z1bmMgPSBmdW5jdGlvbihmdW5jLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtcbiAgICAgICAgJ3RyYWNrJzogXy5iaW5kKHRoaXMudHJhY2ssIHRoaXMpLFxuICAgICAgICAncGVyc2lzdGVuY2VfdHlwZSc6IHRoaXMuZ2V0X2NvbmZpZygnb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlJyksXG4gICAgICAgICdjb29raWVfcHJlZml4JzogdGhpcy5nZXRfY29uZmlnKCdvcHRfb3V0X3RyYWNraW5nX2Nvb2tpZV9wcmVmaXgnKSxcbiAgICAgICAgJ2Nvb2tpZV9leHBpcmF0aW9uJzogdGhpcy5nZXRfY29uZmlnKCdjb29raWVfZXhwaXJhdGlvbicpLFxuICAgICAgICAnY3Jvc3Nfc2l0ZV9jb29raWUnOiB0aGlzLmdldF9jb25maWcoJ2Nyb3NzX3NpdGVfY29va2llJyksXG4gICAgICAgICdjcm9zc19zdWJkb21haW5fY29va2llJzogdGhpcy5nZXRfY29uZmlnKCdjcm9zc19zdWJkb21haW5fY29va2llJyksXG4gICAgICAgICdjb29raWVfZG9tYWluJzogdGhpcy5nZXRfY29uZmlnKCdjb29raWVfZG9tYWluJyksXG4gICAgICAgICdzZWN1cmVfY29va2llJzogdGhpcy5nZXRfY29uZmlnKCdzZWN1cmVfY29va2llJyksXG4gICAgICAgICdpZ25vcmVfZG50JzogdGhpcy5nZXRfY29uZmlnKCdpZ25vcmVfZG50JylcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIC8vIGNoZWNrIGlmIGxvY2FsU3RvcmFnZSBjYW4gYmUgdXNlZCBmb3IgcmVjb3JkaW5nIG9wdCBvdXQgc3RhdHVzLCBmYWxsIGJhY2sgdG8gY29va2llIGlmIG5vdFxuICAgIGlmICghXy5sb2NhbFN0b3JhZ2UuaXNfc3VwcG9ydGVkKCkpIHtcbiAgICAgICAgb3B0aW9uc1sncGVyc2lzdGVuY2VfdHlwZSddID0gJ2Nvb2tpZSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmModGhpcy5nZXRfY29uZmlnKCd0b2tlbicpLCB7XG4gICAgICAgIHRyYWNrOiBvcHRpb25zWyd0cmFjayddLFxuICAgICAgICB0cmFja0V2ZW50TmFtZTogb3B0aW9uc1sndHJhY2tfZXZlbnRfbmFtZSddLFxuICAgICAgICB0cmFja1Byb3BlcnRpZXM6IG9wdGlvbnNbJ3RyYWNrX3Byb3BlcnRpZXMnXSxcbiAgICAgICAgcGVyc2lzdGVuY2VUeXBlOiBvcHRpb25zWydwZXJzaXN0ZW5jZV90eXBlJ10sXG4gICAgICAgIHBlcnNpc3RlbmNlUHJlZml4OiBvcHRpb25zWydjb29raWVfcHJlZml4J10sXG4gICAgICAgIGNvb2tpZURvbWFpbjogb3B0aW9uc1snY29va2llX2RvbWFpbiddLFxuICAgICAgICBjb29raWVFeHBpcmF0aW9uOiBvcHRpb25zWydjb29raWVfZXhwaXJhdGlvbiddLFxuICAgICAgICBjcm9zc1NpdGVDb29raWU6IG9wdGlvbnNbJ2Nyb3NzX3NpdGVfY29va2llJ10sXG4gICAgICAgIGNyb3NzU3ViZG9tYWluQ29va2llOiBvcHRpb25zWydjcm9zc19zdWJkb21haW5fY29va2llJ10sXG4gICAgICAgIHNlY3VyZUNvb2tpZTogb3B0aW9uc1snc2VjdXJlX2Nvb2tpZSddLFxuICAgICAgICBpZ25vcmVEbnQ6IG9wdGlvbnNbJ2lnbm9yZV9kbnQnXVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBPcHQgdGhlIHVzZXIgaW4gdG8gZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2VcbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIG9wdCB1c2VyIGluXG4gKiAgICAgbWl4cGFuZWwub3B0X2luX3RyYWNraW5nKCk7XG4gKlxuICogICAgIC8vIG9wdCB1c2VyIGluIHdpdGggc3BlY2lmaWMgZXZlbnQgbmFtZSwgcHJvcGVydGllcywgY29va2llIGNvbmZpZ3VyYXRpb25cbiAqICAgICBtaXhwYW5lbC5vcHRfaW5fdHJhY2tpbmcoe1xuICogICAgICAgICB0cmFja19ldmVudF9uYW1lOiAnVXNlciBvcHRlZCBpbicsXG4gKiAgICAgICAgIHRyYWNrX2V2ZW50X3Byb3BlcnRpZXM6IHtcbiAqICAgICAgICAgICAgICdFbWFpbCc6ICdqZG9lQGV4YW1wbGUuY29tJ1xuICogICAgICAgICB9LFxuICogICAgICAgICBjb29raWVfZXhwaXJhdGlvbjogMzAsXG4gKiAgICAgICAgIHNlY3VyZV9jb29raWU6IHRydWVcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZVxuICogQHBhcmFtIHtmdW5jdGlvbn0gW29wdGlvbnMudHJhY2tdIEZ1bmN0aW9uIHVzZWQgZm9yIHRyYWNraW5nIGEgTWl4cGFuZWwgZXZlbnQgdG8gcmVjb3JkIHRoZSBvcHQtaW4gYWN0aW9uIChkZWZhdWx0IGlzIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyB0cmFjayBtZXRob2QpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHJhY2tfZXZlbnRfbmFtZT0kb3B0X2luXSBFdmVudCBuYW1lIHRvIGJlIHVzZWQgZm9yIHRyYWNraW5nIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMudHJhY2tfcHJvcGVydGllc10gU2V0IG9mIHByb3BlcnRpZXMgdG8gYmUgdHJhY2tlZCBhbG9uZyB3aXRoIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZV9wZXJzaXN0ZW5jZT10cnVlXSBJZiB0cnVlLCB3aWxsIHJlLWVuYWJsZSBzZGsgcGVyc2lzdGVuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZV90eXBlPWxvY2FsU3RvcmFnZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlIC0gZmFsbHMgYmFjayB0byBjb29raWUgaWYgbG9jYWxTdG9yYWdlIGlzIHVuYXZhaWxhYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX3ByZWZpeD1fX21wX29wdF9pbl9vdXRdIEN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llX2V4cGlyYXRpb25dIE51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXMgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfZG9tYWluXSBDdXN0b20gY29va2llIGRvbWFpbiAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zaXRlX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc2l0ZS1lbmFibGVkIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3N1YmRvbWFpbl9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUub3B0X2luX3RyYWNraW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7XG4gICAgICAgICdlbmFibGVfcGVyc2lzdGVuY2UnOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLl9nZHByX2NhbGxfZnVuYyhvcHRJbiwgb3B0aW9ucyk7XG4gICAgdGhpcy5fZ2Rwcl91cGRhdGVfcGVyc2lzdGVuY2Uob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIE9wdCB0aGUgdXNlciBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2VcbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIG9wdCB1c2VyIG91dFxuICogICAgIG1peHBhbmVsLm9wdF9vdXRfdHJhY2tpbmcoKTtcbiAqXG4gKiAgICAgLy8gb3B0IHVzZXIgb3V0IHdpdGggZGlmZmVyZW50IGNvb2tpZSBjb25maWd1cmF0aW9uIGZyb20gTWl4cGFuZWwgaW5zdGFuY2VcbiAqICAgICBtaXhwYW5lbC5vcHRfb3V0X3RyYWNraW5nKHtcbiAqICAgICAgICAgY29va2llX2V4cGlyYXRpb246IDMwLFxuICogICAgICAgICBzZWN1cmVfY29va2llOiB0cnVlXG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGVsZXRlX3VzZXI9dHJ1ZV0gSWYgdHJ1ZSwgd2lsbCBkZWxldGUgdGhlIGN1cnJlbnRseSBpZGVudGlmaWVkIHVzZXIncyBwcm9maWxlIGFuZCBjbGVhciBhbGwgY2hhcmdlcyBhZnRlciBvcHRpbmcgdGhlIHVzZXIgb3V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNsZWFyX3BlcnNpc3RlbmNlPXRydWVdIElmIHRydWUsIHdpbGwgZGVsZXRlIGFsbCBkYXRhIHN0b3JlZCBieSB0aGUgc2RrIGluIHBlcnNpc3RlbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VfdHlwZT1sb2NhbFN0b3JhZ2VdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9wcmVmaXg9X19tcF9vcHRfaW5fb3V0XSBDdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZV9leHBpcmF0aW9uXSBOdW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX2RvbWFpbl0gQ3VzdG9tIGNvb2tpZSBkb21haW4gKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc2l0ZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zdWJkb21haW5fY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLm9wdF9vdXRfdHJhY2tpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtcbiAgICAgICAgJ2NsZWFyX3BlcnNpc3RlbmNlJzogdHJ1ZSxcbiAgICAgICAgJ2RlbGV0ZV91c2VyJzogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgLy8gZGVsZXRlIHVzZXIgYW5kIGNsZWFyIGNoYXJnZXMgc2luY2UgdGhlc2UgbWV0aG9kcyBtYXkgYmUgZGlzYWJsZWQgYnkgb3B0LW91dFxuICAgIGlmIChvcHRpb25zWydkZWxldGVfdXNlciddICYmIHRoaXNbJ3Blb3BsZSddICYmIHRoaXNbJ3Blb3BsZSddLl9pZGVudGlmeV9jYWxsZWQoKSkge1xuICAgICAgICB0aGlzWydwZW9wbGUnXS5kZWxldGVfdXNlcigpO1xuICAgICAgICB0aGlzWydwZW9wbGUnXS5jbGVhcl9jaGFyZ2VzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZ2Rwcl9jYWxsX2Z1bmMob3B0T3V0LCBvcHRpb25zKTtcbiAgICB0aGlzLl9nZHByX3VwZGF0ZV9wZXJzaXN0ZW5jZShvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgaW4gdG8gZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2VcbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIHZhciBoYXNfb3B0ZWRfaW4gPSBtaXhwYW5lbC5oYXNfb3B0ZWRfaW5fdHJhY2tpbmcoKTtcbiAqICAgICAvLyB1c2UgaGFzX29wdGVkX2luIHZhbHVlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZV90eXBlPWxvY2FsU3RvcmFnZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlIC0gZmFsbHMgYmFjayB0byBjb29raWUgaWYgbG9jYWxTdG9yYWdlIGlzIHVuYXZhaWxhYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX3ByZWZpeD1fX21wX29wdF9pbl9vdXRdIEN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gY3VycmVudCBvcHQtaW4gc3RhdHVzXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5oYXNfb3B0ZWRfaW5fdHJhY2tpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dkcHJfY2FsbF9mdW5jKGhhc09wdGVkSW4sIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2VcbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIHZhciBoYXNfb3B0ZWRfb3V0ID0gbWl4cGFuZWwuaGFzX29wdGVkX291dF90cmFja2luZygpO1xuICogICAgIC8vIHVzZSBoYXNfb3B0ZWRfb3V0IHZhbHVlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZV90eXBlPWxvY2FsU3RvcmFnZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlIC0gZmFsbHMgYmFjayB0byBjb29raWUgaWYgbG9jYWxTdG9yYWdlIGlzIHVuYXZhaWxhYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX3ByZWZpeD1fX21wX29wdF9pbl9vdXRdIEN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gY3VycmVudCBvcHQtb3V0IHN0YXR1c1xuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuaGFzX29wdGVkX291dF90cmFja2luZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2Rwcl9jYWxsX2Z1bmMoaGFzT3B0ZWRPdXQsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBDbGVhciB0aGUgdXNlcidzIG9wdCBpbi9vdXQgc3RhdHVzIG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGlzIE1peHBhbmVsIGluc3RhbmNlXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyBjbGVhciB1c2VyJ3Mgb3B0LWluL291dCBzdGF0dXNcbiAqICAgICBtaXhwYW5lbC5jbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nKCk7XG4gKlxuICogICAgIC8vIGNsZWFyIHVzZXIncyBvcHQtaW4vb3V0IHN0YXR1cyB3aXRoIHNwZWNpZmljIGNvb2tpZSBjb25maWd1cmF0aW9uIC0gc2hvdWxkIG1hdGNoXG4gKiAgICAgLy8gY29uZmlndXJhdGlvbiB1c2VkIHdoZW4gb3B0X2luX3RyYWNraW5nL29wdF9vdXRfdHJhY2tpbmcgbWV0aG9kcyB3ZXJlIGNhbGxlZC5cbiAqICAgICBtaXhwYW5lbC5jbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nKHtcbiAqICAgICAgICAgY29va2llX2V4cGlyYXRpb246IDMwLFxuICogICAgICAgICBzZWN1cmVfY29va2llOiB0cnVlXG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlX3BlcnNpc3RlbmNlPXRydWVdIElmIHRydWUsIHdpbGwgcmUtZW5hYmxlIHNkayBwZXJzaXN0ZW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVfZXhwaXJhdGlvbl0gTnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1pbiBjb29raWUgZXhwaXJlcyAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9kb21haW5dIEN1c3RvbSBjb29raWUgZG9tYWluIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3NpdGVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWQgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5jbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7XG4gICAgICAgICdlbmFibGVfcGVyc2lzdGVuY2UnOiB0cnVlXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICB0aGlzLl9nZHByX2NhbGxfZnVuYyhjbGVhck9wdEluT3V0LCBvcHRpb25zKTtcbiAgICB0aGlzLl9nZHByX3VwZGF0ZV9wZXJzaXN0ZW5jZShvcHRpb25zKTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5yZXBvcnRfZXJyb3IgPSBmdW5jdGlvbihtc2csIGVycikge1xuICAgIGNvbnNvbGUkMS5lcnJvci5hcHBseShjb25zb2xlJDEuZXJyb3IsIGFyZ3VtZW50cyk7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCFlcnIgJiYgIShtc2cgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICAgIG1zZyA9IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2V0X2NvbmZpZygnZXJyb3JfcmVwb3J0ZXInKShtc2csIGVycik7XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKGVycik7XG4gICAgfVxufTtcblxuLy8gRVhQT1JUUyAoZm9yIGNsb3N1cmUgY29tcGlsZXIpXG5cbi8vIE1peHBhbmVsTGliIEV4cG9ydHNcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnaW5pdCddICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmluaXQ7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3Jlc2V0J10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5yZXNldDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZGlzYWJsZSddICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmRpc2FibGU7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RpbWVfZXZlbnQnXSAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50aW1lX2V2ZW50O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0cmFjayddICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2s7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RyYWNrX2xpbmtzJ10gICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19saW5rcztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndHJhY2tfZm9ybXMnXSAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX2Zvcm1zO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0cmFja19wYWdldmlldyddICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfcGFnZXZpZXc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3JlZ2lzdGVyJ10gICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5yZWdpc3Rlcjtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsncmVnaXN0ZXJfb25jZSddICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlZ2lzdGVyX29uY2U7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3VucmVnaXN0ZXInXSAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS51bnJlZ2lzdGVyO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydpZGVudGlmeSddICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuaWRlbnRpZnk7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2FsaWFzJ10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5hbGlhcztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnbmFtZV90YWcnXSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLm5hbWVfdGFnO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzZXRfY29uZmlnJ10gICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc2V0X2NvbmZpZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X2NvbmZpZyddICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9jb25maWc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2dldF9wcm9wZXJ0eSddICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfcHJvcGVydHk7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2dldF9kaXN0aW5jdF9pZCddICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfZGlzdGluY3RfaWQ7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RvU3RyaW5nJ10gICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50b1N0cmluZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnb3B0X291dF90cmFja2luZyddICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLm9wdF9vdXRfdHJhY2tpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ29wdF9pbl90cmFja2luZyddICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5vcHRfaW5fdHJhY2tpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2hhc19vcHRlZF9vdXRfdHJhY2tpbmcnXSAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydoYXNfb3B0ZWRfaW5fdHJhY2tpbmcnXSAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuaGFzX29wdGVkX2luX3RyYWNraW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydjbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nJ10gICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuY2xlYXJfb3B0X2luX291dF90cmFja2luZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X2dyb3VwJ10gICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9ncm91cDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnc2V0X2dyb3VwJ10gICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnNldF9ncm91cDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnYWRkX2dyb3VwJ10gICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmFkZF9ncm91cDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsncmVtb3ZlX2dyb3VwJ10gICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlbW92ZV9ncm91cDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndHJhY2tfd2l0aF9ncm91cHMnXSAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX3dpdGhfZ3JvdXBzO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzdGFydF9iYXRjaF9zZW5kZXJzJ10gICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc3RhcnRfYmF0Y2hfc2VuZGVycztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnc3RvcF9iYXRjaF9zZW5kZXJzJ10gICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0b3BfYmF0Y2hfc2VuZGVycztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnc3RhcnRfc2Vzc2lvbl9yZWNvcmRpbmcnXSAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0YXJ0X3Nlc3Npb25fcmVjb3JkaW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydzdG9wX3Nlc3Npb25fcmVjb3JkaW5nJ10gICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuc3RvcF9zZXNzaW9uX3JlY29yZGluZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsncGF1c2Vfc2Vzc2lvbl9yZWNvcmRpbmcnXSAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnBhdXNlX3Nlc3Npb25fcmVjb3JkaW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydyZXN1bWVfc2Vzc2lvbl9yZWNvcmRpbmcnXSAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUucmVzdW1lX3Nlc3Npb25fcmVjb3JkaW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfc2Vzc2lvbl9yZWNvcmRpbmdfcHJvcGVydGllcyddICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Nlc3Npb25fcmVjb3JkaW5nX3Byb3BlcnRpZXM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2dldF9zZXNzaW9uX3JlcGxheV91cmwnXSAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfc2Vzc2lvbl9yZXBsYXlfdXJsO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfdGFiX2lkJ10gICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3RhYl9pZDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnREVGQVVMVF9BUElfUk9VVEVTJ10gICAgICAgICAgICAgICAgID0gREVGQVVMVF9BUElfUk9VVEVTO1xuXG4vLyBFeHBvcnRzIGludGVuZGVkIG9ubHkgZm9yIHRlc3Rpbmdcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnX19nZXRfcmVjb3JkZXInXSAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLl9fZ2V0X3JlY29yZGVyO1xuXG4vLyBNaXhwYW5lbFBlcnNpc3RlbmNlIEV4cG9ydHNcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlWydwcm9wZXJ0aWVzJ10gICAgICAgICAgICA9IE1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnByb3BlcnRpZXM7XG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZVsndXBkYXRlX3NlYXJjaF9rZXl3b3JkJ10gPSBNaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS51cGRhdGVfc2VhcmNoX2tleXdvcmQ7XG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZVsndXBkYXRlX3JlZmVycmVyX2luZm8nXSAgPSBNaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS51cGRhdGVfcmVmZXJyZXJfaW5mbztcbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlWydnZXRfY3Jvc3Nfc3ViZG9tYWluJ10gICA9IE1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmdldF9jcm9zc19zdWJkb21haW47XG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZVsnY2xlYXInXSAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5jbGVhcjtcblxuXG52YXIgaW5zdGFuY2VzID0ge307XG52YXIgZXh0ZW5kX21wID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gYWRkIGFsbCB0aGUgc3ViIG1peHBhbmVsIGluc3RhbmNlc1xuICAgIF8uZWFjaChpbnN0YW5jZXMsIGZ1bmN0aW9uKGluc3RhbmNlLCBuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lICE9PSBQUklNQVJZX0lOU1RBTkNFX05BTUUpIHsgbWl4cGFuZWxfbWFzdGVyW25hbWVdID0gaW5zdGFuY2U7IH1cbiAgICB9KTtcblxuICAgIC8vIGFkZCBwcml2YXRlIGZ1bmN0aW9ucyBhcyBfXG4gICAgbWl4cGFuZWxfbWFzdGVyWydfJ10gPSBfO1xufTtcblxudmFyIG92ZXJyaWRlX21wX2luaXRfZnVuYyA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHdlIG92ZXJyaWRlIHRoZSBzbmlwcGV0cyBpbml0IGZ1bmN0aW9uIHRvIGhhbmRsZSB0aGUgY2FzZSB3aGVyZSBhXG4gICAgLy8gdXNlciBpbml0aWFsaXplcyB0aGUgbWl4cGFuZWwgbGlicmFyeSBhZnRlciB0aGUgc2NyaXB0IGxvYWRzICYgcnVuc1xuICAgIG1peHBhbmVsX21hc3RlclsnaW5pdCddID0gZnVuY3Rpb24odG9rZW4sIGNvbmZpZywgbmFtZSkge1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSBhIHN1YiBsaWJyYXJ5XG4gICAgICAgICAgICBpZiAoIW1peHBhbmVsX21hc3RlcltuYW1lXSkge1xuICAgICAgICAgICAgICAgIG1peHBhbmVsX21hc3RlcltuYW1lXSA9IGluc3RhbmNlc1tuYW1lXSA9IGNyZWF0ZV9tcGxpYih0b2tlbiwgY29uZmlnLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBtaXhwYW5lbF9tYXN0ZXJbbmFtZV0uX2xvYWRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1peHBhbmVsX21hc3RlcltuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG1peHBhbmVsX21hc3RlcjtcblxuICAgICAgICAgICAgaWYgKGluc3RhbmNlc1tQUklNQVJZX0lOU1RBTkNFX05BTUVdKSB7XG4gICAgICAgICAgICAgICAgLy8gbWFpbiBtaXhwYW5lbCBsaWIgYWxyZWFkeSBpbml0aWFsaXplZFxuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gaW5zdGFuY2VzW1BSSU1BUllfSU5TVEFOQ0VfTkFNRV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgLy8gaW50aWFsaXplIHRoZSBtYWluIG1peHBhbmVsIGxpYlxuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gY3JlYXRlX21wbGliKHRva2VuLCBjb25maWcsIFBSSU1BUllfSU5TVEFOQ0VfTkFNRSk7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuX2xvYWRlZCgpO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlc1tQUklNQVJZX0lOU1RBTkNFX05BTUVdID0gaW5zdGFuY2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1peHBhbmVsX21hc3RlciA9IGluc3RhbmNlO1xuICAgICAgICAgICAgaWYgKGluaXRfdHlwZSA9PT0gSU5JVF9TTklQUEVUKSB7XG4gICAgICAgICAgICAgICAgd2luW1BSSU1BUllfSU5TVEFOQ0VfTkFNRV0gPSBtaXhwYW5lbF9tYXN0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRlbmRfbXAoKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG52YXIgYWRkX2RvbV9sb2FkZWRfaGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIENyb3NzIGJyb3dzZXIgRE9NIExvYWRlZCBzdXBwb3J0XG4gICAgZnVuY3Rpb24gZG9tX2xvYWRlZF9oYW5kbGVyKCkge1xuICAgICAgICAvLyBmdW5jdGlvbiBmbGFnIHNpbmNlIHdlIG9ubHkgd2FudCB0byBleGVjdXRlIHRoaXMgb25jZVxuICAgICAgICBpZiAoZG9tX2xvYWRlZF9oYW5kbGVyLmRvbmUpIHsgcmV0dXJuOyB9XG4gICAgICAgIGRvbV9sb2FkZWRfaGFuZGxlci5kb25lID0gdHJ1ZTtcblxuICAgICAgICBET01fTE9BREVEID0gdHJ1ZTtcbiAgICAgICAgRU5RVUVVRV9SRVFVRVNUUyA9IGZhbHNlO1xuXG4gICAgICAgIF8uZWFjaChpbnN0YW5jZXMsIGZ1bmN0aW9uKGluc3QpIHtcbiAgICAgICAgICAgIGluc3QuX2RvbV9sb2FkZWQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZG9fc2Nyb2xsX2NoZWNrKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jdW1lbnQkMS5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwoJ2xlZnQnKTtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGRvX3Njcm9sbF9jaGVjaywgMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkb21fbG9hZGVkX2hhbmRsZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoZG9jdW1lbnQkMS5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIGlmIChkb2N1bWVudCQxLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgIC8vIHNhZmFyaSA0IGNhbiBmaXJlIHRoZSBET01Db250ZW50TG9hZGVkIGV2ZW50IGJlZm9yZSBsb2FkaW5nIGFsbFxuICAgICAgICAgICAgLy8gZXh0ZXJuYWwgSlMgKGluY2x1ZGluZyB0aGlzIGZpbGUpLiB5b3Ugd2lsbCBzZWUgc29tZSBjb3B5cGFzdGFcbiAgICAgICAgICAgIC8vIG9uIHRoZSBpbnRlcm5ldCB0aGF0IGNoZWNrcyBmb3IgJ2NvbXBsZXRlJyBhbmQgJ2xvYWRlZCcsIGJ1dFxuICAgICAgICAgICAgLy8gJ2xvYWRlZCcgaXMgYW4gSUUgdGhpbmdcbiAgICAgICAgICAgIGRvbV9sb2FkZWRfaGFuZGxlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQkMS5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgZG9tX2xvYWRlZF9oYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50JDEuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgLy8gSUVcbiAgICAgICAgZG9jdW1lbnQkMS5hdHRhY2hFdmVudCgnb25yZWFkeXN0YXRlY2hhbmdlJywgZG9tX2xvYWRlZF9oYW5kbGVyKTtcblxuICAgICAgICAvLyBjaGVjayB0byBtYWtlIHN1cmUgd2UgYXJuJ3QgaW4gYSBmcmFtZVxuICAgICAgICB2YXIgdG9wbGV2ZWwgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRvcGxldmVsID0gd2luLmZyYW1lRWxlbWVudCA9PT0gbnVsbDtcbiAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAvLyBub29wXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9jdW1lbnQkMS5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgJiYgdG9wbGV2ZWwpIHtcbiAgICAgICAgICAgIGRvX3Njcm9sbF9jaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZmFsbGJhY2sgaGFuZGxlciwgYWx3YXlzIHdpbGwgd29ya1xuICAgIF8ucmVnaXN0ZXJfZXZlbnQod2luLCAnbG9hZCcsIGRvbV9sb2FkZWRfaGFuZGxlciwgdHJ1ZSk7XG59O1xuXG5mdW5jdGlvbiBpbml0X2FzX21vZHVsZShidW5kbGVfbG9hZGVyKSB7XG4gICAgbG9hZF9leHRyYV9idW5kbGUgPSBidW5kbGVfbG9hZGVyO1xuICAgIGluaXRfdHlwZSA9IElOSVRfTU9EVUxFO1xuICAgIG1peHBhbmVsX21hc3RlciA9IG5ldyBNaXhwYW5lbExpYigpO1xuXG4gICAgb3ZlcnJpZGVfbXBfaW5pdF9mdW5jKCk7XG4gICAgbWl4cGFuZWxfbWFzdGVyWydpbml0J10oKTtcbiAgICBhZGRfZG9tX2xvYWRlZF9oYW5kbGVyKCk7XG5cbiAgICByZXR1cm4gbWl4cGFuZWxfbWFzdGVyO1xufVxuXG4vLyBGb3IgbG9hZGluZyBzZXBhcmF0ZSBidW5kbGVzIGFzeW5jaHJvbm91c2x5IHZpYSBzY3JpcHQgdGFnXG4vLyBzbyB0aGF0IHdlIGRvbid0IGxvYWQgdGhlbSB1bnRpbCB0aGV5IGFyZSBuZWVkZWQgYXQgcnVudGltZS5cblxuLy8gRm9yIGJ1aWxkcyB0aGF0IGhhdmUgZXZlcnl0aGluZyBpbiBvbmUgYnVuZGxlLCBubyBleHRyYSB3b3JrLlxuZnVuY3Rpb24gbG9hZE5vb3AgKF9zcmMsIG9ubG9hZCkge1xuICAgIG9ubG9hZCgpO1xufVxuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cbnZhciBtaXhwYW5lbCA9IGluaXRfYXNfbW9kdWxlKGxvYWROb29wKTtcblxuZXhwb3J0IHsgbWl4cGFuZWwgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mixpanel-browser/dist/mixpanel.module.js\n");

/***/ })

};
;